<html><header><title>Memory leak bug found in BusinessBase.cs</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Memory leak bug found in BusinessBase.cs</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5835.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>KGy posted on Thursday, November 20, 2008</h2>I use the most recent version of CSLA for .NET 2.0 (that is v2.1.4) and I have discovered the following thing:<br><br>Lets assume that an editable child list is bound to a grid/listbox/etc. To edit a child item I open a new form and to make possible to cancel changes that were performed on child I use undo possibilities like this:<br><br><font size="2" color="#0000ff" face="Courier New">public bool </font><font size="2" face="Courier New">Execute(</font><font color="#0000ff"><b><font size="2" face="Courier New">Child </font></b></font><font size="2" face="Courier New">child)<br>{<br></font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; <font color="#008000">// binding (unbind is performed on closing the dialog)</font><br>
</font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; <font color="#0000ff">this</font>.Child = child;<br><br>&nbsp;&nbsp;&nbsp; <font color="#008000">// editing<br><font color="#000000">&nbsp;&nbsp;&nbsp; child.BeginEdit();<br></font></font>&nbsp;&nbsp;&nbsp; <font color="#0000ff">if </font>(<font color="#0000ff">this</font>.ShowDialog() == <font color="#0000ff"><b>DialogResult</b></font>.OK)<br>&nbsp;&nbsp;&nbsp; {<br></font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </font><font size="2" face="Courier New"><font color="#008000"><font color="#000000">child</font></font></font><font size="2" face="Courier New">.ApplyEdit();<br>
</font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <font color="#0000ff">return true</font>;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">else</font><br>&nbsp;&nbsp;&nbsp; {<br></font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </font><font size="2" face="Courier New"><font color="#008000"><font color="#000000">child</font></font></font><font size="2" face="Courier New">.CancelEdit();<br>
</font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <font color="#0000ff">return false</font>;<br>&nbsp;&nbsp;&nbsp; }<br>}</font><br><br>So when the form is opened the child element is bound twice: firstly, in the grid of the opener form, and secondly, in the newly opened form. <b><i>Seemingly</i> </b>everything works fine: thanking to data binding as I modify properties of the child I can see modifications in the grid as well, and when I cancel editing, modifications will be undone. But <i><b>in practice</b></i> there is a memory leak when CancelEdit is called. I have noticed that EditLevel of child is increases on calling BeginEdit, decreases on AppyEdit <i>but does not decrease on calling CancelEdit</i>! It means that the stack that stores undo steps gets greater and greater.<br><br>Source of the problem: When CancelEdit is called (which at first correctly undoes the object and decreases EditLevel) a <font size="2" face="Courier New">_bindingEdit</font> flag will be cleared in UndoChangesComplete method. This method calls OnUnknownPropertyChanged at the end, which invokes some delegates which finally call IEditableObject.BeginEdit via interface. Since _bindingEdit was cleared (despite of the fact that the child is bound in the caller form, too) this will call the regular BeginEdit immediately after the object has been undone. This bug is hard to notice because functionally child objects work well and if EditLevel of the root object is correct, then it will be savable along with its children.<br><br>Here is my solution for the problem (old version in comments, new version is in italic; only <b>BusinessBase.cs</b> is affected):<br><br>Line 629:<br><font size="2" face="Courier New"><font color="#0000ff">private </font><font color="#008000">/*bool*/</font> <i><font color="#0000ff">int</font></i> _bindingEdit <i>= 0</i>;</font><br><br>Line 640: (this is when only the first call should be honored and this was the source of the problem)<br><font size="2" face="Courier New"><font color="#0000ff">void </font>System.ComponentModel.<b><font color="#0000ff">IEditableObject</font></b>.BeginEdit()<br></font><font size="2" face="Courier New">{<br>&nbsp; <font color="#0000ff">if </font>(<font color="#008000">/*!*/</font>_bindingEdit<b> </b><i>== 0</i>)<br>&nbsp;&nbsp;&nbsp; BeginEdit();<br>}</font><br><br>Line 658: (in IEditableObject.CancelEdit)<br><font size="2" face="Courier New"><font color="#0000ff">if </font>(_bindingEdit<b> </b><i>&gt; 0</i>)</font><br><br>Line 685: (in IEditableObject.EndEdit)<br><font size="2" face="Courier New"><font color="#0000ff">if </font>(_bindingEdit<b> </b><i>&gt; 0</i>)</font><br><br>Line 713: (in BeginEdit)<br><font size="2" face="Courier New">_bindingEdit<i>++</i>; <font color="#008000">// = true;</font></font><br><br>Line 741: (in UndoChangesComplete - this triggered the problem by clearing the flag)<br><font size="2" face="Courier New">_bindingEdit<i>--</i>; <font color="#008000">// = false;</font></font><br><br>Line 766: (in ApplyEdit)<br><font size="2" face="Courier New">_bindingEdit<i>--</i>; <font color="#008000">// = false;</font></font><br><br>This seems to be a good solution for me but of course I cannot be sure whether this causes another problem somewhere else. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br>Cheers,<br>&nbsp; KGy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, November 20, 2008</h2>Actually, the most recent version for .net 2.0 is 3.0.5.&nbsp; I strongly recommend you upgrade to that, because there are a TON of data binding fixes.<span id="ctl00_ContentPlaceHolder1_BodyLabel"><strong><br></strong></span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KGy replied on Thursday, November 20, 2008</h2>Oh, I don't know why but I thought that CSLA 3.x is for .NET 3.x...<br>My fault.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, November 20, 2008</h2>It's pretty reasonable to expect that actually.. but as .net 3.0 was only an additive update, so is Csla 3.0.x.&nbsp; Csla 3.5 requires .net 3.5 though, because the compilers for .Net have changed.<br><br>Oh, I think you'll need to set a NET20 compiler flag when using Csla 3.0.x though, to disable the compiling of features that require .net 3.0.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KGy replied on Thursday, November 20, 2008</h2>I have just installed CSLA 3.0.5 and I have to say that this version contains the bug, too. Functionally everything is OK but it is possible to reproduce the memory leak with the scenario that I have shown in my first post.<br><br>Shortly:<br>- ApplyEdit is fine, EditLevel decreases<br>- CancelEdit has still the wrong behaviour: UndoChages works fine until the UndoChangesComplete call, where _bindingEdit is cleared, so the final OnUnknownPropertyChanged call results in a new BeginEdit invocation if the object is bound to more than one sources. I emphasize that functionally there is no problem because the successfully undone object will be copied to the stack again. And since calling Save on the root object checks only the EditLevel of the root object the bug cannot be noticed unless you get an OutOfMemoryException. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br>Problem is not too serious because as soon as you realod the whole business object hierarchy (for example after saving) and release the old references the "leak" disappears.<br><br>The solution is almost the same as I have sketched above but in this version also <b>UndoableBase.cs</b> is affected since _bindingEdit field has been moved into that class (and a new BindingEdit property has been introduced).<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, November 20, 2008</h2>Ok, I re-read your post in more detail now..<br><br>I think the issue is that what you want to do isn't really supported; Windows BindingSource components expect that a single bindingsource is "in charge" of the object it is managing.&nbsp; In your case, you have two; one bindingsource managing the child via the grid, and another on the form which you open.&nbsp; That's not supported by Windows data binding...<br><br>You might be able to work around this issue though; you should be able to chose to ignore Windows databinding calls, and manage the undo / cancel / accepts yourself.&nbsp; Look for DisableIEditableObject.&nbsp; There's a thread on this forum as well, you should try searching for that.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KGy replied on Thursday, November 20, 2008</h2>&gt; That's not supported by Windows data binding...<br><br>Windows handles multiple bounded sources well - just try to bind the same collection to a grid, list, combo box, etc. Windows handles both currency (select a row in the grid and also everything else will update the selection) and data (the edited field will be refreshed everywhere). As far as I know what WinForms does not handle correctly is reading back the previously set data into the edited control itself. But CSLA BindingSourceRefresh control solves this issue.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, November 20, 2008</h2><P>Data binding allows binding the same collection to multiple UI controls, but not multiple bindingsource controls. At least not if the objects in the collection implement IEditableObject (which CSLA objects do).</P>
<P>In other words, you can bind multiple UI elements (grid, list, etc) to a bindingsource, and that bindingsource to an object. But if you bind multiple bindingsource controls to the same underlying object (and that object implements IEditableObject) then things break quickly.</P>
<P>The reason is that the bindingsource control assumes it "owns" that object. It calls the IEditableObject methods as it needs, assuming that no other entity (like another bindingsource control) will be calling them as well.</P>
<P>For example, as soon as a bindingsource binds to an object, it calls IEO.BeginEdit(). If you connect a second bindingsource to that same object, it will also call IEO.BeginEdit() - but that second call is ignored due to the rules of implementing IEO (only the first call is to be honored).</P>
<P>If the user then starts doing things through one bindingsource, it'll call EndEdit() or CancelEdit() as appropriate, followed by a subsequent BeginEdit() call. The <EM>other</EM> bindingsource may also react, based on PropertyChanged or ListChanged events from the object, and the two controls can easily end up fighting each other.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, November 20, 2008</h2><P>I see, I more carefully read your initial post. That's interesting, in that you are proposing a solution to the race condition I outlined in my previous post.</P>
<P>Your solution seems like a good one, at least on the surface. Whether it introduces unwanted side-effects is the real question :)</P>
<P>I'll add this to the issue tracker - something to investigate for 3.6.1 at least.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KGy replied on Friday, November 21, 2008</h2>Unfortunately the solution for version 3.0.5 is not as trivial as for version 2.x that I have written in my first post. Simply converting the bool flag into an integer field and increasing/decreasing it instead of setting/clearing will not do the trick because of the restructured logic has been made since 2.x. I have sent you a solution in email that seems good to me - maybe you can use it as a start up point in the issue tracker.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
