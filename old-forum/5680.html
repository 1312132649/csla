<html><header><title>Request for alternative approach to Business object class properties in CSLA 3.6</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Request for alternative approach to Business object class properties in CSLA 3.6</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5680.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jmcd posted on Monday, October 27, 2008</h2>I recently posted on the forum about a problem I was having with Business Objects containing lists of child Business Objects (http://forums.lhotka.net/forums/thread/27194.aspx).&nbsp; The problem seemed to be related to the fact that static fields weren’t being initialised early enough on deserialization (in part due to the management of class properties via the new FieldDataManager component and the way that .NET deserialises objects).&nbsp; The reasons cited in a related thread (http://forums.lhotka.net/forums/thread/26807.aspx), seemed to suggest that it was due to my Child Business objects inheriting from my own base class (which in turn inherits from Csla.BusinessBase) instead of inheriting from Csla.BusinessBase directly. <br><br>(Note: The referred thread above is with regards to specializing from a base class – Csla.BusinessBase -&gt; Customer -&gt; GoodCustomer &amp; BadCustomer whereas we inherit from a shared base class and then a generated class e.g. Csla.BusinessBase -&gt; OrganisationBase -&gt; CustomerBase (generated) -&gt; Customer.)<br><br>In my organisation, it&nbsp; is standard practice to inherit from our custom base class in order to avoid code duplication and share common concerns between all our business objects such as standardised exception processing (off-topic: we would also like to see CSLA use a ref for the Exception passed into DataPortal_OnDataPortalException for replacing/wrapping purposes).&nbsp; The workaround suggested is to use a static dummy variable.&nbsp; This works, however, in my opinion it doesn’t seem very elegant, requiring dummy variables throughout all our business objects.<br><br>Is there a possibility of a redesign at some point in the future which would negate the need for dummy variables in business objects not directly inheriting from Csla.BusinessBase?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, October 27, 2008</h2><P>I agree that the static dummy variable solution is really ugly.</P>
<P>I have a large app and the move to 3.6 managed properties will be a real pain if I have to edit each BO in my hierarchy and slap this code in.</P>
<P>If there was a way to do it once in my own Base class then it would be trivial to implement. But Rocky has stated many times that each level of the chain needs it.</P>
<P>So if I have this hierarchy:</P>
<P>Csla -&gt; MyBaseClass -&gt; MyCodeGenClass -&gt; MyDeveloperClass -&gt; My Type </P>
<P>then I need to add the dummy variable code in 4 places!</P>
<P>One of the alternatives was to implement a static constructor but that had a serious performance drawback since it injects code *everywhere* in your classes to ensure it is initialized correctly. But even worse - Rocky mentioned it doesn't even work reliably in Csla so it is not even a possibility anymore.</P>
<P>It would be nice if a more elegant solution could be contrived.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, October 27, 2008</h2>If you use static field initializes, you end up with a static constructor anyway.&nbsp; So all that ugly code ends up in there anyway.&nbsp; <br><br>So that's why using a static constructor doesn't help; you're just explicitly defining it instead of letting the compiler handler it, but the result is the same.<br><br>Rocky's trick works because you have an instance member trying to use the static member, so that ensures the static constructor fires.&nbsp; Which is where all that ugly code likely ends up firing.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, October 27, 2008</h2><P><FONT face=Tahoma size=2>I haven't followed the entirety of the conversations surrounding this issue, but I have seen quite a few of them.&nbsp; And from what I've read, the answer is probably "no".</FONT></P>
<P><FONT face=Tahoma size=2>From what I have gathered, the issue is that .NET does not guarantee the initialization order of an inheritance chain.&nbsp; That's what the static variable does - it forces an order of initialization so that the field manager&nbsp;collects everything in the proper order.&nbsp; MS is not probably going to change that situation, since doing so would&nbsp;eliminate an optimization technique.&nbsp; Given that, I know of no other way to take care of the situation - certainly nothing that would be considered more elegant than the current suggestion.&nbsp; Apparently, neither does Rocky - I know that several solutions were tried before the dummy-variable solution was settled on.</FONT></P>
<P><FONT face=Tahoma size=2>Having not done an extensive study of the 3.5 codebase, I can't say how much order is important.&nbsp; There are surely ways to re-factor the code to eliminate the&nbsp;dependency on&nbsp;ordering, but moving to a key-based solution&nbsp;would almost certainly introduce a performance hit.&nbsp; Given how much the field manager is accessed, that could very well be significant.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Tuesday, October 28, 2008</h2>The problem comes when you try to access properties defined in the base class, from an inherited child.&nbsp; There is no guarantee that the static parent properties have been initialized, leading to null reference errors.<br><br>If the MS developers of the compiler had the same foresight and regard for developers as our own Rocky, they would have made the 'optimization' you mention optional via a switch, and ensured the whole thing was backwards compatible <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" />.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
