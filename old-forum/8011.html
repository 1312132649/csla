<html><header><title>Centralized Business Rules - Data Manipulation Rules</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Centralized Business Rules - Data Manipulation Rules</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8011.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 posted on Wednesday, November 18, 2009</h2><P>As Rocky has stated in the past, the term ValidationRules encompasses two concepts and so he feels it was named incorrectly. It should have been called BusinessRules so that Validation and Data Manipulation could both be included in it. </P>
<P>By Data Manipulation I mean changing the value of a Property of a BO will cause its rules to fire - one of the rules could be to Trim and Uppercase the value - this is a Data Manipulation rule or a Business rule.</P>
<P>If I write a rule&nbsp;called TrimAndUpperCaseString and put it directly in my BO then I can manipulate the private field (or managed field) without re-triggering the rules involved in a Property Set.</P>
<P>But now say that I want to write this rule once and put it in my library of rules so that I can call it from various BOs. There are some implications to that and I would like some feedback as to how others view this.</P><FONT size=2></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</FONT></FONT><FONT size=2> TrimAndUpperCaseString(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> target </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Object</FONT></FONT><FONT size=2>, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> e </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> RuleArgs) </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Dim</FONT></FONT><FONT size=2> ruleArg </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> MyRuleArgs = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>DirectCast</FONT></FONT><FONT size=2>(e, MyRuleArgs)<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Dim</FONT></FONT><FONT size=2> propertyName </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2> = ruleArg.PropertyName<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Dim</FONT></FONT><FONT size=2> newValue </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Dim</FONT></FONT><FONT size=2> value </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2> = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>CStr</FONT></FONT><FONT size=2>(CallByName(target, propertyName, CallType.Get))</P>
<P>&nbsp; newValue = value.Trim.ToUpper<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; If</FONT></FONT><FONT size=2> newValue = value </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Then<BR></FONT></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>&nbsp;&nbsp;&nbsp; 'do nothing<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Else<BR></FONT></FONT><FONT size=2>&nbsp;&nbsp;&nbsp; CallByName(target, propertyName, CallType.Set, newValue)<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; Return</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>True<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</FONT></FONT></P><FONT color=#0000ff size=2><FONT color=#0000ff size=2><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>Here are the implications that I have drawn.</FONT></FONT></FONT></P>
<P><FONT size=2><FONT size=2><FONT color=#000000>1. Data Manipulation Rules are never broken. </FONT></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>2. They just modify the property value in some way and always return True.</FONT></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>3. Their value is the fact that whenever the Property is changed then the rules for that property get run.</FONT></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>4. This allows us to write a rule once and then re-use it many times rather than write code in the Property Set many times.</FONT></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>5. The one drawback to writing a general rule in My Rules instead of a specific rule in the BO is that the general rule will&nbsp;</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000>end up re-setting the property which causes the rule to be re-run. That is why we have to test if the newValue has been</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> set once already - else we could end up in an infinite loop. If the rule is in a BO then we could simply set the field&nbsp;</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> directly and avoid the re-run issue.</FONT></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>6. In order to avoid re-running other rules too, the policy is that Data Manipulation Rules should always have priority = -1.</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> That way they always get run first before the default priority = 0 rules and our DB hit priority=1 rules.</FONT></FONT></FONT></FONT></FONT></P>
<P>Is there a way to write Data Manipulation Rules centrally that do not cause the Property Set to re-run the rule? </P>
<P>Also, should Data Manipulation Rules really run at the lowest possible priority (-1 in my case) so that they occur before any Validation rules are run?</P>
<P>&nbsp;Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Wednesday, November 18, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div> 
<P>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2></FONT></FONT></P>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2><FONT size=2><FONT size=2><FONT color=#000000>5. The one drawback to writing a general rule in My Rules instead of a specific rule in the BO is that the general rule will&nbsp;</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000>end up re-setting the property which causes the rule to be re-run. That is why we have to test if the newValue has been</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> set once already - else we could end up in an infinite loop. If the rule is in a BO then we could simply set the field&nbsp;</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> directly and avoid the re-run issue.</FONT></FONT></FONT></FONT></FONT></P>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2><FONT size=2><FONT size=2><FONT color=#000000 size=3></div></BLOCKQUOTE></FONT></FONT></FONT></FONT></FONT></P>
<P>I use the following general rule.&nbsp; Because it uses the CallByName convention (CSLA version), it does not appear to trigger a re-firing of the rule check.&nbsp; Even if it did, since the value of the property would only be modified once, a supsequent call would not change the value and not re-trigger an infinite loop.&nbsp;</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>bool</FONT></FONT><FONT size=2> StringUpperTrim(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>object</FONT></FONT><FONT size=2> target, Csla.Validation.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RuleArgs</FONT></FONT><FONT size=2> e)</P>
<P>{</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2> value = (</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2>)Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Utilities</FONT></FONT><FONT size=2>.CallByName(target, e.PropertyName, </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>CallType</FONT></FONT><FONT size=2>.Get);</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>if</FONT></FONT><FONT size=2> (!</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2>.IsNullOrEmpty(value))</P>
<P>{</P>
<P>Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Utilities</FONT></FONT><FONT size=2>.CallByName(target, e.PropertyName, </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>CallType</FONT></FONT><FONT size=2>.Set, value.ToUpperTrim());</P>
<P>}</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>true</FONT></FONT><FONT size=2>;</P>
<P>}</P></FONT>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2><FONT size=2><FONT size=2><FONT color=#000000 size=3><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div> </FONT></P>
<P></P></FONT></FONT><FONT size=2>
<P></FONT><FONT size=2><FONT size=2><FONT color=#000000>6. In order to avoid re-running other rules too, the policy is that Data Manipulation Rules should always have priority = -1.</FONT></FONT></FONT><FONT size=2><FONT size=2><FONT color=#000000> That way they always get run first before the default priority = 0 rules and our DB hit priority=1 rules.</FONT></FONT></FONT></FONT></FONT></P>
<P></div></BLOCKQUOTE></P>
<P>I would not want this as I typically have a "StringRequired" rule as well as the Trim and Upper rule.&nbsp; The string required rule fires first, and the trim/upper rule only runs if the string required rule passes.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, November 18, 2009</h2><P>Thanks for the feedback. I should not have said infinite loop. I meant that if the property is changed that the rule will get run a second time. Your point about the second time is correct - since it is now the same value it will not run the rule a 3rd time. But it does run the rule twice. I tried your code with the CSLA CallByName and it acts the same way as VB.</P>
<P>By checking newValue=Value in the rule itself you avoid the 2nd reflection call which doesn;t do anything anyone, as you pointed out.</P>
<P>Good point on the StringRequired Rule. But shouldn't all string properties in a BO be initialized to ""? And even if they are Nothing doesn't casting them to string using Cstr make them ""? So it should be safe to call the ToUpper.Trim on it.</P>
<P>Also, if you run other rules before the DataManipulation rule then they will all get re-run when the data is changed! So my point is that Data Manipulation rules should run first to minimize the re-running of rules.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Peran replied on Thursday, November 19, 2009</h2>Here are 2 ideas I was working on last night:<br><br>The below prevents any database access rules with a higher priory from
running twice, as it uses the StopProcessing property to stop the first
iteration of rules running in the knowledge that the second iteration
will have re-run the rules.&nbsp; The disadvantage is that if you have a few
rules like this it could get confusing to dubug with rule loops running
inside rule loop runing inside rule loops...<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static bool ToUpperTrim1(object target, Csla.Validation.RuleArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string value = (string)Utilities.CallByName(target, e.PropertyName, CallType.Get);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string newValue = value.ToUpper(CultureInfo.CurrentCulture).Trim();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != newValue)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // this property set will cause the validation rules to run again... <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Utilities.CallByName(target, e.PropertyName, CallType.Set, newValue);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...so stop this iteration as we know that another iteration has just run<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.StopProcessing = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>The second idea was to use IManageProperties to update the value without causing the rules to rerun at all.&nbsp; This does however break encapsulation (using an explicit interface, so it's not quite as bad!) and requires IManageProperties to be changed from internal to public.&nbsp; You would need to run the StringRequired rule after this rule, incase the user just entered some space characters.<br><br>&nbsp;&nbsp;&nbsp; public class StringRuleArgs : Csla.Validation.RuleArgs<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region constructors<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public StringRuleArgs(PropertyInfo&lt;string&gt; propertyInfo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(propertyInfo)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.PropertyInfo = propertyInfo;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region proeprties<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public PropertyInfo&lt;string&gt; PropertyInfo { get; private set; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static bool ToUpperTrim2(object target, Csla.Validation.RuleArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var args = (StringRuleArgs)e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var businessObject = (IManageProperties)target;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string value = businessObject.ReadProperty(args.PropertyInfo);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string newValue = value.ToUpper(CultureInfo.CurrentCulture).Trim();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; businessObject.LoadProperty(args.PropertyInfo, newValue);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>I have not decided wheather to use these or not...what are your thoughts?<br><br><br>Peran<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Thursday, November 19, 2009</h2><P>Thanks!<BR>Those are two very interesting approaches. I have not made any decisions yet either.</P>
<P>Rocky - can you please provide some feedback on the issue that I raised and these potential solutions? Plus any other thoughts on the subject. Like for example should there be an enumeration with ValidationRules and DataManipulationRules. Then the Rules engine could discriminate between the two types of rule and run the DataManipulationRules first but without triggering any events. Then the validation rules could run second.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, November 20, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div><P>Thanks!<BR>Those are two very interesting approaches. I have not made any decisions yet either.</P><br /><P>Rocky - can you please provide some feedback on the issue that I raised and these potential solutions? Plus any other thoughts on the subject. Like for example should there be an enumeration with ValidationRules and DataManipulationRules. Then the Rules engine could discriminate between the two types of rule and run the DataManipulationRules first but without triggering any events. Then the validation rules could run second.</P><br /><P>Joe</P><br /><P>&#160;</P></div></BLOCKQUOTE><br /><br />Yes, and while we're at it there was also this related thread in which we discussed at length that the rule should understand why it was being called (actual property change versus someone just calling CheckRules)...<br /><br />http://forums.lhotka.net/forums/thread/36593.aspx</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, November 20, 2009</h2><P>This is an area I plan to work on for 4.0, as it will involve some breaking changes.</P>
<P>My current thinking includes a few changes:</P>
<OL>
<LI>Rename the ValidationRules protected property to BusinessRules</LI>
<LI>Eliminate the bool return from rule methods, instead returning the result via RuleArgs with the default being true (so business rules can ignore the whole thing, while validation rules will set e.Result = false for failure)</LI>
<LI>Provide a RuleContext value in RuleArgs that allows you to get/set property values from the target object in an abstract manner, much the way async rules work today, but bi-directional</LI>
<LI>With sync and async rules, after the rule completes (so the code is running on the UI thread), update changed property values from RuleContext back into the object</LI>
<LI>Maybe call a lambda (Action&lt;T&gt;) after the rule completes and the code is running on the UI thread (whether sync or async)</LI>
<LI>Allow "rule chaining", where a rule can call other rules, and can aggregate&nbsp;the results of those rules into RuleArgs so post-processing occurs against all the results</LI>
<LI>Possibly use MEF to dynamically discover and load rule methods in a more abstract manner</LI>
<LI>Add the concept of "rule domains", so a business type can have multiple rule sets, each belonging to a domain - this would support shared hosting scenarios for server apps and app servers</LI>
<LI>If I can get the sync/async rule syntax to match by using RuleContext, I may use an [AsyncRule] attribute so you can indicate that a rule is required to run async by putting that attribute on the rule method</LI>
<LI>Add a BusinessRuleAttribute (subclass of ValidationAttribute) that implements ObjectFactory-like protected members, making it easier to create a rule attribute that can get/set values in the target object</LI></OL>
<P>At a high level my goals are</P>
<OL>
<LI>Support shared hosting scenarios</LI>
<LI>Change naming/coding to better reflect business rules, not just validation</LI>
<LI>Provide consistency between sync and async rules</LI></OL>
<P>As you can imagine, these changes will have at least some impact on existing rule methods and AddBusinessRules() methods. I hope that the changes are pretty mechanical (and thus easy to make), but this will improve readability and open up some new scenarios that are hard/impossible today.</P>
<P>You can imagine AddBusinessRules() looking more like this:</P>
<P>protected override void AddBusinessRules()<BR>{<BR>&nbsp; base.AddBusinessRules();<BR>&nbsp; BusinessRules.AddRule(MyRule, MyProperty);<BR>&nbsp; BusinessRules.AddRule(MyRule, MyOtherProperty);<BR>}</P>
<P>And you can imagine a rule looking like this:</P>
<P>private static void MyRule&lt;T&gt;(T target, RuleArgs e) where T : MyType<BR>{<BR>&nbsp; if (some condition is met)<BR>&nbsp;&nbsp;&nbsp; return;<BR>&nbsp; else<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; e.Description = "oops";<BR>&nbsp;&nbsp;&nbsp; e.Result = false;<BR>&nbsp; }<BR>}</P>
<P>or a mutator rule like this:</P>
<P>private static void MyRule&lt;T&gt;(T target, RuleArgs e) where T : MyType<BR>{<BR>&nbsp; e.RuleContext.PropertyValues[e.PropertyName] =&nbsp;<BR>&nbsp;&nbsp;&nbsp; e.RuleContext.PropertyValues[e.PropertyName].ToString().ToUpper();<BR>}</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, November 20, 2009</h2><P>Are there any plans to seperate kinds of rules?&nbsp; For instance, validation rules tend to look at the value, but don't change it, but other rules do change the values... so sometimes I would only want to run valedation rules (maybe after a DP_F), but I'd want both sets running in response to a property changed event.. maybe all business rules run prior to validation.</P>
<P>What do you think?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, November 20, 2009</h2><P>Rocky,</P>
<P>Thanks for the detailed feedback on the future direction.</P>
<P>For the immediate 3.8 version could you please comment on what can be done right now? I tend to think the StopProcessing idea for Data Manipulation Rules is the simplest one. Along with setting their Priority to -1 so that they always run first. Under that scenario, a Data Manipulation Rule would run, change the value via reflection, stop processing the current loop and then re-start the loop due to the changed property set. But this time the Data Manipulation rule would not have to modify the value since newValue=value and the rest of the Validation rules would then run.</P>
<P>I will try to find time next week to look into this but I am in the middle of some other projects.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Thursday, November 26, 2009</h2>What of authorisation rules?<br><br>One of the very limiting issues with authorisation rules is that we can't define an authorisation rule using a delegate like we can with business/validation rules.<br><br>Having the auth rules run purely against a set of roles only caters for very basic authentication models.&nbsp; <br>Most more advanced LOB applications (like mine) have many other temporal and contextual parameters to consider when determining whether or not a user has write/read/view access to a property or object.<br><br>It would be a major improvement if you could enable the auth rules side to work like business/validation rules.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, November 26, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>You can override CanReadProperty() and CanWriteProperty() in a
class to provide more contextual rule behaviors.</span><b><span><o:p></o:p></span></b></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Friday, November 27, 2009</h2>True, though CanRead and CanWriteProperty methods are hardly as nice to code and read as ValidationRules.&nbsp; Plus there's not annotation options with the CanRead/Write methods.<br><br>Besides the property level, there is no current way to use delegates to control operations at the object level.&nbsp; As far as I know all the AuthorisationRules methods are based on a string [] of Roles.<br>So controlling things like creation and deletion of objects is still very much tied to the basic roles model.<br><br>If I'm wrong about this, please enlighten me - but otherwise I would really hope that adding delegate options to the AuthorisationRules class methods is on the list for CSLA 4.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, November 27, 2009</h2><P>There are three types of authz in most people's minds:</P>
<P>Per-property, which you can customize by overriding CanReadProperty()/CanWriteProperty() - and even if I provided a Func&lt;T&gt; so you could inject a lambda you'd end up writing the same code in the lambda that you do in the override - so it isn't clear there's a benefit?</P>
<P>Per-type, which are static rules that are role-based. Since these are static rules, they don't have access to instance data and so can't really be contextual. If someone can present a clear scenario where there'd be value in providing a static bool method to evaluate each rule I'd consider the idea.</P>
<P>Per-instance, which isn't currently supported by CSLA at all. Such rules could be contextual, because they'd live in an instance. But since they'd live in an instance they'd be potentially expensive (if role-based), because it would require initializing and maintaining the lists of roles on a per-instance basis. The perf and memory impact would likely be non-trivial, and having been down that road once before (CSLA 2.0) I have no desire to go there again.</P>
<P>I suppose I could define a per-instance <EM>interface</EM> that has a default implementation in BusinessBase and BusinessListBase of always returning the value of the existing static methods for each operation - and then allow you to override the methods to provide your own implementation. That way I would merely enable costly implementations, but wouldn't actually create one :)</P>
<P>The per-instance rule concept is actually an item in the wish list - it has been there for a while, because I haven't been able to get excited about it...</P>
<P><A href="http://www.lhotka.net/weblog/PrioritizingCSLANETWorkItems.aspx">http://www.lhotka.net/weblog/PrioritizingCSLANETWorkItems.aspx</A></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Sunday, November 29, 2009</h2>I'll try and explain the issue I have with the current static auth rules implementation with the following example:<br><br>In my system, users have multiple roles with each role linked to a set of function/task permissions. <br>When determining whether or not a user has access to create/delete an object or execute a function, we check a specific task permission to see what level of access they have.<br>On top of this, we also have to account for their access to certain projects/entities in the system.&nbsp; If the user does not have access to a specific project entity, then they cannot perform functions on items related to that project.<br>And to top everything off, we also have a multitude of system parameters/settings that affect whether or not certain functions are available at all at an application level.<br><br>Thus we often have to make a 3 level check to detemine whether or not a user can create an object:<br>Has task permission?<br>&nbsp; If yes, has project access?<br>&nbsp;&nbsp;&nbsp; If yes, has system parameter set to true?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If yes, then user can execute.<br><br>I did try to load a user's task permissions up into the Roles property of the Identity object, but that still left me without any way to check their project access and the system parameter setting.<br><br>What I have ended up doing is actually overriding BusinessPrincipalBase.IsInRole.&nbsp; <br>I then used the role parameter as a delimited string using a pattern of my devising in order to be able to pass in the various task, project, system parameter and other values I want to check as part of the access check:<br><font size="2" face="Courier New"><br>/// &lt;summary&gt;<br>&nbsp;&nbsp;&nbsp; /// Highly customised override of the default CSLA IsInRole.<br>&nbsp;&nbsp;&nbsp; /// This method can validate against user profile, user task permission, system setting, project permission<br>&nbsp;&nbsp;&nbsp; /// and arbitary string equality.<br>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;remarks&gt;<br>&nbsp;&nbsp;&nbsp; /// The role string passed in is expected to contain one of the constant strings defined in class IsInRoleInstruction<br>&nbsp;&nbsp;&nbsp; /// followed directly by the int value to check for.<br>&nbsp;&nbsp;&nbsp; /// This method will extract the int value and then run the appropriate security check based on the Instruction.<br>&nbsp;&nbsp;&nbsp; /// &lt;/remarks&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;param name="role"&gt;The string containing an instruction about what specifically to check&lt;/param&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;True if the instruction is executed with a true result&lt;/returns&gt;<br>&nbsp;&nbsp;&nbsp; public override bool IsInRole(string role)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (role.Contains(IsInRoleInstruction.TaskInstruction))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.MyIdentity.HasTaskPermission(Int32.Parse(role.Replace(IsInRoleInstruction.TaskInstruction, "")));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (role.Contains(IsInRoleInstruction.ProjectInstruction))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.MyIdentity.HasProjectPermission(Int32.Parse(role.Replace(IsInRoleInstruction.ProjectInstruction, "")));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (role.Contains(IsInRoleInstruction.SysParamInstruction))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return AppCache.SystemSettings.IsSettingEnabled(Int32.Parse(role.Replace(IsInRoleInstruction.SysParamInstruction, "")));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (role.Contains(IsInRoleInstruction.IsEqualInstruction)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var split = role.Replace(IsInRoleInstruction.IsEqualInstruction, "").Split('=');<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return String.Equals(split[0], split[1], StringComparison.InvariantCultureIgnoreCase);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp; }</font><br><br>An example of a call to this highly customised IsInRole would be something like:<br><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; public static void AddObjectAuthorizationRules()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowDelete(typeof(Document), IsInRoleInstruction.HasTask(TaskPermissions.AllowDeleteDocuments));<br></font><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowDelete(typeof(Document),&nbsp; </font><font size="2" face="Courier New"><br>IsInRoleInstruction.HasProject(AppCache.CurrentProject));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font size="2" face="Courier New">AuthorizationRules.AllowDelete(typeof(Document), </font><br><font size="2" face="Courier New">IsInRoleInstruction.HasSysParam(SystemParameters.AllowGLImportTrans));<br>&nbsp;&nbsp;&nbsp; }</font><br><br>As you can see I have tried to wrap all the delimited string nastiness up in classes, but at the end of the day my approach is hard coded and not at all easy to read like a similar delegate-based ValidationRule would be.<br><br>My approach has some issues too.&nbsp; For one I am relying on only instantiating the static constructor of the class containing the AddObjectAuthorizationRules() method after I have intialised various static cache classes (AppCache for example above).&nbsp; <br>Given it is static, I can only use the user project access checks on the client side since server side it would be static for the app domain.<br>Being able to use a delegate would solve these issues.<br><br>Hope this helps you understand my position.&nbsp; Having static object rules that are based purely on a call to IsInRole is severely limiting in a more complex security model like mine.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, November 29, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>So you are able to get this &#8220;project&#8221; information from ambient
data? As in it isn&#8217;t specific to an object instance, but rather exists because
of some broader global context data?</span><b><span><o:p></o:p></span></b></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Tuesday, December 01, 2009</h2>Rocky,<br><br>Yes - we load the user's projects into the "MyIdentity" class as an additional property, along with some other properties for the logged-in user's specific settings and data.&nbsp; <br>There are a few more user-specific entity assignments that happen in our system which influence authorisation rules at an object level, I've just excluded them for clarity here.<br><br>In terms of how we do the <font size="2" face="Courier New">AddObjectAuthorizationRules</font>&nbsp; method, we have static cache objects which return session data on the client and on the server.&nbsp; <br>So for example, in the line:<br><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowDelete(typeof(Document),&nbsp; </font><font size="2" face="Courier New"><br>IsInRoleInstruction.HasProject(AppCache.CurrentProject));</font><br>The AppCache.CurrentProject call goes to a static singleton on the Silverlight client side (since we assume the app domain and session are the same on the client) and on the server side is a more complex call which pulls the user's specific instance of the AppCache out of the ASP.Net session.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, December 02, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>So you are able to get this “project” information from ambient<br />data? As in it isn’t specific to an object instance, but rather exists because<br />of some broader global context data?</div></BLOCKQUOTE><br /><br />In our case, the authorization is often determined by a combination of instance and ambient data in many cases. <br /><br />The main idea is that some objects have a "location" associated with them.  The users have roles assigned to them, but they can vary by location. If the object has an associated location, then it is used. Otherwise, the ambient location is used. <br /><br />I could possibly implement a (comparatively expensive) instance level roles list, but IMHO the best thing would be to have authorization work almost exactly like the validation rules mechanism - have the ability to associate rule methods with reading and writing of properties, and with the basic CRUD operations. If any rule fired returns false, then the authorization is denied. Otherwise, it is granted.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, December 02, 2009</h2><P>You can do this by overriding CanReadProperty/CanWriteProperty though, so I'm not sure what sort of change you'd like?</P>
<P>I could maintain more metadata per property, allowing you to define a delegate that is called instead of the normal CanReadProperty/CanWriteProperty - but that's just sugar, since the code you'd write would be essentially the same as today. And maintaining those lists of delegates would be overhead that doesn't exist today - so I think there should be a broad and compelling argument (as in many people asking, not just one) to justify the overhead.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, December 02, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><P>You can do this by overriding CanReadProperty/CanWriteProperty though, so I'm not sure what sort of change you'd like?</P><br /><P>I could maintain more metadata per property, allowing you to define a delegate that is called instead of the normal CanReadProperty/CanWriteProperty - but that's just sugar, since the code you'd write would be essentially the same as today. And maintaining those lists of delegates would be overhead that doesn't exist today - so I think there should be a broad and compelling argument (as in many people asking, not just one) to justify the overhead.</P></div></BLOCKQUOTE><br /><br />Well, paupdb pretty much summed it up above: <br /><br />"True, though CanRead and CanWriteProperty methods are hardly as nice to code and read as ValidationRules.  Plus there's not annotation options with the CanRead/Write methods."<br /><br />With validation rules, the infrastructure determines which property changed and fires the proper delegates for you. <br /><br />Sure, you can override CanRead/CanWrite, then you'll end up manually implementing the test for each property in every such override that you write.  <br /><br />Now there are at least two of us asking... :)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 02, 2009</h2><P>Its true you can override CanRead / WriteProperty to do this, but its never seemed consistent with the rest of Csla.&nbsp; I think it has been said in this forum that auth. rules are just a certain kind of business rule, and I tend to agree.</P>
<P>Allowing delegates puts things along the line of all the other business rules, and people may be more inclined to factor out auth rules into seperate classes, if there's a property whose auth rules are consistent across several use cases.&nbsp; </P>
<P>If auth rules are consistent within a BO such that they apply to all properties in that BO, overriding CanXProperty is a fine solution.</P>
<P>But when my overrides end up containing switch statements, something starts to feel quite a bit off, and I do have a few of these kinds of BOs around.&nbsp; </P>
<P>I'm also left wondering if this could help a situation I have where I have the concept of Quotes, Orders, Invoices, etc.&nbsp; Each of these has a common base (Document) because they share a lot of common behavior (more than not) and I also have a child ShipTo BO.&nbsp; It needs to know what kind of document, so I have QuoteShipTo, OrderShipTo, InvoiceShipTo, and the only difference between the three is the AddAuthorizationRules override.&nbsp; There's probably nothing wrong with this design, but I end up with 18 classes (5 distinct types of documents, and besides ShipTo theres BillTo and SoldTo).&nbsp; Having a delegate may help me remove some of these classes, and put the answer to "who has auth" where it feels like it belongs; in the parent document class.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Wednesday, December 02, 2009</h2>What about adding overload to AllowRead and AllowWrite method to allow user to inject their own handler.<br><br>AuthorizationRules.AllowWrite(string propertyName, Action&lt;T&gt; testHandler)<br><br>That way user can implement their own permission check for more complex security not just based on role.<br><br>Like Rocky say, this is technically can be done now by overriding CanReadProperty/CanWriteProperty however going through AuthorizationRule will kinda formalize the implementation.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 02, 2009</h2>Well I think that's the suggestion isn't it?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Wednesday, December 02, 2009</h2>I can live with CanRead/WriteProperty at a property level since at least this is a reasonable workaround - thank goodness for regions is all I can say for this.&nbsp; I use a lot of regions in my CanWriteProperty methods since a lot of them are easily 500+ lines on their own.<br><br>I'm still waiting on a response regarding the object level authorisation rules.&nbsp; <br><br>The problem with object level auth rules is that there is <b>no workaround</b> when one wants to apply rules which involve more than just what is stored in the user principal's roles.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, December 02, 2009</h2><P>I thought I was clear in a previous post - there's a wish list item to allow per-type rules to be customized, and I understand that argument.</P>
<P>There is no such thing as per-object (per-instance) rules. I am not yet sure how they'd work. There's no way to implement CanCreateObject() and CanGetObject() on a per-instance basis, because the object doesn't exist yet when those rules are invoked by the data portal. There could be CanEditObject() and CanDeleteObject() per-instance rules, but that seems quite incomplete as a story...</P>
<P>There are absolutely ways to do delegate-based per-property rules. That incurs a certain amount of overhead because I'd have to maintain the delegate references.&nbsp;A quick look at the code to refresh my memory leads me to believe the overhead would be very minor, and so I may well add support for this concept.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Wednesday, December 02, 2009</h2>Rocky,<br><br>My focus is on the per type static object level auth rule facilities.<br><br>In your previous post you mentioned that per-instance object level rules enhancements were on the wish list, but said nothing about what the plans are for the per type statics.<br><br>You said<br>"Per-type, which are static rules that are role-based. Since these are
static rules, they don't have access to instance data and so can't
really be contextual. If someone can present a clear scenario where
there'd be value in providing a static bool method to evaluate each
rule I'd consider the idea."<br><br>I provided an example in detail.<br><br>You also said that static rules cannot access contextual data, but thats not true.&nbsp; <br>The current per type rules system uses the IsInRole method on the user principal - which is clearly contextual to the user currently logged in.<br><br>What I am saying is that along with user "Roles", I have a system where the user has a number of other properties that feed into authentication decisions at a per type level.&nbsp; <br><br>I gave my system's project concept as an example - where the projects that the user has access to were loaded onto the user principal at present.<br>We use this project access information to determine authorisation rules.<br>For instance depending on the user's level of access on the current project selected in the application, a user might be able to delete certain business object types.&nbsp; This "current project" concept is a session wide value that the user modifies when they want to change project context.<br><br>If I'm off track or have missed something here, let me know - but I hope what I have summarised above is clear and accurate.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 03, 2009</h2><A href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=13">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=13</A></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Thursday, December 03, 2009</h2>OK so adding delegates into per type auth rule calls seems to be part of what you refer to as shared hosting improvements?&nbsp; <br>I saw you mention that earlier in this thread - so can I assume this means that the the issue # 13 is on the list for CSLA 4?<br><br>If so then :)<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 03, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>Issue 13 is in the running for CSLA 4. In the end some of these
things will come down to a matter of time. But multi-tenant business and authz
rules are fairly high on my priority list.<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Thursday, November 19, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Peran:</strong></div><div>Here are 2 ideas I was working on last night:<BR><BR>The second idea was to use IManageProperties to update the value without causing the rules to rerun at all.&nbsp; This does however break encapsulation (using an explicit interface, so it's not quite as bad!) and requires IManageProperties to be changed from internal to public.&nbsp; You would need to run the StringRequired rule after this rule, incase the user just entered some space characters.<BR><BR>&nbsp;&nbsp;&nbsp; public class StringRuleArgs : Csla.Validation.RuleArgs<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region constructors<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public StringRuleArgs(PropertyInfo&lt;string&gt; propertyInfo)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(propertyInfo)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.PropertyInfo = propertyInfo;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region proeprties<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public PropertyInfo&lt;string&gt; PropertyInfo { get; private set; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion<BR>&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static bool ToUpperTrim2(object target, Csla.Validation.RuleArgs e)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var args = (StringRuleArgs)e;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var businessObject = (IManageProperties)target;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string value = businessObject.ReadProperty(args.PropertyInfo);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string newValue = value.ToUpper(CultureInfo.CurrentCulture).Trim();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; businessObject.LoadProperty(args.PropertyInfo, newValue);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR><BR></div></BLOCKQUOTE></P>
<P>This is how I have handled these rules when they are located local to the business object. &nbsp; </P>
<P>After the LoadProperty you probably also need to add:</P>
<P>businessObject.OnPropertyChanged(args.PropertyInfo.Name)</P>
<P>so that the UI updates correctly.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Peran replied on Thursday, November 19, 2009</h2>Hi Fintanv,<br><br>I'm guessing your using a WinForms UI as the call to OnPropertyChanged is not required for a Silverlight UI.<br><br>Rocky created the BindingSourceRefresh control as an alternative approach for WinForms.<br><br><br>Cheers<br><br>Peran<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Thursday, November 19, 2009</h2>Joe, <br>
This is pretty interesting topic.&nbsp; I've ran into this situation before
where I need to enforce value to be upper cased. Because I don't do
this many times, it never cross my mind to implement it so it can be
used globally.&nbsp; <br>
<br>
I'd probably not use ValidationRules to implement data manipulation for
clarity.&nbsp; I'd override PropertyHasChanged and inject the data
manipulation code right before validation rules get called.&nbsp; I'd use
attribute to indicate property that requires data manipulation.&nbsp; <br>
<br>The following implemented in custom business base:<br><font size="2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void PropertyHasChanged(string propertyName)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var prop = TypeDescriptor.GetProperties(typeof(T)).Find(propertyName, false);</span><br><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attr = (from Attribute a in prop.Attributes</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where a is EnforcerAttribute</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select (EnforcerAttribute)a).ToArray();</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attr.Length &gt; 0)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var modValue = prop.GetValue(this);</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var attribute in attr)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; modValue = attribute.Enforce(modValue);</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prop.SetValue(this, modValue);</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.PropertyHasChanged(propertyName);</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br></font>And here how I'd implement Trim and ToUpper attributes:<br><font size="2"><span>&nbsp;&nbsp;&nbsp; class ToUpperAttribute : EnforcerAttribute</span><br><span>&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override object Enforce(object value)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((string) value).ToUpper();</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br><span>&nbsp;&nbsp;&nbsp; }</span><br><br><span>&nbsp;&nbsp;&nbsp; class TrimAttribute : EnforcerAttribute</span><br><span>&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override object Enforce(object value)</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((string) value).Trim();</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span><br><span>&nbsp;&nbsp;&nbsp; }</span><br></font><br>I have also attach the complete project contain my experimental code, take a look and let me know if that would work for you.<br><br>Ricky<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
