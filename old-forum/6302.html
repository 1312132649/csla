<html><header><title>Transactions and SQL Connection Efficiencies</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Transactions and SQL Connection Efficiencies</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6302.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>DCottle posted on Friday, January 30, 2009</h2><P>I have to questions, related but distinct:</P>
<P>1.&nbsp; During the update/insert process for an object with child object graphs, a very normal operation would be to get back the primary key for an inserted parent and pass that to the children updating their key with the parents newly created primary.&nbsp; Using the new .NET Transaction scope, what would happen if the last of these children actually failed in their update.&nbsp; I know the data in the database would all get rolled back, but what about the parent and all of the children that were updated previous to the one that failed...how would they have their primary / foreign key data rolled back to the previous state?</P>
<P>2.&nbsp; The company I am currently working for has an in house Data Access Library (DAL) that they have optimized to handle many 100's of transactions per second.&nbsp; So, using a dataset with relations established, they will basically construct all of the command objects (NOT executing them at this time), and then once they are all constructed they will open a connection and start executing each of the command objects that would represent the data hierarchy in rapid sequence.&nbsp; The only actions that really happen between the execute of one command to the next is updating a primary / foreign key if necessary.&nbsp; This ensures that their connections objects are open for the minimum amount of time possible, and thus reduces any chances of locking or deadlocks that you could find in a large volume application.&nbsp;&nbsp;&nbsp; Specifically, how does the performance of CSLA's built in DataPortal_Update application compare with this optimized scenerio.&nbsp; I know (or at least I think I know), that CSLA will open a connection for me with the first reference to the ConnectionManager, and basically as long as I have any objects in my object tree that are being updated with that connection it will hold onto the connection as long as needed.&nbsp; </P>
<P>How much more likely is a blocking or deadlock situation using this method employed by CSLA?&nbsp; Do you have any recommendations that we can make sure we try to follow to prevent those situations?</P>
<P>Thanks</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, January 30, 2009</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DCottle:</strong></div><div>1.&nbsp; During the update/insert process for an object with child object graphs, a very normal operation would be to get back the primary key for an inserted parent and pass that to the children updating their key with the parents newly created primary.&nbsp; Using the new .NET Transaction scope, what would happen if the last of these children actually failed in their update.&nbsp; I know the data in the database would all get rolled back, but what about the parent and all of the children that were updated previous to the one that failed...how would they have their primary / foreign key data rolled back to the previous state?</div></BLOCKQUOTE><br><br>They wouldn't.&nbsp; You'd get back an exception, and the original object is cloned before saving, so it shouldn't be left in an inconsistent state.&nbsp; Note that some earlier versions of Csla didn't do the cloning if you're using the Local DataPortal, and so you need to do this step yourself to prevent corrupting the in memory object.<br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DCottle:</strong></div><div>2.&nbsp; The company I am currently working for has an in house Data Access Library (DAL) that they have optimized to handle many 100's of transactions per second.&nbsp; So, using a dataset with relations established, they will basically construct all of the command objects (NOT executing them at this time), and then once they are all constructed they will open a connection and start executing each of the command objects that would represent the data hierarchy in rapid sequence.&nbsp; The only actions that really happen between the execute of one command to the next is updating a primary / foreign key if necessary.&nbsp; This ensures that their connections objects are open for the minimum amount of time possible, and thus reduces any chances of locking or deadlocks that you could find in a large volume application.&nbsp;&nbsp;&nbsp; Specifically, how does the performance of CSLA's built in DataPortal_Update application compare with this optimized scenerio.&nbsp; I know (or at least I think I know), that CSLA will open a connection for me with the first reference to the ConnectionManager, and basically as long as I have any objects in my object tree that are being updated with that connection it will hold onto the connection as long as needed. </div></BLOCKQUOTE></p><p>Csla leaves it up to you to do your data access.&nbsp; So it offers nothing in this regard.&nbsp; Your DataPortal_Insert or Update code must be setup to keep the connection open as little as possible.&nbsp; So you could even continue to use your custom DAL in the same manner.&nbsp; I'll also point out that this is how Linq To Sql and likely Linq to Entities works (that is, they figure out all the statements, then execute in a single batch).<br></p><p><br></p>HTH</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DCottle replied on Friday, January 30, 2009</h2><P>That is not exactly true as far as CSLA leaving it up to me to do my data access.&nbsp; It does in fact provide a ConnectionManager that will take advantage of the .NET TransactionScope object, but by utilizing the ConnectionManager I am pretty much forcing my connection to stay open during the entire update process am I not?</P>
<P>It is this time comparison that concerns me.&nbsp; Normal CSLA Parent/Child/Grandchild updates, versus the optimzed DAL that will batch all of the Command objects and send them all in rapid succession.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, January 30, 2009</h2>The connection manager has nothing directly to do with TransactionScope.&nbsp; It's purpose is to allow the use of a single, shared connection, but you don't have to use it if your custom DAL will do this for you.<br><br>You can use the TransactionScope object directly, or via an attribute.. but neither method requires the use of the ConnectionManager.&nbsp; It's there for convince for those that don't use a custom DAL.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DCottle replied on Friday, January 30, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>The connection manager has nothing directly to do with TransactionScope.&nbsp; It's purpose is to allow the use of a single, shared connection, but you don't have to use it if your custom DAL will do this for you.<BR><BR>You can use the TransactionScope object directly, or via an attribute.. but neither method requires the use of the ConnectionManager.&nbsp; It's there for convince for those that don't use a custom DAL.<BR></div></BLOCKQUOTE></P>
<P>Got it.&nbsp; I understand that I do not have to use the ConnectionManager, nor the TransactionScope.&nbsp; But using the ConnectionManager does give me the ability to use the TransactionScope because each of my calls for a new connection will return the same one, thus providing for the context of the transaction to remain open.</P>
<P>I understand I do not HAVE to use these features.&nbsp; I am simply stating that I WANT to use the features if I can do so while still maintaining efficient data access and avoiding the locking scenerios described above.</P>
<P>So back to my original question: Does anyone have any input as to how scalable it would be (say using just regular ADO.NET) to use the ConnectionManager and the TransactionScope to manage our database inserts/updates.</P>
<P>Has anyone else noticed when they scale this up using the ConnectionManager and the TransactionScope features provided with CSLA that they have locking issues?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, January 30, 2009</h2><P>In my opinion the use of the ConnectionManager will be fine. It will operate just&nbsp;as fast&nbsp;as the custom DAL code. </P>
<P>They are both doing similar things:&nbsp;opening a connection, and then processing SQL commands as fast as they can. There is nothing special about either of them. </P>
<P>When you setup a transaction for use in ADO.Net then you will have the same potential issues with deadlocks as with your custom DAL which uses transactions too. To me they are equivalent.</P>
<P>The key idea when coding your Insert/Update/Delete operations inside a tr is to keep them open as short as posisble. In other words, when you do an insert, do not turn around and do a Fetch, and then some massive processing while the tr is still uncommitted. Also, once the tr is open be sure each of your queries uses it to prevent other issues. This is easier to overlook than you might think. You could be updating many different BOs and one of them might do a quick lookup during processing and if it does not use the tr it won't see the new data. Or it could deadlock waiting for the tr to commit.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, January 31, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>DCottle:</strong></div><div>
<P>Has anyone else noticed when they scale this up using the ConnectionManager and the TransactionScope features provided with CSLA that they have locking issues?</P>
<P></div></BLOCKQUOTE></P>
<P>As Joe points out, you <EM>can</EM> get in trouble. But the trouble is the kind you'll get into with any DAL.</P>
<P>If all your code is running within a transaction, then you have to "get in and out fast" and avoid doing a lot (or any) data reads or other long-running work.</P>
<P>If you use the Transactional attribute on a DataPortal_XYZ method, then all your server-side code will run within the transaction. The data portal starts the transaction before calling your code, and ends it after your code completes.</P>
<P>You need to be aware that this is the case, and realize that all your code is inside a transaction, and so you can have NO LONG RUNNING BEHAVIORS in your server-side code.</P>
<P>If you <EM>need</EM> long running behaviors, then don't use the Transactional attribute. Use manual transactions, and create your own TransactionScope object. You should realize that the Transactional attribute really saves you exactly 2 lines of code. Instead of this:</P>
<P>[Transactional(TransactionScope)]<BR>protected override void DataPortal_Update()<BR>{<BR>&nbsp; // update here<BR>}</P>
<P>You have this:</P>
<P>protected override void DataPortal_Update()<BR>{<BR>&nbsp; using (var tr = new TransactionScope())<BR>&nbsp; {<BR>&nbsp; &nbsp; // update here<BR>&nbsp; }<BR>}</P>
<P>Arguably you've added two lines of code: "{" and "}"&nbsp; ;)</P>
<P>Either way, you can use ConnectionManager - it has nothing at all to do with the Transactional attribute.</P>
<P>The thing I want you to notice, is that in the <EM>second</EM> code block, you could execute code before or after entering the transactional scope. You could run long-running code outside the transaction.</P>
<P>However, I also want to point out that you'll cascade the calls to your child objects <EM>inside the transaction scope</EM> in both cases. So if the <EM>child</EM> needs to do some long-running code outside the transaction, you'll have to devise your own scheme by which the root can invoke the child before or after the transactional scope block.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
