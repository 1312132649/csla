<html><header><title>Fetch a particular object without criteria</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Fetch a particular object without criteria</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/595.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Michael Hildner posted on Tuesday, July 11, 2006</h2><P>Hello,</P>
<P>I'm a little unsure how to accomplish this, looking for some help.</P>
<P>Let's say I have an object, CustomerReadOnlyRoot, that I need to fetch. The data access is done through stored procedures. I don't know anything about the Customer, like primary key etc. Instead I need to use a stored procedure such as SelectMostActiveCustomer or SelectMostRecentCustomer.</P>
<P>I'm thinking I'd like to have public methods in my BO like .GetMostActive() and .GetMostRecent(). How do I set up the DataPortal_Fetch method(s) so I can specify which sproc to use?</P>
<P>I haven't delved into this part of CSLA, so not sure if I'd use some sort of Criteria or not.</P>
<P>Thanks,</P>
<P>Mike</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, July 11, 2006</h2><P>Your logic for selecting the customer doesn't really change, right? You still are going to want to fetch the same information for a customer by ID -&nbsp;you don't know the ID up front.<EM> </EM>You need to get it first. </P>
<P>One option might be to have a couple command objects that are used to get the most active and most recent id, respectively. You might have factory methods on your object for Customer.GetCustomer(id), along with two for these purposes Customer.GetCustomerMostActive() and Customer.GetCustomerMostRecent(). The first task of the two new factory methods would be to invoke a command object needed to get the appropriate Id, and then delegate the call to Customer.GetCustomer() with the right Id. </P>
<P>That would be my suggestion... </P>
<P>Hope this helps. </P>
<P>Chris</P>
<P>... or, you could embed the extra fields into your Criteria object and then populate it differently for each factory method - one would assign the Id, one a flag for MostRecent, and one for MostActive. In your fetch if the Id doesn't exist you could just call the stored procedure based on which flag was checked and then utilize that Id returned by the stored procedure. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Wednesday, July 12, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div><p>One option might be to have a couple command objects that are used to get the most active and most recent id, respectively. You might have factory methods on your object for Customer.GetCustomer(id), along with two for these purposes Customer.GetCustomerMostActive() and Customer.GetCustomerMostRecent(). The first task of the two new factory methods would be to invoke a command object needed to get the appropriate Id, and then delegate the call to Customer.GetCustomer() with the right Id. </p></div></BLOCKQUOTE><br><br>I would vote for the command objects myself, but I would have the command objects return a concrete editable customer rather than an ID. Consider the case of a remote data portal. If you fetch the ID, you're making a round trip. A second round trip is needed to get the customer.<br><br>If the command object returns the customer object, the call to the customer object's factory method is done from within the command object's DataPortal_Execute method. With a remote data portal, the object is already running on the server, and an extra round trip is not necessary.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, July 14, 2006</h2><P>I agree with hurcane and he very aptly stated exactly what I was thinking.&nbsp; However, I won't discount Fabio's solution either.&nbsp; What it really boils down to is WHERE you want your logic to exist.&nbsp; The command object approach allows you to encapsulate the logic of each method into your BO - at least as far as the sproc name is concerned in this case.&nbsp; Going with the enumerated parameter approach means that your sproc is a little more complicated, a single sproc is handling three different duties, etc.</P>
<P>Either way is valid, but I like the command object approach for consistency's sake.</P>
<P>btw - we have implemented this type of construct for many dynamic features in web apps such as "Recent News" or "Today's Headlines" where the query is different than the standard.&nbsp; In these cases the methods and command objects are on the collection and return the collection, but the logic/approach is the same.</P>
<P>Hope that helps.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fabio replied on Tuesday, July 11, 2006</h2>Your criteria can look like (in your bo):<br>public enum MostMode<br>{<br>MostRecent,<br>MostActive<br>}<br><br>public class CriteriaMost<br>{<br>private MostMode _mostMode= MostMode.MostRecent;<br>public CriteriaMost(MostMode aMostMode)<br>{_mostMode = aMostMode;}<br>public MostMode Mode<br>{get {return _mostMode;}}<br>}<br><br>And your factory look like:<br>&nbsp;&nbsp;&nbsp; public static Customer GetMostActive()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Csla.DataPortal.Fetch&lt;Customer&gt;(new CriteriaMost(MostMode.MostActive));<br>&nbsp;&nbsp;&nbsp; }<br><br><br>Then you must have a DataPortal_Fetch ....<br>Bye.<br>Fabio.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 11, 2006</h2><P>Version 2.0.2 introduced the idea of a parameterless DataPortal.Fetch() call. Which means no criteria is passed to the DataPortal_Fetch() method at all. So if you can figure out what to do in that method with no criteria at all, then you can do this:</P>
<P>Factory:</P>
<P>Public Shared Function GetObj() As Obj<BR>&nbsp; Return DataPortal.Fetch(Of Obj)()<BR>End Function</P>
<P>Data access:</P>
<P>Protected Overrides Sub DataPortal_Fetch(ByVal criteria As Object)<BR>&nbsp; ' criteria is Nothing/null - just ignore it<BR>End Sub</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Michael Hildner replied on Tuesday, July 11, 2006</h2><P>Thanks all for the replies.</P>
<P>Just checking things out for now, but using something similar to Fabio's suggestion. Then in the _Fetch, using a switch (Select Case) to set the stored procedure name. Seems strait-forward and easy to read.</P>
<P>Regards,</P>
<P>Mike</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
