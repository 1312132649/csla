<html><header><title>&quot;Fat&quot; Objects or &quot;Slim&quot; Objects ?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>&quot;Fat&quot; Objects or &quot;Slim&quot; Objects ?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7172.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx posted on Thursday, June 25, 2009</h2>Is it better to write "fat" objects or "thin" objects?<br /><br />Let me explain...<br /><br />Say I need some code to work with data for a Purchase Order, and its related Customer and Vendor.  So I write a "PurchaseOrder" object, a "Customer" object, and a "Vendor" object.<br /><br />Is it better to write a "fat" PurchaseOrder object that contains a Customer child object and a Vendor child object.<br /><br />Or is it better to write a "slim" PurchaseOrder object that contains a CustomerId and a VendorId ("Id" meaning unique identifier or primary key).  And then let the UI developer use two Ids to instantiate the Customer and Vendor objects separately when they're actually needed.<br /><br />I see some advantage to "fat" approach - you make one call to one factory method and you get everything you might need; maybe this makes life easier on the UI developer.<br /><br />I see some advantage to "thin" approach - more loosely coupled; less dependency/reference issues if multiple assemblies; possible performance gain if child objects not always needed.<br /><br />I'm looking at a project I started a long time ago where I took the "fat" approach.  And today I'm thinking that maybe I should have done "thin" instead.  I'm debating whether to convert it.<br /><br />Which approach do you think is better and why?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, June 25, 2009</h2><P>I think you should always design your objects to match the needs of your user scenario/story/use case.</P>
<P>And I think your objects should exist because they have a <EM>responsibility</EM>, not because they contain data (unless their only responsibility is to contain data - such as a DTO).</P>
<P>If your user scenario actually has the user editing PO, Customer and Vendor data on a single screen, then you probably need PurchaseOrderEdit, CustomerEdit and VendorEdit objects all contained as child objects of&nbsp;a parent PurchaseOrderEntry object. </P>
<P>That seems really unlikely though, because these are typically different use cases. Typically the person entering POs can't arbitarily create/edit customer data, and they often can't even create/edit vendor data. And even if they can edit vendor data, that's usually a different use case&nbsp;- a different scenario.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dg78 replied on Friday, June 26, 2009</h2><P class=MsoNormal><SPAN>A few days ago, I was in the same thoughts as Jason.<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>So I put, with code generation, in my business objects three possibilities and I activate only one for each BO :<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>- "fat" object <SPAN>&nbsp;</SPAN>:<SPAN>&nbsp; </SPAN></SPAN><SPAN><SPAN>&nbsp;&nbsp;</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><SPAN>&nbsp; </SPAN>_MyCustomer = Customer.GetCustomer(Value)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>- search in a NameValueList <o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><SPAN>&nbsp;</SPAN>_CustomerName = NvlCustomer.Value(Value)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>- direct access to the database <SPAN>&nbsp;</SPAN>(of course with dataportal)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><SPAN>&nbsp;</SPAN>_CustomerName = ReadName.GetName(<SPAN>"customer"</SPAN>, Value)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>For some objects we need only name and for others we need all data, it depends of the use case.<o:p></o:p></SPAN></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Friday, June 26, 2009</h2>Sorry, I should have stated this more clearly...<br /><br />PurchaseOrder:<br /> - Editable object.<br /> - On the UI, this data is always displayed and can be changed.<br /><br />Customer:<br /> - Read only object.<br /> - On the UI, this data is sometimes displayed and cannot be changed.<br /><br />Vendor:<br /> - Read only object.<br /> - On the UI, this data is sometimes displayed and cannot be changed.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Monday, June 29, 2009</h2>.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 29, 2009</h2><P>Why would PurchaseOrderEdit <EM>contain</EM> CustomerList or VendorList?</P>
<P>PurchaseOrderEdit might <EM>use</EM> CustomerList to validate its CustomerId property value (in a business rule). Or PurchaseOrderEdit might <EM>use</EM> a CustomerIdValidator command object to validate its CustomerId proprty value.</P>
<P>Then again, POE might not have a business rule to validate the CustomerId property, because if it is wrong you'll find out when the database throws an exception during the save process (due to referential integrity), in which case POE might not use CustomerList or a CustomerIdValidator.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
