<html><header><title>BusyAnimation during save?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>BusyAnimation during save?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8016.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Devman posted on Thursday, November 19, 2009</h2>Hi,<br><br>I've hooked up the BusyAnimation IsRunning property to the IsBusy property of my CslaDataProvider/BO. The animation runs as the object is retrieved, so far so good.<br><br>However is it possible to have the animation running whilst saving/undo changes to the BO? I would have thought the IsBusy property would be true during the save/undo process, but it is not :(<br><br><br>I have a checkbox bound to IsBusy (where its datacontext is the CslaDataProvider) to see the status of the property. Ive also removed "BindsDirectlyToSource=True" from the binding and the checkbox never gets checked.<br><br>&lt;CheckBox IsEnabled="False" IsChecked="{Binding Path=IsBusy,Mode=OneWay, BindsDirectlyToSource=True}" Content="IsBusy"/&gt;<br><br>Any thoughts?<br><br>Best Regards<br>David<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, November 20, 2009</h2><P>In WPF the save operation is synchronous, so this won't work. In SL the save operation is async (by definition), so it should work fine.</P>
<P>In WPF when using a ViewModel base class you can choose to use sync or async save, and if you choose async then you can use BusyAnimation.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Devman replied on Monday, November 23, 2009</h2>I haven't got round to looking at the MVVM changes for Csla yet, but it looks the way to go :-)<br><br>Cheers Rocky<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Roel replied on Monday, January 04, 2010</h2>Hi Rocky, <br /><br />When CSLA 3.8 was released, I tried to implement one of our screens with a ViewModel. As some of our screens have a lot of data that needs to be loaded, we preferably use asynchronous calls. Normally we let the CslaDataProvider handle that stuff, but with the ViewModel, we got the option to use DoRefresh or BeginRefresh. We went with the BeginRefresh because we want to load the data asynchronously.<br /><br />Next to changing the Mouse cursor to a wait cursor, we would like to show the BusyAnimation. If I bind the BusyAnimation.IsRunning to the ViewModel.IsBusy property, the BusyAnimation won't show, even though I can see the property changes correctly and the PropertyChanged events are fired (I added diagnostics:PresentationTraceSources.TraceLevel=High to the binding)<br /><br />Any ideas why this could possibly not work for us?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>triplea replied on Monday, January 04, 2010</h2><P>I just tried this with the latest version (3.8.2 beta) and it works fine. 2 things I can think of is maybe your binding path is wrong or maybe visibility is set wrong. It probably does not help but here is the XAML with the Path that works for me:</P><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2>
<P>&lt;</FONT></FONT><FONT color=#0000ff><FONT size=2><FONT size=2>csla</FONT></FONT><FONT size=2><FONT size=2>:</FONT></FONT></FONT><FONT color=#ffff00 size=2><FONT color=#ffff00 size=2><FONT color=#0000ff>BusyAnimation</FONT> </FONT></FONT><FONT color=#00ffff size=2><FONT color=#00ffff size=2>Name</FONT></FONT><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2>=</FONT></FONT><FONT color=#00ff00 size=2><FONT color=#00ff00 size=2>"BusyAnimation" </FONT></FONT><FONT color=#00ffff size=2><FONT color=#00ffff size=2>Foreground</FONT></FONT><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2>=</FONT></FONT><FONT color=#00ff00 size=2><FONT color=#00ff00 size=2>"Wheat" </FONT></FONT><FONT color=#00ffff size=2><FONT color=#00ffff size=2>IsRunning</FONT></FONT><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2>="{</FONT></FONT><FONT size=2><FONT color=#0000ff size=2>Binding</FONT></FONT><FONT color=#ff0000 size=2><FONT color=#ff0000 size=2> Path</FONT></FONT><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2>=IsBusy}</FONT></FONT><FONT color=#00ff00 size=2><FONT color=#00ff00 size=2>"</FONT></FONT><FONT color=#c0c0c0 size=2><FONT color=#c0c0c0 size=2> /&gt;</P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Roel replied on Tuesday, January 05, 2010</h2>This is my xaml, nothing different from yours.<br /><br />csla:BusyAnimation Grid.Column="1" Grid.Row="1" Height="30" Width="30" IsRunning="{Binding Path=IsBusy}" /><br /><br />It looks like the asynchronous call isn't that asynchronous. The application still enters a not responding state while executing the factory method on my BO. In the ViewModel I call BeginRefresh with the correct parameters. The static factorymethod gets called, and calls the DataPortal.Fetch method. Since the BeginRefresh requires a callback delegate, I call the DynamicInvoke of that delegate with a new DataPortalResult with the result of the DataPortal.Fetch call as parameter.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2><P>BeginRefresh() should call your async factory, not the sync factory. On .NET your async factory must call BeginFetch(), not Fetch() on the data portal. In other words, it is up to you to ensure that the factory is implemented correctly to be async.</P>
<P>The ViewModel will, by default, always call BeginSave() and so the save operation should be async.</P>
<P>There is no async undo/cancel operation - that's a near-impossibility, since it would only work if you unbound the entire object graph from the UI first, and people will forget to do that and crash their apps, so I have chosen not to go down that road.</P>
<P>Of course you can always override DoCancel() in your viewmodel and make it async. Just remember that you must <EM>completely</EM> unbind the object graph from the UI first, then rebind it after the cancel is complete - which seems very messy to me.</P>
<P>Or I suppose you could clone the object graph, do the undo on the clone, then set Model to the clone. That'll reduce performance, but would allow the undo operation to run on a background thread.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Roel replied on Wednesday, January 06, 2010</h2>Thanks Rocky!</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
