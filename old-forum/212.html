<html><header><title>Flexible rules adapting to the state of an object?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Flexible rules adapting to the state of an object?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/212.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>CrispinH posted on Saturday, May 27, 2006</h2><P><FONT face=Arial>There are instances where business rules need to vary according to circumstance.&nbsp; This would occur as a <EM>contact</EM> moved from being a <EM>prospect</EM> to a <EM>customer</EM> - you may only need a name, organisation name and phone number initially, but once the contact becomes a customer, then you would also need an account number, invoice address, shipping address, etc.</FONT></P>
<P><FONT face=Arial>Now "object models aren't the same as relational models" (p50 VB 2005 book).&nbsp; I'd arrived at this conclusion before reading the book, but Rocky articulated it for&nbsp;me.&nbsp;&nbsp; Thus we have to think of objects as separate entities from&nbsp;the underlying tables.&nbsp;</FONT></P>
<P><FONT face=Arial><STRONG>Method 1:</STRONG>&nbsp;&nbsp;Create a <EM>prospect</EM> object and a <EM>customer</EM> object that&nbsp;operate on&nbsp;subsets of a single SQL Server table.&nbsp; Each object would have it's own validation rules and could be saved when those rules were met.</FONT></P>
<P><FONT face=Arial><STRONG>Method 2:</STRONG> Create a single (stateful) object that can handle the change of state from prospect to customer and dynamically adapt its rules accordingly.</FONT></P>
<P><FONT face=Arial>The question I have - which is likely to be easiest to maintain?&nbsp; Has anyone had any experience of this situation?&nbsp; Any good methodologies?</FONT></P>
<P><FONT face=Arial>If it's method 2 that's optimal, then the rules collection needs to be aware of the state of the object.&nbsp; Does this mean that multiple rules collections need to be created, or is it best to have state dependent rules?</FONT></P>
<P><FONT face=Arial>There's another thought that occurred to me: sometimes it would be good to be able to save an object event though its state is invalid (ie broken rules count &gt; 0) for those occasions when&nbsp;the user is&nbsp;asked for a bit of information&nbsp;they haven't got to hand.&nbsp; This means that <EM>IsSavable</EM> is now the combination of <EM>IsDirty</EM> and <EM>IsSufficientlyValidToSave.</EM>&nbsp; A the risk of stretching my example too far, if someone on high decides that prospect records have to include name, phone and email to be 'valid', there still may be a case of being able to save the record with <EM>name</EM> AND (<EM>phone</EM> OR <EM>email</EM>).&nbsp; So the states for this object would enumerate as: invalid prospect, invalid prospect but saveable, valid prospect and saveable, invalid customer but almost certainly saveable, valid customer.</FONT></P>
<P><FONT face=Arial>Incidentlaly I'm using the customer/prospect example as just that, an example.&nbsp; I've got other stateful objects in mind that are too complicated to explain in a hurry.</FONT></P>
<P><FONT face=Arial>Crispin</FONT></P>
<P><FONT face=Arial></FONT>&nbsp;</P>
<P><FONT face=Arial></FONT>&nbsp;</P><FONT face=Arial></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Saturday, May 27, 2006</h2><P>I'd recommend Method #1.&nbsp; Before I "saw the light", I tried using Method #2.&nbsp; I ended up having all sorts of maintenance issues.&nbsp; There were so many conditional checks to see what state the object should be in - making any sort of change required quite a bit of effort.</P>
<P>Just remember - you don't need a 1:1 relationship between your objects and your DB.&nbsp; Define your objects based on your use cases, reuse when possible, but don't try to force one object to do something that it's not responsile for.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Monday, May 29, 2006</h2>If you go with different objects, you're likely to run into a situation
where another object needs to collaborate with either of the two
objects. Extending the given example, you might have a <i>quote</i>
object that is used to provide prices to prospects or customers. You
could make a third object, quote customer, for this, or you could
create a quote customer interface and implement it on the prospect and
customer objects.<br>
<br>
Another alternative to consider is having a CustomerBase object that
defines the behavior (and data) shared between the customer and
prospect. Customer and Prospect would both inherit from this class.<br>
<br>
It's hard to say what is the best practice because the devil is in the
details. I think even experts in OOD (which I'm not) make choices that
they realize later weren't the best choice. That's when you start
refactoring.<br>
<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Sunday, May 28, 2006</h2><span>You may also want to look into the State
pattern.&nbsp; This will allow the object to change its behavior when its
internal states change.<span></span><br>
</span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rhoeting replied on Monday, May 29, 2006</h2>First of all, this is a great question.&nbsp; In fact, I often argue that CSLA enables us to raise the discussion to a more abstract and meaningful level.<br><br>As we design apps, we need to make many of these little decisions.&nbsp; Both methods seem reasonable.&nbsp; I've often found that if I resort to the OO mantra "Objects are defined by behavior, not data" making such decisions become much easier.&nbsp; You've described some behavior differences that suggest two objects rather than one. You also may want to perform a little speculative alalysis, trying determine if the "customer" and "prospect" will need to evolve along separate paths.&nbsp; If so, it strengthens the argument decoupling the two objects, if not, perhaps combining them is better.<br><br>If you do decouple them, you may want to create a new factory method on your customer object, something like "Customer.NewCustomerFromProspect(Prospect)" that allows a seemless transition from prospect to customer.<br><br>Also, you need to be careful how you think of CSLA business rules (which govern IsValid).&nbsp; They only reflect one aspect of object behavior. &nbsp; That is, they are "rules that govern savability."&nbsp;&nbsp; You also have rules that govern other aspects of object behavior.&nbsp;&nbsp;For example, you may have a rule on your prospect object that governs whether or not it can be promoted to Customer.&nbsp; In this case, you'd simply create a brand new Readonly Boolean Property called "CanBecomeCustomer."&nbsp; So let's say the users say, prospects must have last name to be promoted.&nbsp; The body of the rule would be simply:<br><br>Public Readonly Boolean Property CanBecomeCustomer as<br>&nbsp;&nbsp;&nbsp; Return LastName.Length &gt; 0&nbsp; <br>End Property<br><br>It says nothing about savability of a prospect, but it does say something about it promotability to customer.&nbsp; Of course, you'd have to consume that rule in other places in the app to make is useful, such as binding it to a "Promote To Customer" button enabled flag, or perhaps in a workflow type object that helps the two objects collaborate.<br><br>Hope this helps<br><br>Rob<br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Igor replied on Monday, May 29, 2006</h2><P class=MsoNormal>Rob,<o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>I think that I understand what you mean when you say: "... CSLA business rules (which govern IsValid).<SPAN>&nbsp; </SPAN>...<SPAN>&nbsp; </SPAN>they are “rules that govern savability.”"<o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>But:<o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>CSLA gives us&nbsp;a way of finding what rules are currently broken in the BO. How to use this information is up to us. We know that CSLA has a built-in support for savability (the IsSavable property that tells us if any rule is broken). But my savability requirements may be different, in which case I can simply override the IsSavable property. <o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>On the other hand, I may have other interesting/important sets of rules: say a set of rules that determine if a quote can be converted to an invoice. It is reasonable to use in this case a property called IsConvertable, which is true if and only if none of the <B><U>conversion</U></B> rules are broken. I can have on my form a Save button bound to the IsSavable property and a Convert button bound to the IsConvertable property.<o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>In my applications (CSLA 1.5) I do have multiple buttons on the same form. The buttons are enabled/disabled according to the object's current state and on the role membership of the current user. If a button is disabled the user sees why in an ErrorProvider message.<o:p></o:p></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P>
<P class=MsoNormal>Igor</P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Monday, May 29, 2006</h2>Why not create the rule based on the type? The code inside the rule would look like:<br><br>If Me.ContactType = ContactTypes.Customer Then<br>&nbsp;&nbsp;&nbsp; If mInvoiceAddress.Trim().Equals(String.Empty) Then<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; e.Description="Invoice address is required for customers"<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Return False<br>&nbsp;&nbsp;&nbsp; End If<br>End If<br>Return True<br><br><br>Andrés</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CrispinH replied on Tuesday, May 30, 2006</h2><P><FONT face=Arial>Thanks for the input so far - there have&nbsp;been some good ideas.</FONT></P>
<P><FONT face=Arial>Picking up on Mark's point about using separate objects, this then begs the question as to whether to use inheritance (mentioned by Hurcane)&nbsp;or interfaces to maintain consistency between the prospect and customer objects.&nbsp; Since it's possible that the behaviour of the customer object may differ from that of the prospect, using an interface might be a better solution.&nbsp; Thinking aloud, an interface would be better in the situation (say) where a customer is also a vendor - the object would then implement IProspect, ICustomer and IVendor.&nbsp; With inheritance you'd run into a muddle - just consider that you might have ProspectiveVendor objects as well as Vendor objects...</FONT></P>
<P><FONT face=Arial>With regard to using the&nbsp;state pattern (suggested by malloc104)&nbsp;- the problem I have is lack of familiarity with patterns in general.&nbsp; However I did a quick foray into&nbsp;the&nbsp;state pattern&nbsp;and although it seemed very powerful, my feeling was it was more than was required in this instance - though I'm happy to be proved wrong.</FONT></P>
<P><FONT face=Arial>What seems to be emerging is that if an object changes state sufficiently then you should consider two objects rather than one.&nbsp; This poses the question: what constitutes <EM>sufficiently</EM>?&nbsp; The answer to that is to count the behavioral changes of the object in 'state 2': if it's more than three or four, then it's new object time.</FONT></P>
<P><FONT face=Arial>Crispin</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SoftwareArchitect replied on Tuesday, May 30, 2006</h2>I faced a similar problem and since that solution hasn't been mentioned....here it is to consider.<br><br>In my case, I had an address object.&nbsp; Sometimes it was a ContactAddress requiring a phone number and sometimes it was a PlayerAddress requiring a postal code.&nbsp; So, the objects all contained the same properties but needed to implement different rules based on...well....really their parent.<br><br>I first (and I later refactored) created an abstract base class and began creating specific classes that inherited from that class on top of it.&nbsp; It worked well and I would use that in certain circumstances; however, I quickly realized that with each address, I was creating quite a few differing address type objects and the maintenance of those would have been too great.<br><br>So, I created an AddressValidationArgument class that contained ALL of the various requirements for all addresses in the system.&nbsp; I pass that in to the NewAddress factory method and also into the GetAddress factory method.&nbsp; These in turn get passed into the constructor and the proper validation rules added for each.<br><br>The entire discussion in in the old forum<br>http://www.searchcsla.com/Details.aspx?msn_id=26557<br><br>Hope that helps.&nbsp; <br>Mike<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Tuesday, May 30, 2006</h2>Mike,<br><br>I just read the complete discussion from the old forum and I remembered having read it <br>when it was on top. I also had the impression of having seen some more code examples <br>showing the AddressValidationArgs class and the passing of behaviour-configurating-data <br>to the constructor. Must have been in another thread...<br><br>Could you post some code schema in the sense of a short how-to, <br>showing the implementation of what you did? <br><br>That surely would make this thread an all-time-goody in our new forum ;-)<br><br>Thanks anyway for bringing this topic back...<br><br>Stefan<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SoftwareArchitect replied on Thursday, June 01, 2006</h2>Basic pseudo code - lots of stuff omitted but this should get you the general gist.&nbsp; <br><br>The following example contains 3 classes.&nbsp; The parent class (Customer), the child address class (Address) and the validation class for addresses (AddressValidationArgs).&nbsp; This shows that for a customer, the postal code is required.&nbsp;&nbsp; Assume that for some other parent, the phone number is required.<br><br>It will probably be easier if you just cut and paste this into a code window so that the layout is readable.<br><br><br>Class Customer<br>&nbsp;&nbsp;&nbsp; private _name as String<br>&nbsp;&nbsp;&nbsp; private _address As Address = Address.NewAddress(new AddressValidationArgs(True, False))<br><br>&nbsp;&nbsp;&nbsp; '... etc.<br>End Class<br><br><br>Class Address<br><br>&nbsp;&nbsp; Private _street1 As String<br>&nbsp;&nbsp; Private _city As String<br>&nbsp;&nbsp; Private _state As String<br>&nbsp;&nbsp; Private _phone as String<br>&nbsp;&nbsp; Private _postalCode as String<br><br>&nbsp;&nbsp; Private _validationargs As New AddressValidationArgs()<br><br>&nbsp;&nbsp;&nbsp; Protected Overrides Sub AddBusinessRules()<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.AddRule(AddressOf CSLARules.LengthMax, "Street1")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.AddRule(AddressOf CSLARules.LengthMax, "PostalCode")<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; ... etc<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Since AddBusinessRules is called from the base constructor, and since it<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp; calls into the most derived method, the _validationargs variable will NOT<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp; yet have been instantiated when called the FIRST time.&nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not _validationargs Is Nothing Then<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Validation rules that change based on who is using this object (player, coach, guardian, etc.)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If _validationargs.RequirePostalCode Then ValidationRules.AddRule(AddressOf Validation.CommonRules.StringRequired, "PostalCode")<br><br>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; '... process other validation args here<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp; End Sub<br><br><br>&nbsp; &nbsp; 'default address - creates a default address validation args class<br>&nbsp;&nbsp;&nbsp; Friend Shared Function NewAddress() As Address<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return NewAddress(New AddressValidationArgs())<br><br>&nbsp;&nbsp;&nbsp; End Function<br><br><br>&nbsp;&nbsp;&nbsp; Friend Shared Function NewAddress(ByVal args As AddressValidationArgs) As Address<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return New Address(args)<br><br>&nbsp;&nbsp;&nbsp; End Function<br><br><br>&nbsp;Friend Shared Function GetAddress(ByVal dr As SafeDataReader) As Address<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return GetAddress(dr, New AddressValidationArgs())<br><br>&nbsp;&nbsp;&nbsp; End Function<br><br>&nbsp;&nbsp;&nbsp; Friend Shared Function GetAddress(ByVal dr As SafeDataReader, ByVal args As AddressValidationArgs) As Address<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return New Address(dr, args)<br><br>&nbsp;&nbsp;&nbsp; End Function<br><br>'&nbsp; Constructors<br>&nbsp;Private Sub New(ByVal dr As SafeDataReader, ByVal args As AddressValidationArgs)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _validationargs = args<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBusinessRules()&nbsp; 'now that _validationargs is set, re-add business rules (MUST DO HERE)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MarkAsChild()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fetch(dr)<br><br>&nbsp;&nbsp;&nbsp; End Sub<br><br><br>&nbsp;&nbsp;&nbsp; Private Sub New(ByVal args As AddressValidationArgs)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _validationargs = args<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddBusinessRules()&nbsp;&nbsp;  &nbsp;  'now that _validationargs is set, re-add business rules (MUST DO HERE)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MarkAsChild()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules()<br><br>&nbsp;&nbsp;&nbsp; End Sub<br><br>&nbsp;&nbsp;&nbsp; '...data access here -- removed --<br>&nbsp;&nbsp; <br>End Class<br><br><br><br>Public Class AddressValidationArgs<br><br>&nbsp;&nbsp;&nbsp; Private _requirePostalCode As Boolean = False&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; Private _requirePhone1 As Boolean = False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; Public Property RequirePostalCode() As Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return _requirePostalCode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set(ByVal value As Boolean)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _requirePostalCode = value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Set<br>&nbsp;&nbsp;&nbsp; End Property<br><br>&nbsp;&nbsp;&nbsp; Public Property RequirePhone() As Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return _requirePhone1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set(ByVal value As Boolean)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _requirePhone1 = value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Set<br>&nbsp;&nbsp;&nbsp; End Property<br><br>&nbsp;&nbsp;&nbsp; Public Sub New(ByVal requirePostalCode As Boolean, _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByVal requirePhone As Boolean)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _requirePostalCode = requirePostalCode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _requirePhone1 = requirePhone<br><br>&nbsp;&nbsp;&nbsp; End Sub<br><br>&nbsp;&nbsp; 'Default Constructor - nothing is required<br>&nbsp;&nbsp;&nbsp; Public Sub New()<br>&nbsp;&nbsp;&nbsp; End Sub<br><br><br>End Class<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Thursday, June 01, 2006</h2>Thanks a lot Mike for that piece of code!<br><br>Today I found where I read about some sort of "Case dependant validation" a few days ago. It was a blogpost on a very interesting blog on the web...<br><br>http://www.jpboodhoo.com/blog/ValidationInTheDomainLayerTakeOne.aspx<br><br>I think that Blog is worth mentioning (and a bookmark)!<br><br>Thanks again,<br><br>Stefan<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Friday, June 02, 2006</h2>

<p class="MsoNormal"><span>Using a
ValidationArgument is a good way to go if you are not going to add more rules
to a class.<span>&nbsp; </span>However, it does violate the
open-closed principle.<span>&nbsp; </span>Every time you
want to add a rule you would have to change code instead of just adding
code.<span>&nbsp; </span>Further, it also produces ugly
if-else or case statements in the AddBusinessRules method.<span>&nbsp; </span>Using the state or strategy pattern will
eliminate these problems and give you more flexibility and better code<o:p></o:p></span></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
