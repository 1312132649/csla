<html><header><title>Granularity and Csla Object(s)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Granularity and Csla Object(s)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5670.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius posted on Friday, October 24, 2008</h2><P>I am hoping to get the community's general concensus on the topic of structuring a series of objects for both fine-granular and coarse-granular situations.</P>
<P>Here's the situation of my work environment:</P>
<P>Seldomly, it is needed to fetch a whole bunch of objects at once.&nbsp; So&nbsp;I figure I'd make a EditableRoot with several children.&nbsp; But sometimes these children need to be fetched by themselves.&nbsp; What's the typical approach for this kind of situation?</P>
<P>I've considered a couple options:</P>
<OL>
<LI>Give the children of the parent object public factory methods that can call up the dataportal on their own.&nbsp; Thus, this would make them pseudo Child/Root objects... ? However, I feel like that might be unintuitive to the UI developers if a object is both a child AND a root... 
<LI>Create fresh new "Root" versions of the child objects.&nbsp; But this seems like it would add too much extra code/objects to maintain.</LI></OL>
<P>The end result I'm trying to achieve is is finding the best way setup a series of objects that optimize granularity and flexibility.&nbsp;I was hoping to hear about other's opinions and wisdom on this topic.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dnwheeler replied on Friday, October 24, 2008</h2><P>I do something like this in one situation (I have a business object of type X that holds a list of child objects also of type X). I simply put two Get() methods on the object, one for&nbsp;client use, and one for&nbsp;server use. The client version then calls DataPortal.Fetch() and the other calls DataPortal.ChildFetch(). There are corresponding DataPortal_Fetch and a Child_Fetch methods to handle the data access.</P>
<P>--Doug</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, October 24, 2008</h2><P>Our application is (at least currently) implemented exactly this way. We just moved to CSLA 3.5 so I haven't started using the child data portal, but all of our objects could be arbitrarily composed. A root object would typically lazy load children, but if you need to fetch a child directly you can. </P>
<P>I think this would be tough to do if you are deriving your BO's directly from BusinessBase&lt;T&gt; and BusinessListBase&lt;T&gt; etc., but we have inserted a class in between that our BO's derive from that provides the necessary infrastructure support to make this fairly easy to do. </P>
<P>BusinessListBase&lt;T&gt;, in particular, wants child objects to be explicitly marked as such, but that can be handled in your factory Get methods. </P>
<P>Since IEditableBusinessObject has support for parents, it seems to me like all CSLA objects can either be children or not simply based on whether you have assigned a parent to them and marked them as children, but I admittedly have only worked with the framework for a little over a year and may not fully understand what trouble that might get you into. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dnwheeler replied on Friday, October 24, 2008</h2><P>The ChildDataPortal automatically marks the object you are getting as a child (i.e. it calls MarkAsChild() on the target object in the Fetch() call (called from the static FetchChild() method), so there's no problem using a BusinessBase&lt;T&gt; derived objects.</P>
<P>--Doug</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>rsbaker0:</strong></div><div></P>
<P>Our application is (at least currently) implemented exactly this way. We just moved to CSLA 3.5 so I haven't started using the child data portal, but all of our objects could be arbitrarily composed. A root object would typically lazy load children, but if you need to fetch a child directly you can. </P>
<P>I think this would be tough to do if you are deriving your BO's directly from BusinessBase&lt;T&gt; and BusinessListBase&lt;T&gt; etc., but we have inserted a class in between that our BO's derive from that provides the necessary infrastructure support to make this fairly easy to do. </P>
<P>BusinessListBase&lt;T&gt;, in particular, wants child objects to be explicitly marked as such, but that can be handled in your factory Get methods. </P>
<P>Since IEditableBusinessObject has support for parents, it seems to me like all CSLA objects can either be children or not simply based on whether you have assigned a parent to them and marked them as children, but I admittedly have only worked with the framework for a little over a year and may not fully understand what trouble that might get you into. </P></div></BLOCKQUOTE></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Friday, October 24, 2008</h2><P>Thanks for the input, this is definitely helping.&nbsp; Sounds like you guys are&nbsp;confirming that it's acceptable to have a object act as both a child and root based on the factory method that's called, which was what I was wondering.&nbsp; </P>
<P>I was unaware of the ChildDataPortal method in 3.5, I'm working with 3.0 currently, but it's cool to know about.&nbsp; I don't really mind having to call MarkAsChild() manually in the factory method anyway.&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Saturday, October 25, 2008</h2><P>As an aside, I get the definite impression from my experience on this forum that even though you *can* do this, there&nbsp;are&nbsp;good arguments that you shouldn't. Purists here say you should design an object for the specific use case it is needed for, and reuse it only if it's being used in *exactly* the same way. </P>
<P>Root objects and child objects are typically used in different ways, so you may end up with more complicated objects that have "If I'm a root do X else do Y". So, you end up with a single more weighty object instead of 2 simple,&nbsp; straightforward, unambiguous objects. </P>
<P>I come from years of C++ development, so my tendency -- very hard to shed unfortunately&nbsp;-- is to reuse code through inheritance and other means whenever possible. Over the long term maintaining one application, though, you can end up with a large, unwieldy,&nbsp;and difficult to maintain source code base. A seemingly innocuous change can break a totally unrelated part of the application. So, I'm warming up to the "separate objects" viewpoint. Code generation, snippet type tools,&nbsp;and modeling tools make this much less onerous than it would have been 10 years ago. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Saturday, October 25, 2008</h2><P>Thanks for more great advice.&nbsp; I was concered about this too.&nbsp; Not only would it make the object less intuitive, but your right, you'd probably end up with a lot of extra conditional logic to indicate the object's state (root or child), making things more convoluted.&nbsp; This purist philosophy makes a lot of sense, and definitely will help me make an educated decision.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
