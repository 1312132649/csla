<html><header><title>CSLA for WinRT : Getting exceptions when awaiting DataPortal.FetchAsync</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA for WinRT : Getting exceptions when awaiting DataPortal.FetchAsync</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11428.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor posted on Monday, June 25, 2012</h2><p>Hi, I&#39;ve just started playing around with the WinRT-build of CSLA. I&#39;ve been working somewhat with CSLA.NET previously, so I&#39;m familiar with the basic concepts.</p>
<p>Now what happens is that when I call DataPortal.FetchAsync&lt;MyObject&gt;(&quot;someParameter&quot;), I get the following exception:</p>
<p>There was no endpoint listening at http://localhost:2114/WcfPortal.svc that could accept the message.<br />InnerException: No connection could be made because the target machine actively refused it 127.0.0.1:2114</p>
<p>I&#39;m making the assumtion that the dataportal is attempting to set up a WCF client-server for the dataportal. First of all, can I avoid that? It seems like an unneccessary overhead when I&#39;m running both the client and server locally. I thought maybe I could add the [RunLocal] attribute, but it seems not to exist in CSLA.WinRt?</p>
<p>If I have to go with the WCF-method, then I&#39;d like to know why I&#39;m getting the exception. I thought at first it had something to do with permissions, but I have enabled &quot;Internet (Client &amp; Server)&quot; in the appxmanifest-file.</p>
<p>Help appreciated</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, June 25, 2012</h2><p>Hi Frode, </p>
<p>What type of server accees do you need? You may run local only but you can only interact with web/rest/json services.</p>
<p>The Exception indicates that your serverside DataPortal is not started or the client is miscononfigured.. </p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Monday, June 25, 2012</h2><p>&quot;My server&quot; a one of Google&#39;s services. The application I&#39;m developing is a pure front-end against Google. JSON requests will fire from the client. I don&#39;t see why I would need a client-server architecture locally.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Monday, June 25, 2012</h2><p>Try this instead:</p>
<p>&nbsp;DataPortal.FetchAsync&lt;MyObject&gt;(&quot;someParameter&quot;, DataPortal.ProxyModes.LocalOnly)</p>
<p>Tells the dataportal to use local mode (just as in Silverlight). .</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Monday, June 25, 2012</h2><p>I&#39;m afraid that did not help. Same result. I could post some test code tomorrow.</p>
<p>DataPortal.FetchChild works though... It always runs locally, right? But I would really like to use the Factory-pattern.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, June 25, 2012</h2><p>Ok, if you can post some test code then I will look into it.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, June 25, 2012</h2><p>The exception indicates that you either don&#39;t have a server-side data portal endpoint set up, or that it isn&#39;t reachable.</p>
<p>First, the endpoint must be a <em>Silverlight</em> data portal endpoint, not a .NET endpoint. When you set up and configure the data portal server, you should follow the instructions for setting up a Silverlight server endpoint.</p>
<p>Second, for testing the server is localhost (based on your post). Callbacks to localhost from a WinRT app are normally blocked, but Visual Studio does unblock them on your dev workstation (in the RC). So it <em>shouldn&#39;t</em> be a problem to do this unless VS12 was unable to unblock localhost for your app.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 25, 2012</h2><p>I should also point out that the local data portal isn&#39;t tested yet. Therefore it is possible that the async methods are ignoring the LocalOnly parameter. I thought I got that right, but maybe not.</p>
<p>The reason the local data portal is untested, is that I&#39;m probably going to change the way the local data portal methods are implemented for Silverlight (and therefore also WinRT) so the DataPortal_XYZ methods don&#39;t get a callback parameter.</p>
<p>The callback parameter is required for the event-based model used by Silverlight and WP7, but it is not ideal. With the new async support used in CSLA 4.5 I should be able to get rid of that parameter in the DataPortal_XYZ methods. If you want your method to be async, you should make it async and use the await keyword to make your async call in your code.</p>
<p>This won&#39;t break any WinRT apps (because there aren&#39;t any), and I don&#39;t think all that many people use the local data portal in Silverlight - at least not extensively. So for Silverlight users this will be a breaking change, but hopefully a worthy one, and one that doesn&#39;t have major impact for most apps.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Tuesday, June 26, 2012</h2><p>I&#39;m not exactly sure I understand what the LocalOnly-parameter is supposed to do. Do I still need to configure&nbsp; a localhost WCF server as described in the CSLA for Silverlight documentation? I was under the impression I bypassed the entire WCF-stuff With LocalOnly. At leas that&#39;s what I&#39;d like to achieve.</p>
<p>I have created a sample solution for Win8 RP using&nbsp;CSLA 4.5&nbsp;here which highlights the exception I&#39;m getting : <a href="http://home.rivered.org/Csla45.WinRt.AsyncAwait.zip">download link</a></p>
<p>I&#39;m also confused that you say that you&#39;re <em>going to</em> implement DataPortal_XYZ Methods not to get a callback parameter. Haven&#39;t you already done that in CSLA 4.5? :) The FetchAsync-method does indeed return an awaitable Object, and does not take a callback parameter.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, June 26, 2012</h2><p>Hi Frode, </p>
<p>Fix checked in to&nbsp;repository - get latest version and try again. </p>
<p>For some reason the Compiler selected overloads that used ProxyMode as UserState and not as ProxyMode. Added explicit null as UserState to make Compiler select correct version. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Tuesday, June 26, 2012</h2><p>Rockford: Ok I understand. Thanks for the explanation. I understand that the WinRT-build of CSLA still is in an early phase.</p>
<p>Jonny: Your fix seemd to work! ...but a new problem arose: Now the task freezes upon the &quot;await&quot;. Deadlock of some sort? The&nbsp;Fetch()-method of my&nbsp;factory&nbsp;executes successfully, but code execution never returns to the awaiting method.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, June 26, 2012</h2><p>Frode, </p>
<p>Your data access is async and does not use Task (not supported yet). So Your DataPortal_Fetch should look like this:</p>
<p>&nbsp;public void DataPortal_Fetch(object criteria, LocalProxy&lt;BusinessObject&gt;.CompletedHandler callback)<br />{<br />&nbsp; try<br />&nbsp; {<br />&nbsp; Text = &quot;Hello world&quot;;<br />&nbsp;callback.Invoke(this, null);<br />&nbsp; }<br />&nbsp; catch (Exception ex)<br />&nbsp; {<br />&nbsp;callback.Invoke(this, ex);<br />&nbsp; }<br />}</p>
<p>Since Your data Access code is going to call asyncronous webservices you must Accept a callback and is responsible to Call this to notify calling code that async operation is Complete.</p>
<p>This is probably going to change, see 3) in Rockys previous post but for the time beeing the callback parameter is required. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, June 26, 2012</h2><p>By the way, you can absolutely use async/await in the current implementation.</p>
<p>public async void DataPortal_Fetch(..., callback)<br />{<br />&nbsp; try<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; await MyAsyncMethodOrOperation();<br />&nbsp;&nbsp;&nbsp; callback(this, null);<br />&nbsp; }<br />&nbsp; catch (Exception ex)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; callback(null, ex);<br />&nbsp; }<br />}</p>
<p>The&nbsp;reason this works is that the data portal won&#39;t proceed until the callback is invoked (as you noticed). And the await keyword will block execution at that point in the method until the async operation is complete, so the callback won&#39;t be invoked until either an exception occurs, or the async operation completes.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Wednesday, June 27, 2012</h2><p>Your solution works with the DataPortal_XYZ-pattern, Jonny, but when I went back to a ObjectFactory a new problem came up, I&#39;m afraid. The signature of the Fetch-method in the factory class is as follows:</p>
<p>public BusinessObject Fetch(object criteria, LocalProxy&lt;BusinessObject&gt;.CompletedHandler callback)</p>
<p>At runtime I then get this weird ClassCastException:</p>
<pre>(A)CompletedHandler[Csla45.WinRt.AsyncAwait.BusinessObject] cannot be cast to (
(B)CompletedHandler[Csla45.WinRt.AsyncAwait.BusinessObject]

Type A originates from &#39;Csla, Version=4.5.1.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30&#39; in the context &#39;LoadNeither&#39; at location &#39;D:\\coding\\source\\samples\\Csla45.WinRt.AsyncAwait\\Csla45.WinRt.AsyncAwait\\bin\\Debug\\AppX\\Csla.DLL&#39;. 

Type B originates from &#39;Csla, Version=4.5.1.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30&#39; in the context &#39;LoadNeither&#39; at location &#39;D:\\coding\\source\\samples\\Csla45.WinRt.AsyncAwait\\Csla45.WinRt.AsyncAwait\\bin\\Debug\\AppX\\Csla.DLL&#39;.&quot;}

</pre>
<p>As you can see, the exception basically says class A and B are identical, but still casting fails. <a href="http://stackoverflow.com/questions/2500280/invalidcastexception-for-two-objects-of-the-same-type">This stack overflow-thread</a> had some kind of explanation for this phenomenon,&nbsp;but the case in the question was a bit different. Can you make anything out of this?</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Wednesday, June 27, 2012</h2><p>The callback handler is specified in each Proxy type so for ObjectFactory the method should be like this:</p>
<p><i>&nbsp; public class BusinessObjectFactory : ObjectFactory<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; public void Fetch(object criteria, <b>FactoryProxy&lt;BusinessObject&gt;.CompletedHandler callback</b>)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var bo = new BusinessObject();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(bo, BusinessObject.TextProperty, &quot;Hello world&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback.Invoke(bo, null);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback.Invoke(null, ex);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }</i></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nilzor replied on Wednesday, June 27, 2012</h2><p>Brilliant, that did it! I think we can officially close this thread now :-) Thank you both for the help.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, June 26, 2012</h2><p>Right now the local proxy in Silverlight, WP7, and WinRT all use a callback parameter passed to the DataPortal_XYZ method to know that the DataPortal_XYZ method is complete.</p>
<p>Remember that the client-side data portal components and logical server-side data portal components are different things.</p>
<ol>
<li>I changed the client-side data portal to support async/await.</li>
<li>I am still trying to decide if I want to change the .NET server-side behavior, because that&#39;d break nearly everyone - and that would be bad.</li>
<li>I am now convinced that I WILL change the logical server-side behavior for Silverlight and WinRT to not require the callback parameter. I can&#39;t change WP7, because it doesn&#39;t support async/await. When WP8 comes out, I&#39;ll make it match WinRT of course.</li>
</ol>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
