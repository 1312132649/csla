<html><header><title>CSLA and NHibernate</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA and NHibernate</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7394.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Slayer posted on Tuesday, August 04, 2009</h2>Hi,<br /><br />I built a c# application using csla and nhibernate. I know this topic has been discussed before, so please bare with me.<br /><br />My nhibernate files are in a totally seperate assembly called DataAccess.<br />In my DataAccess assembly, I have a Customer class, which contains a collection of Orders. These classes are my DTOs which maps to the DB.<br /><br />In a seperate assembly, my business object assembly, I reference the DataAccess assembly. This assembly also contains a Customer class, which contains a collection of Orders. I then use my DTOs from the DataAccess assembly to populate these objects.<br /><br />One of my colleagues disagrees with me. He said that nhibernate should tap directly into my business objects.<br /><br />I need some advice on this. I value his opinion - and I believe that if I can get his method to work, there might be a performance gain.<br /><br />Thanks<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, August 04, 2009</h2>Hi, <br><br>Download the <a href="http://cslacontrib.codeplex.com/SourceControl/ListDownloadableCommits.aspx#DownloadLatest">Csla contrib code</a> from Codeplex and look at the ProjectTracker.NHibernate project.<br><br>I have no experience with NHibernate - so cannot give you any more guidance.&nbsp; <br><br>/jonnybee <br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cberthold replied on Tuesday, August 04, 2009</h2>If I were your colleague I would definately agree on your side.&nbsp; CSLA is designed in such a way that it can work both as a 2 tier or 3 tier application, it enforces business rules, authorization, and a multitude of other things.&nbsp; In general your tiers should always flow in a single direction. Your UI should call upon BO to enforce the business logic and ultimately save that to your DAL.&nbsp; Your BO will in a lot of cases not map out to DAL code.&nbsp; For example you have an inventory database and your pulling up a list of read only items.&nbsp; Those items are in categories and you want to display the category and that categories class name with the description and inventory levels of your items.&nbsp; you may be joining on 5 or 6 tables to do that.&nbsp; Your BO should be asking for that information and filling it in.&nbsp; If you tried to go the other way you would have both your user and your data telling you what data should be.&nbsp; The other issue is that the properties of the CSLA BO (if using managed backing fields (recommended)) are protected which when reading and writing properties enforces business logic allowing access to particular fields.&nbsp; The only way to bypass that logic (when you are reading and writing to the database using ReadProperty and LoadProperty) is from the DataPortal side.&nbsp; If you tried to write to a field that was being enforced by a data rule and you were creating 10000 objects you would also suffer from all of those business rules firing over and over.&nbsp; In some cases you might have an ExistsCommand which makes another database call to see that the description doesn't exist or something along those lines.&nbsp; Those would call other database commands and it would go on and on.&nbsp; Another issue you would face is who is going to call the DAL?&nbsp; If the UI calls the DAL then you've defeated the purpose of the BO as you can no longer insulate the UI from calling the DAL directly.&nbsp; If you have BO objects that call the DAL and return other BO objects you can't enforce all the business rules have been enforced properly and end up with a lot more objects and code.&nbsp; It all ends up being BAD BAD BAD.&nbsp; From CSLA standpoint you only stand to lose performance and fight circular references ultimately creating unmaintainable code.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, August 05, 2009</h2><P><FONT face=Tahoma size=2>One other potential issue with directly&nbsp;connecting CSLA to NHibernate is that the "traditional" pattern in CSLA is to have private constructors.&nbsp; IIRC, NHibernate requires a public default constructor to do its job.</FONT></P>
<P><FONT face=Tahoma size=2>The private-constructor concept is certainly not required - Rocky chose that route so that UI coders would be forced to use the factory methods.&nbsp; And I think that in SL implementations CSLA BO's have public constructors because of reflection limitations in SL.&nbsp; So there's certainly nothing stopping you from creating the necessary constructor.&nbsp; But I do agree that&nbsp;can open&nbsp;a "hole" in your object model, though a small one.</FONT></P>
<P><FONT face=Tahoma size=2>Long-term, I think you will be much happier de-coupling your CSLA and NHibernate implementations.&nbsp; Sure, it's an extra step, so there is a performance hit.&nbsp; But I wouldn't worry too much about that unless you already are seeing performance problems.&nbsp; If you directly tie NHibernate to your CSLA BO's, it's going to make managing change between the DB and your BO's harder.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, August 05, 2009</h2><P>I agree with what's been said here.</P>
<P>However, I should point out that in 3.6 and higher the ObjectFactory model does allow you to have the DAL (NHibernate) create and populate the business object graph directly. So if you do want to follow your colleague's advice you can go down that route.</P>
<P>You should be aware however, that no technology that loads property values will really work. Your technology needs to load <EM>field</EM> values.</P>
<P>This is because CSLA objects aren't dumb data containers, they are smart business objects. And that means that authorization, validation and business rules are triggered when properties are accessed - even by the DAL. The way to avoid this is to load <EM>fields</EM>, not properties. If NHibernate can load fields, then you should be set, otherwise it won't work well.</P>
<P>Finally, if you want to support Silverlight, you need to use managed backing fields (or write a bunch of serialization code). In that case you can't load fields either, but instead you must call the LoadProperty() method, and I very much doubt HNibernate can handle that scenario...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Wednesday, August 05, 2009</h2>We are planning to map our CSLA objects directly to NHibernate, and use BypassPropertyChecks(obj) in the factory before the NHibernate repository fills the object.&nbsp; NHibernate being mapped to the managed properties.&nbsp; I was under the impression at the time BypassPropertyChecks allowed you to use the property setter.<br><br>This was working I think (although I haven't looked in a while)&nbsp; The problem with collections remains where you need to copy into CSLA collection.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, August 05, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>Yes, ByPassPropertyChecks can help &#8211; but if your DAL
technology creates the individual objects then it isn&#8217;t really a
solution.</span><b><span><o:p></o:p></span></b></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Thursday, August 06, 2009</h2>We have this in our factory (Fetch):<br><br>public virtual T Fetch(Csla.SingleCriteria&lt;T,S&gt; criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (criteria != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = (T)Activator.CreateInstance(typeof(T), true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks(obj))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (Repository)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = Repository.Get(criteria.Value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MarkOld(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Fetch();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>Do you see any problem with this?<br><br>Repository.Get(...) uses an NHibernate Session to get the object so I guess it will create it also.<br><br>public virtual T Get(object id)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Session.Get&lt;T&gt;(id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>I'm now doubting if this works correctly as I haven't began to look at the object state, i.e. rules broken etc.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, August 06, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>Yes, you create obj and use BypassPropertyChecks, but then it
looks like the Get() method creates a new obj, which wouldn&#8217;t be
bypassing property checks, because it is a new object.<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Thursday, August 06, 2009</h2>Thanks Rocky,&nbsp; NHibernate has a Load method which I think will do the trick here as it takes an "empty" object instance in according to the docs.<br><br>public virtual T Fetch(Csla.SingleCriteria&lt;T,S&gt; criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (criteria != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = (T)Activator.CreateInstance(typeof(T), true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks(obj))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (Repository)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Repository.Load(obj, criteria.Value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MarkOld(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return obj;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Fetch();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>public virtual bool Load(object obj, object id)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return Session.Load&lt;T&gt;(obj,id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>Cheers<br>Kevin<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
