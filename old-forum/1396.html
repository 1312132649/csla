<html><header><title>Architecture question - design of incremental fetch of large read-only collections</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Architecture question - design of incremental fetch of large read-only collections</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1396.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>stephen.fung posted on Thursday, October 05, 2006</h2>Hi,<br><br>I'm designing a Windows Forms app on CSLA .NET, which may need to be accessed remotely with server side validation checking, so I'd like it to be mostly 3-tier.<br><br>An interesting design issue I'm having is that I'd like to display large collections of read-only data (a collection of summaries of up to 50,000 old orders) in a DataGridView, and incrementally show this data as it is loaded, so that after the first say 100 orders are loaded, the user can begin browsing while the rest of the data is being fetched.<br><br>A potential solution I'm considering is to bypass the application server and directly connect to the database from the client for this case (fetching large collections of read-only data) using a DataReader, but still going through the app server in other cases for write/update requests.&nbsp; However, this halfway breaks the 3-tier abstraction and increases the risk of security issues.<br><br>Another potential idea is to have multiple command objects that request a small batch of 100 or so orders at a time through the app server.&nbsp; However, this seems to increase complexity as the app server would either need many DB calls (like paging) or some DB cursor-like logic.&nbsp; It also seems like an extra performance burden.<br><br>Does anybody have any experience or advice in implementing something like this?<br><br>Thanks,<br>-Stephen<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 05, 2006</h2>Your list should manage this.&nbsp; I'd create a method which fetches the next set of data.&nbsp; You may be able to use the IReportTotalCount interface (not sure if that's the right name, just look at Csla.Core for interfaces).&nbsp; I think there was some discussion of this before on this forum (which is why Rocky created that interface).&nbsp; <br><br>Don't break n-tier by directly connecting to the database.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, October 05, 2006</h2>I agree - breaking n-tier for one object is just creating a problem you'll have to deal with forever...<br><br>There are numerous solutions to this problem - but arguably the best one is to use a virtual grid. Some grid controls directly support a "virtual" or "paged" mode.<br><br>To do this, you do need to make your collection itself support paging as well. As Andy points out, this is the reason for adding the IReportTotalRowCount interface - because paged <i>web</i> grids need to know the total count. But I'm guessing some of the Windows grids would need to know it as well.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stephen.fung replied on Thursday, October 05, 2006</h2>Thanks for your responses, Andy and Rocky.&nbsp; I didn't know about IReportTotalRowCount or grid virtual modes, and I will probably make the switch to CSLA 2.1 soon.<br><br>Could you please help me understand the tradeoffs a little better?&nbsp; The main concern I have with doing this MS Access style UI with paging is performance.&nbsp; The queries could potentially have non-trivial filters on them, and we'd normally like all the records to eventually be loaded in the background.&nbsp; Loading this via many requests for data a page at a time seems like much more work for the database (even if we implement optimizations like temporary cache tables, etc.).&nbsp; It would also mean a heavier load on the application server, which has to instantiate and serialize many objects.&nbsp; A colleague is looking into some crude benchmarks for this style of approach.<br><br>On the other hand, what are the problems created by breaking n-tier, and how severe are they?<br><br>Some that I can see are:<br>- Security - the database will need to allow access from all client machines, not just the app server<br>- Deployment complexity - more open ports, access rights, etc. to configure<br>- More communication code - might be trickier to maintain, although it would be limited to this module<br><br>Thanks,<br>-Stephen<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>richardb replied on Friday, October 06, 2006</h2><P>We are still on CSLA 1.x and have an Orders Search screen that in theory could bring back all the rows in the database, but we created a lightweight readonly collection and page&nbsp;the records, just bring back 1000 records at a time with an indicator if MoreRecords are available and what Page we are on.&nbsp; We work out from the search criteria in the database stored procedure how many records we 've got, which page we are after and which 1000 records we need to send back.</P>
<P>It works well in our situation - SQL Server does the job, our server has fast disks and lots of memory, and the amount of data serialised up and down the wire is reduced and the client PC's get their data fast.</P>
<P>Looking forward to using CSLA 2.x .</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
