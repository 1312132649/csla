<html><header><title>Avoiding data layer calling business layer</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Avoiding data layer calling business layer</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4203.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant posted on Tuesday, January 22, 2008</h2><P>Hi guys<BR><BR>In the situation where i want to define the authorisation (which roles can access what) and business rules&nbsp;information for a particular class from the database, in the situation where data portal is going over the server (or the data portal is cloning the object) how do i do this without the data layer calling methods in the business layer. <BR><BR>In that to get the rules/definitions from the database I would have a list and item class. From the AddAuthorizationRules (or any of the other rules or authorization methods) I would be requesting that the list return a list of information that i would loop through and add the roles or rules. To do this i would be calling the fetch on the list class (which is in the business layer) and in turn it would call the data_fetch method (which is in the data layer). The problem is that because the security information is NonSerialized, the AddAuthorizationRules methods will run in both the business layer and the data layer. Now this is expected but if from within these methods I am calling the fetch method of another object I am going to get the case where the data layer is calling the business layer which was/is always a big no no in my books.<BR><BR>Does anyone have anyways that they deal with these situations or any suggestions?? <BR>Thanks <BR>Anthony<o:p></o:p></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Tuesday, January 22, 2008</h2><P>First of all, you should use/override 'AddInstanceBusinessRules' and 'AddInstanceAuthorizationRules' methods but &nbsp;instead&nbsp;the&nbsp; 'AddBusinessRules' and 'AddAuthorizationRules' when dealing with the dynamic rules/roles.</P>
<P>I wouldn't suggest you to call any&nbsp;factory (server-side) methods from those methods since they are called after the object creation, deserialization, in the UndoChange method and maybe elswhere too. This means that you can never be sure where your code in those two methods&nbsp;is currently running.</P>
<P>I would suggest you to consider your roles/rules not as much as methods but as data that is part of the business object&nbsp;itself:</P>
<P>private RoleInfoList _roles;</P>
<P>You could load the 'RoleInfoList' object in the MyBusinessObject.DataPortal_Fetch() method. From the Fetch method you could call RoleInfoList.Get(dataReader1) since this is a child object and it doesn't have its own DataPortal_Fetch method.</P>
<P>In the 'AddInstanceAuthorizationRules' method loop through the '_roles' collection of rules and add them to the ValidationRules collection.</P>
<P>&nbsp;</P>
<P>-- Jure</P>
<P></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant replied on Tuesday, January 22, 2008</h2><P class=MsoNormal>It sounds like from what you are saying that I should store my results from the database in a list (I guess I would have two, one for auth. and the other for rules) within the object and then when the corresponding instance methods run I then loop through and do the population from this list. <BR><BR>If this is the case am I not adding the overhead of sending that extra information around the network? Also the reason why this is an issue is because in the framework the fields that currently store that same data we are talking about storing is marked as NonSerialized. I am guessing that this is done for a reason and wouldn't that same reason be valid here?<BR><BR>Thanks <BR>Anthony </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, January 22, 2008</h2><P><FONT face=Tahoma size=2>There have been a couple of other threads regarding working with business rules/authorization rules coming from a database.&nbsp; Rocky has commented on a couple of them, and the one overriding rule he gives is:</FONT></P>
<P><STRONG><EM><FONT face=Tahoma size=2>Don't make any database calls in any CSLA method other than the DP_ methods.</FONT></EM></STRONG></P>
<P><FONT face=Tahoma size=2>(Obviously, I added the emphasis, but I think Rocky's post also used a larger font - he really wanted to make sure the point was made.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />)</FONT></P>
<P><FONT face=Tahoma size=2>The solution that's usually given is to create another BO to collect your authorization/business rules from the database.&nbsp; It could be a Command object, or it could be a ReadOnlyList.&nbsp; In any event, that allows you to make the database calls in that object's DP_ methods, return the results, and then process them in the appropriate methods in your other BO.</FONT></P>
<P><FONT face=Tahoma size=2>Yes, it's another object, and another DP_ trip, and another database call... but if you need the flexibility of storing that information in the database, you're going to have to take the performance hit somewhere.&nbsp; It's probably not going to be as bad as you think, either - you should already have a database connection to use, and the list of rules should be relatively small.&nbsp; As you've noted, if you collect this information with the rest of your BO data, you're going to have to store it somewhere so that you can use it in other methods.&nbsp; And you can't mark those variables as NonSerialized, because authorization/business rules are re-hooked on the client side -&nbsp;<EM>after</EM> the object comes back from the DP.&nbsp; So if you don't serialize your data, you can't re-hook the rules.&nbsp; That's why the built-in fields are marked as NonSerialized - it's a trading-space-for-time optimization in the framework.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant replied on Tuesday, January 22, 2008</h2><SPAN>As i see it I have three options<BR><BR><EM><B><U><SPAN>Option A </SPAN></U></B></EM><B><I><U><BR></U></I><STRONG><SPAN>Workings</SPAN></STRONG></B><BR>If when the class gets called through any of the static methods (if i use that pattern) or when I create the object, when it is still on the client (where ever that may be) I call another client objects fetch&nbsp;method to return the list. I then run through the list while I am still on the client, populate the rules/auth on the client and then store the results. The server is then called which uses the stored data to results to populate the internal rules/auth list. <BR><BR><STRONG><SPAN>Bad Side</SPAN></STRONG><BR>Because the results are being stored, it means the the server is trusting the results coming from the client. If I am going over the network using&nbsp;XML or something this means that the packet could be changed to change the auth/rules. This is a big bad in my books.<BR><BR><STRONG><SPAN>Good Side</SPAN></STRONG><BR>Client class are only calling client classes. Good performance as the DB is only hit once.<BR><BR><EM><B><U><SPAN>Option&nbsp;B </SPAN></U></B></EM><B><I><U><BR></U></I><STRONG><SPAN>Workings</SPAN></STRONG></B><BR>When the class goes to populate the auth/rules list (regardless of whether we are on the client or server) we go to the another client objects fetch&nbsp;method to return the list. <BR><BR><STRONG><SPAN>Bad Side</SPAN></STRONG><B><BR></B>We have server methods (i.e. data_xyz) calling client methods (i.e. xyz) which is what I am trying to avoid. Also with the way the current Data Portal works even though I am on the server I would try and go across the network again when it is already on the server. To not have this problem (and just quickly looking i can't see that it does) the portal would have to check to see if the calling is coming from a method that is already on the server. <BR><BR><STRONG><SPAN>Good Side</SPAN></STRONG> <BR>We don’t have any trust issues.<BR><BR><EM><B><U><SPAN>Option C </SPAN></U></B></EM><B><I><U><BR></U></I><STRONG><SPAN>Workings</SPAN></STRONG></B><BR>Logically when retrieving the list of rules/auth, <U>logically</U> i call a command class (which may or may not be a CLSA concept of a command&nbsp;class) which determine where it is executing and acts accordingly. This determination might not happen in the class its self but rather the data portal.<BR><BR><STRONG><SPAN>Bad Side</SPAN></STRONG><BR>Not sure&nbsp;if the framework caters for this logical/physical scenario.<BR><BR><STRONG><SPAN>Good Side</SPAN></STRONG> <BR>We don’t have any trust issues. Logically I don’t have to worry about data methods calling business methods. Seems to be the&nbsp;best of all worlds.<BR><BR>Well&nbsp;that’s my brain picked. Does anyone have any ideas.<BR>Thanks <BR>Anthony </SPAN></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Wednesday, January 23, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>vdhant:</strong></div><div>Also the reason why this is an issue is because in the framework the fields that currently store that same data we are talking about storing is marked as NonSerialized.</div></BLOCKQUOTE></P>
<P>Like tmg4340&nbsp;said. You generally&nbsp;don't need to serialize rules/roles because these are hardcoded and&nbsp;framework can reastablish them on either side by&nbsp;invoking those two methods. But since your rules/roles are stored in database you will have to bring this data to the client in any case.</P>
<P>So, the question is only how/when and in what form.</P>
<P>You could also use a Command object to load these data before the DataPortal_Fetch&nbsp;has been called&nbsp;as additional data in the factory method of the BO. But I don't see the point of doing it, since this would mean another round trip to server which could be accomplished in only one. And I see this solution would also be more complicated.</P>
<P>I see the rules/roles data as child BOs which are part of the root BO, much like the&nbsp;objects Project (root) and ProjectResources (child) in the ProjectTracker.Library. So I can still see this the only solution.</P>
<P>I can assume these dynamic&nbsp;rules/roles should be part of all your BOs. In this case you could create base business object&nbsp;class that would already include all the mechanisms for acquiring and adding roles/rules, and derive all BOs from it/them.</P>
<P>&nbsp;</P>
<P>-- Jure</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, January 23, 2008</h2><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>jureleskovec:</strong></div><div></FONT><FONT face=Tahoma size=2>Like tmg4340&nbsp;said. You generally&nbsp;don't need to serialize rules/roles because these are hardcoded and&nbsp;framework can reastablish them on either side by&nbsp;invoking those two methods. But since your rules/roles are stored in database you will have to bring this data to the client in any case.</FONT>
<P><FONT face=Tahoma size=2>So, the question is only how/when and in what form.</FONT></P>
<P><FONT face=Tahoma size=2>You could also use a Command object to load these data before the DataPortal_Fetch&nbsp;has been called&nbsp;as additional data in the factory method of the BO. But I don't see the point of doing it, since this would mean another round trip to server which could be accomplished in only one. And I see this solution would also be more complicated.</FONT></P>
<P><FONT face=Tahoma size=2>I see the rules/roles data as child BOs which are part of the root BO, much like the&nbsp;objects Project (root) and ProjectResources (child) in the ProjectTracker.Library. So I can still see this the only solution.</FONT></P>
<P><FONT face=Tahoma size=2>I can assume these dynamic&nbsp;rules/roles should be part of all your BOs. In this case you could create base business object&nbsp;class that would already include all the mechanisms for acquiring and adding roles/rules, and derive all BOs from it/them.</FONT><FONT face=Tahoma size=2></div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>The only potential issue with that approach is if your rules are per-type and not per-instance.&nbsp; Under CSLA, the default for business &amp; authorization rules is per-type.&nbsp; Adding that data as part of the BO's DP_Fetch/DP_Create means it is getting loaded with every object, instead of once per type.&nbsp; So the savings of loading the rules in the same DB call as the object's other data is lost because you're loading the same data over and over, which most of the time won't be used.&nbsp; The per-type rules are statically stored, so they are only loaded once, and don't necessarily need to get re-hooked (and thus re-loaded)&nbsp;on every deserialization.</FONT></P>
<P><FONT face=Tahoma size=2>Now, if you have per-instance rules, then there could certainly be some benefit using this scheme.</FONT></P>
<P><FONT face=Tahoma size=2>Lastly, things like authorization rules often&nbsp;don't have much&nbsp;to do with the data in the object, and more to do with the user's rights in the application.&nbsp;&nbsp;So keeping the data separate offers a more loosely-coupled design.&nbsp;&nbsp;Several different BO's could&nbsp;use the same authorization set, so including it with each BO load&nbsp;could be&nbsp;a duplication of effort.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant replied on Wednesday, January 23, 2008</h2><P>Thanks for the reply.<BR><BR>Just one thing though, what about the fact that if you are storing the auth data as child data within the object, it means that the server is trusting that this data coming from the client&nbsp;is correct and has not been tampered with. If the information is coming over the network as XML its not that had to edit the data to say that a user now has access who shouldn't and the server would allow this because with this pattern&nbsp;the server is&nbsp;trusting that the object has the correct data. So if clients in this case are untrusted, I would have thought that this was not the best idea. But that said I dont think CSLA checks the rules and auth once it has gone through the data portal and is on the server - which i would have thought it should be doing considering trust issues.<BR><BR>Thanks <BR>Anthony</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, January 23, 2008</h2><P><FONT face=Tahoma size=2>Rocky, and others,&nbsp;have discussed the issue of trust in several threads lately.&nbsp; It seems a lot of folks are worried about the trust of the data that's being passed around...</FONT></P>
<P><FONT face=Tahoma size=2>CSLA's design is predicated on the fact that the two machines that are talking - the client and the server - inherently trust each other.&nbsp; If you feel that you can't trust the app server that you're talking to, then you have to approach your design that way.&nbsp; That means that you&nbsp;code a trust boundary into your design, be it via a web-service separation or other (likely SOA-style) means.&nbsp; That also means you could spend a fair amount of time developing procedures to more securely transmit your data, translate it between your DTO's and your BO's, and verify the data on both ends.&nbsp; That will also affect the performance of your application, and it will also affect the design of your BO's.&nbsp; CSLA is not optimized to work under those conditions.</FONT></P>
<P><FONT face=Tahoma size=2>From my perspective, if you're going to do that, then you can't store your business rules &amp; authorization rules in the database.&nbsp; If you can't trust your app server, then you&nbsp;shouldn't&nbsp;make the rules that govern how your application functions, and what sort of access any user of the application has, accessible only from that untrusted source.&nbsp; That effectively cripples your client application, as it literally has no recourse in the case of data corruption.</FONT></P>
<P><FONT face=Tahoma size=2>This is, of course, only my opinion.&nbsp; As I said before, this has been discussed in several threads lately - just do a search on the forums and you'll find them.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Thursday, January 24, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><FONT face=Tahoma size=2>Lastly, things like authorization rules often&nbsp;don't have much&nbsp;to do with the data in the object, and more to do with the user's rights in the application.</FONT></div></BLOCKQUOTE></P>
<P>Yes, I agree. The notion of rules/roles as children of BOs that I tried to sell is wrong. But still you could stick to my solution.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><FONT size=2>Adding that data as part of the BO's DP_Fetch/DP_Create means it is getting loaded with every object, instead of once per type.</FONT></div></BLOCKQUOTE></P>
<P>But they have to be loaded with every root object anyway, one way or another. And since these are dynamic rules/roles you can't use per-type rules/roles.</P>
<P>Scott, could you describe your solution in more detail. As an alternative I only see the one that makes another round-trip via the&nbsp;Command object, and this doesn't seem reasonable to me.</P>
<P>&nbsp;</P>
<P>-- Jure</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, January 24, 2008</h2><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>jureleskovec:</strong></div><div></FONT><FONT face=Tahoma size=2>But they have to be loaded with every root object anyway, one way or another. And since these are dynamic rules/roles you can't use per-type rules/roles.</FONT>
<P><FONT face=Tahoma size=2>Scott, could you describe your solution in more detail. As an alternative I only see the one that makes another round-trip via the&nbsp;Command object, and this doesn't seem reasonable to me.</FONT><FONT face=Tahoma size=2></div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>Just because I store the business rules in a database doesn't mean they are completely dynamic.&nbsp; And as I said, if they are dynamic (i.e. instance-related), then you certainly could package the rules with the BO when you collect it.&nbsp; Under those circumstances, I&nbsp;might say you should.</FONT></P>
<P><FONT face=Tahoma size=2>But&nbsp;I might&nbsp;need to create per-type rules that users of my application&nbsp;can manage.&nbsp; Every BO would work the same way - thus, per-type rules -&nbsp;but the users (or, more appropriately, administrators)&nbsp;could manage&nbsp;those rules.&nbsp; Or, perhaps I want a way to abstract the rules such that changes to the business are still done by me (or my team), but don't require a new application version.</FONT></P>
<P><FONT face=Tahoma size=2>This implementation doesn't require that the rules be loaded on every instance - indeed, you probably wouldn't want to.&nbsp; Consider this - you have one Order object open, and while you have that open,&nbsp;an administrator&nbsp;changes the rules for Order objects.&nbsp; If you open another Order object, and attach the new rules to it, you now have one of two potentially-confusing situations:</FONT></P>
<P><FONT face=Tahoma size=2>1. Two&nbsp;Orders operating under different business rules, if the rules are stored per-instance.&nbsp; I've honestly thought&nbsp;that per-instance business/authorization rules would be a recipe for disaster anyway.&nbsp; I know there can be valid reasons for it, but unless that information is clearly displayed to the user, I believe they'd more often than not be left scratching their heads when using your app.&nbsp; Plus, <FONT face=Tahoma size=2>it's entirely possible that the rules were changed such that the first Order would have been invalid - and thus not savable - had&nbsp;that Order&nbsp;been operating under the new rules the entire time.&nbsp; But that Order has no knowledge of the new rules, and thus happily allows the user to save an invalid set of data.&nbsp; This last issue could also apply to someone who only opens one Order, but does so before the new rules are saved.</FONT></P></FONT>
<P><FONT face=Tahoma size=2>2. Your first Order spontaneously changing its status, if the rules are stored per-type.&nbsp; It could be very disorienting to the user to switch back to the first Order and suddenly see a bunch of errors on a&nbsp;screen they did nothing to.&nbsp; Plus, now you add the overhead of an object registry, so you can develop a notification scheme to tell all the open Order objects to re-validate themselves on demand.</FONT></P>
<P><FONT face=Tahoma size=2>The mechanics of dealing with&nbsp;this situation -&nbsp;changes to the business rules mid-stream -&nbsp;can be frustratingly&nbsp;complex, no matter how you manage your database rules.&nbsp; The easiest solution usually involves a human element - i.e. coordination among users and administrators to clear people out of the application, modifying the rules only at&nbsp;certain times&nbsp;of the day, or an understanding that people need to re-start the app.&nbsp; Other options often include some sort of daily job that re-processes all data in the database&nbsp;according to the current business rules, flagging those that have become invalid.&nbsp; That can significantly alter your object, and application, design, depending on the requirements to fix those errors.&nbsp; Or, you can design your "middle tier" to re-validate every object before it's saved, thus providing an extra level of protection.&nbsp; That won't entirely eliminate the problem, but it will help.&nbsp; The downside is that it increases your network traffic, as you have to send the object to the server, which then sends it right back with new rules - which are then stored on the client, which then performs yet another re-validation to get the current list of errors.&nbsp; It's not too long before you consider not sending the rules to the client at all - after all, you can't trust what's there.</FONT></P>
<P><FONT face=Tahoma size=2>As for the alternative, you are correct - it does involve another round-trip, either with a Command object or a ReadOnlyList.&nbsp; But for per-type rules, you would only do that once per type, so the overhead is fairly minimal.&nbsp; If you wanted, you could develop a process that loads them all on startup - users are more likely to accept a longer startup time over a performance drain at (what appears to them to be) unpredictable points in the app.&nbsp; Then you could get them all in one trip.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Friday, January 25, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><FONT size=2>But&nbsp;I might&nbsp;need to create per-type rules that users of my application&nbsp;can manage.&nbsp; Every BO would work the same way - thus, per-type rules -&nbsp;but the users (or, more appropriately, administrators)&nbsp;could manage&nbsp;those rules.&nbsp; Or, perhaps I want a way to abstract the rules such that changes to the business are still done by me (or my team), but don't require a new application version.</FONT></div></BLOCKQUOTE></P>
<P>Yes, I can see now what you meant. I didn't even think of&nbsp;such scenario.</P>
<P>Thanks,</P>
<P>-- Jure</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant replied on Friday, January 25, 2008</h2>I have to agree with Scott with this one. Per-Type is the way i was going to go and for all the reasons that Scott has described. If the rules are undated during the day, I would have the system run script which updates them in the system overnight. Likewise with the Auth except that there would be the option to force the update in case there was a security concern but i don’t think that this would be a common accordance.<BR>Thanks for all your feedback.<BR>Anthony </div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
