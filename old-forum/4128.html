<html><header><title>Re: Weak points in the framework. Do they exist?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Re: Weak points in the framework. Do they exist?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4128.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka posted on Sunday, January 06, 2008</h2><P class=MsoNormal><FONT face=Calibri>With any framework it is important to understand, and accept, the philosophy and goals on which the framework is founded. This is the purpose behind Chapters 1 and 2 in the book, to explain the philosophy, goals and resulting design choices I have made.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>I’ve blogged about a lot of this numerous times, but here’s a short and sweet summary of my (and thus CSLA’s) philosophy.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>CSLA .NET is a client/server, n-tier development tool. Its primary purpose is to make it easier to build a powerful, feature-rich and .NET-integrated business layer composed of business objects. Those objects are ideally designed using single-responsibility design. </FONT></P>
<P class=MsoNormal><FONT face=Calibri>The other primary purpose of CSLA .NET is to enable flexible deployment of the business layer on a single machine, or on both a client and server. This uses the concept called mobile objects, which is strictly an n-tier concept.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>N-tier directly implies that you are building an application with multiple layers, where those layers are deployed on 2 or more physical tiers (some inter-layer communication at least crosses process boundaries, if not network boundaries). However, it is an architecture for building <I>an application</I>. Singular.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>An application describes a “trust boundary”. By which I don’t just mean security, but also semantic trust. N-tier applications rarely re-apply all business logic on every tier. That is incredibly expensive and inefficient in many ways. And it is pointless, because all the tiers live within this trust boundary.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>If you have code that will run <I>outside the trust boundary of your application</I> then you have, by definition, two applications. It is not possible for an application to span a trust boundary.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>When you have two applications, they should communicate with each other using message-based techniques. These days this is often called “SOA”, and so the techniques are now “service-oriented”. Regardless of the terminology, the point is that you have <I>two applications</I>, one on either side of the trust boundary. The only thing flowing across the trust boundary is raw data in the form of messages (XML or otherwise).</FONT></P>
<P class=MsoNormal><FONT face=Calibri>Neither application trusts the other. In many cases this means both applications will implement the same logic. At least the same validation, but often the same calculations and data manipulation. The client application does this to provide the user with a decent user experience. The server application does this because it doesn’t trust the client application. So they both do it.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>If you <I>really</I> want to be service-oriented, you won’t try to share code between these two applications. If you do that, you lose the primary benefit of SOA, which is decoupling and version independence. But that is really expensive, because you must then implement and maintain two applications that have much of the same <I>logical</I> code.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>But if all you want is to safely traverse the trust boundary, and you don’t care about being “SOA” or loosely coupled or version independent, then you can share code between the two applications. You can build them both against the same business DLL. This business DLL can be created using CSLA .NET if you like.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>Which ultimately brings us to the issue of data access code in the DataPortal_XZY methods. This too is a topic I’ve discussed many times, but here’s a quick summary.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>The DataPortal_XZY methods really only have one purpose: to trigger interaction with the data persistence mechanism. They don’t have to <I>include</I> or even <I>implement</I> the data persistence, they just need to trigger it.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>However, the data access mechanism does need to get and set the object’s <I>field data</I>. Fields are private. So you are left with two real options: get/set the fields in the DP_XYZ methods, or externalize the get/set operation.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>If you externalize the get/set operation you have two basic options: somehow make the fields non-private (make them protected, expose them via an interface, etc) or you use reflection. Making the fields non-private is an unsound idea for very obvious reasons. Using reflection is slow.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>So personally I recommend leaving the field get/set behavior in the DP_XYZ methods. That is meaningless code anyway – there’s no security benefit to be gained by protecting code like</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>X = Y;</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>A = B;</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>C = D;</FONT></P>
<P class=MsoNoSpacing><o:p><FONT face=Calibri>&nbsp;</FONT></o:p></P>
<P class=MsoNormal><FONT face=Calibri>Really, who cares?</FONT></P>
<P class=MsoNormal><FONT face=Calibri>What you <I>do want to externalize</I> is the code to open the database and execute the SQL. Well, really what you want to externalize is the SQL.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>And you can do that very effectively. See the DeepData example on my web site, or attend Dunn Training’s CSLA .NET training class to see this idea in action.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>But even externalizing the SQL isn’t enough if you want to re-use the business layer in two different applications. The reason is that the client application will almost certainly consume and produce DTOs to send as messages across the boundary. The server application will almost certainly use ADO.NET to talk to the database.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>So what you really need is a more complex architecture where the DP_XYZ methods always consume and produce DTOs. Your client application’s “DAL” then ships those DTOs to/from the server application, while the server application’s DAL puts the DTO data into/out of the database using ADO.NET. Or LINQ.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>So the application stack (with both applications) looks like this:</FONT></P>
<P class=MsoNormal><FONT face=Calibri>Client Presentation</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Client UI</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Business Objects (CSLA)</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>DTOs</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Client “DAL” (service calls)</FONT></P>
<P class=MsoNoSpacing><B><FONT face=Calibri>&lt;------- trust boundary -----&gt;<o:p></o:p></FONT></B></P>
<P class=MsoNoSpacing><FONT face=Calibri>Service Presentation (XML)</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Service UI (actual service code)</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Business Objects (CLSA)</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>DTOs</FONT></P>
<P class=MsoNoSpacing><FONT face=Calibri>Service DAL (ADO.NET, LINQ, etc.)</FONT></P>
<P class=MsoNoSpacing><o:p><FONT face=Calibri>&nbsp;</FONT></o:p></P>
<P class=MsoNormal><FONT face=Calibri>Both applications follow the same basic architecture – the one from Chapter 1 in my book. Both business object layers can be the same (again, assuming you don’t care about being “SOA”). The DTO layers need to be the same as well, because they are the official contract followed by the DP_XYZ methods. But the DAL implementations are obviously radically different from each other.</FONT></P>
<P class=MsoNormal><FONT face=Calibri>And really, if you are willing to use dynamic language features like those in VB, Ruby or Python, then the DTOs don’t need to be <I>the same type</I>, they just need to have the <I>same</I> <I>shape</I>. But if you want to stick with strong typing (like C# or VB without the dynamic options turned on) then they need to be the same type.</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
