<html><header><title>Securing a publicly accessible data portal? </title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Securing a publicly accessible data portal? </h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8849.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Tuesday, April 27, 2010</h2><p>I&#39;m looking for some suggestions&nbsp;to provide some sort of mechanism to provide medium security access control for a data portal that is visible on a public IP address. This would be on top of the user having to authenticate themselves in situations where an interactive application is connecting to the portal. </p>
<p>This isn&#39;t so much an issue of the connection itself being secure (as it is possible to encrypt the connection itself), but whether the *client* itself is considered trusted. Also, I&#39;m not so much concerned about serious hackers as I am more &quot;casual&quot; abuse. So, it doesn&#39;t have to be fool-proof, just medium-proof. </p>
<p>I&#39;m envisioning a basic setup where all clients are considered &quot;untrusted&quot; until they go through some sort of process that establishes that they are trusted. This process would require the user provide credentials that are valid in the back-end database, and then some sort of persistent data would&nbsp;be stored somewhere (perhaps on the client, but also possibly on the&nbsp;server)&nbsp;to provide a record that it was trusted.&nbsp; The data portal would reject any calls except those needed to authenticate the client until the trust is established, after which it would operate normally. </p>
<p>For example, I might keep a table in the database of the MAC addresses of the trusted clients. If your MAC address isn&#39;t in the table, the data portal would reject any calls other than &quot;I want to be trusted here are my credentials call&quot;, at which point the MAC address would be added to the table. Alternatively, maybe a token could be generated and stored on the client, and passed over&nbsp;via the ApplicationContext on each request, and the data portal could inspect the token somehow for validity. </p>
<p>Does anyone have any suggestions&nbsp;on a good way to do something like this? </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DocJames replied on Wednesday, April 28, 2010</h2><p>I have the same problem. I need to secure the data portal as much as possible with easy means.</p>
<p>I thought about:</p>
<ol>
<li>Provide username/password and authenticate/authorize the user on each request.</li>
<li>Provide a token/guid on login with a timeout. Updating the timeout on each request i.e. server time + 20 min.</li>
</ol>
<p>Using the MAC address sounds like a viable solution as well.</p>
<p>I think I will use the token on login for extra security (I&#39;m already using SSL to secure the communication).</p>
<p>There has been some discussing on the subject lately. I would be great to have a common easy-to-use way to solve the problem (which I think a lot of people have).</p>
<p>Any other ideas?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 28, 2010</h2><p>Certainly if someone has succeeded in using a client certificate with CSLA&nbsp;that has to be the list of trusted certificates on the server, then this would provide a high degree of trust (albeit requiring some plumbing to get in place), but I&#39;ve searched the forum and don&#39;t see any obvious success stories. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, April 28, 2010</h2><p>I&#39;d bet you aren&#39;t seeing much information because it&#39;s not likely to be a recommended technique.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>Typically what you&#39;ll see people recommend is that rather than trying to secure the DataPortal, you build a service interface in front of the DataPortal and secure that.&nbsp; I don&#39;t think the DataPortal was built to easily accommodate the kind of security you&#39;re looking for.</p>
<p>I realize that you&#39;re not really in a &quot;service&quot; scenario, but I&#39;m not sure how you reconcile a trusted client with a public IP address for your DataPortal...</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 28, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b>
<p>Typically what you&#39;ll see people recommend is that rather than trying to secure the DataPortal, you build a service interface in front of the DataPortal and secure that.&nbsp; I don&#39;t think the DataPortal was built to easily accommodate the kind of security you&#39;re looking for.</p>
<p></div></p>
<p>Perhaps, but in CSLA 3.6,&nbsp; Rocky introduced the IAuthorizeDataPortal interface and thus the ability to specifically authorize access to the data portal.&nbsp; I&#39;m basically looking for a good way to implement IAuthorizeDataPortal.&nbsp; There is already Principal based security in CSLA, so presumably this interface and authorization capbility was provided to enable an additional layer of security on top of user credentials, yes? </p>
</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Wednesday, April 28, 2010</h2><p>It isn&#39;t really a data portal limitation, as much as that this is an extremely challenging thing to do in general.</p>
<p>If I understand correctly, you don&#39;t want to secure the user (other than username/password), but you want to secure the <i>client workstation</i>.</p>
<p>There are companies that specialize in doing this. Sometimes they use hardware dongles, other times complex client-side keys, or services that monitor the system for changes. The best places to look for models around this is online gaming, where there are very extensive efforts to solve this problem. And even with those extensive efforts the games are continually hacked.</p>
<p>But the initial post specified that this wasn&#39;t to block hackers or advanced developers, just to block misuse by casual users.</p>
<p>In that case you can probably get away with having some sort of registration step in your installer, or in a separate registration app. Ensure that the user goes through registration, which of course would communicate with your server. The server can issue a security token that is then written into the registry on the client.</p>
<p>Your real app then, will always go get this security token from the registry and will put it into Csla.ApplicationContext.ClientContext. This ensures it flows from the client to the server on every data portal call.</p>
<p>Then implement an IAuthorizeDataPortal provider on the server, and check the token passed through ClientContext to make sure it is valid. Remember that this happens on every data portal call, so make sure your implementation doesn&#39;t become a performance bottleneck.</p>
<p>Will this stop hackers, developers or high-end power users? Almost certainly not. Will it stop a casual user from copying the app to another machine and running it there? Probably.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 28, 2010</h2><p>Thanks for the reply, Rocky. You understand the request perfectly.&nbsp;&nbsp; I was basically looking for some good suggestions for generating a security token (although the more I think about it, since I&#39;m mainly concerned with a kiosk type connection registering MAC addresses is starting to seem more reasonable). </p>
<p>The main problem I&#39;m trying to solve is making it more difficult to copy the application (or more specifically the assemblies that implement the CSLA-derived components) and have them &quot;just work&quot; when connected to any remote portal.&nbsp; I&#39;ll settle for making it &quot;reasonably difficult&quot;. &nbsp;</p>
<p>(On a related note regarding hacking, it seems like the data portal pretty much depends on someone having a set of matching binaries on the other side. I&#39;m sure it might be possible in theory&nbsp;try to talk the the portal by &quot;spoofing &quot;the object serialization somehow, but in reality how serious is the threat if someone doesn&#39;t have the actual assemblies themselves?) </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, April 28, 2010</h2><p>Yeah, having the client send the server the MAC address, then having the server encrypt it using a simple symmetric encryption method (everything you need is build into .NET) is probably sufficient. </p>
<p>Keep in mind the concept of revocation - keep a record on the server of the MAC addresses so you can flag an address as invalid (or remove it from your table) to revoke the key.</p>
<p>It is true that the data portal requires matching binaries on both sides. If you sign your assemblies that&#39;ll make it more secure in this regard, as otherwise it is just the name of the assembly that must match, which is pretty meaningless.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DocJames replied on Wednesday, April 28, 2010</h2><p>Would it be possible to see the business object type and get access to Csla.ApplicationContext.ClientContext in IAuthorizeDataPortal? I need to let Login pass through without a token ...</p>
<p>Any code examples (I haven&#39;t checked BO2008 yet as it&#39;s in the office)?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 28, 2010</h2><p>I believe the AuthorizeRequest object&nbsp; that is passed to IAuthorizeDataPortal.Authorize() has the ObjectType of the business object (at least this is what it appears to be). </p>
<p>I&#39;ll have the exact same issue as I&#39;ll have to allow the registration command&nbsp;to come in without prior authorization, so I&#39;ll block access for all but that one object type (and perhaps whatever other types I need in order to verify the registration). </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, April 29, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>Yeah, having the client send the server the MAC address, then having the server encrypt it using a simple symmetric encryption method (everything you need is build into .NET) is probably sufficient. </p>
</div></p>
<p>So, (and here&#39;s the real trick) what would you suggest so that the security token generated by the server and stored in the client won&#39;t work (at least not trivially) if someone copies the token itself to another machine?&nbsp; The only thing that comes to mind is that the client would need to supply a second piece of information that is programmatically generated that can be cross-checked with the encrypted token.&nbsp; </p>
<p>Using MAC addresses for example,&nbsp;the client&nbsp;could also send the MAC address along it&#39;s client context (encrypted or not), and then the server could not only check that the token itself is valid, but also that the MAC address it contains&nbsp;matches the copy provided by the client. </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
