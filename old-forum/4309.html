<html><header><title>Safety of approach to manually managing database transactions?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Safety of approach to manually managing database transactions?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4309.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Thursday, February 07, 2008</h2><P>I have done some searching of the forum to see if this OK, and I think it is, but it might&nbsp;be helpful to have someone with more experience comment before I do a bunch of rework.</P>
<P>I don't think we can use&nbsp;the built-in transaction scoping because we support Access as a database (the BOL code is database-independent), so we have been managing ADO.NET transactions in the code. </P>
<P>Rather than try to pass the transaction object around internally as a parameter, I was going to store a reference to it in the LocalContext (or server-side ClientContext), and that way each BO that was going to try to save itself in the database could grab the active transaction and save itself in that context. </P>
<P>The Begin/Rollback/Commit code would be <EM>very</EM> good about maintaining the reference in the LocalContext, ensuring that the transaction would be there only during the execution of the transaction and removed/disposed&nbsp;afterwards if either a commit,&nbsp;rollback, or disaster&nbsp;occurred.</P>
<P>This already seems to work well in prototype testing. My main concern is that, when using a separate application server, is that (1) proper isolation is maintained when two different clients execute a transaction, and that (2) requests from the same client don't end up in separate transactions. The latter part is really of lesser concern and maybe I don't even need to worry about it, since in theory the client would only be saving one BO at a time and all the transaction processing is on the server-side of the data portal. </P>
<P>Does this seem like a reasonable approach?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Thursday, February 07, 2008</h2><P>I use that exact scenario and it seems to work well.</P>
<P>It also solves the case of&nbsp;2 different root BOs using the same tr.</P>
<P>I posted my solution a long time ago - try searching for it (using LocalContext and Transaction).</P>
<P>You&nbsp; may get another idea or 2 from it.</P>
<P>Oh - and I left the tr as a parameter for child collections and objects inside a root BO because I did not want to modify all my template code and it was easier to leave it alone.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, February 07, 2008</h2><P>Thanks!</P>
<P>I'll search for your solution and check it out. </P>
<P>The initial problem I ran into that prompted this&nbsp;was that our BO may "lazy-load" child objects (or even other "using" type root BO's), and the object accessor doesn't know that a transaction is in progress, so it may end up using another connection and you deadlock on yourself (or read stale data not available outside the transaction, etc).</P>
<P>So, I want to funnel any database access through the "active" transaction, but it has to work with multiple clients doing transactions at once. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Thursday, February 07, 2008</h2><P>I had the same question. </P>
<P>As I recall Rocky told me that since the tr is occuring inside the DataPortal method and uses the local context that the thread it is running on is dedicated to the current user only. So multiple users can start their own transactions and it should be OK.</P>
<P>Joe</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
