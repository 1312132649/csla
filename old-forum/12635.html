<html><header><title>PropertyHasChanged / MarkDirty</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>PropertyHasChanged / MarkDirty</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12635.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SMILEMan posted on Tuesday, May 20, 2014</h2><p>I&#39;m using CSLA 4.5.501 from NuGet w/WPF.</p>
<p>In Rocky&#39;s eBook Creating Business Objects the MarkDirty Method says:<br /><em>&quot;By default this method not only effectively set IsSelfDirty to true, it also raises the PropertyChanged event with a property of string.Empty.&nbsp; This tells the data bining to refresh the bindings on all the properties of the object, ensuring that the UI is up to date based on any changes that were committed to the object&#39;s state or metastate.&quot;</em></p>
<p>This <strong><span style="text-decoration:underline;">is</span></strong> the behavior that I want, but when I change a text field on my model and step through in the debugger, only the Getters of the Affected properties are called.&nbsp;&nbsp; Specifically I want a CSLA Property that accesses the metadata (IsDirty, IsValid, broken rules, etc.) to be updated in the UI when any of my read / write Properties are changed.</p>
<p>Has something changed since the book was written and if so, how do I get the behavior above?</p>
<p>Ray.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 21, 2014</h2><p>The IsDirty, IsValid, and other metadata properties are marked as [Browsable(false)] and so they are ignored by data binding.</p>
<p>It is a bit of iffy design on Microsoft&#39;s part, because if we make them browsable then the UI designers in Visual Studio won&#39;t ignore them either so you&#39;ll have to manually remove them every time you let VS auto-create things like grid columns.</p>
<p>The PropertyInfo control in Csla.Xaml is designed to elevate all the metastate values about a property to be bindable. This turns out to be a better solution overall, at least for property-level metastate, because every property has numerous metastate values to which you might want to bind.</p>
<p>All that said, I _think_ we might have changed the browsable attribute in version 4.5 so at least some of the object level metastate properties are directly bindable. I was doing a bunch of stuff right before I had my heart events last year and I&#39;m afraid my memory isn&#39;t as clear as I&#39;d like from that time period...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SMILEMan replied on Thursday, May 22, 2014</h2><p>I&#39;m not sure that it&#39;s about the Browsable(false) attribute.<span style="mso-spacerun:yes;">&nbsp;&nbsp; </span>If my object has 10 properties and the user changes one that causes a 2nd to be changed (affected), what&#39;s happening when stepping through in debug is only the 2 property &quot;get&quot;s are being called rather than all 10.<span style="mso-spacerun:yes;">&nbsp; </span>One of my properties is a &quot;traffic light&quot; object status that I want to have set without specifically including it in my all my rules as an affected property&nbsp;(though if I had to I could try to make it a DataAnnotation type rule to simplify coding).&nbsp; The code for my property is attached.&nbsp;&nbsp; Any suggestions would be welcome.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, May 22, 2014</h2><p>The behavior of how CSLA raises PropertyChanged is different depending on whether you are in Windows Forms or XAML.</p>
<p>It sounds like the content in the book you reference relates to Windows Forms, and probably should be more clear (and/or corrected).</p>
<p>In Windows Forms when PropertyChanged is raised for a bound property the data binding infrastructure will refresh all bound properties. Raising PropertyChanged with a null or string.Empty property name also refreshes all bound properties. As a result CSLA is optimized to raise as few PropertyChanged events as possible, but always at least one. Raising lots of events just causes performance issues, but raising zero would make the UI not refresh.</p>
<p>In XAML (WPF, SL, WinRT) Microsoft changed the way data binding refreshes to work the way you&#39;d expect - which is to say that properties refresh only if their specific PropertyChanged event is raised. In this context CSLA is optimized to raise PropertyChanged events as properties change, or are affected by rules.</p>
<p>If you have rules that affect a property (such as your traffic light) then that property should be an affected property in the rules so the CSLA infrastructure does the right thing for each data binding environment.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Friday, May 23, 2014</h2><p>Or just add this simple rule to you project and add one rule in your BO: </p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">NotifyChangedWhenInputChanged</span>&nbsp;:&nbsp;Csla.Rules.<span style="color:#2b91af;">BusinessRule</span>
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;NotifyChangedWhenInputChanged(<span style="color:#2b91af;">IPropertyInfo</span>&nbsp;primaryProperty,&nbsp;<span style="color:blue;">params</span>&nbsp;<span style="color:#2b91af;">IPropertyInfo</span>[]&nbsp;inputProperties)&nbsp;:&nbsp;<span style="color:blue;">base</span>(primaryProperty)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputProperties&nbsp;=&nbsp;InputProperties&nbsp;??&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">List</span>&lt;<span style="color:#2b91af;">IPropertyInfo</span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputProperties.AddRange(inputProperties);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Execute(<span style="color:#2b91af;">RuleContext</span>&nbsp;context)&nbsp;{&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}<br /><br />usage in BO:<br />BusinessRules.AddRule(<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">NotifyChangedWhenInputChanged</span>(StatusProperty,&nbsp;Param1Property,&nbsp;Param2Property));<br /><br />You can add as many properties as you like... <br /><br /> </pre></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
