<html><header><title>RoleList (NVL) in ProjectTracker.Library - question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>RoleList (NVL) in ProjectTracker.Library - question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10824.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF posted on Friday, October 28, 2011</h2><p>I know NVLs aren&#39;t used as much anymore, but I&#39;m still trying to understand this:&nbsp; in the ProjectTracker example provided with the new WPF/SL e-book, there doesn&#39;t seem to be a public constructor defined for the RoleList class.&nbsp; In addition, the SL code provides a sync GetList method that returns a RoleList.&nbsp; If the cached list is available, it returns that.&nbsp; If it isn&#39;t available, it returns &quot;new RoleList()&quot;.&nbsp; What gets returned in the latter case?&nbsp; An empty list?&nbsp; If so, why wouldn&#39;t it call the async GetList method to&nbsp;get the actual data?&nbsp;&nbsp;Here&#39;s what I&#39;m referring to:</p>
<p style="padding-left:30px;">public static RoleList GetList()<br />{<br />&nbsp; if (_list != null)<br />&nbsp;&nbsp;&nbsp; return _list;<br />&nbsp; else<br />&nbsp;&nbsp;&nbsp; <span style="background-color:yellow;">return new RoleList();</span><br />}</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Saturday, October 29, 2011</h2><p>There is no constructor defined at all, so the compiler does the normal thing and creates a public default constructor. That&#39;s standard .NET/SL behavior.</p>
<p>The GetList factory on SL is interesting. Ideally it shouldn&#39;t even exist as a synchronous method, but I chose to rely on some side-effect behavior to avoid having async complexity spread throughout the code.</p>
<p>If you look through the code, you&#39;ll find that the sync GetList is only used by the RoleName properties in classes like ResourceAssignmentEdit.</p>
<p>I could have made that async, but really, the idea is that in an SL/WP7 app a unit of work will have been used to get the various root objects - thus ensuring that RoleList is loaded into memory before any root objects are bound to the UI.</p>
<p>It is a balancing act. Do you allow/force async behaviors to flow through large parts of the app? Or do you make assumptions about proper use of UOW objects and allow some of the code to use simpler sync implementations?</p>
<p>Once we all move to C# 5.0 and VB 11, we can use the async/await keywords (CSLA 4.5 should support this), and that&#39;ll help this whole issue go away - because the sync and async code are of comparable complexity. There&#39;ll still be a <em>performance</em> difference, so proper use of a UOW is still critical, but at least the code can be async everywhere without becoming complex.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
