<html><header><title>BusinessRules to deal with circular references</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>BusinessRules to deal with circular references</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5840.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Thursday, November 20, 2008</h2>Hi,<br><br>I'm building an inventory application.&nbsp; Each inventory part (Part) has a part number and some other properties.&nbsp; Nothing fancy.&nbsp; Each part may also have a BOM.&nbsp; The BOM is just a list of other parts which make up the parent part.&nbsp; So a BOM for a computer would include RAM, HDs, MBs, etc.&nbsp; RAM could have it's own BOM as well; circuits, chips, etc.<br><br>So.. here's my problem.&nbsp; I'm trying to code business rules to detect and prevent circular references.&nbsp; For example, you shouldn't be able to add the system RAM as a component to an HD (which may have memory... just not the kind that fits on the MB).&nbsp; <br><br>My tables look like this:<br>BOM( BOMId, PartId, Notes )<br>Part( PartId, other values )<br>BOMPart( BOMId, PartId )<br><br>Any ideas?&nbsp; For some reason I figured this out when I let product bundles contain other bundles... but something here is throwing me off (I only had two tables to worry about for that.. Product and ProductBundleItem).<br><br>Ideas?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, November 20, 2008</h2>I'm not sure exactly how/when you would incorporate this into a business rule, but you could, in theory, just walk up your parent chain recursively to be sure there isn't an object of the same type in your "ancestry", so to speak.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jack replied on Friday, November 21, 2008</h2><P>I'm not sure you could use a business rule as you have a lot of recursion to deal with.&nbsp; You basically need to write a recursive function to loop through all your related collection lists and those of each parent.&nbsp; I find this sort of thing is best done in the database as otherwise you have to load all the data for each part and their BOM.&nbsp; You could lazyload each part's BOMList but maybe you already have the hierarchy in memory for other reasons</P>
<P>isPartInBomTree(BOMListBO, PartBO)<BR>{<BR>&nbsp;&nbsp;&nbsp; foreach (partBO p in BOMListBO.PartListBO) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p.PartId = PartID) return true<BR>&nbsp;&nbsp;&nbsp; &nbsp;if (p.BOMList != null) return isPartInBomTree(p.BOMList, PartBO)<BR>&nbsp;return false;<BR>}</P>
<P>Othewise you can use the database to validate the hierarchial tree on an insert to the BOM.</P>
<P>You probably have a few choices - pass the set of partID/BOMs to a stored proc in bulk and then loop through an exists type function for each part that does a scan to see if the part exists in the BOM/part tree.&nbsp; If it fails cancel the transaction, if not keep looping.</P>
<P>You could also simulate this in your application one&nbsp;part at a time</P>
<P>You other choice if it fits into the paradigm would be to write a datbase function that looks for circular references and flag them.&nbsp; If you are allowed to put the circular reference into the database then you can do a single query to get the parts.&nbsp; You could build in a no more part/BOM edits until that is fixed sort of thing.&nbsp; That sounds lousy though as I finish typing it up.</P>
<P>It's early in the morning so the code maybe a bit wonky but that should be the idea.</P>
<P>jack</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, November 21, 2008</h2>Well what I did with bundles was to call a UDF on the database which did the recrusion for me via a CTE.<br><br>The algorithm you're describing sounds like the one I did for product bundles... but for some reason I'm convincing myself that in this case it won't work.&nbsp; The part I'm hung up on is if the BOM which has the parts being checked is new; my thinking is the check will miss because nothing's in the database yet.<br><br>Consider this:&nbsp; Part A has a BOM, and is made up of parts B, C &amp; D.<br>I try to create a BOM for part C, which would include A.&nbsp; If A is added to C's list first, the check will succeed... actually it shouldn't... if I fully expands A's BOM, I should be able to check if C is part of that list.. and fail.&nbsp; Ok, so it is like the bundles... I just needed to reverse my thinking.<br><br>Thanks!<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, November 21, 2008</h2><P>Ah, you're talking about a circular reference for a specific part number in an hierarchical assemblage of some form. (e.g. the rule is something like "a part cannot contain itself")</P>
<P>We have that exact problem in our legacy application also and just band-aided it at the time versus implementing a good solution. (We just chopped off the BOM "explosion" at a certain depth to avoid runaway recursion)</P>
<P>I'll be interested in your solution, since I'd prefer something better. We have a "BOM" table that essentially is a set of ordered pairs of the "parent"&nbsp;part number and list of "child" part numbers, so I'd think it's a pretty common problem with this type of representation. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, November 24, 2008</h2>Here's my solution.&nbsp; I have a UDF in Sql Server (this solution needs 2005, but you should be able to use cursors to accomplish the same thing in earlier versions).<br><br>Basically, as each part is added to the BOM, we ask if the BOM being modified appears anywhere in the expanded BOM hierarchy of the part being added.&nbsp; For example, Part A is made up of Parts B, C &amp; D.&nbsp; Part C is in turn made up of part K &amp; L.&nbsp; When editing the BOM for C, we should check to make sure that C isn't part of A's BOM anywhere in the hierarchy.&nbsp; In my example using the UDF below, we'll pass the part id of C (which is the BOM we want to add A to) as the first parameter, and the part id of A as the second (the part which is to be added to C's BOM).&nbsp; If the UDF returns 1, that means that C is already included somewhere on A's BOM, which means we'd create a circular reference if we allowed it.&nbsp; If it's 0, everything will be fine.&nbsp; <br><br>Like the products and bundles code, I execute this check on BomItem's DataPortal_Create (so we'll to hit the DB) and also while I'm doing the save for the root BOM object.<br><br>HTH someone else.<br>Andy<br><br>Here's the UDF I use:<br><br>ALTER FUNCTION [dbo].[IsPartInBom] (<br>&nbsp;&nbsp;&nbsp; @PartId int, -- This is the part we are looking at<br>&nbsp;&nbsp;&nbsp; @PartIdBom int -- This is the part who's BOM we must check<br>)<br>RETURNS bit<br>AS<br>BEGIN<br><br>&nbsp;&nbsp;&nbsp; DECLARE @Result bit<br>&nbsp;&nbsp;&nbsp; DECLARE @Count int;<br><br>&nbsp;&nbsp;&nbsp; WITH ExpandedBom(<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; PartId,<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BomId<br>&nbsp;&nbsp;&nbsp; ) AS<br>&nbsp;&nbsp;&nbsp; (<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; bpart.PartId, NULL<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM&nbsp;&nbsp;&nbsp; BillOfMaterials bom<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN BillOfMaterialsPart bpart ON bom.BillOfMaterialsId = bpart.BillOfMaterialsId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WHERE&nbsp;&nbsp;&nbsp; bom.PartId = @PartIdBom<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UNION ALL<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; bpart.PartId, bpart.BillOfMaterialsId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM&nbsp;&nbsp;&nbsp; BillOfMaterials bom<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN ExpandedBom eb ON eb.PartId = bom.PartId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN BillOfMaterialsPart bpart ON bom.BillOfMaterialsId = bpart.BillOfMaterialsId<br>&nbsp;&nbsp;&nbsp; )<br><br>&nbsp;&nbsp;&nbsp; SELECT&nbsp;&nbsp;&nbsp; @Count = COUNT( * )<br>&nbsp;&nbsp;&nbsp; FROM&nbsp;&nbsp;&nbsp; ExpandedBom<br>&nbsp;&nbsp;&nbsp; WHERE&nbsp;&nbsp;&nbsp; PartId = @PartId<br><br>&nbsp;&nbsp;&nbsp; IF @Count = 0 BEGIN<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SET @Result = 0<br>&nbsp;&nbsp;&nbsp; END ELSE BEGIN<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SET @Result = 1<br>&nbsp;&nbsp;&nbsp; END<br><br>&nbsp;&nbsp;&nbsp; RETURN @Result<br><br>END<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, November 24, 2008</h2><P>Thanks! &nbsp;That gives me some good ideas. </P>
<P>I can't use this exact code because I have to worry about Oracle, Access, and SQL 2000, but we implemented some cross-platform views that compute the BOM to a fixed depth (basically by chaining 1 level views to each other) and I think I can use this to what you are doing. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 25, 2008</h2>The idea should work for you though.&nbsp; This just "flattens" the BOM hierarchy recursively.&nbsp; You should be able to do something similar with temp tables and cursors though and it sounds like you might already be doing so.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Wednesday, November 26, 2008</h2>Hi Andy,<br><br>I have an alternative way of verifying if a BomPart is valid for a given part.<br>In addition to your sp, I test for valid parameters (e.g. PartId == PartIdBom, &gt;0 )<br>I use standard SQL so it is somehow universal:<br><br><font size="1" face="Arial">CREATE FUNCTION IsValidBOMPart <br>(<br>&nbsp;&nbsp;&nbsp; @PartId int, -- This is the part we are looking at<br>&nbsp;&nbsp;&nbsp; @PartIdBom int --This is the part who''s BOM we must check<br>)<br>RETURNS bit<br>AS<br>BEGIN<br>&nbsp;&nbsp;&nbsp; DECLARE @Result bit<br>&nbsp;&nbsp;&nbsp; DECLARE @Count int;<br><br>&nbsp;&nbsp;&nbsp; -- no self-reference<br>&nbsp;&nbsp;&nbsp; IF @PartId=@PartIdBom OR @PartId&lt;1 OR @PartIdBom&lt;1 BEGIN<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SET @Result=0<br><br>&nbsp;&nbsp;&nbsp; END ELSE BEGIN<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -- collect all Part_IDs that are not allowed inside the BOM that is examined<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WITH IllegalParts(<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; PartId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ) AS<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -- all parts containing @PartIdBom INCLUDING @PartIdBom itself<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT @PartIdBom<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UNION<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT tblBOM.intPart_IDBOM<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM tblBOMPart <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN tblBOM ON tblBOMPart.intBOM_IDBOMPart = tblBOM.intBOM_ID<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WHERE&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (tblBOMPart.intPart_IDBOMPart = @PartIdBom)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UNION<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -- all parts containing @PartId INCLUDING @PartId itself<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT @PartId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; UNION<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT tblBOM.intPart_IDBOM<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM tblBOMPart <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN tblBOM ON tblBOMPart.intBOM_IDBOMPart = tblBOM.intBOM_ID<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WHERE&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (tblBOMPart.intPart_IDBOMPart = @PartId)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; )<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; -- now check if there are any invalid part_IDs...<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SELECT @Count = COUNT(*) <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM IllegalParts ip<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN (SELECT tblBOMPart.intPart_IDBOMPart AddedPartId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FROM tblBOM <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INNER JOIN tblBOMPart ON tblBOM.intBOM_ID = tblBOMPart.intBOM_IDBOMPart<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; WHERE&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (tblBOM.intPart_IDBOM = @PartIdBom)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ) bom2Check ON ip.PartId = bom2Check.AddedPartId<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; IF @Count = 0 BEGIN<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SET @Result = 1<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; END ELSE BEGIN<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; SET @Result = 0<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; END<br><br>&nbsp;&nbsp;&nbsp; END<br><br>&nbsp;&nbsp;&nbsp; RETURN @Result<br><br>END<br></font><br><br>Stefan<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, November 21, 2008</h2>Well, in the product bundle use case, I checked the rule when creating a new ProductBundleItem, and also when ProductBundleItems saved themselves.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
