<html><header><title>ApplicationContext.LogicalExecutionLocation wrong if nested local data portal calls made?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ApplicationContext.LogicalExecutionLocation wrong if nested local data portal calls made?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6874.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Wednesday, April 29, 2009</h2><P>I copied the LogicalExecutionLocation support from CSLA 3.6.2 into 3.5.1. Of course, I could have bungled it, but it seemed simple enough. </P>
<P>Anyway, what seems to happen is that if you make another data portal call while in the middle of the first one, the call to ClearContext() when returning from the nested call will unconditionally set your LogicalExecutionLocation back to Client, even though you are still in the middle of the first call. </P>
<P>I'd think some sort of stack or counter-based mechansim would be required if this was going to work when making nested calls, as any nested local data&nbsp;portal call made before the outer call completes&nbsp;one should not change the execution location (assuming I'm understanding the intent correctly)</P>
<P>Also, the location is implemented as a static enum variable, so I'm curious as to how this would work if you had a multi-threaded application with different threads making data portal calls? Perhaps&nbsp;this really needs to&nbsp;be a&nbsp;value stored&nbsp;in the LocalContext rather than a shared static one?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 29, 2009</h2><P>Just to see what would happen, I replaced the implementation with this one and it seems to work properly. Basically I'm just storing a data portal call depth in the local context. Any set of location to Server increments the depth, and a location set back to Client decrements it. I definitely get to a depth of at least 2 in my current application running over the local data portal. </P>
<P>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<BR>&nbsp;&nbsp;&nbsp; /// Gets a value indicating the logical execution location<BR>&nbsp;&nbsp;&nbsp; /// of the currently executing code.<BR>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<BR>&nbsp;&nbsp;&nbsp; public static LogicalExecutionLocations LogicalExecutionLocation<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nDepth = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object o = LocalContext["LogicalExecutionLocation"];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o is int)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nDepth = (int)o;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nDepth &gt; 0 ? LogicalExecutionLocations.Server : LogicalExecutionLocations.Client;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp; internal static void SetLogicalExecutionLocation(LogicalExecutionLocations location)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nDepth = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object o = LocalContext["LogicalExecutionLocation"];<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o is int)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nDepth = (int)o;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (location == LogicalExecutionLocations.Server)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nDepth++;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (nDepth&nbsp; &gt; 0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nDepth--;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalContext["LogicalExecutionLocation"] = nDepth;<BR>&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;</P>
<P>(I can see how this is might need to be tweaked for a remote data portal implementation as anything running on the remote portal is always server side so this is overkill)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 30, 2009</h2>This does need looking into - thank you for calling out the issues.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Wednesday, September 09, 2009</h2>I just ran into this.  I have logic in my DAL that checks if I am on the server side of the DataPortal (logically) before attempting to make a connection to the DB.<br /><br />This problem causes a nested call to fail.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, September 09, 2009</h2>This issue is fixed in a recent version (3.6.3 or 3.7).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Wednesday, September 09, 2009</h2> Yes...fixed in 3.8<br /><br />from change log<br />______________________<br /><br />LogicalExecutionLocation (090721)<br />http://www.lhotka.net/cslabugs/edit_bug.aspx?id=395<br /><br />Store LogicalExecutionLocation in LocalContext so it is safe on the server and in multi-threaded client scenarios.<br /><br /> <br /><br />Also change the data portal so LogicalExecutionLocation works with nested calls. To do this I changed SetContext and ClearContext to be instance methods so they can work with an _oldLocation field to handle the nesting.<br /></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
