<html><header><title>CSLA 3.6 B2 - Security in static AuthorizationRules methods</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 3.6 B2 - Security in static AuthorizationRules methods</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5708.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick posted on Thursday, October 30, 2008</h2>Hi,<br><br>because AuthorizationRules.CanEditObject is public the following is possible:<br><br>Current user is in role "Artist":<br><br>Csla.Security.AuthorizationRules.CanEditObject(typeof(Library.Edges.EdgeBase)) evaluates to false<br>
<br>call this from UI code:<br>Csla.Security.AuthorizationRules.AllowEdit(typeof(Library.Edges.EdgeBase), new string[] { "Me", "Myself", "I", "Artist" });<br><br>then test again:<br>Csla.Security.AuthorizationRules.CanEditObject(typeof(Library.Edges.EdgeBase)) evaluates to true now.<br><br>Thanks,<br>Patrick<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, October 30, 2008</h2><P>That is true, and is a possibility of which I'm aware. I don't directly consider it a bug however, for two reasons.</P>
<P>First, this enables a scenario where you have a "security loader" object that loads all the per-type rules for your business layer all at once (probably data driven). That's very valuable.</P>
<P>Second, it is not clear how I'd prevent this in any case. At least not without seriously complicating the process of calling AllowEdit(), etc. The only real solution would involve making those methods internal to CSLA, and then having all the CSLA base classes expose a protected instance of some class that could invoke the internal methods. Very messy - and this would preclude the security loader concept.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick replied on Thursday, October 30, 2008</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>That is true, and is a possibility of which I'm aware. I don't directly consider it a bug however, for two reasons.</div></BLOCKQUOTE><br>Hi Rocky,<br><p>
that's true if you are aware of it it's not really a bug :)<BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>First, this enables a scenario where you have a "security loader" object that loads all the per-type rules for your business layer all at once (probably data driven). That's very valuable.</p>
<p>Second, it is not clear how I'd prevent this in any case. At least not without seriously complicating the process of calling AllowEdit(), etc. The only real solution would involve making those methods internal to CSLA, and then having all the CSLA base classes expose a protected instance of some class that could invoke the internal methods. Very messy - and this would preclude the security loader concept.</div></BLOCKQUOTE></p><p>Good point. <br></p><p>One solution might be to make a private property bool _permissionsSealed.</p><p>After setting permissionsSealed = true a call to this would throw an exception:<br></p><p>Csla.Security.AuthorizationRules.AllowEdit(typeof(Library.Edges.EdgeBase), new string[] { "Me", "Myself", "I", "Artist" });</p><p>throws excpetion<br></p><p>Business base could automatically set permissionsSealed after calling AddObjectAuthorizationRules()</p><p>So a user loading business rules from the outside would just need to make sure to do it in the very beginning before AddObjectAuthorizationRules() is called.</p><p>All the best,<br>Patrick<br></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
