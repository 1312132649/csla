<html><header><title>Obj design: store or not to store in db</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Obj design: store or not to store in db</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6763.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 posted on Wednesday, April 08, 2009</h2>I've got a project that does some comparison between current and previous data values to get a range for the data points. This is then charted. The charts are in-process but can also be brought up as history.<br /><br />Should I store the comparisons in the database or create them manually (LINQ)? The problem I see storing them in db is that a sample can be deleted and all of the ranges would need to be recalculated. OTOH I'm typically only charting the current run.<br /><br />Anyone have a similar construct or advice?<br /><br />Thanks,<br /><br />_E</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Wednesday, April 08, 2009</h2>My "default" behavior would be to normalize &amp; re-compute everything, and then modify that position when I've got a good reason.<br><br>Examples of good reasons to store pre-computed results:<br><ul><li>Performance.&nbsp; If computing values takes a long time, and you know you're going to be hurt by re-computing values, then you can consider storing computed values.&nbsp; In this case, you'd want to think of the pre-computed values as sort of a persisted cache, and give some thought to state changes that might make you want to re-compute your "cache".</li><li>Historical tracking.&nbsp; If it's important (say, for legal reasons) that you can demonstrate exact values for computed fields, it's worth storing the as-computed values.&nbsp; Otherwise, you may find that when you go back to look at historical data, you re-compute fields for display and produce different output than you did when you ran originally.&nbsp; This can happen if you change algorithms, lookup values, or other inputs since you originally recorded data.</li></ul>Give some thought to usage scenarios.&nbsp; When you talk about "history", are you talking minutes, days, months, years?&nbsp; Given that you run a graph right now, and then you come back and look at it in a year, is it important that you see exactly the same graph, or would you expect to see the graph recalculated with the newest available input data?<br><br>You'll have to chase down the details based on your business scenario, I think, but that's the sort of thought process I'd apply. <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 replied on Wednesday, April 08, 2009</h2><P>Thanks for the reply, that's along the lines I was thinking. My decision has been to not store the values since they are computed as the process is happening. History for this&nbsp;app is any data related directly on the program being analyzed and ordered by test date. If at some point I do store it, I can add a trigger to the database on delete actions to recalc the values and cascade it through.</P>
<P>They also want a predetermined number of results no more than 30 data points, so I think letting the client do the calculation will be OK. Some info came to me finally as I was working on it, so I'll see if it works well enough.</P>
<P>_E</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
