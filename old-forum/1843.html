<html><header><title>Having one Base for Business objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Having one Base for Business objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1843.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>patingamon posted on Monday, November 27, 2006</h2><P>I am trying to determine the best method for setting up my business objects. I will use a previous post's Pet Store scenario to setup the problem.<o:p></o:p></P>
<P>Assume we have business objects Store, Cage, Animal where there may be one or more Stores. Each Store has one or more Cages and each Cage one or more types of Animal.<o:p></o:p></P>
<P>It stands to reason that a Store might have numerous business rules, attributes, methods, etc. <o:p></o:p></P>
<P>For example, a Store (whether it is read-only or editable)&nbsp;needs to be able to list the set of Cages, display the address of the store, generate an inventory, etc.<o:p></o:p></P>
<P>Only an editable Store can have Cages added or deleted (and, for that matter, have the contents of Cages modified).<o:p></o:p></P>
<P>Because BusinessBase and ReadOnlyBase are distinct, it appears that I will need both an EditableStore (derived from BusinessBase) and ReadOnlyStore (derived from ReadOnlyBase). <o:p></o:p></P>
<P>That seems to imply that the only way I can have a common Store business object between the two is to have both EditableStore&nbsp;and ReadOnlyStore contain the Store. This doesn't seem right as an EditableStore&nbsp;ISA Store and a ReadOnlyStore ISA Store.</P>
<P>Am I missing something obvious? Is there a clever strategy to support this?<o:p></o:p></P>
<P>Thanks for any insights.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 27, 2006</h2><P>In my view you should not have&nbsp;a common Store object, because objects are defined by behavior, not data.&nbsp;And you are describing two very different sets of behaviors. Different behaviors mean different objects.</P>
<P>This is a common theme for the questions I get, and the root of the issue is that most people learn a type of object design that is very data-centric. In my view, and the view of people like Cunningham, Beck and West, this data-centric design approach is fundamentally flawed. Objects should drive off your use cases, and should reflect the responsibilities and behaviors defined by those use cases.</P>
<P>Of course I read sentences like that many times and didn't grok the concept. Until I realized that reuse is NOT the goal of OOD. Reuse, if it happens, is a fortunate side-effect. But the real goal of OOD is to create maintainable and readable code - which reduces the cost of development and maintanence. And THAT is the goal.</P>
<P>Translated, this means that reuse of objects across use cases is not a primary goal. If you happen to find that you can reuse an object that's a bonus. But even then, you have to view such a move with skepticism because such sharing of an object tightly couples two use cases to each other, and that reduces maintainability...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>
<P>Objects should drive off your use cases, and should reflect the responsibilities and behaviors defined by those use cases.</P>
<P></div></BLOCKQUOTE></P>
<P>That seems like such an obvious point to me, but it's amazing how experienced high-quality developers can't see it.</P>
<P>Ask yourself this... if you walked into a client to beging scoping and designing a software project, do you start by asking "what data do you want to store" or by asking "what do you want this thing to do?"&nbsp; If you're starting with use cases, it seems so obviously natural to progress from </P>
<P>use case -&gt; business layer to support use cases -&gt; data to support business layer</P>
<P>than from</P>
<P>use case -&gt; data to&nbsp;support use case&nbsp;(indrectly) -&gt; business layer to support use case</P>
<P>IMO in the first case the flow is so much more natural, as&nbsp;demonstrated in the section of the book in which Rocky designs the object model for PTracker.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div></P>
<P>Translated, this means that reuse of objects across use cases is not a primary goal. If you happen to find that you can reuse an object that's a bonus. But even then, you have to view such a move with skepticism because such sharing of an object tightly couples two use cases to each other, and that reduces maintainability...</P>
<P></div></BLOCKQUOTE></P>
<P>I think that's clouded somewhat by the principle that a particular piece of responsibility should exist in only one place.&nbsp; It's easy to see that as&nbsp;the same thing as code reuse.&nbsp; Or should I say, reuse of objects jumps out as a way to achieve that.</P>
<P>So, if I have a Customer.LastName that concatenates the firstName and lastName fields in the Customer object, and I also have a CustomerSummary.LastName in my read only list picking list... it seems the easy OOD solution is that Customer would just aggregate the CustomerSummary object and therefore a) not have to duplicate the LastName business logic and b) then naturally also achieve code reuse.</P>
<P>One of the problems with that approach is that while you've achieved some code reuse, you've also <EM>added</EM> a bunch of code to handle the aggregations, particularly in regard to the crud operations since a complex business object is now composed of a half dozen objects that can now&nbsp;operate independently or in this mode.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div> 
<P>Objects should drive off your use cases, and should reflect the responsibilities and behaviors defined by those use cases.</P>
<P></div></BLOCKQUOTE></P>
<P>That seems like such an obvious point to me, but it's amazing how experienced high-quality developers can't see it.</P>
<P>Ask yourself this... if you walked into a client to beging scoping and designing a software project, do you start by asking "what data do you want to store" or by asking "what do you want this thing to do?"&nbsp; If you're starting with use cases, it seems so obviously natural to progress from </P>
<P>use case -&gt; business layer to support use cases -&gt; data to support business layer</P>
<P>than from</P>
<P>use case -&gt; data to&nbsp;support use case&nbsp;(indrectly) -&gt; business layer to support use case</P>
<P>IMO in the first case the flow is so much more natural, as&nbsp;demonstrated in the section of the book in which Rocky designs the object model for PTracker.</P>
<P></div></BLOCKQUOTE></P>
<P>I've seen some really brittle software application designs that were driven by use cases instead of the underlying data.&nbsp; The first cut of the application worked ok.&nbsp; And the (apparently unexpected but incredibly common) response of the users was, "Great, now that the immediate problem facing me is solved, I need to do X, Y, and Z to the data."&nbsp;&nbsp; Except the application had to be completely gutted to do that because the data was structured to facilitate the A, B and C use cases instead of being structured to support its true nature.</P>
<P>I think that making behavior definition primary over data definition is just as bad a mistake as making data definition primary.&nbsp; Data and behaviour are equal in importance, and have to be respected as such.</P>
<P>For that reason, I prefer this flow:</P>
<P>goals &amp; objectives &amp; problems &amp; risks <BR>-&gt; desired capability (at a high level, both immediate and future)<BR>&nbsp;&nbsp;&nbsp;&nbsp; -&gt; use case design and&nbsp;data design in parallel<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; business layer to support implemented functionality</P>
<P>That way, both behavior and data get equal attention on their own terms.&nbsp; The process of reconciling the two&nbsp;with one another (and to the desired capability) in order to design a business layer catches mistakes caused where only one viewpoint on the problem would have missed a critical feature.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I've seen some really brittle software application designs that were
driven by use cases instead of the underlying data.&nbsp; The first cut of
the application worked ok.&nbsp; And the (apparently unexpected but
incredibly common) response of the users was, "Great, now that the
immediate problem facing me is solved, I need to do X, Y, and Z to the
data."&nbsp;&nbsp; Except the application had to be completely gutted to do that
because the data was structured to facilitate the A, B and C use cases
instead of being structured to support its true nature.</div></BLOCKQUOTE><br><br>It would seem to me that X, Y and Z would then generate completely new, independent objects from the previously built ones... unless X, Y and Z somehow invalidated the previous use cases.&nbsp; <br><br>But your wording implies that is not the case, so it would seem to me that the objects were built off of data, not business requirements, because X, Y and Z should get their own objects, and the previously built ones should remain completely unchanged unless X, Y, or Z modifies the previous use cases.&nbsp; If you're gutting the previous objects, again, it sounds like the new use cases completely invalidated the previous ones.<br><br>That's my take on the scenario you describe, and it doesn't sound like a failing of the 'behavior over data' design philosophy.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, November 28, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I've seen some really brittle software application designs that were driven by use cases instead of the underlying data.&nbsp; The first cut of the application worked ok.&nbsp; And the (apparently unexpected but incredibly common) response of the users was, "Great, now that the immediate problem facing me is solved, I need to do X, Y, and Z to the data."&nbsp;&nbsp; Except the application had to be completely gutted to do that because the data was structured to facilitate the A, B and C use cases instead of being structured to support its true nature.</div></BLOCKQUOTE><BR><BR>It would seem to me that X, Y and Z would then generate completely new, independent objects from the previously built ones... unless X, Y and Z somehow invalidated the previous use cases.&nbsp; <BR><BR>But your wording implies that is not the case, so it would seem to me that the objects were built off of data, not business requirements, because X, Y and Z should get their own objects, and the previously built ones should remain completely unchanged unless X, Y, or Z modifies the previous use cases.&nbsp; If you're gutting the previous objects, again, it sounds like the new use cases completely invalidated the previous ones.<BR><BR>That's my take on the scenario you describe, and it doesn't sound like a failing of the 'behavior over data' design philosophy.<BR></div></BLOCKQUOTE></P>
<P>You've misunderstood me.&nbsp; The data model did not support the other tasks that would soon be required of it.&nbsp; It only supported the initial use cases.&nbsp; That's because the data was structured ONLY to suit the original use case's convenience.&nbsp; It did not properly reflect the true nature of the data.</P>
<P>Here's one of the worst examples of behavior-based data design I ever encountered.</P>
<P>A software development company (now defunct for reasons that will become apparent), built accounting software.&nbsp; For payroll, they had several use cases for preparing a payroll check:&nbsp; Timecard Entry, Salary, and Manual (and a fourth I don't remember off-hand).&nbsp; Each use case not only had its own code (perfectly acceptable!), it had it's own permanent&nbsp;data structures in the database - even though all four methods&nbsp;produced the exact same result - a payroll check.</P>
<P>So, when those were done, and they got around to doing&nbsp;Financial reporting, the reporting use cases had to deal with four entirely different data structures to report on payroll checks&nbsp;when only one was necessary.&nbsp;&nbsp;&nbsp;The entire data model was like that.</P>
<P>And, of course, I'm sure folks can chime in with examples of data modelers gone haywire, building complex edifices without the slightest clue of how they would be used in the real world.&nbsp; That's why I advocate treating them equally rather than favoring one over another.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>You've misunderstood me.&nbsp; The data model did not support the other tasks that would soon be required of it.&nbsp; It only supported the initial use cases.&nbsp; That's because the data was structured ONLY to suit the original use case's convenience.&nbsp; It did not properly reflect the true nature of the data.</div></BLOCKQUOTE><br><br>Indeed, and that's one of the things the business layer is supposed to hide.&nbsp; If you data model changes, the public API to your business objects should remain the same.. perhaps some new properties and rules regarding those properties, but you should not have to completely scrape the business objects.&nbsp; <br><br>In building a system, you should only build what you need.&nbsp; At the same time though, the long term needs to be discussed as well.&nbsp; So your engineers should have known what was to come down the road, and accounted for that if it is certain that certain functionality was going to be built in the next phase.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>A software development company (now defunct for reasons that will become apparent), built accounting software.&nbsp; For payroll, they had several use cases for preparing a payroll check:&nbsp; Timecard Entry, Salary, and Manual (and a fourth I don't remember off-hand).&nbsp; Each use case not only had its own code (perfectly acceptable!), it had it's own permanent&nbsp;data structures in the database - even though all four methods&nbsp;produced the exact same result - a payroll check.
<p>So, when those were done, and they got around to doing&nbsp;Financial reporting, the reporting use cases had to deal with four entirely different data structures to report on payroll checks&nbsp;when only one was necessary.&nbsp;&nbsp;&nbsp;The entire data model was like that.</p>
<p>And, of course, I'm sure folks can chime in with examples of data modelers gone haywire, building complex edifices without the slightest clue of how they would be used in the real world.&nbsp; That's why I advocate treating them equally rather than favoring one over another.</div></BLOCKQUOTE></p>I see what you're getting at now.&nbsp; I don't think anyone is advocating 'ignore the data model' at all.&nbsp; The mantra 'business objects are driven by use cases' applies only to building business objects.&nbsp; That's not to say that the database design is unimportant and should be modeled on behavior though, and I don't think anyone would advocate basing the db design on use cases.&nbsp; It of course should be done with a focus on the data.&nbsp; You then have to have BOs intelligent enough to map its state to the data schema.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, November 28, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>You've misunderstood me.&nbsp; The data model did not support the other tasks that would soon be required of it.&nbsp; It only supported the initial use cases.&nbsp; That's because the data was structured ONLY to suit the original use case's convenience.&nbsp; It did not properly reflect the true nature of the data.</div></BLOCKQUOTE><BR><BR>Indeed, and that's one of the things the business layer is supposed to hide.&nbsp; If you data model changes, the public API to your business objects should remain the same.. perhaps some new properties and rules regarding those properties, but you should not have to completely scrape the business objects.&nbsp; <BR></div></BLOCKQUOTE></P>
<P>The DATA model, not the object model, had to be trashed because it was garbage.</P>
<P>The data model was entirely unable to support the new behavior because it was done wrong.</P>
<P>The data model was garbage because the data in it was defined by behavior instead of in its own terms.&nbsp; And just because you could keep the business layer doesn't mean that much of it didn't have to be rewritten once the data model was gutted and re-done.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>
<P>The DATA model, not the object model, had to be trashed because it was garbage.</P>
<P>The data model was entirely unable to support the new behavior because it was done wrong.</P>
<P>The data model was garbage because the data in it was defined by behavior instead of in its own terms.&nbsp; And just because you could keep the business layer doesn't mean that much of it didn't have to be rewritten once the data model was gutted and re-done.</P>
<P></div></BLOCKQUOTE></P>
<P>It seems to me that what you've described at length is an inadequacy of the original discovery process, and not at all&nbsp;any&nbsp;measure of&nbsp;one development&nbsp;paradigm vs. another.&nbsp; How on earth could starting with the data have anticipated the new requirements any better than starting with the business layer if the analyst was too careless to dig deeper or the user was too obscure about their requirements?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>The data model was garbage because the data in it was defined by behavior instead of in its own terms. </div></BLOCKQUOTE><br><br>From the problem you described, the data should have been coming from a 5th table, PayCheck, whose data could easily be calculated from the other tables.&nbsp; The BOs then could enter a row in both PayCheck and whatever table it needed.&nbsp; Alternately, it may have been that the four tables really described the same data entity, and should not have been seperated out.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>And just because you could keep the business layer doesn't mean that
much of it didn't have to be rewritten once the data model was gutted
and re-done.</div></BLOCKQUOTE><br><br>If the data model changes, but the original use cases have not, I would think that the only work would be (in Csla terms) in the DP methods, and other internal methods related to data access.&nbsp;&nbsp; That may be work, but not as much work as starting from scratch, and your UI layer should remain largely unchanged I would think, also saving a lot of work.<br><br>If there was data needed that wasn't captured in the initial use cases, I would think that's a failure in the requirements gathering, not with the methodology used to design the business objects and database.<br><br>It sounds like this was the case, that not enough data was being gathered by the inital use cases.&nbsp; I know there must be more to the story, but I really think that was the problem.&nbsp; And a report needing four different tables shouldn't totally trash your data model..&nbsp; at worse you should have a messy view, or need to restructure the data... but it almost certainly sounds like a failure in requirements gathering more than anything else.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, November 28, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>The data model was garbage because the data in it was defined by behavior instead of in its own terms. </div></BLOCKQUOTE><BR><BR>From the problem you described, the data should have been coming from a 5th table, PayCheck, whose data could easily be calculated from the other tables.&nbsp; The BOs then could enter a row in both PayCheck and whatever table it needed.&nbsp; Alternately, it may have been that the four tables really described the same data entity, and should not have been seperated out.<BR></div></BLOCKQUOTE></P>
<P>You got it in one. :)<BR></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>And just because you could keep the business layer doesn't mean that much of it didn't have to be rewritten once the data model was gutted and re-done.</div></BLOCKQUOTE><BR><BR><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div></P>
<P>If there was data needed that wasn't captured in the initial use cases, I would think that's a failure in the requirements gathering, not with the methodology used to design the business objects and database.<BR><BR>It sounds like this was the case, that not enough data was being gathered by the inital use cases.&nbsp; I know there must be more to the story, but I really think that was the problem.&nbsp; And a report needing four different tables shouldn't totally trash your data model..&nbsp; at worse you should have a messy view, or need to restructure the data... but it almost certainly sounds like a failure in requirements gathering more than anything else.<BR><BR></div></BLOCKQUOTE></P>
<P>Double-entry accounting is a well-documented business practice dating back to the 13th century AD.&nbsp; So, yes, you could say that there was a failure to model the system correctly.&nbsp; But they knew they had to produce reports from the get go, it wasn't a surprise.&nbsp; </P>
<P>To get this thread back on the original topic... :)</P>
<P>Objects, from the discussion on this forum, are about defining behavior.&nbsp; An object may grab some data, alter it, and deposit it in the appropriate place when done.&nbsp;&nbsp; The focus is on the immediate behavior - how the data is used by that object at that time.&nbsp; </P>
<P>Data Entities, from relational modeling theory, are about the data that is stored, i.e., the data that is left behind when an object finishes its work.&nbsp;&nbsp;What information is contained in that entity?&nbsp; What is its true definition?&nbsp; Have I partially confused it with&nbsp;another data entity?&nbsp; How does it relate to other data entities?&nbsp; What uniquely identifies it?&nbsp; What data is essential for properly completing it?&nbsp; (Yes, the usage of the data does matter, but that is not the primary focus.&nbsp; I *could* choose to calculate the estimated weight in micro-grams of the ink printed on each invoice, but who would care?)&nbsp; This gives me a different, unique view on the problem domain.&nbsp; If I get the definition of the data entities right, they have the latent capability of supporting all behavior expected of them.&nbsp; In other words, as I add new objects to cover new use cases, the data model is already ready for them.&nbsp;</P>
<P>I do what is called a CRUD matrix (in the database world) for each object.&nbsp; For each object, I define which data entities it will Create, Retrieve, Update and/or Delete.&nbsp; If I do this in a data table, I can easily see whether any data entity does not have a use case to create it, or retrieve it, etc.</P>
<P>For larger systems, I do a similar matrix at the data attribute (field) level, and for the same reasons.</P>
<P>Each way of modeling the system provides different insights into the problem domain.&nbsp; Each will tend to miss different aspects of the system, so cross-checking them against one another is a great way to reduce mistakes.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, November 29, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>From the problem you described, the data should have been coming from a 5th table, PayCheck, whose data could easily be
calculated from the other tables.&nbsp; The BOs then could enter a row in
both PayCheck and whatever table it needed.&nbsp; Alternately, it may have
been that the four tables really described the same data entity, and
should not have been seperated out.</div></BLOCKQUOTE>You got it in one. :)</div></BLOCKQUOTE><br><br>I know we're a bit off topic now, but why did the model have to be scraped?&nbsp; It seems like you should be able to generate the needed data for this fifth table from the 'single entry' system.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Double-entry accounting is a well-documented business practice dating
back to the 13th century AD.&nbsp; So, yes, you could say that there was a
failure to model the system correctly.&nbsp; But they knew they had to
produce reports from the get go, it wasn't a surprise. </div></BLOCKQUOTE><br><br>It seems like the reports should have been part of the initial batch of use cases.&nbsp; Its odd that no one thought of the reporting implications before settling on a model.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Objects, from the discussion on this forum, are about defining
behavior.&nbsp; An object may grab some data, alter it, and deposit it in
the appropriate place when done.&nbsp;&nbsp; The focus is on the immediate
behavior - how the data is used by that object at that time. </div></BLOCKQUOTE><br><br>This is a fine way to approach things as well, because all your use cases together should give you a picture of how the data will be used at a later point as well.&nbsp; <br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Data Entities, from relational modeling theory, are about the data that
is stored, i.e., the data that is left behind when an object finishes
its work.&nbsp;&nbsp;What information is contained in that entity?&nbsp; What is its
true definition?&nbsp; Have I partially confused it with&nbsp;another data
entity?&nbsp; How does it relate to other data entities?&nbsp; What uniquely
identifies it?&nbsp; What data is essential for properly completing it?&nbsp;
(Yes, the usage of the data does matter, but that is not the primary
focus.&nbsp; I *could* choose to calculate the estimated weight in
micro-grams of the ink printed on each invoice, but who would care?)&nbsp;
This gives me a different, unique view on the problem domain.&nbsp; If I get
the definition of the data entities right, they have the latent
capability of supporting all behavior expected of them.&nbsp; In other
words, as I add new objects to cover new use cases, the data model is
already ready for them.</div></BLOCKQUOTE><br><br>I agree with you here.&nbsp; <br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I do what is called a CRUD matrix (in the database world) for each
object.&nbsp; For each object, I define which data entities it will Create,
Retrieve, Update and/or Delete.&nbsp; If I do this in a data table, I can
easily see whether any data entity does not have a use case to create
it, or retrieve it, etc.
<p>For larger systems, I do a similar matrix at the data attribute (field) level, and for the same reasons.</p>
<p>Each way of modeling the system provides different insights into the
problem domain.&nbsp; Each will tend to miss different aspects of the
system, so cross-checking them against one another is a great way to
reduce mistakes.</div></BLOCKQUOTE></p>This sounds like a great method.&nbsp; I don't think the back and forth when designing the business layer and data layer should cause changes to the public API and behavior of the business layer, but its perfectly reasonable that a BO may need to track some extra data so that it can properly update the database.&nbsp;&nbsp; I think that's all that we mean by the 'BOs are defined by behavior only' saying.&nbsp; That's all my point was; you don't stop doing data modeling like you always have, you just don't design your BOs according to the data model.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>patingamon replied on Tuesday, November 28, 2006</h2><P class=MsoNormal><SPAN>I agree, David. Object oriented design does need to combine attributes and behaviors. Business cases ought to bring to the surface both of these aspects. Unfortunately, they don’t in every case, because it relies on the customer being completely aware of how they want their system to work, or how the current environment functions. Even interviewing a plethora of subject matter experts rarely brings the business model more homogenous – instead it seems to have the opposite effect, requiring the architect to draw dissimilar desires together.<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>All that aside, I didn’t mean to imply in the first post that this was entirely data driven. In fact, just the opposite was the intention. Whether an “object” is editable or not is only one behavior – in fact, I would look at the editablity (ok – that is not a real word) as a current state of the object, not necessary driving its behavior. Granted, an object that is editable does have different behavior than a read only one, but that is external behavior – behavior that is shared by any editable object (perhaps editable/read-only is an interface supported by an object – though I haven’t thought that one through yet).<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>Anyway (sorry for the digression), that is why I list behaviors of the Store instead of data that I wanted in common whether or not the object was editable. I completely agree that the “data” portion may be different. To an extent, it is a view on the object, i.e., what data I want exposed or carried about with me.<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>Very good discussion. Thank you for all your input.<o:p></o:p></SPAN></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, November 28, 2006</h2><P>However, redundant code also reduces maintainability and reliability...</P>
<P>One professor of mine said "Computer Science is the science of giving away some feature you want for another feature you want more."&nbsp; </P>
<P>With 2.1+, we can save objects that violate the rules.&nbsp; This implies that a read-only object, if it is to report on its rule status, also has to access the rule code.&nbsp; The odds of a read-only object getting updated when the rules change isn't good...&nbsp; Perhaps a compromise on the two positions would be to put common functions in a static StoreHelper object?&nbsp;&nbsp;&nbsp; That would at least get any custom code (except for rule initialization) out of the two objects and into a shared object.&nbsp; </P>
<P>Ideally, each of the Store objects would call a shared rule setup function that would initialize the rules, but I'm not sure that's workable given the Csla architecture.&nbsp; The right hooks might be too private...</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
