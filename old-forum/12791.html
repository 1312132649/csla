<html><header><title>NetDataContractSerializer - Type is not resolved for member</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>NetDataContractSerializer - Type is not resolved for member</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12791.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Monday, November 03, 2014</h2><p>We&#39;re trying to upgrade to the latest Csla 4.5 on .Net 4.0.&nbsp; We&#39;re still using remoting for the time being and will at some future point move to WCF, but for now remoting it is.&nbsp; I&#39;ve hit a problem where the BinaryFormatter hangs when deserizlizing one of our types.&nbsp; The odd part is that it does work the first few times, it only fails after a few back and forths.&nbsp; So I&#39;m trying to move us to the NetDataContractSerializer, which we&#39;d use on WCF anyway.</p>
<p>My issue there is that immediately we get an exception (before any of the remoting even happens) when trying to serialize the very first type.&nbsp; It fails with a SerializationException: Type is not resolved for member &quot;ABC&quot;&nbsp; I&#39;ve not been able to find any useful information, and its my understanding the NDCS should pretty much be a drop in replacement for BinaryFormatter and thus honor the Serializable / NonSerializable attributes.&nbsp; </p>
<p>This failure is happening just running our unit tests over remoting, both in R# and in the NUnit GUI.&nbsp; Here&#39;s&nbsp;a portion of the &nbsp;stack trace (omitted parts are our code / remoting proxy calling into serialize the object):</p>
<p>at System.AppDomain.GetHostEvidence(Type type)<br />at System.Security.Policy.AppDomainEvidenceFactory.GenerateEvidence(Type evidenceType)<br />at System.Security.Policy.Evidence.GetHostEvidenceNoLock(Type type)<br />at System.Security.Policy.Evidence.RawEvidenceEnumerator.MoveNext()<br />at System.Security.Policy.Evidence.EvidenceEnumerator.MoveNext()<br />at System.Configuration.ClientConfigPaths.GetEvidenceInfo(AppDomain appDomain, String exePath, String&amp; typeName)<br />at System.Configuration.ClientConfigPaths.GetTypeAndHashSuffix(AppDomain appDomain, String exePath)<br />at System.Configuration.ClientConfigPaths..ctor(String exePath, Boolean includeUserConfig)<br />at System.Configuration.ClientConfigPaths.GetPaths(String exePath, Boolean includeUserConfig)<br />at System.Configuration.ClientConfigurationHost.RequireCompleteInit(IInternalConfigRecord record)<br />at System.Configuration.BaseConfigurationRecord.GetSectionRecursive(String configKey, Boolean getLkg, Boolean checkPermission, Boolean getRuntimeObject, Boolean requestIsHere, Object&amp; result, Object&amp; resultRuntimeObject)<br />at System.Configuration.BaseConfigurationRecord.GetSection(String configKey)<br />at System.Runtime.Serialization.Configuration.NetDataContractSerializerSection.TryUnsafeGetSection(NetDataContractSerializerSection&amp; section)<br />at System.Runtime.Serialization.NetDataContractSerializer.get_UnsafeTypeForwardingEnabled()<br />at System.Runtime.Serialization.XmlObjectSerializerWriteContextComplex..ctor(NetDataContractSerializer serializer, Hashtable surrogateDataContracts)<br />at System.Runtime.Serialization.NetDataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer, Object graph, DataContract contract, Hashtable surrogateDataContracts)<br />at System.Runtime.Serialization.NetDataContractSerializer.InternalWriteObject(XmlWriterDelegator writer, Object graph)<br />at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer, Object graph, DataContractResolver dataContractResolver)<br />at System.Runtime.Serialization.XmlObjectSerializer.WriteObject(Stream stream, Object graph)</p>
<p>Any ideas?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, November 03, 2014</h2><p>Hi Andy,</p>
<p>Have you tried to hook into AppDomain.TypeResolve event? <br />http://msdn.microsoft.com/en-us/library/system.appdomain.typeresolve(v=vs.110).aspx</p>
<p>This should at least give some indication of which type and assembly that is not found (resolved).&nbsp;</p>
<p>It could be that some assembly is not available in the folder that the testrunner is loading assemblies from or maybe even an old version that is missing some types is in that folder.</p>
<p>You could also use ProcMon from Sysinternals to trace which assemblies is &quot;searched&quot; for and &quot;loaded&quot; and from which &quot;folders&quot;. &nbsp;This might also help you identify whether the correct assemblies is loaded or not.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 04, 2014</h2><p>I figured out our main problem was our remoting proxy.&nbsp; Instead of returning TaskFactory.StartNew with an Action that called the remote data portal, I changed to code to use TaskCompletionSource and called SetResult / SetException as appropriate.&nbsp; Once that was out of the way, the NDCS still didn&#39;t work in the unit tests but did in the main application (and no more issues with the application hanging while awaiting a DP_F call).</p>
<p>I then changed back to BinaryFormatter for serialization and now the unit tests run as well.&nbsp; Looking at the Fusion logs it appears that R# 8 is probing the \Program Files (x86)\JetBrains\ReSharper\v8.2\Bin folder which of course contains none of the needed assemblies.&nbsp; Turning of shadow copying didn&#39;t seem to work either; it looks like for some reason the NDCS ends up running in a new AppDomain which causes this shift.&nbsp; I don&#39;t know why the BinaryFormatter works as expected though.</p>
<p>I&#39;d like to solve this as we do want to move to WCF and I think the team will want to keep remote dataportal enabled as part of the tests we have, so if there&#39;s a way to get this working I&#39;d still like to know.</p>
<p>Also, what is weird is that there are a few unit tests that have always failed serializing with the same message, and those tests and the NDCS always fail with the same type, which is our custom principal.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, November 04, 2014</h2><p>Hi,</p>
<p>Do you use the CslaTaskScheduler - If not then the problem is likely that the background thread does not get the CurrentPrincipal and ApplicationContext from the calling thread.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 04, 2014</h2><p>No, we weren&#39;t using that.. would that cause the Task to hang and never return?&nbsp; I notice that on .Net 4 the WcfProxy does something similar; it uses BackgroundWork and then awaits a TaskCompletionSource&#39;s Result property instead of calling via TaskFactory.StartNew.&nbsp; I was wondering if the same issue had shown up there as I would have expected to be able to use TaskFactory.StartNew.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, November 04, 2014</h2><p>No., it shouldnt cause the thread to hang (unless you are calling an async dataportal call in the background thread). </p>
<p>TaskFactory.StartNew will make the code run on a background thread and you could end up loosing the synchronizationcontext and not be able to reenter the thread if you make an async Dataportal Fetch call from that background thread. </p>
<p>You code would also change to have the default Principal on the background thread - unless you have added your own mechanism to transfer the calling thread Principal to the background thread or call&nbsp;AppDomain.SetThreadPrincipal to set the default principal in a Windows (WinForms/WPF app).&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
