<html><header><title>EditableRoot will not be removed from Memory</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>EditableRoot will not be removed from Memory</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10827.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl posted on Sunday, October 30, 2011</h2><p>&nbsp;
Hi.</p>
<p>I have attached a printscreen which shows my Problem in Redgates-Memory-Profiler.</p>
<p>I have an EditableRoot-Object called Prayon.Library.Activity. For my Tests, I load the Activity-Object like</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void OnDummy() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var a = Activity.GetTypedActivity(new Guid(&quot;8A4810EB-F516-11E0-B771-040CCEE2D49D&quot;));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p> After the Fetch, I call the fallowing (on the Client-Side):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(FieldManager.FieldExists(GeneralCustomFieldValueListProperty))) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Child.CustomFieldValueList.GetCustomFieldValueListAsync(this, true, initial, (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error == null &amp;&amp; e.Object != null) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(GeneralCustomFieldValueListProperty, e.Object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>CustomFieldValueList is a Child-List of Activity.</p>
<p>The Problem is, that the loaded Activity-Object now stays in the Memory. As you see on the printscreen, it has the fallowing Reference-Path:</p>
<p>- Csla.DataPortal&lt;Child.CustomFieldValueList&gt; (FetchCompleted) <br />&nbsp;&nbsp; - System.EventHandler&lt;DataPortalResult&lt;Child.CustomFieldValueList&gt;&gt;<br />&nbsp;&nbsp; &nbsp;&nbsp; -&nbsp; Prayon.Library.Activity</p>
<p>Can anybody help me, how I can solve this problem, that the Activity-Object will be collected of the GC?</p>
<p>Thank you.</p>
<p>Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Sunday, October 30, 2011</h2><p>I have found out, that when I remove the FetchCompleted-Eventhandler after complete from the DataPortal, it is working and my Object will be collected from the Memory.<br /><br />For doing this, I have created the Helper-Method:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static EventHandler&lt;DataPortalResult&lt;Child.CustomFieldValueList&gt;&gt; GetEventHandler(object classInstance, string eventName) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type classType = classInstance.GetType();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FieldInfo eventField = classType.GetField(eventName, BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Instance);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var eventDelegate = (EventHandler&lt;DataPortalResult&lt;Child.CustomFieldValueList&gt;&gt;)eventField.GetValue(classInstance);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // eventDelegate will be null if no listeners are attached to the event<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (eventDelegate == null) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return eventDelegate;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />Which I use there:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(FieldManager.FieldExists(GeneralCustomFieldValueListProperty))) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Child.CustomFieldValueList.GetCustomFieldValueListAsync(this, true, initial, (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((DataPortal&lt;Child.CustomFieldValueList&gt;)o).FetchCompleted -= GetEventHandler(o, &quot;FetchCompleted&quot;);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error == null &amp;&amp; e.Object != null) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(GeneralCustomFieldValueListProperty, e.Object);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />BUT: I ask me know, if it is right, that I have to do this? Do I something wrong with the async-DataPortal or perhaps this is a Bug of CSLA?<br /><br />Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, October 31, 2011</h2><p>Can you post your factory method so we can see what it looks like?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Monday, October 31, 2011</h2><p>Hi Rocky</p>
<p>This is the factory-method of the child-list (Child.CustomFieldValueList.GetCustomFieldValueList()):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static void GetCustomFieldValueListAsync(Activity activity, bool general, bool defaultValues, EventHandler&lt;DataPortalResult&lt;CustomFieldValueList&gt;&gt; callback) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataPortal.BeginFetch(new ActivityCriteria(activity.Id, general, defaultValues), callback);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>and here the DataPortal_Fetch-Method:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void DataPortal_Fetch(ActivityCriteria criteria) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.RaiseListChangedEvents = false;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var customFieldValueRepository = new CustomFieldValueRepository()) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var customFieldValue in customFieldValueRepository.GetAll().Where(x =&gt; x.BusinessObjectId == criteria.Value)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(CustomFieldValue.GetCustomFieldValue(customFieldValue));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.RaiseListChangedEvents = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>This is the factory-method of the EditableRoot:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static Activity GetTypedActivity(Guid Id) {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var criteria = new SingleCriteria&lt;Activity, Guid&gt;(Id);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ret = DataPortal.Fetch&lt;Activity&gt;(criteria);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret.OnFetchComplete(criteria);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>The async Load of the Child list will be started in ret.OnFetchComplete(criteria).</p>
<p>Thanks for your help.</p>
<p>Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, October 31, 2011</h2><p>There&#39;s nothing we (Sergey, Justin and me) are seeing that would cause this effect.</p>
<p>Justin was wondering if your application makes uses of large images or large byte[] types or some other huge object instances that might fragment memory (and be handled differently by the GC)?</p>
<p>Thinking out loud:</p>
<p>The FetchCompleted event is always declared as an instance event, never static. And the instances of DataPortal&lt;T&gt; are scoped to individual methods. And the FetchCompleted handler (the data portal creates an implicit reference to the handler of the callback) is a lambda right? The lambda is an object at runtime.</p>
<p>It is true that some of these objects might not get GCed quickly, because they may create circular references between themselves.</p>
<p>But even then, none of them should have ever established a reference to the Activity object itself.</p>
<p>Unless you have some code somewhere that establishes an event handler for FetchCompleted that isn&#39;t a lambda? But even if you did that, the data portal instance holding that reference would eventually get GCed because the data portal instance is scoped to a specific method.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Tuesday, November 01, 2011</h2><p>Hi Rocky</p>
<p>I do not use large imaged or large byte[] types on this place. I will now build in my application two small classes (Editable-Root and Child) like this two without anything and try this with this two classes. I will back with the results.</p>
<p>Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Tuesday, November 01, 2011</h2><p>Hi Rocky</p>
<p>I have tested this. I think it will work - but when I Load the Child-List, it take a very long time, till the instance will be collected from the GC (about 90 Seconds).</p>
<p>Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, November 01, 2011</h2><p>Garbage collection is not immediate, that is absolutely true. And it can take longer or shorter amounts of time depending on whether you are using the server or client GC. In other words, you&#39;ll see different behavior on the server from the client.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, October 31, 2011</h2><p>Also, when you call RegisterProperty for your child property declaration, you are marking it as a child as part of the registration right?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Tuesday, November 01, 2011</h2><p>Hi Rocky</p>
<p>The ChildProperty is declared on this way:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static readonly PropertyInfo&lt;Child.CustomFieldValueList&gt; GeneralCustomFieldValueListProperty = RegisterProperty(new PropertyInfo&lt;Child.CustomFieldValueList&gt;(&quot;GeneralCustomFieldValueList&quot;));</p>
<p>Best Regards, Thomas</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
