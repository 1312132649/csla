<html><header><title>&lt;CrtImplementationDetails&gt;.ModuleLoadException thrown </title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>&lt;CrtImplementationDetails&gt;.ModuleLoadException thrown </h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7419.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ChrisM posted on Friday, August 07, 2009</h2>I'm having an issue w/ the above exception on a command object I'm using in CSLA for Silverlight.  I've read this thread:<br />http://forums.lhotka.net/forums/thread/21402.aspx<br /><br />which seems to point at the C++ runtime and it's inability to use the custom CSLA Principal.  My question:  Is it possible instead to use the stand windows principal?  I'm in an intranet deployment, and have access to the windows identity via IIS and the integrated authentication.  Is there a reason NOT to use this, as from what I can tell it might solve my issues?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, August 07, 2009</h2><P>You need to decide on your authentication and authorization strategy.</P>
<P>From a technical perspective you can use Windows auth, Membership auth or custom auth. CSLA .NET works with all of those options. Which option is right for you depends on your requirements.</P>
<P>By default CSLA .NET uses Windows auth - which is to say it doesn't do anything with the principal at all, and it is up to you to ensure that your environment is configured properly so the Windows principal is the current principal on the thread or HttpContext.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ChrisM replied on Friday, August 07, 2009</h2>Okay, are there any of the examples you put out w/ the CSLA for Silverlight that show how to use the Windows Auth?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, August 08, 2009</h2>There's a project in the Test download - there are several test projects for<br />different authn models actually.<br /><br />And this is covered in the CSLA .NET for Silverlight video series, along<br />with a sample app (http://store.lhotka.net).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ChrisM replied on Monday, August 10, 2009</h2>Okay, this is what I can see so far.  If I go the Silverlight path, I end up with a custom Principal on the client due to the fact that Silverlight can't natively get the local users security info.  This custom principal then gets passed to the wcf portal along with any requests, which then fubars loading these c++ libraries that can't handle the custom Principal.  So this is my solution:  Modify the Csla.ApplicationContext class, adding a static IPrincipal called First.  In the user get of Csla.ApplicationContext, if First is null set it to current.  then in my command class, my data portal execute ends up looking like this:<br /><br />protected new void DataPortal_Execute()<br />        {<br />            IPrincipal p = ApplicationContext.User;<br />            ApplicationContext.User = ApplicationContext.First;<br />            exec(); //do the actual command work<br />            ApplicationContext.User = p;<br />        }<br /><br />This way the custom principal goes back to the client, but for this one call I use the native windows principal.  Does this look like a good plan?  It does work..I just don't want to fubar my Csla too much here.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 10, 2009</h2>Ahh, yes.<br /><br />Fixing this is an item in the wish list. Ideally there'd be an option where<br />the Silverlight data portal doesn't pass the client principal to the server<br />- assuming the server will just "do the right thing" - which it would in<br />your case.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
