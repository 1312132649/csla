<html><header><title>Which stereotype should I use - non-editable list of editable root objects?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Which stereotype should I use - non-editable list of editable root objects?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10421.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH posted on Tuesday, June 07, 2011</h2><p>I would like to bring back a list of editable root objects.&nbsp; I don&#39;t want the objects to be children, as I don&#39;t want the entire list to be sent back to the server to save changes to one object&#39;s graph.</p>
<p>I also do not want the behavior of the DynamicListBase, as I don&#39;t want the objects to be automatically persisted as the user exits edited rows.&nbsp; I want this to be a conscious effort on their part when to save data.</p>
<p>Given these requirements, it seems that creating a list that inherits BusinessListBase is the best route, but what is the best way to load my editable roots?&nbsp; Just an internal GetObject(data) method that bypasses the DataPortal_Fetch/Child_Fetch methods?</p>
<p>Any thoughts / suggestions / existing discussion links would be greatly appreciated!</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, June 07, 2011</h2><p>The data portal works against any serializable type.</p>
<p>Therefore, if you don&#39;t need the features of BLB or DLB, then you could just create a serializable List&lt;T&gt; or ObservableCollection&lt;T&gt; or BindingList&lt;T&gt; as your collection type and use that.</p>
<p>If you actually keep the objects in the collection on the client side though, you&#39;ll need to reimplement much of DLB. Although DLB does the automatic save operations, the most important thing it does is manage the concept of an object in the list being saved without disrupting the list itself.</p>
<p>But if you just need a list to bring back a bunch of objects to the client, and you aren&#39;t going to keep the objects in the list, or use the list for anything on the client, then List&lt;T&gt; is a good option.</p>
<p>If you want to support Silverlight - use the Csla.Core.MobileXYZ types (like MobileList&lt;T&gt;).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH replied on Wednesday, June 08, 2011</h2><p>Is it recommended practice to actually invoke DataPortal_Fetch for each editable root in this case, or is it acceptable to expose an internal static Fetch() method in which I pass the data to directly?</p>
<p>In other words, is DataPortal_Fetch doing anything for me behind the scenes (invoking business rules, etc.) that I wouldn&#39;t otherwise get if I bypass it to load an object&#39;s data?</p>
<p>I see that authentication is being checked and each object is being set as clean and old, but it seems like DataPortal_Fetch is performing alot of work that could be easily bypassed in the scenario that I&#39;m after.</p>
<p>Any thoughts on this?&nbsp; Am I missing something that DataPortal_Fetch is doing for me that I would otherwise have to handle myself if I bypass it and call my own internally defined static Fetch() method?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 08, 2011</h2><p>The data portal, by default, manages the object&#39;s metastate (isnew, isdirty, ischild, etc). It also clones the object graph before an update, ensuring that if if the update fails, you still have a deterministic object graph in memory (otherwise you must discard and reload from scratch - if that&#39;s even possible).</p>
<p>The <em>Using CSLA 4: Data Access</em> and <em>Using CSLA 4: Data Portal Configuration</em> ebooks are pretty thorough in covering the data portal and data access behaviors provided by CSLA .NET.</p>
<p>You can entirely replace the data portal of course. In that case, you need to devise your own way to manage metastate as CSLA expects, and you need to devise some way to deal with failure during the update process. I suggest that you also need some way to abstract the persistence of objects to retain the maintainability and consistency provided by the data portal.</p>
<p>You can do all those things - you just need to understand what the data portal is doing so you can replicate the minimum behaviors.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
