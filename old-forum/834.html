<html><header><title>Support for &quot;Built-In&quot; objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Support for &quot;Built-In&quot; objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/834.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Monday, August 07, 2006</h2><P>I am throwing this out there in the hopes of getting some feedback with ideas/suggestions on how best to implement, enforce and protect some "built-in" objects in our framework.</P>
<P>For an example, we want to build-in an "Administrators" group/role into our framework so that it will always be available for every application and cannot be modified by users when configuring security on an application basis.&nbsp; In other words, we can guarantee that this role has the access we want, etc.&nbsp; We will also have a built-in "Administrator" user that is a member of this role where we can control the password so that we are guaranteed access for support concerns.&nbsp; This is all analagous to what Windows does.</P>
<P>The question is how to best implement this into the framework?</P>
<P>Our initial stab at this was to create an AdministratorsGroup object that inherits our Group class and hard-defines the appropriate property values.&nbsp; It also marks itself as read-only.&nbsp; We have a SecurityManager (pseudo-factory) class that exposes the application's users and groups through its Users and Groups static properties (respectively). When the GroupCollection class initializes, we add a new instance of the AdministratorsGroup to the collection.</P>
<P>That works great but then we had to start dealing with all of the operations that can be done with the collection: Add, Clear, Insert, Remove, etc.&nbsp;this has become daunting as we have to override&nbsp;just about every property and method in our collection to prevent users from changing them or removing them or adding a new object with the same name, etc. &nbsp;Plus, if the app is data-driven and we allow the client application to assign new users to this group, how do we enforce a foreign key relationship to an object that exists only in code?</P>
<P>See where I'm going with this?</P>
<P>Any thoughts on how to accomplish what we are after?</P>
<P>We've already done a similar thing in a couple of other areas of our framework but in those cases we are not dealing with data-driven objects and we allow the applications to remove the built-in objects if we want to override the behavior.&nbsp; Plus, those objects are not user (on-the-fly) configurable as our security model is.</P>
<P>Your ideas/suggestions are appreciated.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 07, 2006</h2>Maybe you could just have a BuiltIn column in your roles table in the database. If this is true, then any object loaded based on that data would set itself to read-only, and would refuse to delete the data, etc?<br><br>During app install you'd have a special program that runs to pre-initialize the data table with your built-in roles, but only that special program would ever set the BuiltIn flag to true, so no other roles would ever have that flag.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, August 07, 2006</h2><P>I'd thought of the idea of having the built-in objects always marked as New so that they would always be added to the database if they didn't exist when changes were applied.&nbsp; We already have logic in our sprocs to pre-check for the existance of the primary key field (Guid) when we attempt to insert an object and defer to an Update if it already exists.&nbsp; So, the combination of these two things would address the foreign key issue.&nbsp; But...</P>
<P>The reason we want to build these object into the framework is because we can't trust the database as the 'source' for the objects.&nbsp; We develop many applications that are deployed on remote/client networks that are vulnerable to the prying hands of...well, whomever is allowed accesses to their systems.&nbsp; Because of this, we have to account for the fact that there is no guarantee that changes to the application's data were made through the application's interface.&nbsp; So, if we only pre-initialize the data on install, and later someone who didn't know any better was 'cleaning house' or something and deleted our objects from the database, we would need some way of restoring those objects.&nbsp; Which, the above method does allow us to do - but only if an object is changed and applied to the database.</P>
<P>We have about a dozen different thoughts flying around on this end covering a range of "what ifs" and "how tos".&nbsp; I'm hoping that someone may have crossed this before and can share their approach to help me sort through these ideas.</P>
<P>The big issues as I see them are:</P>
<P>1. Making it so the objects can't be altered through application code (either modified or removed) and duplicates cannot be created by client code.&nbsp; So far, the best approach we've have is to override all of the methods in our base collection to block such functions from occurring.&nbsp; Total pain in the...</P>
<P>2. Addressing the data storage concerns where the object is automatically created in the database if missing so that foreign key references are valid.&nbsp; Then there's the added twist that once it's in the database, we have to block the data access methods from creating the object out of the database and to use the coded instance.&nbsp; This is because the hard-coded object is 'golden' whereas the database version could have been modified by someone playing with Query Analyzer or Enterprise Manager (for instance).</P>
<P>At the core of our logic is that our compiled code, the framework, is secure and not vulnerable to intentional or inadvertant changes whereas our data store, whatever that may be, is open, accessible and subject to changes outside of our control.&nbsp; When designing our applications, we always lead with the assumption that the database is an unstable and unreliable source and equip our types with fail-safe measures to account for that.&nbsp; This is part of that process.&nbsp; Our goal, in this portion, is to ensure a reliable way for users and our support personnel to gain access and control of the application even when undesirable changes have been made to the database (like someone blowing away the Users table!).</P>
<P>One line of thought (that I don't prefer) is to eliminate enforcement of the foreign key constraints in the database so that these objects never have to exist in the database.&nbsp; That would eliminate the data access issues but, as I said, I don't like this idea because FK constraints are a powerful tool to enforce data integrity.&nbsp; So, that brings me back to trying to figure out a happy medium that does what we want without having to make unwanted sacrifices in the exchange.</P>
<P>Hopefully that puts things in a little more perspective.&nbsp; I appreciate the feedback.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, August 07, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>We develop many applications that are deployed on remote/client
networks that are vulnerable to the prying hands of...well, whomever is
allowed accesses to their systems.&nbsp; Because of this, we have to account
for the fact that there is no guarantee that changes to the
application's data were made through the application's interface. </div></BLOCKQUOTE><br><br>If this is the case, then there's not a whole lot you can do about this problem.&nbsp; Once people access and change your database from outside your application, you really don't have any control over that anymore.&nbsp; I would say don't worry about it.&nbsp; If someone pokes into the database, and a role which your application assumes to be there isn't, have the application throw an exception when it tries to find your role / user.<br><br>Make it clear to your clients that they aren't to modify the data outside of your system, and if they do and something breaks, you'll be happy to help them, but only for a fee.&nbsp; Alternately, let them know which rows of data they shouldn't modify, if they feel they must modify some data.<br><br>Andy<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jurjen replied on Tuesday, August 08, 2006</h2><P><FONT face=Verdana size=2>SonOfPirate,</FONT></P>
<P><FONT face=Verdana size=2>Assuming you always have access to the database, </FONT><FONT face=Verdana size=2>I think I would make some sort of SQL script, this script would check to see if the user(s)/role(s) used for support are in place, if not it will insert them, it could also remove any users in the Administrators group not belonging there.&nbsp; You could even decide to execute this script (StoredProc) every time the app starts, making sure that any 'polution' introduced by your users is removed.</FONT></P>
<P><FONT face=Verdana size=2>Jurjen.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, August 08, 2006</h2><P>Yea, it would be great if we could make demands on our customers to not touch things and it is certainly reasonable to follow a "buyer beware" approach to breakage, but this is as much for us as it is used to keep things running smoothly.&nbsp; We sell commercial software and with it comes support.&nbsp; A large segment of our market is manufacturing/industrial oriented and they have certain expectations about the support they receive.&nbsp; In order to compete, we have to play ball by many of their rules - or at least on par with what our competitors offer.&nbsp; With that comes the need to be able to address issues quickly including recovering applications from something catastrophic like someone manually messing with the contents of the database (it happens, geez, don't get me started on the crazy crap we've seen!)</P>
<P>As part of this, my support personnel need a reliable, guaranteed way to access the system for support tasks.&nbsp; This is where the concept of a built-in user and role applies.&nbsp; If we allow the client ANY opportunity to remove those items, we lock ourselves out of our own software.</P>
<P>We are extending this to a common set of "built-in" users and roles that we would be incorporating into every application anyway: Administrator/Administrators.&nbsp; This way the customer is also guaranteed access regardless of what their personnel do to that application out on the shop floor.</P>
<P>Again, this is analogous to Windows, so our expectation was that there'd be more experience in this area.&nbsp; The biggest difference from Windows is, of course, that the database is accessible in our case and your average Windows user isn't getting into the OS's security.</P>
<P>At this point, what we are considering doing is&nbsp;building-in a "safety check" in our data portal fetch method for our collection class that checks to see that our built-in objects are retrieved from the database with any other objects.&nbsp; If they are not, the built-in objects are added to the collection, marking them as new.&nbsp; Presumably, our FK constraint in the DB has made it so any changes to the records in the database have been&nbsp;cascaded to any referencing items, so integrity is maintained (and if they removed the FK constraint, then we won't have any problems as the reference will be restored once we re-write the record back into the table with the same uniqueidentifer).</P>
<P>As such, if we find the items are not in the collection retrieved from the database, we can add the built-in items back into the collection where they will be re-applied to the database with the next set of changes.&nbsp; This allows us to eliminate additional classes for these objects and handle these objects within the confines of our collection class(es).</P>
<P>Make sense?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 08, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>Yea, it would be great if we could make demands on our customers to not touch things and it is certainly reasonable to follow a "buyer beware" approach to breakage, but this is as much for us as it is used to keep things running smoothly.&nbsp; We sell commercial software and with it comes support. </div></BLOCKQUOTE><br><br>I certainly hear where you are coming from.&nbsp; FWIW, most products exclude from warranty support if any modifications are done by the user.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>A large segment of our market is manufacturing/industrial oriented and they have certain expectations about the support they receive.&nbsp; In order to compete, we have to play ball by many of their rules - or at least on par with what our competitors offer.&nbsp; With that comes the need to be able to address issues quickly including recovering applications from something catastrophic like someone manually messing with the contents of the database (it happens, geez, don't get me started on the crazy crap we've seen!)</div></BLOCKQUOTE><br><br>Sounds like a tough industry in which to be.&nbsp; I worked at a company that built custom solutions for clients; we did encounter most of these problems with one of them.&nbsp; At once point, the company decided to no longer accept business from this client.&nbsp; It was tough, since it was a larger client, but they felt that's the only course of action that made sense.&nbsp; In our case, it was because not only was the customer breaking things, they were expecting us to fix it for free.&nbsp; In general, they were a pretty unreasonable company.<br><br>If your entire market is like that, well.. that's a problem, but not impossible to solve.&nbsp; I assume you have some loyal customers.&nbsp;&nbsp; What you need are sales people who can 'manage the customer' very well.&nbsp; Bucking the trend may work for you, since your system should be more reliable (because the customer has less chance to mess it up) that your competitors.&nbsp; I was suprised; our company also started pushing back against unreasonable expectations.&nbsp; To my suprise, customers seemed to actually like that aspect.&nbsp; We didn't just say no of course, we offered a better alternative to what they wanted to do.&nbsp; I'm no longer with the company (left for some personal reasons) but from what I hear they are doing well.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>As part of this, my support personnel need a reliable, guaranteed way to access the system for support tasks.&nbsp; This is where the concept of a built-in user and role applies.&nbsp; If we allow the client ANY opportunity to remove those items, we lock ourselves out of our own software.</div></BLOCKQUOTE></p>Yes, I agree you need to be able to access the application.&nbsp; How do your support people get in?&nbsp; Do they use a client's workstation?&nbsp; Their own laptop (from your company)?&nbsp; If its the latter, perhaps code can skip any authentication and grant full access if the domain is your companies (and the laptop is a 'support' laptop).&nbsp; Perhaps even better, have your application look for a USB dongle of some kind, that grants admin access.<br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>We are extending this to a common set of "built-in" users and roles that we would be incorporating into every application anyway: Administrator/Administrators.&nbsp; This way the customer is also guaranteed access regardless of what their personnel do to that application out on the shop floor.</p>
<p>Again, this is analogous to Windows, so our expectation was that there'd be more experience in this area.&nbsp; The biggest difference from Windows is, of course, that the database is accessible in our case and your average Windows user isn't getting into the OS's security.</div></BLOCKQUOTE></p><p>This is a good way to go, if you must always have certain groups.&nbsp; FWIW though, Windows suffers the same problems as your application.&nbsp; You can boot off a Linux Cd, change the administrator password, and unlock the account, then reboot into Windows.&nbsp; This will cause windows to see a 'problem' with the filesystem, but if you tell it not to do anything, you're in.&nbsp; Obviously, if you can do this, you can delete the expected accounts.&nbsp; I'm not sure Windows would behave that well in that situation either.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>At this point, what we are considering doing is&nbsp;building-in a "safety check" in our data portal fetch method for our collection class that checks to see that our built-in objects are retrieved from the database with any other objects.&nbsp; If they are not, the built-in objects are added to the collection, marking them as new.&nbsp; Presumably, our FK constraint in the DB has made it so any changes to the records in the database have been&nbsp;cascaded to any referencing items, so integrity is maintained (and if they removed the FK constraint, then we won't have any problems as the reference will be restored once we re-write the record back into the table with the same uniqueidentifer).</p><p>As such, if we find the items are not in the collection retrieved
from the database, we can add the built-in items back into the
collection where they will be re-applied to the database with the next
set of changes.&nbsp; This allows us to eliminate additional classes for
these objects and handle these objects within the confines of our
collection class(es).</div></BLOCKQUOTE></p>Probably a better idea is to build a seperate tool which connects to the db, and scans system data, with the option to fix things.&nbsp; This way you can fix the problems with the database, and don't need to code anything special to get into your application.&nbsp;&nbsp;<br><br>The only potential problem is that I'm not sure there's any guarantee that the collection will be saved (well, I suppose you could&nbsp; make sure).<br><br>Just remember though, this isn't just a security problem.&nbsp; Any data may be compromised at which point reports that don't check the data will give invalid results.&nbsp; This is a more subtle problem, and your customers may blame you.&nbsp; Even your application may behave oddly or crash, if they do something extreme like change the schema.&nbsp; You have to validate data from the db, which usually is not a requirement (I would hope, anyway).<br><br>Good luck.<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, August 08, 2006</h2><P>Andy,</P>
<P>I agree completely.&nbsp; As I said, this effort is as much, if not more, for us than for the customers and I certainly do agree that there is a line we can and do draw in regards to support.&nbsp; With mfg customers (esp. the Big-3!), there are many hands involved from a user standpoint and a system failure costs big bucks so the heat is really on you to make corrections fast.&nbsp; Having a 'backdoor' for our support personnel side-steps the hassles of having to locate the person who knows the passwords or waiting for IT to come down or any of the several dozens issues we've ran into over the years.&nbsp; You put a computer in front of a user and they will play, that's the rule of thumb.&nbsp; So, having this 'backdoor' is more to facilitate support than anything.&nbsp; Whether we are getting paid to be there or not is a whole 'nother issue!</P>
<P>I like the idea of the dongle.&nbsp; Definitely something to look into.&nbsp; My initial thought, however, is that this is an authentication tool to identify the user but that user still has to be 'mapped' to the roles and rights within the application.&nbsp; So, in that regard, it isn't really any different than integrated Windows authentication.&nbsp; In other words, we still need some way of indicating that user 'x' is in such-and-such role with these rights for our authorization rules to grant access.&nbsp; We already have an interface under development for RF ID badges and would assume that a security fob or dongle would follow the same suit as this.&nbsp; In that case we treat the user's information the same as we do with Windows (single-sign-on) authentication and consider the user authenticated but still have to determine what roles/rights that user has to the application.</P>
<P>BTW - we connect in a variety of ways depending on the type of access and connectivity available.&nbsp; Our preferred method is via Remote Desktop connection or other remoting tool, but that is rarely an option and&nbsp;more times than not, it requires someone be on site (because the first thing these guys do when budgets get tight is remove as much of the networking as they can without compromising the systems).&nbsp; Some of the network topologies we've had to endure are amazing!</P>
<P>I understand the idea of doing a system scan on startup or with a separate utility, but am trying to simplify this from a usage standpoint to a) eliminate as many phone calls as possible from customers;&nbsp;b) encapsulate the logic as much as possible; and, c) reduce the work for my developers.&nbsp; Because these objects are built into our framework, a "recovery" utility would only be able to address framework-level components.&nbsp; We would either have to extend this utility for every application to add application-specific components or develop a second utility for each.&nbsp; Either way, we've just added to the development efforts required for each application.&nbsp; Plus, initiating the utility would require either&nbsp;service intervention or a walk-through with the customer on the phone. &nbsp;I'd rather have the "fail-safe" built in along with the objects so that all of this becomes transparent to my developers and users.</P>
<P>Obviously, this is still a work in progress, but I think we are getting closer.&nbsp; Thanks for the input.&nbsp; It is appreciated.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 08, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I like the idea of the dongle.&nbsp; Definitely something to look into.&nbsp; My initial thought, however, is that this is an authentication tool to identify the user but that user still has to be 'mapped' to the roles and rights within the application.&nbsp; So, in that regard, it isn't really any different than integrated Windows authentication.&nbsp; In other words, we still need some way of indicating that user 'x' is in such-and-such role with these rights for our authorization rules to grant access.&nbsp; We already have an interface under development for RF ID badges and would assume that a security fob or dongle would follow the same suit as this.&nbsp; In that case we treat the user's information the same as we do with Windows (single-sign-on) authentication and consider the user authenticated but still have to determine what roles/rights that user has to the application.</div></BLOCKQUOTE><br><br>I was thinking along different lines with regards to the dongle idea.&nbsp; The security checks in my mind would be similar to:<br><br>public bool void CanLoad() {<br>&nbsp;&nbsp;&nbsp;&nbsp; IPrincipal prin;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; prin = ApplicationContext.User;<br><br>&nbsp;&nbsp;&nbsp;&nbsp; return prin.IsInRole( "Administrators" ) || Dongle.IsPresent;<br>}<br><br>So you wouldn't check just the roles of the user, you'd also check if there was this dongle present.&nbsp; The drawback to this method is that you'd have to remember to do this in every security check and make the change to all the existing code.&nbsp; <br><br>The advantage though is that you're not relying on an untrustable source to do your authenciation when things go wrong.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>BTW - we connect in a variety of ways depending on the type of access and connectivity available.&nbsp; Our preferred method is via Remote Desktop connection or other remoting tool, but that is rarely an option and&nbsp;more times than not, it requires someone be on site (because the first thing these guys do when budgets get tight is remove as much of the networking as they can without compromising the systems).&nbsp; Some of the network topologies we've had to endure are amazing!</div></BLOCKQUOTE></p><p></p>Hmm, the dongle approach may not work for you in this case.&nbsp; <br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I understand the idea of doing a system scan on startup or with a separate utility, but am trying to simplify this from a usage standpoint to a) eliminate as many phone calls as possible from customers; </div></BLOCKQUOTE></p><p>You could do that by raising support costs.&nbsp; <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" />&nbsp; Sorry, I don't have any serious advice in this regard.<br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>b) encapsulate the logic as much as possible; </div></BLOCKQUOTE></p><p>This is certainly good.&nbsp; Perhaps the best bet is to approach this as another use case.&nbsp; Build objects custom to handling these problems.&nbsp; Of course that doesn't help you if the problem is getting into the system.&nbsp; <img src="/emoticons/emotion-6.gif" alt="Sad [:(]" /><br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>and, c) reduce the work for my developers.&nbsp; Because these objects are built into our framework, a "recovery" utility would only be able to address framework-level components.&nbsp; We would either have to extend this utility for every application to add application-specific components or develop a second utility for each.&nbsp; </div></BLOCKQUOTE></p><p>One approach is to have a main program, that always performs common tasks, and than can load modules based on the system chosen to work with.&nbsp; These modules would be classes implementing an interface (could be as simple as an Execute method, and each class knows how to check for an fix a particular problem).&nbsp; <br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>Either way, we've just added to the development efforts required for each application.&nbsp; Plus, initiating the utility would require either&nbsp;service intervention or a walk-through with the customer on the phone. &nbsp;I'd rather have the "fail-safe" built in along with the objects so that all of this becomes transparent to my developers and users.</div></BLOCKQUOTE></p>Initial development time could be large; maintence hopefully much much lower as your tool matures.&nbsp; I'm curious though.. it sounds like you want to enable the users to fix things themselves.&nbsp; Assumnig they can get into the system, how will they know how to fix the problems?&nbsp; If this needs to be documented or explained by one of your people, could you not explain / document the tool instead?&nbsp; <br><br>At any rate, I hope I've thrown some ideas out there you may not have considered.. sorry I couldn't be of more help though.<br><br>I hope you'll keep us updated on your solution, if you don't mind.&nbsp; I'd be curious to know what you come up with.<br><br>Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
