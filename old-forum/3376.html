<html><header><title>Caching in asp.net</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Caching in asp.net</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3376.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Tuesday, August 14, 2007</h2>Hi all,<br><br>I started as a web developer, but haven't done asp.net development since about 03.&nbsp; I'm currently working on a new asp.net site, with .Net 2.0.&nbsp;&nbsp;&nbsp; <br><br>I have some NVLs that I want to cache site wide.&nbsp; The BL should make this transparent (so that if an admin changes the list it can be invalidated).&nbsp; In my WinForms app, I'm using the EntLib 2.0 Cache manager.&nbsp; <br><br>Should I continue to use this?&nbsp; Or should I use the Cache from the System.Web assembly?&nbsp; A third option that would be better for use in asp.net?&nbsp; One final thing; I only use the null backing source for the EntLib caching... any other configuration ideas for this would be welcome.<br><br>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, August 14, 2007</h2><P>One thing we did was implement a CacheManager, which gets its CacheProvider based on a configuration setting. We wrote a WebCacheProvider for use in Web applications, and you could equally write some WinCacheProvider or something more specific (EntLibCacheProvider, etc). Our WebCacheProvider uses the ASP.Net caching, of course. (CacheManager and CacheProvider are just classes we created and named, of course). </P>
<P>Just a suggestion&nbsp;as you don't <EM>have</EM> to use the same caching scheme if you don't want to. </P>
<P>Chris</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 14, 2007</h2>I wrote a similar wrapper for the EntLib caching I'm using.&nbsp; the nice thing about entlib is that you can change it via configuration settings.<br><br>It sounds like you use the asp.net caching.&nbsp; Is there any reason you didn't use the caching provided by EntLib?&nbsp; Just curious.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, August 14, 2007</h2><P>Andy,</P>
<P>A couple of things to consider.</P>
<P>1. Use the ASP.Net cache.</P>
<P>2. Only cache Read Only objects that are not changed by users. I cache NVLs all the time.<BR>I tried caching a read/write object and served up a clone from the cache but it is not a deep clone and many related BOs inside of it were "changed" and then put back in the cache so users were seeing data input by other users. Overall - a bad idea.</P>
<P>3. Depending on your technology stack you may be able to use SQL Server 2005 database cache invalidation through publish/subscribe.</P>
<P>4. If not, it is fairly straighforward to write your own database cache invalidation mechanism. There are many articles on the topic. I went with a polling solution instead of the "touch a file" solution. The trick is to set up a cache dependency object and then make your NVL in the cache related to it. When the DB is "changed" the dependency object is flushed from the cache (on the next poll interval) and it takes your NVL with it. </P>
<P>Any DB table that you want to track needs a small trigger attached to it that can call a SP to insert a row in a tracking table. The tracking table has 2 columns: tablename and changeid. The SP simply increments changeid for the tablename that was modified. The polling code just selects this tracking table and compares the stored changeid value to the current changeid value. If they are the same, the table has not been modified. If they are different, the table has been modified and the cache dependency object is removed from the cache taking your NVL with it.</P>
<P>Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 14, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div>1. Use the ASP.Net cache.</div></BLOCKQUOTE><br><br>Sounds like two recommendations for asp.net cache.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div>2. Only cache Read Only objects that are not changed by users. I cache NVLs all the time.<br>I tried caching a read/write object and served up a clone from the cache but it is not a deep clone and many related BOs inside of it were "changed" and then put back in the cache so users were seeing data input by other users. Overall - a bad idea.</div></BLOCKQUOTE></p><p>No, wasn't planning on caching any editable objects.<br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div>3. Depending on your technology stack you may be able to use SQL Server 2005 database cache invalidation through publish/subscribe.</div></BLOCKQUOTE></p><p>Thats one I had forgotten about.&nbsp; How have you integrated this with Csla (if you have)?&nbsp; I have a DAL which hides the db server specifics, so this might be a bit more challenging, but I'm sure I could figure something out.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div>4. If not, it is fairly straighforward to write your own database cache invalidation mechanism. There are many articles on the topic. I went with a polling solution instead of the "touch a file" solution. The trick is to set up a cache dependency object and then make your NVL in the cache related to it. When the DB is "changed" the dependency object is flushed from the cache (on the next poll interval) and it takes your NVL with it. </p>
<p>Any DB table that you want to track needs a small trigger attached to it that can call a SP to insert a row in a tracking table. The tracking table has 2 columns: tablename and changeid. The SP simply increments changeid for the tablename that was modified. The polling code just selects this tracking table and compares the stored changeid value to the current changeid value. If they are the same, the table has not been modified. If they are different, the table has been modified and the cache dependency object is removed from the cache taking your NVL with it.</div></BLOCKQUOTE><br></p>I'd rather not roll my own, and instead stick with proven solutions (System.Web.Caching or the EntLib Caching AB).<br><br>Thanks!<br>Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
