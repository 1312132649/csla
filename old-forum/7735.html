<html><header><title>Chicken vs. Egg problem with AddInstanceBusinessRules</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Chicken vs. Egg problem with AddInstanceBusinessRules</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7735.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Tuesday, October 06, 2009</h2>I haven't had a need for these until now, but I'm confused by the fact that BusinessBase() calls AddInstanceBusinessRules in its constructor. <br /><br />Since I don't think it is possible for the derived class to populate any properties or fields before the base class constructor is called, how can an override of AddInstanceBusinessRules() make a context-based decision as to what rules apply just to that instance.  Am I misunderstanding the intent of these?<br /><br />I've worked around it for now by moving the rule-adding code to a shared method that I manually call immediately after constructing the object with desired initial state and it seems to work, but this seems like a hack. Other than that, however, it seems to be providing the desired behavior. <br /><br />(The use case here is a tree-style display of 300 or so configuration or option values that are all basically identical except for their name and how they are validated. An alternative would be to derive a unique class for each option value just so it could have its own rule, but that seems like overkill)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, October 06, 2009</h2><P>I'll probably remove per-instance rules in 4.0. </P>
<P>They were <EM>the</EM> model in 2.0, but had serious perf/resource issues, which is why I added the per-type concepts. Andres lobbied me to remove per-instance at the time, and I think he was right, but I left them in for "backward compatibility".</P>
<P>They exist as they did in 2.0 though, and really don't address a valid scenario in my view. Clearly almost no one uses them, because if anyone did use them they'd run into the issues you describe - and this is the first complaint I've had in years :)</P>
<P>The right answer, imo, is to create per-type rules that are smart enough to be context-sensitive based on the state of the object. In other words, there's nothing you can do with per-instance rules that you can't do with a smarter per-type rule.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, October 06, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><P>They exist as they did in 2.0 though, and really don't address a valid scenario in my view. Clearly almost no one uses them, because if anyone did use them they'd run into the issues you describe - and this is the first complaint I've had in years :)</P><br /><P>The right answer, imo, is to create per-type rules that are smart enough to be context-sensitive based on the state of the object. In other words, there's nothing you can do with per-instance rules that you can't do with a smarter per-type rule.</P></div></BLOCKQUOTE><br /><br />I don't disagree -- this is the first time I thought I could use them and I was trying to do the "right" thing (which it turns out was wrong :)<br /><br />I could probably (for this use case) simply have a single per type rule that calls a delegate exposed by the object that uses the same signature and achieve the equivalent to what I get now (serialization issues with delegates aside).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Wednesday, October 07, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>
<P>I'll probably remove per-instance rules in 4.0. </P>
<P></div></BLOCKQUOTE></P>
<P><STRONG><FONT size=5>Nooooooo!</FONT></STRONG></P>
<P>Please don't remove them.&nbsp; They may now be edge cases, but they still can serve a purpose.&nbsp; I have a dynamic system where the users create data collection flows.&nbsp; They can add data collection points, number of samples, datatype, etcetera&nbsp;and can set up rules (depending on the actual datatype) such as min/minlength, max/maxlength, and so on.&nbsp; </P>
<P>When the sample business object is instantiated for actual data entry, I use the database stored rule metadata to create and add the instance&nbsp;rules to the business objects.&nbsp; It works great but I do not think that I could do the same thing with the static rules alone.&nbsp; The individual business objects for a 'sample' are the same, but may have different rules in effect based not only on the datatype, but also by&nbsp;the specific type of the item you are collecting data on&nbsp;(hierarchical rules), and they type of measurement.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 07, 2009</h2>How do you get around the chicken-and-egg problem in your implementation?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, October 07, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>How do you get around the chicken-and-egg problem in your implementation?</div></BLOCKQUOTE><br /><br />It'a flawed, but essentially I just exposed my AddInstanceBusinessRules method via a helper function that I call just once after I instantiate the object. <br /><br />If only there was some way for CSLA to defer the call until sometime after the constructor was called, I would never have had an issue. <br /><br />In my case, the actual AddInstanceBusinessRules method is looking for a particular property and is a NOP otherwise, and since I can't set it in the constructor before CSLA calls the method, the CSLA call does nothing. <br /><br />I'll vote with Fintanv that these may indeed have a niche. They are working out quite well in this one case when I need them.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 07, 2009</h2><P>I could move the call to Initialize(), or not do it at all - leaving it to you to do the call if you care (which most people wouldn't).</P>
<P>Either one would be a breaking change for anyone using this niche feature (probably just you two :) ), so may not be worth doing.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, October 07, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><P>I could move the call to Initialize(), or not do it at all - leaving it to you to do the call if you care (which most people wouldn't).</P><br /><P>Either one would be a breaking change for anyone using this niche feature (probably just you two :) ), so may not be worth doing.</P></div></BLOCKQUOTE><br /><br />Ouch!  :) <br /><br />Actually, I just looked in the 3.5 code and Initialize() is still called in the BusinessBase constructor. So, that wouldn't be a substantive change. <br /><br />Perhaps in DataPortal_Create()? This does the first call to ValidationRules.CheckRules() anyway.<br /><br />A possible non-breaking change would be to expose _instanceRules (or at least the Count) via a protected property. Then derived classes could implement deferred creation of the rules as necessary.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, October 08, 2009</h2>The only real solution is probably for CSLA to stop calling the method at<br />all, and for you to call it when you are ready.<br /><br />You'd need to call it after you've initialized your object in<br />DataPortal_Create and _Fetch, and also in OnDeserialized().<br /><br />That'd allow you to get your object state the way you want it before loading<br />appropriate rules.<br /><br />Very much a breaking change though...</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Thursday, October 08, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>How do you get around the chicken-and-egg problem in your implementation?</div></BLOCKQUOTE></P>
<P>I ignore it! ;-)</P>
<P>I add the rules later in the process.</P>
<P>The rules are added to child objects that are nested down a couple of levels in my object hierarchy.&nbsp; As the child is added to its parent collection I query a read-only collection of rule metadata for the sub-set that match the childs criteria.&nbsp; I then iterate over that subset and attach the rule using a helper method.&nbsp; (IValidation just exposes the Csla.Validation.ValidationRules for the object).</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#000000 size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void AddDynamicRule(IValidation item, Csla.Core.IPropertyInfo property, Validation.ItemDetailRuleInfo rule)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string method = string.Format("Add{0}Rule", rule.RuleType.ToString()); // rule type is 'Min', 'Max', 'MaxLength', 'MinLength', 'In', 'Regex' etc.</FONT></FONT></P>
<P><FONT color=#0000ff size=2><FONT color=#000000 size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodInfo mi = typeof(MyApp.Library.Validation.CommonRules).GetMethod(method, BindingFlags.NonPublic | BindingFlags.Static);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mi != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mi.IsGenericMethod)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mi.MakeGenericMethod(rule.Datatype).Invoke(null, new object[] { item, property, rule });<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mi.Invoke(null, new object[] { item, property, rule });<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></FONT></P>
<P>&nbsp;</P>
<P>If a property affecting the rule choice is changed, then I can clear out the rules, and re-add them.&nbsp; The clearing of the rules is carried out by a method that gets down and dirty with reflection:</P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void ClearInstanceRules(this Csla.Validation.ValidationRules item)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get the rule manager<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodInfo mi = item.GetType().GetMethod("GetInstanceRules", BindingFlags.Instance | BindingFlags.NonPublic);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ruleManager = mi.Invoke(item, new object[] { true });</FONT></P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // clear the instance rules<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyInfo pi = ruleManager.GetType().GetProperty("RulesDictionary", BindingFlags.Instance | BindingFlags.NonPublic);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dictionary = pi.GetValue(ruleManager, null);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MethodInfo dmi = dictionary.GetType().GetMethod("Clear", BindingFlags.Instance | BindingFlags.Public);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dmi.Invoke(dictionary, null);</FONT></P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get the broken rules variable and re-set it to null<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FieldInfo fi = item.GetType().GetField("_rulesToCheck", BindingFlags.NonPublic | BindingFlags.Instance);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi.SetValue(item, null);</FONT></P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get the broken rules variable and re-set it to null<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi = item.GetType().GetField("_brokenRules", BindingFlags.NonPublic | BindingFlags.Instance);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fi.SetValue(item, null);</FONT></P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // recheck the remaining (per-type) rules<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.CheckRules();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT><FONT size=2></P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, October 08, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Fintanv:</strong></div><div>...If a property affecting the rule choice is changed, then I can clear out the rules, and re-add them...</div></BLOCKQUOTE><br /><br />In my case, the set of instance rules desired is known at the time the object is constructed via information passed to the constructor, which seemed simple enough, other than AddInstanceBusinessRules being called before this information is available.<br /><br />(Kudos to you for figuring out how to implement dynamic instance rules...)<br /><br /></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
