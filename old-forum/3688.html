<html><header><title>OO Design Confusion</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OO Design Confusion</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3688.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>monsi posted on Thursday, October 11, 2007</h2>Hi all,<br><br>I'm just starting converting/improving a program I wrote a few years ago in vb6 to csla using proper OO design but there are a couple of areas that I'm not sure about.<br><br>The application is a simple mrp like system for our company, and the section I'm struggling with is implementing a partlist for a product. A product is made up of many parts, but these parts are comprised of brought in components, machined components, and sub assemblies (which have there own parts list) my idea is to have a editable root part which is then subtyped into brought out components, machined components and sub-assemblies.<br><br>Does this sound like the correct way to go? This is my first large OO design and I want to make sure its right.<br><br>Thanks<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Thursday, October 11, 2007</h2>The most important question that you want to work through is what the application needs to do with this data.&nbsp; It is likely that there will be several different uses of the data.&nbsp; It may well be that each separate use of the data will needed a separate "view" of the data.&nbsp; Let me take two very different views of the data.<br><br>First, there is the obvious, given thing X, what other things do I need to create an instance of thing X.&nbsp; You could build the entire hierarchy or you could simply build a flattened list of the piece parts.&nbsp; If it were important for the particular use case to know how things "nested within" other things, the hierarchy is the way to go.&nbsp; If all you are interested in is ordering the parts or picking them from inventory, the flattened list would be the way to go.&nbsp; Note that you might have both use cases; in that case you might end up building two separate sets of objects to support the two use cases.<br><br>Second, given thing Y, give me a list of the other things that use thing Y.&nbsp; Again, I could build a hierarchically oriented list showing the relationships: thing Q uses thing R that uses thing S that uses thing X.&nbsp; Or I could simply create a list of the other things without regard to the "distance" from thing X.&nbsp; <br><br>It is possible that you might be able to share the same classes in each of these situations, but you should not assume that you can.&nbsp; The data values that you need to store for each "thing" in each of these situations is almost certainly going to be different.&nbsp; You do not want to create a single Thing class that gets used in all of the situations.&nbsp; For example, the database row for each thing might have a number of columns that contain detailed specifications for the thing or even an embedded image of the thing.&nbsp; You probably would not want to read thespecifications or the image data in to generate a simple warehouse pick-list of things needed to build a thing.<br><br>The really big "ah ha" moment is when you realize that the structure of the data on the database and the structure of the data in objects need not be the same.&nbsp; <br><br>Jon<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jeff replied on Thursday, October 11, 2007</h2><P>Check out this thread <A HREF="/forums/thread/11923.aspx">http://forums.lhotka.net/forums/thread/11923.aspx</A></P>
<P>IMO, avoid these types of heirarchies if you can, especially in a business model. For it to be worth the trouble and to come out clean there would need to be a decent amount of truly common behavior which is rarely the case in a business model in my experience. Especially with a low number of preknown types. Just have them implement a common interface if&nbsp;you need &nbsp;to deal with them generically. Otherwise you'll spend more time designing and refining the inheritance chain when you could have just made the 3 classes and an interface and gotten back to work.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>monsi replied on Friday, October 12, 2007</h2>Hi thanks for your replys,<br><br>After having a read through the post you linked to does this sound like a better solution<br><br>3 root objects (Brought in Component, Machined Component, and Finished Item) which all have the interface IPart<br><br>IPart will expose part number, revision, etc and also a collection of IPart objects<br><br>So..<br><br>Finished Item (Root) -&gt; IParts Collection&nbsp; -&gt; Brought In Component<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp; -&gt; Machined Component<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp; -&gt; Machined Component<br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
