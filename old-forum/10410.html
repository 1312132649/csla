<html><header><title>Using CSLA 4 and Lazy Loading</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Using CSLA 4 and Lazy Loading</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10410.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>correodemarques posted on Thursday, June 02, 2011</h2><p>I&#39;m looking at the example of Lazy Loading on &quot;Using CSLA 4 Creating Business Objects&quot; ebook, bottom of page 27. And I have two questions:</p>
<p>1-The code shown there for the AddressListCreator class does not get any parent key. How the child collection is going to know which children to load?</p>
<p>2-The code in the method DataPortal_Fetch (in AddressListCreator) is just this line:</p>
<p>Result = DataPortal.CreateChild&lt;AddressEditList&gt;();</p>
<p>What if the calling code (the parent object) is trying to retrieve an already existent collection of children? Should not this code call DataPortal.FetchChild instead?</p>
<p>Sure you can always go to the database, even from DataPortal_Create, and see if you can find any child object for the calling parent, but when the parent is new, that&#39;s one trip to the database for nothing.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>correodemarques replied on Thursday, June 02, 2011</h2><p>Finally I did something, but I would like to know if it&#39;s the right approach:</p>
<p>In the parent class (the class name is Contact)</p>
<p>&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;WebAddressList&gt; WebAddressesProperty = RegisterProperty&lt;WebAddressList&gt;(p =&gt; p.WebAddresses, RelationshipTypes.Child | RelationshipTypes.LazyLoad);<br />&nbsp;&nbsp;&nbsp; public WebAddressList WebAddresses<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!FieldManager.FieldExists(WebAddressesProperty)) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var creator = WebAddressListCreator.GetWebAddressListCreator(this); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebAddresses = creator.Result; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetProperty(WebAddressesProperty); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(WebAddressesProperty, value); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnPropertyChanged(WebAddressesProperty); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p>And the Creator class:</p>
<p>using System;<br />using Csla;<br /><br />namespace ContactInformation.Library.Contact<br />{<br />&nbsp; [Serializable]<br />&nbsp; public class WebAddressListCreator : ReadOnlyBase&lt;WebAddressListCreator&gt;<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; #region Result<br /><br />&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;WebAddressList&gt; ResultProperty = RegisterProperty&lt;WebAddressList&gt;(c =&gt; c.Result);<br />&nbsp;&nbsp;&nbsp; public WebAddressList Result<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return ReadProperty(ResultProperty); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set { LoadProperty(ResultProperty, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; #endregion<br /><br />&nbsp;&nbsp;&nbsp; public static void GetWebAddressListCreator(Contact contact, EventHandler&lt;DataPortalResult&lt;WebAddressListCreator&gt;&gt; callback)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (contact.IsNew)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataPortal.BeginCreate&lt;WebAddressListCreator&gt;(callback);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataPortal.BeginFetch&lt;WebAddressListCreator&gt;(contact.Id, callback);<br />&nbsp;&nbsp;&nbsp; }<br /><br />#if !SILVERLIGHT<br />&nbsp;&nbsp;&nbsp; public static WebAddressListCreator GetWebAddressListCreator(Contact contact)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (contact.IsNew)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Create&lt;WebAddressListCreator&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Fetch&lt;WebAddressListCreator&gt;(contact.Id);<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private void DataPortal_Create()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result = DataPortal.CreateChild&lt;WebAddressList&gt;();<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private void DataPortal_Fetch(Guid contactId)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result = DataPortal.FetchChild&lt;WebAddressList&gt;(contactId);<br />&nbsp;&nbsp;&nbsp; }<br />#endif<br />&nbsp; }<br />}</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, June 02, 2011</h2><p>Yes, your creator command object can (and should) call FetchChild to retrieve an existing child if that&#39;s what your scenario requires.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
