<html><header><title>An SL MvvM Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>An SL MvvM Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9422.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav posted on Monday, August 23, 2010</h2><p>I would like to permit the enduser to periodically Save her work and then continue working with the same object graph.&nbsp; I do know that the Save method returns the new Object Graph.&nbsp; I use SL navigation to allow access to different parts of the object graph, with each navigable UI unit serviced by a viewmodel. And everything works great - until the Save is clicked, that is.&nbsp;&nbsp;I have to make sure that all UI units at that point receive the Model(s) in the newly returned object graph.</p>
<p>My question is relatively simple.&nbsp; Is it enough to simply reset the viewmodel&#39;s Model property to the new object, or is there a ritual of removal of the previous Model that I have to go through first.&nbsp; The reason I ask is because I recall seeing a Remove method in a viewmodel in one of the demo projects, although I am thinking that there the Model object was being removed from its parent in the object graph, and not from the viewmodel (I can&#39;t locate it now)</p>
<p>Jav</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, August 23, 2010</h2><p>Generally speaking, if you set the Model property everything else updates automatically based on data binding.</p>
<p>The one thing I can think of right offhand though, is to watch out for the ManageObjectLifetime setting, because you could encounter some odd n-level undo issues if that&#39;s true (the default) and you have multiple viewmodel objects using the same object graph.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Monday, August 23, 2010</h2><p>The only object in my object graph with a&nbsp; ManageObjectLifetime setting of True is the Root object, everything else is set to false.</p>
<p>Initially I would set the Root object to the NewObject.&nbsp; With that, I found that the Model property of the viewmodel servicing the&nbsp;part of the object graph currently being worked on in&nbsp;the navigation frame when Save button is clicked, remained attached to the old object(s) - I could tell because any further modification in that Model had no effect on the Save button (it remained disabled).&nbsp; If I navigated to a different part of object graph, things worked as expected.&nbsp; I am pretty sure that the Models of those viewmdoels were properly swiched to new (I am going to have to check it again just to be sure&nbsp;- on second thought)&nbsp; They did behave correctly - that&#39;s for certain, but it may be the act of navigation to them that refreshed their Models.</p>
<p>The Objects that were being worked on when Save was pressed, also became normal if I navigated away and then navigated back.</p>
<p>Now what I am doing is this.&nbsp; All my UI units have NavigationCacheMode=&quot;Required&quot;.&nbsp; I cannot keep recreating them every time the user navigates to and fro.&nbsp; originally I was setting the Model property right after the InitializeComponent statement.&nbsp; This was probably the part of my problem, or so I thoght.&nbsp; Now I set up everything else&nbsp;as before in the Page&#39;s Contructor, but I set the Model property of the viemodel in the OnNavigatedTo() event.&nbsp; It has fixed every other problem but with an issue and a concern.&nbsp; The concern (or question):&nbsp;&nbsp;Is all this repeated setting of the Model property of the viewmodel <em><strong>while the UI unit (page) is cached</strong></em> an inocuous thing or does it have a downside.&nbsp; And the issue is: I still have to navigate out and then back in - in other words I am back to square one.&nbsp; I can always send the user to a page that says &quot;Congratulations - you have won a toaster - Now click this&quot;, and thus force her to navigate back !!&nbsp; There&#39;s that!</p>
<p>Jav</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 23, 2010</h2><p>I suppose your other option is to maintain relationships between the various viewmodel objects. I always think about viewmodels as have parent-child relationships that mirror the relationships of the model objects they reference. So if you change a parent model instance, all the child viewmodels need to also update their references too.</p>
<p>I think about viewmodels as existing in their own layer.</p>
<p>In a layered architecture, objects within a layer can interact freely (as a general rule). And objects from the next higher layer can interact as well - so the view can interact with the viewmodel, but not the other way around. Similarly, the viewmodel can interact with the model, but not the other way around. (the exception here being upward interactions via events or data binding interfaces)</p>
<p>Given that way of thinking, it is very acceptable for viewmodel objects to have parent-child relationships. And if that&#39;s true, when the Model property of a parent is changed, the child viewmodel can change itself too (perhaps because it is handling the parent&#39;s PropertyChanged event to be notified when the parent&#39;s Model property changes).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Monday, August 23, 2010</h2><p>All my viewmodels are subclassed from my <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyViewModel&lt;T&gt; : Csla.Xaml.ViewModel&lt;T&gt;<br />which has an override:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void OnModelChanged(T oldValue, T newValue)</p>
<p>This&nbsp;code was graciously provided by Jaan a few weeks back.&nbsp; I tried messing with that but didn&#39;t get anywhere - I&#39;m kind&#39;a dunse when it comes to these - OnThis and OnThat&nbsp;(Geez - I didn&#39;t have to admit that!) so probably I wasn&#39;t doing it right.</p>
<p>How about&nbsp;creating a List property in the Root ViewModel in which each child viewmodel can register when it is set up.&nbsp; Then the root VM can cycle through the list and tell each child to reset its Model?</p>
<p>Jav</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 23, 2010</h2><p>It seems like that would work.</p>
<p>I usually reverse that, and only allow child viewmodel objects to be created by the parent. In other words, the only way to get a child viewmodel is to ask the parent viewmodel for the child.</p>
<p>That way the parent can always provide a reference to itself to the child as the child is created. The child can then just set up an event handler for PropertyChanged, and in that event handler it can watch to see when the &quot;Model&quot; property changes. When that happens, the child knows it must set its own Model property to a value based on its parent&#39;s Model property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 23, 2010</h2><p>Something like this (off the top of my head):</p>
<p>public class ParentVm : ViewModel&lt;Parent&gt;<br />{<br />&nbsp; private ChildVm _child;<br /><br />&nbsp; public ChildVm GetChildVm()<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; if (_child == null)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _child = new ChildVm(this);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return _child;<br />&nbsp; }<br />}<br /><br />public class ChildVm : ViewModel&lt;Child&gt;<br />{<br />&nbsp; private ParentVm _parent;<br /><br />&nbsp; internal ChildVm(ParentVm parent)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; _parent = parent;<br />&nbsp;&nbsp;&nbsp; _parent.PropertyChanged += (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.PropertyName == &quot;Model&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetModel(_parent.Model);<br />&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp; SetModel(_parent.Model);<br />&nbsp; }<br /><br />&nbsp; private void SetModel(Parent parentModel)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; Model = parentModel.Child;<br />&nbsp; }<br />}</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Monday, August 23, 2010</h2><p>Fantastic.&nbsp; That sounds like a better way to do it. Thank you.&nbsp; Now I have something to work with.</p>
<p>Jav</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Tuesday, August 24, 2010</h2><p>In my RootViewModel I am doing this:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private ViewModels.SubjectViewModel subjectVM;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void OnRefreshed()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnRefreshed();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subjectVM = new SubjectViewModel(this);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>The childViewModel has the following code.</p>
<p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EncounterViewModel parentVM;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public SubjectViewModel(EncounterViewModel parent) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ManageObjectLifetime = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentVM = parent;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parentVM.PropertyChanged += (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.PropertyName == &quot;Model&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetModel(parentVM.Model);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetModel(parentVM.Model);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void SetModel(Encounter parent)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Model = parent.subject;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>I place a breakpoint&nbsp;at &nbsp;if (e.PropertyName == &quot;Model&quot;) and&nbsp; modify the child as well as the root data.&nbsp; When I save, I do get a number of breaks on&nbsp;(IsBusy, CanSave, CanFetch&nbsp;etc), but Model isn&#39;t one of them.</p>
<p>Jav</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Tuesday, August 24, 2010</h2><p>Additional Info:</p>
<p>In MyViewModel, from which all other of my viewmodels are subclassed, I added the following line at the end of</p>
<p>protected override void OnModelChanged(T oldValue, T newValue)<br />{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnPropertyChanged(&quot;Model&quot;);<br />}</p>
<p>Now I see a break with PropertyName = &quot;Model&quot;, and my Save button becomes Enabled when I make another change to my data, like clicking a checkbox.</p>
<p>Jav</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, August 24, 2010</h2><p>That is strange. Model is a dependency property, so PropertyChanged should be raised automatically by the DependencyObject base class...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Tuesday, August 24, 2010</h2><p>I don&#39;t know!&nbsp; The answer to that is above my pay grade. <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p>
<p>I have now implemented the same exact code in all of the current UI units, and they are all working as expected.&nbsp; Thanks for your help.<br />Oh, I did try subclassing directly from Csla.ViewModel thinking that MyViewModel may be causing a problem but the results were the same.&nbsp;</p>
<p>Jav</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
