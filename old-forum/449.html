<html><header><title>Suggested transactions enhancement for CSLA.NET</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Suggested transactions enhancement for CSLA.NET</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/449.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane posted on Thursday, June 22, 2006</h2>I have a suggestion for an enhancement to how TransactionScope transactions are used. Before I provide the solution, let me explain what drove me to make these changes.<br><br>I have been writing integration tests with NUnit. All&nbsp; my work had been done with a local data portal and database. Our customers are going to have a remote data portal and database, so I decided I should set up that configuration and make sure our tests all run. Our customers are already using VB6-based components through COM+, so I decided to set up the data portal using the EnterpriseServicesProxy and EnterpriseServicesHost.<br><br>When I ran my tests, some of them worked, but most of them failed.&nbsp;<img src="/emoticons/emotion-6.gif" alt="Sad [:(]" /> It turned out there were three general reasons my tests were failing: bad test code, bad business code, and database transaction issues.<br><br>The bad test code was usually due to using old references after a Save. This works with a local data portal, but not a remote one. The bad business code was usually caused by setting shared data in the DataPortal_Xxx methods and then trying to use it on the client. These were relatively easy to fix.<br><br>However, a lot of my tests were erroring with the same error: A distributed transaction timed out. This turned out to be because  of how I have configured my testing environment. I want my tests to have no residual effect on the database data, so I have a test fixture in NUnit that looks like this:<br><br>Public MustInherit Class TransactionFixture<br>&nbsp;&nbsp;&nbsp; Private tx As CommittableTransaction<br><br>&nbsp;&nbsp;&nbsp; &lt;SetUp()&gt; _<br>&nbsp;&nbsp;&nbsp; Public Sub Setup()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx = New CommittableTransaction(New TimeSpan(0, 5, 0))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Make the transaction the ambient transaction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ADO.NET and COM+ will automatically participate with this ambient transaction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transaction.Current = tx<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Log in to gain access to the database.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BusinessPrincipal.Login( _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; My.Settings.Item("TestUserID").ToString, _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; My.Settings.Item("TestPW").ToString)<br>&nbsp;&nbsp;&nbsp; End Sub<br><br>&nbsp;&nbsp;&nbsp; &lt;TearDown()&gt; _<br>&nbsp;&nbsp;&nbsp; Public Sub TearDown()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tx.Rollback()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transaction.Current = Nothing<br>&nbsp;&nbsp;&nbsp; End Sub<br>End Class<br><br>My unit tests inherit from this transaction fixture. A typical test follows these general steps:<br><ul><li>Insert data into the database</li><li>Manipulate business object</li><li>Make assertions</li></ul><br>Because the transaction is rolled back at the end of each test, all data manipulation, whether through the test or through the business objects, is rolled back, leaving a consistent database state between tests.<br><br>These are the tests that timed out when I changed to the remote data portal. The insert data statement&nbsp; runs in a transaction (serializable by default) which is active throughout the test. The problem was that the business object would attempt to read the data that had just been inserted, but the business object was not participating in the transaction, so it couldn't read the data. <br><br>I needed a way for the server side to participate in the same transaction on the client. In theory, Transaction objects can escalate to distributed transactions, including transactions that happen on different machines. How do I share the transaction?<br><br>My solution is to pass the "ambient" transaction through the data portal. Since the framework already passes culture information automatically, couldn't it also pass the transaction? The transaction is serializable, so this was easy to do with a few lines of code in the Server.DataPortalContext and Server.DataPortal.<br><br>In Server.DataPortalContext<br><ul><li>Add a private variable: Private mAmbientTransaction As Transactions.Transaction</li><li>Add a read-only property, "AmbientTransaction"</li><li>Set mAmbientTransaction in the constructor. I put the code right after the set of mGlobalContext. These variables are only set when the portal is remote.</li></ul><br>In Server.DataPortal, I added the following code in SetContext:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Use the transaction from the client, if one is in effect.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not IsNothing(context.AmbientTransaction) Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transactions.Transaction.Current = context.AmbientTransaction<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br><br>I don't automatically set the current transaction on the server because there might already be an ambient transaction in effect on the server's thread. I wouldn't want to reset it to nothing if the client didn't have an active transaction. However, if the client has an active transaction, that trumps all other transactions.<br><br>Just a few lines of code, and my tests are working through the remote data portal. It was such an easy change, and I'm not sure that it has any negative impact. Perhaps somebody has already tried something like this and can alert me to any potential issues.<br><br>Could this be a candiate for inclusion in a future update of the framework?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, June 22, 2006</h2>Since this is a testing issue, and not actually something with the Csla framework itself, I don't think this would be a good enhancement.<br><br>Instead of doing your tests in a transaction so thaty ou don't leave the DB in an intermediate state, just write a clean up stored procedure which clears all the tables and inserts any dat which must always be present.<br><br>This will have the other advantage of being faster tahn using distributed transactions.<br><br>As a side note, I wouldn't go the route of continuing to use Enterprise services just because their old VB6 framework did; this will also have a negative peformance impact.&nbsp; I'd stick to either manual transactions or transaction scope if your database is Sql Server 2005.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Thursday, June 22, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Since this is a testing issue, and not actually something with the Csla framework itself, I don't think this would be a good enhancement.</div></BLOCKQUOTE><br><br>I think this can be applied in more than testing scenarios. I think integration projects could be helped by this enhancement. Suppose I have CSLA objects that are utilized by other existing systems in an enterprise. One of the requirements might be that that CSLA object has to participate in a distributed transaction.<br><br>This can be solved by implementing the passing of the transaction within the business object instead of the framework. However, wouldn't it be nicer if the framework handled it automatically?<br><br>Enhancements generally need to be evaluated against two major criteria. Does it break existing code? Does it affect performance? For the change I have made, the answer is no.<br><br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Instead of doing your tests in a transaction so that you don't leave the DB in an intermediate state, just write a clean up stored procedure which clears all the tables and inserts any dat which must always be present.</div></BLOCKQUOTE><br><br>I considered this. Many of our tests generate a lot of data. Cleanup scripts are not a trivial task. If I could be convinced that the performance improvement is enough to justify the extra time spent writing cleanup code, I would do it that way.<br><br><BLOCKQUOTE><div>As a side note, I wouldn't go the route of continuing to use Enterprise services just because their old VB6 framework did; this will also have a negative peformance impact.&nbsp; I'd stick to either manual transactions or transaction scope if your database is Sql Server 2005.</div></BLOCKQUOTE><br><br>Well, my CSLA objects <b>must</b> integrate with the VB6-based objects. It's part of a long-term migration project. The .NET-based objects have to integrate with the COM-based objects, and vice versa. We also have to support SQL 2000, as 95% of our customers are using that version and we can't force them to upgrade yet. <img src="/emoticons/emotion-6.gif" alt="Sad [:(]" /><br><br>I wish that I could be working with a clean slate, instead of with legacy integration requirements. I would be doing a lot of things very differently!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, June 22, 2006</h2>We have set up all of our CSLA 2.0 tests to run through a single command object.&nbsp; The command object's data access method is marked with [Transactional(TransactionScope)] (or whatever it is, don't have access to the code right now).&nbsp; The command object also takes a method as its criteria.&nbsp; Inside the data access method, the method is invoked and then a DtcRollbackException is thrown.&nbsp; A test is made up of two methods:<br><br>[Test]<br>public void TestMethod()<br>{<br>&nbsp;&nbsp;&nbsp; // Run the test through the command object<br>&nbsp;&nbsp;&nbsp; TestCommand.RunTest(TestMethodCore);<br>}<br><br>private void TestMethodCore()<br>{<br>&nbsp;&nbsp;&nbsp; // Add, update, fetch and delete objects here<br>}<br><br>I do not know if this would work for your situation, but it has worked well for us. All our objects manipulate their data within a single transaction.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Thursday, June 22, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Brian Criswell:</strong></div><div>We have set up all of our CSLA 2.0 tests to run through a single command object.</div></BLOCKQUOTE><br><br>This is a very interesting idea. I will be exploring this a little bit. It does mean that I'd have to rewrite all our data-access tests (over 4000 of them), but that project could be assigned to a summer intern. <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><br> <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Thursday, June 22, 2006</h2><P>Brian,</P>
<P>This is very interesting, would you mind share us&nbsp;how you do this.&nbsp; Does it means your test classes leave in the same project as your library classes or you have nunit project being reference by your library project?</P>
<P>Some code would be very helpfull, Thanks.</P>
<P>Ricky</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, June 22, 2006</h2>The NUnit tests are in their own library which references the business object library.<br><br>I would have to get permission to post code, but it the command object looks something like this (doing this from memory now, so don't blame me if it does not compile ;) ) :<br><br>internal TestCommand : CommandBase<br>{<br>&nbsp;&nbsp;&nbsp; private CommandBase()<br>&nbsp;&nbsp;&nbsp; {}<br><br>&nbsp;&nbsp;&nbsp; // Define RollbackDtcException<br><br>&nbsp;&nbsp;&nbsp; // Define delegate<br><br>&nbsp;&nbsp;&nbsp; // Define criteria<br><br>&nbsp;&nbsp;&nbsp; internal static RunTest(TestHandler testMethod)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  try<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  DataPortal.Execute(new Criteria(testMethod));<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  catch (RollbackDtcException ex)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  {}<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; [Transactional(TransactionScope)]<br>&nbsp;&nbsp;&nbsp; private DataPortal_Execute(Criteria criteria)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  criteria.TestMethod.Invoke();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  throw new RollbackDtcException();<br>&nbsp;&nbsp;&nbsp; }<br>}<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Friday, June 23, 2006</h2><P>Brian,</P>
<P>Thanks for the insight, I came out with something like the following:</P><PRE>using System;
using System.Collections.Generic;
using System.Text;
using System.Transactions;
using Csla;
using Csla.Data;

namespace CslaTest
{
    internal class TestCommand : Csla.CommandBase 
    {
        private TestCommand(TestHandler testMethod) 
        {
            TestMethod = testMethod;
        }
        public delegate void TestHandler();
        private TestHandler TestMethod;

        public static void RunTest(TestHandler method)
        {
            try
            {
                DataPortal.Execute(new TestCommand(method));
            }
            catch (Csla.DataPortalException ex)
            { 
                if (!(ex.BusinessException is RollbackDtcException)) 
                    throw; 
            }
        }
        [Transactional(TransactionalTypes.TransactionScope)]
        protected override void DataPortal_Execute()
        {
            TestMethod.Invoke();
            throw new RollbackDtcException();
        }

        private class RollbackDtcException : ApplicationException { }
    }
}
</PRE>I didn't get a chance to test this using remoting, but it works without remoting using the following test: <PRE>using System;
using System.Collections.Generic;
using System.Text;
using NUnit.Framework;
using CslaTest.CslaObjects;

namespace CslaTest
{
    [TestFixture]
    public class SingleTestReadOnly
    {
        [Test]
        public void TestReadOnlyList()
        {
            TestCommand.RunTest(new TestCommand.TestHandler(TestReadOnlyListCore));
        }
        private void TestReadOnlyListCore()
        {
            ReadOnlyRootList list = ReadOnlyRootList.GetReadOnlyRootList();
            foreach (ReadOnlyChild item in list)
            {
                Console.WriteLine(string.Format("{0} {1}", item.SupplierID, item.ContactName));
            }
        }

        [Test]
        public void TestReadOnlyRoot()
        {
            TestCommand.RunTest(TestReadOnlyRootCore);
        }
        private void TestReadOnlyRootCore()
        {
            ReadOnlyRoot root = ReadOnlyRoot.GetReadOnlyRoot(1);
            Console.WriteLine("Supplier={0} {1}:{2}", root.SupplierID, root.CompanyName, root.ContactName);
            foreach (ReadOnlyChildItem item in root.ReadOnlyChildList)
            {
                Console.WriteLine("- Product={0} {1}", item.ProductID, item.ProductName);
            }
        }

    }
}
</PRE>
<P>Let me know if this is what you described.</P>
<P>Once again thanks for sharing.</P>
<P>Ricky.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Monday, June 26, 2006</h2>That is pretty much it.&nbsp; Did you ever get a chance to try it with remoting?&nbsp; I have never gotten around to setting up remoting.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Monday, June 26, 2006</h2><P>Brian,</P>
<P>Thanks for confirming.&nbsp; I haven't got a chance to try this with remoting but I think it would not work. If I think about it, we really passing a pointer to a test method which reside locally.</P>
<P>Ricky</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Tuesday, June 27, 2006</h2>Okay, what if we used a MethodInfo object or passed a string and used CallByName instead of the delegate?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 26, 2006</h2><P>Yes, the problem with this entire discussion is that it assumes a 2-tier physical model. It isn't realistic to start a transaction outside the data portal in a 3-tier physical scenario.</P>
<P>My suggestion, if you want to have repeatable, testable, transactional data access, is to put the data access into a formal data access layer. You can then write unit tests for the DAL to test it. You could then also write a mock DAL if that's your thing, and use that to test the objects themselves.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Wednesday, June 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><p>Yes, the problem with this entire discussion is that it assumes a 2-tier physical model. It isn't realistic to start a transaction outside the data portal in a 3-tier physical scenario.</p></div></BLOCKQUOTE><br><br>If by a 3-tier physical scenario, you mean having three machines, but still using ADO.NET within the DataPortal_Xxx methods, I have tested this scenario and it works just fine. ADO.NET code automatically enlists in the thread's transaction on the application server, if it has been set. When you use an implicit TransactionScope, it automatically sets the thread's current transaction.<br><br>I'm afraid that the unit testing scenario is clouding the original intent of my post. What negatives are there to including the thread's current transaction in the data portal context and setting it on the server thread? The serialized data is not significantly increased. If the client has no transaction on the thread, there is no performance penalty. You won't be creating a distributed transaction unless the client passes the transaction. The client shouldn't be starting a transaction unless there is activity that needs to be synchronized.<br><br>Not passing the transaction can also break CSLA-based apps when they are reconfigured from using a local data portal to a remote data portal. Suppose I have an object graph that involves data from two databases. The root object uses a local database, but a command object uses a remote database for logging activity during the update of the root object. The root object has the ForceLocal attribute applied, but the child object does not have this attribute. Both objects have the attribute to use system transactions.<br><br>With a local portal, everything appears to be working great. If you generate a database error on the client or the server, neither database is updated.<br><br>When you switch to the remote data portal, you start getting reports that a bug in the code is causing an error when saving. The object is not updated in the local database, but the command object appeared to successfully log the activity.<br><br>With the local data portal, the command object was running on the same thread as the root object, and the ADO.NET code automtically enlisted with the transaction that was initiated by the root object's data portal. When the logging data portal was configured to be remote, the transaction was not carried through. The command object successfully updated the database because it was unaware of the transaction on the client.<br><br>In CSLA.NET 1.x, the common practice was to explicity pass a SQLTransaction to synchronize database activity across objects. With TransactionScope, the project tracker doesn't include any transactions in parameters. It relies on the TransactionScope and ADO.NET magically working toghether. My suggestion extends this "magic" through the data portal (and across threads), if needed.<br><br>I could resolve the issue described above by explicitly including the transaction as a parameter in the factory method of the logging command object. Does it not make sense to bake it in, and keep the technical details hidden as much as possible from the business developer?<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
