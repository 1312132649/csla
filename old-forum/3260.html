<html><header><title>CSLA 3.0 CancelEdit Bug...???</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 3.0 CancelEdit Bug...???</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3260.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>kbcb posted on Wednesday, July 25, 2007</h2><P>Well, I recently placed a post (<A HREF="/forums/post/16373.aspx">http://forums.lhotka.net/forums/post/16373.aspx</A>) regarding an issue with business objects and editing the same business object in a grid and in a separate child form. As someone else pointed out, they are two separate use cases... However, I believe in the process of figuring out THAT issue, we stumbled onto a bug in CSLA 3.0.</P>
<P>The problem, was that occasionally, when canceling the changes to a child object who has a list of child objects, the edit levels on the grand-children would get screwed up. In our particular instance, the child would get correctly canceled back down to edit level 1, and then the children would start to cancel down, and <EM>some how</EM> right in the middle of canceling the child list's objects, a BeginEdit would be called by the UndoChangesComplete method. This didn't make a whole lot of sense to me, and was very hard to replicate because it was VERY random. There would be times where I step through the CSLA undo code, and the problem would occur and the child objects (and grand-child objects) would get set back to edit level 1 correctly, and then there would be other times where the grand child object would be set to edit level 3, and the others to edit level 1.</P>
<P>With all of that being taken into consideration, I thought that these "random" type of bugs normally crop up because of threading issues. So, what we decided to do was look through all of the CSLA code to find what code was locked for thread-safety. What I found, was that there was a lock placed in&nbsp;some code in the UndoChangesComplete (of BusinessBase.cs) method for adding the rules back into the object. I looked at little bit more at the method and saw that OnUnknownPropertyChanged was called almost immediately after the lock was released. I remembered that OnUnknownPropertyChanged can eventually lead down to the DeserializedHandlers which can get Invoked. Since <EM>any</EM> thread can wire to the PropertyChanged class, I realized that what was most likely happening was that OnUnkownPropertyChanged was getting called in the middle of my cancel edit, and a PropertyChanged (somewhere) was calling BeginEdit (dont yet know why, though).</P>
<P>All-in-all, I managed to fix the inconsistent issue by increasing the lock within the UndoChangesComplete method to include the OnUnknownPropertyChanged and base.UndoChangesComplete method. The code now looks like this instead:<BR></P>
<P><FONT size=2><FONT face="Courier New"><FONT color=blue><SPAN>private</SPAN></FONT> <FONT color=blue><SPAN>object</SPAN></FONT> _undoChangesCompleteLock = <FONT color=blue><SPAN>new</SPAN></FONT> <FONT color=blue><SPAN>object</SPAN></FONT>();<o:p></o:p></FONT></FONT>&nbsp;<BR><SPAN> <FONT color=blue><SPAN>protected</SPAN></FONT> <FONT color=blue><SPAN>override</SPAN></FONT> <FONT color=blue><SPAN>void</SPAN></FONT> UndoChangesComplete()<BR></SPAN><FONT face="Courier New" size=2><SPAN>{<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp; _bindingEdit = <FONT color=blue><SPAN>false</SPAN></FONT>;<BR><BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp; ValidationRules.SetTarget(<FONT color=blue><SPAN>this</SPAN></FONT>);<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp; AddInstanceBusinessRules();<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN><FONT color=blue><SPAN>&nbsp;<BR>&nbsp;&nbsp;lock</SPAN></FONT> (_undoChangesCompleteLock)<BR><SPAN>&nbsp;&nbsp;{<BR></SPAN></SPAN></FONT><FONT face="Courier New" size=2><SPAN><FONT color=blue><SPAN>&nbsp;&nbsp;&nbsp; if</SPAN></FONT> (!Validation.<FONT color=#2b91af><SPAN>SharedValidationRules</SPAN></FONT>.RulesExistFor(<FONT color=blue><SPAN>this</SPAN></FONT>.GetType()))<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp;&nbsp; &nbsp;{<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN><FONT color=green><SPAN>&nbsp; &nbsp;&nbsp;&nbsp; //lock (this.GetType())<BR></SPAN></FONT></SPAN></FONT><FONT face="Courier New" size=2><SPAN><FONT color=blue><SPAN>&nbsp; &nbsp;&nbsp;&nbsp; if</SPAN></FONT> (!Validation.<FONT color=#2b91af><SPAN>SharedValidationRules</SPAN></FONT>.RulesExistFor(<FONT color=blue><SPAN>this</SPAN></FONT>.GetType()))<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp; &nbsp;&nbsp;&nbsp; AddBusinessRules();<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp;&nbsp;&nbsp; }<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp;&nbsp;&nbsp; OnUnknownPropertyChanged();<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN><FONT color=blue><SPAN>&nbsp;&nbsp;&nbsp; base</SPAN></FONT>.UndoChangesComplete();<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>&nbsp; }<BR></SPAN></FONT><FONT face="Courier New" size=2><SPAN>}</SPAN></FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 25, 2007</h2><P>That's interesting, though you've reintroduced the bug that the lock was there to prevent in the first place... <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></P>
<P>The lock is there to resolve an issue in ASP.NET that exists because the SharedValidationRules are static&nbsp;- they exist across all instances of the type. So the lock itself must also be static. It actually must lock across all instances of that specific type - hence the use of this.GetType() as the lock source.</P>
<P>You could change your _undoChangesCompleteLock to be static, but then you'd be locking across all instances of all types, which is too broad a scope. But by using an instance level object your scope is too narrow and the original race condition has been reintroduced.</P>
<P>So to make this work as you expect, you'll need two locks - one at the type level (like existed before) and your new instance level lock. </P>
<P>But it is important to realize that, in general, CSLA is not threadsafe. In your scenario you must, by definition, be interacting with the object across multiple threads, and that's not supported in general.</P>
<P>So while it might be a "bug" that you are seeing this issue, it is probably one of <EM>many</EM> bugs that you'll encounter if you allow multiple threads to interact with your object concurrently.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kbcb replied on Thursday, July 26, 2007</h2><P>Good point about asp.net. Our application is not asp.net based -&nbsp;it's a windows forms app... So, I failed to think about that particular case. That now makes sense to me why I saw you using this.GetType() for all of your locks.</P>
<P>I am curious though... You say that CSLA.net is not thread-safe, but in any complex application (whether it be ASP.Net or Windows Forms), it is a probability that you will be dealing with multiple threads... For example, in our particular instance, we are not purposely interacting with our object from multiple threads, this is being done somewhere in the .net framework. This is especially the case when dealing with events, such as the PropertyChanged event. I may be wrong, but I can see it being a <EM>very</EM> common use case to have multiple threads accessing the business objects, so why do you say that CSLA is not thread-safe?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 26, 2007</h2>






 





<div class=Section1>

<p class=MsoNormal><span>The .NET BCL is not (for the most part) threadsafe either. Certainly
Windows Forms isn&#8217;t threadsafe for example. Neither is most of ASP.NET,
because it is designed with the assumption that each page request runs on a
single thread. WPF isn&#8217;t threadsafe either, looking into the future &#8211;
all the UI components are assumed to run on a single thread.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>So CSLA .NET is merely following .NET&#8217;s lead in this case.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>The single-threaded assumption is a double-edged sword. On one
hand, it is much faster, because it minimizes locking (which is a perf killer).
On the other hand, it restricts the use of threading in user code. Microsoft
has generally opted for performance rather than the flexibility of using free
threading models, and so have I.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>The only methods, in general terms, that are threadsafe are
static/Shared methods. This is true for the .NET BCL, and for CSLA .NET. If an
instance method or type is threadsafe, there&#8217;s a special note to that
effect in the docs. You&#8217;ll be hard-pressed to find many of them though &#8211;
it just isn&#8217;t the model followed by .NET.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky</span><b><span><o:p></o:p></span></b></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar replied on Thursday, April 03, 2008</h2><P>I was getting this same exact issue, using Windows Forms.&nbsp; I created some extension methods so I could see the edit level for debugging purposes(<A HREF="/forums/thread/22498.aspx">http://forums.lhotka.net/forums/thread/22498.aspx</A>), and discovered that my child that was getting the edit level increased on a OnUnknownPropertyChanged() call.&nbsp; I figured that my child must still be databinded someone where.&nbsp; After searching more, I realized that the child bindingsource.datasource must be set to null to clear it.&nbsp; After I added this call, everything worked fine.</P>
<P>&nbsp;</P>
<P>Is there any chance you can modify the Business Base Class to catch this error?</P>
<P>protected override void UndoChangesComplete()<BR>{<BR>&nbsp; BindingEdit = false;<BR>&nbsp;&nbsp;ValidationRules.SetTarget(this);<BR>&nbsp;&nbsp;AddInstanceBusinessRules();<BR>&nbsp;&nbsp;if (!Validation.SharedValidationRules.RulesExistFor(this.GetType()))<BR>&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp; &nbsp;lock (this.GetType())<BR>&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (!Validation.SharedValidationRules.RulesExistFor(this.GetType()))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;AddBusinessRules();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR><FONT color=#000000>&nbsp;&nbsp;int currentEditLevel = this.EditLevel;<BR>&nbsp;&nbsp;OnUnknownPropertyChanged();<BR>&nbsp;&nbsp;if(this.EditLevel != currentEditLevel)<BR>&nbsp;&nbsp;&nbsp; Throw new Exception("Edit level has been updated during Undo.&nbsp; Object is still databinded and must be unbinded before Cancel Edit is called");</FONT>&nbsp;<BR><BR>&nbsp;&nbsp;base.UndoChangesComplete();<BR>&nbsp;}</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dufflepud replied on Friday, April 04, 2008</h2>I am having this issue as well and traced it back to the OnUnknownPropertyChanged() call but I didn't realize this was due to it being bound in the background form. I am doing all the saves on the parent object and calling the function from the popup form after calling UnbindBindingSource from it.&nbsp; I have moved the UnbindBindingSource from PTWin WinPart into a helper class so I can call it from the regular form with the child datagridview and also from the modal popup window with the child and grandchild info on it. When I call the unbind for the child on the popup the edit level changes on the child okay (I am editing the second one in the list) but the first child's edit level jumps to 2 if I pass in apply = true.&nbsp; If I have apply = false then the edit level decrements but then when I call the CancelEdit in the main form routine it doesn't change the first child.<br>It seems like the editlevel for the first child gets locked or altered the first time CancelEdit gets called.<br>BTW I am using VB although I also pulled the cs version and pointed to it (which seemed to work fine, except CLSA.User had to be changed to CSLA.ApplicationContext.User).<br>Thanks for any help.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar replied on Friday, April 04, 2008</h2><P>I'm not sure what your issue is.&nbsp; For testing purposes, I found it helped to use these Extension Methods <A HREF="/forums/thread/22498.aspx">http://forums.lhotka.net/forums/thread/22498.aspx</A>&nbsp;to see what each call was doing to the edit levels.&nbsp; </P>
<P>Then setup a function that does something like this.</P>
<P>root = cslaRoot.GetRoot() <BR>Console.Writeline("Initial Edit Levels") <BR>Console.Writeline(root.GetChildEditLevelHierarchy()) </P>
<P><BR>dataBindingSource.DataSource = root <BR>Console.Writeline("After&nbsp;Data Binding") <BR>Console.Writeline(root.GetChildEditLevelHierarchy()) </P>
<P><BR>dataBindingSource.DataSource.CancelEdit<BR>Console.Writeline("After&nbsp;Cancel Edit") <BR>Console.Writeline(root.GetChildEditLevelHierarchy())&nbsp;<BR> </P>
<P>If you're binding Children and grand children, make sure to put that in there as well.&nbsp; It really helped me to narrow down what I was working on.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dufflepud replied on Monday, April 07, 2008</h2>I seem to have found my problem.&nbsp; I added code to the BindUI sub to set the datasource for my child grid to the parent binding source and then set the datamember to the list in the parent.&nbsp; The problem seemed to come from the datagrid resetting the editlevel for the first child when I unbound the child in my detail popup screen (alone with the grandchildren).&nbsp; Somehow not rebinding the child seemed to cause it to increment the first one, which may have been the selected row.&nbsp; I am afraid I am not sure exactly how this took care of the problem which will bother me when I have the problem again I suppose.&nbsp; Sorry I am not able to be more specific.&nbsp; Thank you for all your help and ideas.&nbsp; <br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
