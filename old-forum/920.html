<html><header><title>Foreign key deletion</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Foreign key deletion</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/920.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Vertigo1 posted on Wednesday, August 16, 2006</h2><P>Hi and greetings to all.&nbsp; First post here, been wading through the book trying to get my head round all the excellent concepts therein and have come up with my first n00b question :)</P>
<P>Not specifically CSLA-related but basically, what is the recommended way of dealing with the deletion of foreign keys.&nbsp; By this I mean the deletion of a database record to which there are foreign key references in other tables?</P>
<P>To give an example, in the Project Tracker application, if a Role was to be deleted from the Roles table, any Assignments which referenced this role would now hold an invalid foreign key reference.&nbsp; What's the recommended way of dealing with such situations?</P>
<P>A secondary issue is what happens if any business object instances reference this (now deleted) role?&nbsp; How are these dealt with?</P>
<P>TIA,</P>
<P>Toby.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Wednesday, August 16, 2006</h2>I don't think a single recommended way can be stated without knowing more about the business requirements. In some businesses, the requirement may be that a Role cannot be deleted if it has active assignments. Another business might say that when a role is deleted, the assignments are deleted as well.<br><br>Both of these are valid requirements. How you deal with the foreign keys will depend on your usage scenarios.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Vertigo1 replied on Thursday, August 17, 2006</h2><P>Fair point.&nbsp; Taking each scenario in turn...</P>
<P>If the requirement is to prevent the deletion of a role which is "in use" then where would be the best place to handle this?&nbsp; Should the stored procedure do the checking and throw an exception if the role cannot be deleted?&nbsp; This would effectively be putting business logic in the database rather than the objects themselves, which would suggest handling the problem in the objects would be better, but I'm not sure how this would be done.</P>
<P>If the requirement is to remove all references to a deleted role then again, then frankly I can't see any way this could be done other than in the deleteRole stored procedure itself, unless I'm missing something.</P>
<P>Basically any way that I can see of doing this is horrible and clunky, I was just wondering if there's a more elegant and "accepted" way of handling this scenario of which I'm unaware.</P>
<P>Thanks.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Henrik replied on Thursday, August 17, 2006</h2><P>Hi Vertigo</P>
<P>I usually just do the delete and catch exceptions in my override of Save and Delete methods.</P>
<P>All the systems I've made so far based on the CSLA framework, run on SQL Server, so I do not know if my method will work on other DBs.</P>
<P>Scenario 1:<BR>If I have a scenario where I do not allow deletion of&nbsp;a parent record if it is referenced&nbsp;(in use), I do not set a cascading delete on the foreign key relation. In my code I still execute the delete by calling my delete sproc,&nbsp;however the&nbsp;referential integrity constraint on the foreign key relation will automatically throw an exception (sqlexception number 547) which I catch in my Save and Delete overrides. If I catch an exception of this type I know that a delete was tried and failed due to "in use".</P>
<P>Scenario 2:<BR>If you want to allow deletion of child records, when deleting a parent record, you merely have to set a cascading delete on the foreign key relation. If you cannot do that, due to cycles, you will have to do the delete in your stored procedure.</P>
<P>/Henrik</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, August 17, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Vertigo1:</strong></div><div>
<P>Fair point.&nbsp; Taking each scenario in turn...</P>
<P>If the requirement is to prevent the deletion of a role which is "in use" then where would be the best place to handle this?&nbsp; Should the stored procedure do the checking and throw an exception if the role cannot be deleted?&nbsp; This would effectively be putting business logic in the database rather than the objects themselves, which would suggest handling the problem in the objects would be better, but I'm not sure how this would be done.</P>
<P></div></BLOCKQUOTE></P>
<P>You should definitely enforce this in the database if you can.&nbsp; Otherwise, someone who does not understand the rules will trash your database with their own newly created/modified object.&nbsp; My motto is to never trust an application&nbsp;programmer when I can&nbsp;cheaply and efficiently&nbsp;enforce it in the database.&nbsp; I recognize that quite a few others in this audience may disagree. :)&nbsp; Strongly. :)</P>
<P>That doesn't mean you shouldn't check in your object code also - particularly if that would give a better user experience.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Vertigo1:</strong></div><div></P>
<P>If the requirement is to remove all references to a deleted role then again, then frankly I can't see any way this could be done other than in the deleteRole stored procedure itself, unless I'm missing something.</P>
<P></div></BLOCKQUOTE></P>
<P>Depending upon what is meant by "in use", a simple cascade delete option on a foreign key in the database could do the trick.&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>oshokodk replied on Thursday, August 17, 2006</h2><P>Stored procedure&nbsp;would be&nbsp;my choice. You can also try triggers or cascade delete feature of foreign keys (ORACLE).</P>
<P>If your&nbsp;table is large&nbsp;don't forget to create index on foreign key column. This improves&nbsp;referential integrety operation's perfromance.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Michael Hildner replied on Thursday, August 17, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>oshokodk:</strong></div><div>
<P>If your&nbsp;table is large&nbsp;don't forget to create index on foreign key column. This improves&nbsp;referential integrety operation's perfromance.</P>
<P></div></BLOCKQUOTE></P>
<P>Wow, I didn't know that. I use Sql Server 2005. What is your definition of large?</P>
<P>Thanks,</P>
<P>Mike</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>oshokodk replied on Thursday, August 17, 2006</h2><P>This is difficult to quantify. It depends on DB server power and parameters. <o:p></o:p></P>
<P>The best answer is when you feel the difference between table scan and index seek/index scan. I usually add this index regardless of table size to avoid future performance tuning exercises.<o:p></o:p></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Friday, August 18, 2006</h2><P>Sql Server supports the cascade delete feature on foreign keys also (with some limitations).&nbsp; </P>
<P>Triggers are also an option.</P>
<P>If the one stored procedure is the only one you will ever have that deletes records in that table, then the stored procedure can be fully trusted to do the job.</P>
<P>But, if you ever might want to have a BulkDelete stored procedure that deletes multiple records based upon some parameters passed in, it would also have to implement the same logic.&nbsp; Ditto for your PurgeDatabaseOfOldStuff procedure, etc., etc.</P>
<P>Cascade Delete FKs or Triggers will give you the most robust option when it comes to making sure the cascaded deletes happen the same way every time.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
