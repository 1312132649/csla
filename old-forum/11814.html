<html><header><title>Asynchronity on the Data Portal server-side</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Asynchronity on the Data Portal server-side</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11814.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm posted on Saturday, February 02, 2013</h2><p>I was going through my notes around last few days I&#39;m examining Data Portal mechanisms.</p>
<p>Let me just say that it&#39;s astonishing work to see that the main principles behind Data Portal from over a decade ago are still in place with enhanced capabilities and further separated responsibilities, yet they&#39;re unified to provide the same distributed pipe line on today&#39;s increasing number of&nbsp;client / server&nbsp;technologies.</p>
<p>Back to my notes, I spotted that some parts of Data Portal server side do not have all its invocation paths as async and thus can potentially block worker threads and degrade server-side performance and scalability in general. Most notably they do not always invoke underlying data access logic asynchronously.</p>
<p>The Mobile WCF Data Portal uses MobileRequestProcessor which serves both factory and regular data access invocations but sadly they are both synchronous. Latter is synchronous because it delegates sync call to client Data Portal and the former because it invokes sync factory method through MethodCaller.</p>
<p>Even though the non-mobile WCF Data Portal invokes server Data Portal directly, it does that in a sync manner. I don&#39;t see why is this a case when Csla.Server.DataPortal is completely async.</p>
<p>This discussion might be indireclty relevant ( <a href="http://forums.lhotka.net/forums/t/11797.aspx">http://forums.lhotka.net/forums/t/11797.aspx</a>&nbsp;).</p>
<p>Is there any barrier that&#39;s preventing asynchronity on the Data Portal server-side?</p>
<p>Thanks,</p>
<p>- ngm</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, February 05, 2013</h2><p>The server-side data portal is never <em>actually</em> async, because the top-level invocation from WCF (or any other data portal host) is ultimately synchronous.</p>
<p>My goal was to enable the scenario where <em>you</em> implement async behaviors within your DataPortal_Fetch or factory methods.</p>
<p>It is also the case that the sync data portal remains entirely intact. This is important if I want to continue to support existing ASP.NET and WCF service implementations. There&#39;s a fair amount of refactoring required for an ASP.NET application to work with async calls behind web pages, so clearly the data portal needs to retain its sync behaviors for that environment.</p>
<p>(and for all existing sync Windows Forms and WPF apps - of which there are many of course)</p>
<p>&nbsp;</p>
<p>All that said, the <em>local</em> data portal will be changing in the next release of 4.5. Currently when you do an async call (BeginFetch or FetchAsync) against a local data portal the call is ultimately synchronous unless <em>your</em> DP_Fetch code does something async. That behavior is fundamentally different from the remote data portal behavior, and is already the cause of substantial confusion.</p>
<p>As a result, what I&#39;m working on right now is making the local data portal <em>always</em> spin work off to a background thread if the top-level call was BeginFetch or FetchAsync. That way the local data portal directly emulates the remote data portal to eliminate that source of confusion.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Tuesday, February 05, 2013</h2><p>Rocky,</p>
<p>I&#39;m not quite sure we&#39;re on the same page. Here I&#39;m specifically referring to asynchronity on the server-side of Data Portal.</p>
<p>Even more precisely, by asynchronity I don&#39;t mean multi-threading per se and server-side doesn&#39;t consider sync or async proxy implementation on the client at all.</p>
<p>What I want to achieve with my scalable Data Portal host is to follow all its async paths i.e. if I implement data access method (factory or in BO itself) as async it should await it throughout the whole call stack. Then it&#39;s up to business developer to decide whether that data access would be invoked on worker or IO thread by spinning new thread or invoking db connection asynchronously for example.</p>
<p>Why would Csla.Server.Hosts.WcfHost block current request thread as in this fetch implementation:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = portal.Fetch(request.ObjectType, request.Criteria, request.Context, true).Result;</p>
<p>WCF supported server-side asynchronity even before we got async/await baked. It was called server async pattern implemented by APM. It&#39;s just that&#39;s now much easier to achieve it.</p>
<p>Again, it&#39;s nothing to do with the client asynchronity i.e. the client should be able to invoke this service either synchronously or asynchronously.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Tuesday, February 05, 2013</h2><p>Just tried making WcfHost&#39;s Fetch async along with my ObjectFactory&#39;s Fetch which is async as well. </p>
<p>Fetch factory implementation started a new thread simulating very long operation.</p>
<p>Good and bad news.</p>
<p>It works pretty well,&nbsp;freeing request thread. Once factory completed its work, the request resumed where it supposed to.</p>
<p>The issue is that ApplicationContext is not capable of flowing global context. I tested this with WPF app, web app might be in better position due to different ApplicationContextManager which relies on HttpContext instead of thread&#39;s local slot. Principal seems to be flowing correctly though.</p>
<p>Obviously it&#39;s not trivial, but personally I think it&#39;s worth pursuing.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, February 06, 2013</h2><p>GlobalContext should flow one-way, from the caller to the callee. If that doesn&#39;t happen then that&#39;s a bug. But if Principal is flowing then I suspect the context dictionaries are flowing as well - but again, bugs are possible.</p>
<p>You are right that it doesn&#39;t <em>automatically</em> flow back to the caller. It really can&#39;t, because you could have numerous async operations running, so how would CSLA merge the multiple GlobalContext objects back into the caller&#39;s single instance?</p>
<p>Since 2007 with the introduction of BeginFetch, etc. the GlobalContext has flowed back to the DataPortal <em>instance</em> object on the client. It is up to the app developer to get that dictionary and merge it back into the UI thread&#39;s context dictionary. So few apps use GlobalContext (which is good - it is expensive!) that this hasn&#39;t been an issue. At least nobody has ever brought it up as an issue over the past few years.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>You mean ClientContext should flow one-way? GlobalContext should flow in both directions, right?</p>
<p>The reason Principal flows and ClientContext / GlobalContext doesn&#39;t is because System.Threading.ExecutionContext captures System.Security.SecurityContext which preserves current principal. Contexts are stored in TLS (at least with Csla.Xaml.ApplicationContextManager) and therefore they&#39;re not part of captured ExecutionContext. Also the current culture is not&nbsp;preserved as well.</p>
<p>What I proposed initially in this post is to enable WCF infrastructure to release the requesting thread&nbsp;if there&#39;s asynchronous data access&nbsp;and thus achieve better scalability. However, this&nbsp;issue with context flowing&nbsp;is not specific to the modification I&#39;ve done above. Pretty much if today, business developer starts data access (or any other logic)&nbsp; on the separate thread, the context will not flow in any direction to and from that thread.</p>
<p>As far as inbound context goes, I think it would be pretty expected to have it flowing throughout the whole logical call stack, no matter how many threads it&#39;s spanning. One solution to it might be preserving contexts as part of logical call&nbsp;with LogicalSetData / LogicalGetData methods&nbsp;of&nbsp;System.Runtime.Remoting.Messaging.CallContext instead of TLS. Then ExecutionContext should be able to have context flowing.</p>
<p>Regarding outbound context i.e. passing the context out of executing thread, if I recall it correctly, calling LogicalSetData on the CallContext will not make that value available to the caller thread - the one that offloaded work onto other thread. However, if the reference to the object such as dictionary is already set on the caller thread, the executing thread should be able just to add items or change properties referencing the object. That&#39;s probably exactly what you want going on in ApplicationContextManager implementation.</p>
<p>While I agree with the problem about merging of potentially multiple GlobalContext objects back into the caller&#39;s single instance as you stated above, I believe it&#39;s much more related to the client-side than the server-side. The biggest difference is that server-side Data Portal has got the logical call established no matter&nbsp;how many threads it&#39;s switched on. Even if you&#39;ve got some parallelism occuring somewhere on the logical call, setting context values, that should be considered as typical multithreading issue.</p>
<p>The fact that GlobalContext is not used so much (yes, I used it very rarely) doesn&#39;t mean it should be inconsistent. </p>
<p>Still getting fully into this async game on the server side of the house&nbsp;would pretty bold achievement for CSLA.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>I agree that it would be very cool for the data portal to support async channels. This is something I&#39;ve thought about off and on since WCF introduced the concept years ago, but it just has never floated to the top of my priority list.</p>
<p>It is challenging to consider that the client might call the data portal and not get a response for seconds, minutes, or hours (or days) because the server is totally async. If you take this to its logical conclusion there&#39;s a pretty fundamental impact on the overall design and expectations around the data portal.</p>
<p>For example:</p>
<p>order.ReadyToShip = true;<br />await order.SaveAsync();</p>
<p>This call could start an async workflow process on the server that won&#39;t complete until tomorrow when the shipping department is able to fulfill. Obviously the client wont&#39; sit around waiting until then :)</p>
<p>Not to say that supporting true async message-based server interactions isn&#39;t a good idea, because I think it is a good idea. But it is to say that this requires some careful thought.</p>
<p>What WCF bindings would be allowed? How would the ASP.NET Web API be supported? Do we still provide any support for synchronous channels, or completely switch to an async channel model? (probably yes, otherwise the data portal would act differently depending on your channel, and that&#39;d be a mess)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>Rocky,</p>
<p>Async channels would be awesome, but that requires serious reengineering of the infrastructure.</p>
<p>But I&#39;m not talking about async channels here at all. Maybe my explaination of the final goal is pretty muddy but basically I&#39;m talking about service asynchronity, usually called async pattern in WCF terms. Something that ASP.NET Web API you mentioned supports as well.</p>
<p>Here&#39;s one article on the msdn that describes exactly what I want to achieve here ( <a href="http://blogs.msdn.com/b/wenlong/archive/2009/02/09/scale-wcf-application-better-with-asynchronous-programming.aspx">http://blogs.msdn.com/b/wenlong/archive/2009/02/09/scale-wcf-application-better-with-asynchronous-programming.aspx</a>&nbsp;). Although it&#39;s pretty old - it doesn&#39;t cover async / await but rather APM, that&#39;s the&nbsp;one I just found and still the essence is the same.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>I think I accomplish the goal of that MSDN post. In fact, the data portal holds true to one of their tenants:</p>
<p>&quot;<span style="font-size:10pt;font-family:&#39;Cambria&#39;,&#39;serif&#39;;line-height:115%;mso-ascii-theme-font:major-latin;mso-hansi-theme-font:major-latin;">One important thing to note is that WCF is a fully decoupled platform. This means that the client-side asynchrony has nothing to do with the service-side asynchrony</span>&quot;</p>
<p>The data portal does the same thing regardless of whether you use WCF or not. The client-side asynchrony and server-side asynchrony have nothing to do with each other.</p>
<p>In this thread our discussion is (as I understand it) focused on the server side, and specifically within the context of a WCF host.</p>
<p>The data portal requires that the top-level service/operation API be based on a synchronous WCF binding. As you and I note, async bindings would be awesome, but that&#39;s a pretty tall order... Not likely to happen anytime soon.</p>
<p>The data portal host (WcfPortal) creates an instance of Csla.Server.DataPortal and invokes its async methods, but with the .Result() method so the invocation is synchronous at the top level. This allows the actual workflow to use all the cool async/await features, but ensures that the WCF service call itself doesn&#39;t return to the client until the server work is complete.</p>
<p>The entire flow of control from Csla.Server.DataPortal down to the SimpleDataPortal or FactoryDataPortal (the two types that invoke YOUR code) is a series of async methods.</p>
<p>This is because the IDataPortalServer interface is used to flow the calls through the pipeline, and all its methods return Task&lt;DataPortalResult&gt;. So pretty much by definition the entire call chain on the server is a series of async/await calls.</p>
<p>The exceptions being, again, at the top level the .Result() method is used to prevent returning to the client prematurely. And at the bottom of the chain SimpleDataPortal and FactoryDataPortal examine YOUR DataPortal_XYZ or factory methods to see if they are &#39;void&#39; or &#39;async Task&#39; and the calls to your code are adjusted accordingly.</p>
<p>As a result, if your DataPortal_XYZ method is &#39;async Task&#39; then SimpleDataPortal will await your method, and inside your method you can use the full set of async/await behaviors.</p>
<p>For example, you might await the result from a database call as suggested in the MSDN article. Behind the scenes Microsoft is nice enough to use IO completion ports in their implementation, so your await is truly async and won&#39;t block a worker thread.</p>
<p>At least so goes my understanding.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>Got you! </p>
<p>Now I know where&nbsp;confusion lies:</p>
<p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b></p>
<p>&quot;The data portal host (WcfPortal) creates an instance of Csla.Server.DataPortal and invokes its async methods, but with the .Result() method so the invocation is synchronous at the top level. This allows the actual workflow to use all the cool async/await features, but ensures that the WCF service call itself doesn&#39;t return to the client until the server work is complete.&quot;</p>
<p></div></p>
<p>There&#39;s no need to hold server-side request thread in order to keep client&#39;s request alive i.e. not to return it. That&#39;s baked, even better baked with Task based contracts / service implementation. It used to be total mess with APM and passing the state between BeginXXX and EndXXX methods.</p>
<p>My PoC up there where I modified WcfHost&#39;s Fetch was:</p>
<p>&nbsp;&nbsp;&nbsp; [OperationBehavior(Impersonation = ImpersonationOption.Allowed)]<br />&nbsp;&nbsp;&nbsp; public async Task&lt;WcfResponse&gt; Fetch(FetchRequest request)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Csla.Server.DataPortal portal = new Csla.Server.DataPortal();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; object result;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = await portal.Fetch(request.ObjectType, request.Criteria, request.Context, true);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = ex;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new WcfResponse(result);<br />&nbsp;&nbsp;&nbsp; }</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>Two questions then.</p>
<p>First, does this change the service contract? I&#39;m guessing not - it is just an internal implementation difference?</p>
<p>Second, it sounds like WCF is doing the same thing SimpleDataPortal is doing - i.e. detecting that the target method returns a task and therefore invoking it in an async-friendly manner. Do you agree?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b></p>
<p>
<p>Two questions then.</p>
<p>First, does this change the service contract? I&#39;m guessing not - it is just an internal implementation difference?</p>
</p>
<p></div></p>
<p>Depending what you mean by service contract. It doesn&#39;t change actual service contract on the wire i.e. WSDL, but interface of the service - IWcfPortal has to be changed for sure. However, the proxy on the client can stay the same.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b></p>
<p>
<p>Second, it sounds like WCF is doing the same thing SimpleDataPortal is doing - i.e. detecting that the target method returns a task and therefore invoking it in an async-friendly manner. Do you agree?</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>That&#39;s exactly it. </p>
<p>Whatsoever, that&#39;s how I found this blocking at the first place - by following all your awaits through the whole server-side call stack. It&#39;s not because my application server stopped serving the requests ;)</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>I made this change (a little trickier than expected because I had to split the .NET 4 from 4.5 implementation.</p>
<p>It seems smooth enough - at least the existing tests pass and my sample apps run :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>That&#39;s nice!</p>
<p>Yeah, .NET 4 is still in APM world. But it shouldn&#39;t take too much to support that as well.</p>
<p>You&#39;ll need to have separate, APM base IWcfPortal for .NET 4, something like:</p>
<p>&nbsp;&nbsp;[OperationContractAttribute(AsyncPattern = true)]<br />&nbsp;&nbsp;[UseNetDataContract]<br />&nbsp;&nbsp;IAsyncResult BeginFetch(FetchRequest request, AsyncCallback callback, object asyncState);</p>
<p>&nbsp;&nbsp;WcfResponse EndFetch(IAsyncResult result);</p>
<p>AsyncPattern attribute is important here.</p>
<p>That interface should be used both for proxy - ChannelFactory and service - WcfPortal.</p>
<p>Implementation wise, on the WcfProxy, you should be able to use Task.Factory.FromAsync and get a task from BeginFetch / EndFetch methods on the proxy.&nbsp;So you&#39;ll get rid of all BackgroundWorker clutter. That way, .NET 4 clients are not in disadvantage&nbsp;of spinnning separate thread. </p>
<p>Oh boy, do I hate that BackgroundWorker,&nbsp;especially used so low in the Data Portal stack&nbsp;;)</p>
<p>As for WcfHost, I would go with something along these lines:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private IAsyncResult BeginFetch(FetchRequest request, AsyncCallback callback, object state) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var task = portal.Fetch(...request params...);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; task.ContinueWith(t =&gt; callback(t), TaskContinuationOptions.ExecuteSynchronously);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return task;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private WcfResponse EndFetch(IAsyncResult result) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ((Task&lt;WcfResponse&gt;)result).Result;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>Didn&#39;t try, but that should do it. </p>
<p>Please note that this pattern will not start additional task / thread, it relies on any await lower in the call stack. However, if there&#39;s no offload or IO async used, this BeginFetch might be long running guy. That&#39;s not good practice for sure. So you might decide to wrap asynchronously the call to portal.Fetch just to ensure that you returned from BeginXXX as quickly as it requires to start the task.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, February 08, 2013</h2><p>I don&#39;t think I&#39;ll put in the time/effort for .NET 4 though. Always looking forward, that&#39;s the way to be! :)</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
