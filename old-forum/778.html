<html><header><title>Why business list base? Why not business hashtable base?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Why business list base? Why not business hashtable base?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/778.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>kucing posted on Monday, July 31, 2006</h2>Currently, I am doing a development with a business object that has a list containing a few thousand of items in it. Everything loads very well and working flawlessly.<br><br>However, recently I noticed a constant slowdown when trying to add items. This is because when adding an item, function "contains" is called. Say I am trying to add 100 items and the list already contains 1000 items, I will have to perform 100 * 1000 checks, which is far too many. To counter this, I added my own hash table variable that has the keys of the items in the list so it does not have to iterate through all of the items in the list. Instead of 100 * 1000, it only does 100 checks.<br><br>It all sounds good but then it came to my mind, instead of storing the item inside the business list, why not store it inside hashtable to make it faster? Then again, why is business list is implemented as a list that does not scale well if it contains a large amount of items? Why not make it hash table instead? It may prove to be an overkill for a small list but for large lists it will perform extremely well.<br><br>Thoughts?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, August 01, 2006</h2><P>BusinessListBase doesn't call Contains() itself, so it must be your code that is making that call - probably to ensure uniqueness? You might consider adding the ability to skip the Contains() call during the load process.</P>
<P>The reason I went with a list is data binding. You can't use data binding against a hashtable or dictionary.</P>
<P>However, if data binding is not a concern for you, there's no reason you couldn't create your own base class that is derived from a Dictionary&lt;&gt; or something along that line. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kucing replied on Wednesday, August 02, 2006</h2>Thanks for clearing that one out. I actually need to bind the data so I will have to use the list. I will need to do something extra to make it faster though.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, August 02, 2006</h2><P>Would it be possible to construct a parallel internal dictionary/hashtable upon fetching&nbsp;that would respond to additions &amp; removals? </P>
<P>In my "NameValueListBase" (I replaced it with my own hierarchical coding mechanism) I do this very thing. My list is read-only, however, so I haven't accomodated the removal/addition of items - but it shouldn't be particularly tricky I wouldn't think. </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Shazam replied on Wednesday, August 02, 2006</h2><DIV>I had a similar problem.&nbsp; To keep the Dictionary object and the collection in sync, you can override the InsertItem and RemoveItem methods.</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz replied on Thursday, August 03, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Shazam:</strong></div><div><div>I had a similar problem.&nbsp; To keep the Dictionary object and the collection in sync, you can override the InsertItem and RemoveItem methods.</div></div></BLOCKQUOTE>Yes I've done the same on some lists where I needed quick frequently lookups. But ... I guess if its an editable list then you need to update all the references in the Dictionary whenever the list and child objects are serialized. Perhaps someone can confirm that.<br><br>An alternative to holding references in the Dictionary is to just hold the integer index. I think that's fine and perhaps a little cleaner if its a readonly list or if it only ever has items added at the end of the list. I think you then avoid the need to do anything on serialization. It gets complicated if you remove items from the list because everything after that item changes its index.<br><br>Cheers<br>Ross<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
