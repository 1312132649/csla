<html><header><title>From Service to BO - best practices</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>From Service to BO - best practices</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5725.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Monday, November 03, 2008</h2><P>I know there are different patterns and approaches to designing service interfaces but I am very much sold on the Request/Response approach that helps to abstract the underlying implementation and will allow me to make changes to the service interface over time without breaking the contract (for the most part).&nbsp; However, inside the service method, once I have the request object, I am actually using a provider model and my CSLA BOs to do the work.&nbsp; Is it better to break-up the request object and use its fields directly as parameters to&nbsp;the method call on my BO?&nbsp;&nbsp;If I change the interface, then I have to make changes in multiple locations.</P>
<P>Let me use an example...</P>
<P>Take the case of user authentication.&nbsp; Let's say is have a LoginService that is used by my client applications.&nbsp; It has a single Login method that accepts a LoginRequest and returns a LoginResponse object.&nbsp; LoginRequest has properties for UserName and Password and LoginResponse has an IsAuthenticated property.</P>
<P>Inside the Login method, I am going to call the SecurityManager.Login() method.&nbsp; This class is used to support a provider model that allows us to change how authentication is actually performed.&nbsp; SecurityManager.Login then calls my SecurityProvider.Login method which, by default, delegates to my User BO's ValidateUser method.</P>
<P>So, you can see that the request actually passes through 4 classes (in the default case) as shown below:</P>
<P>LoginService.Login(...) -&gt; SecurityManager.Login(...) -&gt; SecurityProvider.Login(...) -&gt; User.ValidateUser(...)</P>
<P>If I change the contract, let's say I require an account number or CAPTCHA value or something, then I have to change ALL of these classes!&nbsp; Wouldn't it be better to pass the request as an object between them all just as I do at the service interface?</P>
<P>Help me see the pro's and con's.&nbsp; Thanks!!!</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 03, 2008</h2><P>Just to pick on your CAPTCHA example, I'll suggest that having these layers is a <EM>good thing</EM>.</P>
<P>Your business layer should service the broad use case, which is to authenticate the user. This is true whether the use case is accessed via the web, a service, Silverlight, WPF, a workflow, etc.</P>
<P>Only one of those (web) will have a CAPTCHA concept. So that concept doesn't belong to the business layer, it belongs to the interface layer. It is the kind of thing that should be checked by the interface before the interface invokes the business layer.</P>
<P>So keeping these things separate is beneficial, because you have the flexibility of adding interface-only concepts without messing up the business layer. Conversely, you may sometimes add things to the business layer that don't (necessarily) impact the interface - especially if your interface is an XML service.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, November 06, 2008</h2><P>A quick follow-up...</P>
<P>Using the Request/Response approach, I am seeing two approaches to creating service interfaces.&nbsp; The seemingly more traditional one has a unique service method for each Request/Response call.&nbsp; This is how I see Rocky doing it in the Project Tracker sample.</P>
<P>The other method, used in particular for Microsoft Dynamics CRM 4, is to have a single service method.&nbsp; In this case, the request object that is instantiated on the service-side has an Execute method that is called by the service to perform the requested action.</P>
<P>I think the first approach is clearer but am drawn to the second because it seems to be much more flexible and, perhaps, even better OO design.&nbsp; To add new functionality is as simply as adding a new Request/Response pair to the interface.&nbsp; And, from an OO perspective, the logic required to carry-out the request is encapsulated within the request object itself.&nbsp; This makes perfect sense.</P>
<P>But, what does this do to discovery and is it really a better way to go?&nbsp; If the service interface doesn't explicity define the type of arguments, how does a client proxy create the necessary classes when a service reference is added?</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
