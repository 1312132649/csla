<html><header><title>Delete and Post Validation Rules</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Delete and Post Validation Rules</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3231.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>stanc posted on Thursday, July 19, 2007</h2><P>I've quickly checked the forum looking for some post on this, but haven't found any. I was wondering if anyone has used/extended validation rules beyond save validations. We have a project where there will be all sorts of validation rules for deletes and posting an item. </P>
<P>I was thinking about possibly extending the Validation rules to cover this, but was wondering how others may have attacked this problem.&nbsp;Another idea I had was to just add my validations as part of the data portal call for the delete. </P>
<P>This raises a separate but related problem concerning Posting. Should I extend data portal calls to include a new one for Posting (DataPortal_Post) or should I just add a flag in my business object that gets set before calling the save letting me know to post?</P>
<P>Any input would be greatly appreciated.</P>
<P>Stan</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 19, 2007</h2><P>If you want to do a final rule check before an insert/update/delete, you can override Save() to do that check - on a root object anyway.</P>
<P>On a child object that's harder, and the only place you can really do such a final check is in the DP_Insert/Update/Delete methods. Nothing is called on child objects immediately before saving...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stanc replied on Thursday, July 19, 2007</h2><P>OK. That is basically what I thought would be the best idea.<o:p></o:p></P>
<P>Do you have any opinions on how I should handle the Post action? It may help if I defined Post from our application: Posting is really just a status change and has stricter rules imposed on it. For example it may be ok to save an object with a certain property filled in, but it has to be filled in to post the object. But it also performs other actions. In our case it's basically an inventory system, and upon saving an item the inventory isn't touched but after posting we remove the items from inventory. Do you think adding a DP_Post would be a good idea in this case? Or should I just use a flag noting the item is being posted and handle it on the DP_Update?<o:p></o:p></P>
<P>Thank you&nbsp;for the input and the framework. Although I am new to CSLA, I already see a great deal of value in it for my group and myself.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 19, 2007</h2><P>Posting sounds like&nbsp;a different use case from "adding" or "editing". As such, you should start out with the assumption that you need a different object for that different use case. </P>
<P>Only if, after doing your design, you discover that the object needed by the Post use case is <EM>identical</EM> to the object from the Add/Edit use case should they be the same object.</P>
<P>From your description, they are most certainly different objects.</P>
<P>In fact, it sounds like your Post use case has at least a&nbsp;couple objects of its own:</P>
<UL>
<LI>A read-only object to display the data to the user for confirmation</LI>
<LI>A command object to do the post</LI></UL>
<P>Neither of which are objects from the Add/Edit use case.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stanc replied on Thursday, July 19, 2007</h2><P>OO! Really just starting to get a grasp on it, and this our first project fully utilizing the principals. </P>
<P>With that said, I just want to ask one more follow up after&nbsp;providing you&nbsp;a little more information. The reason I see it as part of the same object is because the user may go straight from the data entry to posting the object without even a save in between. Or even more commonly they will open the object make some modifications and then post it. From a UI side this will all be accessible from the same screen as data entry. </P>
<P>I know you don't know all the details of the Use Cases, but I am just curious if the additional information changed your opinion any?</P>
<P>Thanks again for your help.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sgraham replied on Wednesday, July 25, 2007</h2><P>I have two&nbsp;very similar situations.</P>
<P>First situation, I don't want to do a validation that requires a database hit until the user is ready to save the object...a child object, I&nbsp; might add.</P>
<P>Second situation, I want a workflow type scenario like you mention (preparing and saving an object prior to submitting/posting it).</P>
<P>Please advise anyone!!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 25, 2007</h2><P>Let's talk about the second first (just for fun).</P>
<P>A workflow is a series of activities. Each activity is independent, and in fact should be thought of as its own use case. So each workflow activity, in a normal case, will have its own objects that implement that activity.</P>
<P>So your prepare/save activity will have different objects from submit/post because those are different actvities at different points in the workflow.</P>
<P>&nbsp;</P>
<P>The first situation can be solved a couple different ways. </P>
<P>The simplest way is to call or implement the rules in your Friend/internal Insert()/Update() methods, and then throw an exception in case of failure. You have to throw an exception at this point, because other objects will have already committed to the database and you need the overall transaction to roll back.</P>
<P>The harder, but more elegant way, is to do what I described earlier (in this or another thread, don't remember), where you use rule priorities to prevent those final rules from running until you are actually saving the object.</P>
<P>This isn't really that hard, but it is a bit of extra work. The trick is that you need to trigger checking of all rules for the children of the root, from wthin the root object's Save() method. This must happen <EM>before</EM> calling MyBase.Save() or base.Save().</P>
<P>So what you need to do is simply cascade a CheckFinalRules() call down through all children. Using the priority scheme, each object (root or child) will have a private field like _checkFinal, which will normally be false, but now will be true. So CheckFinalRules() will look like this:</P>
<P>internal void CheckFinalRules()<BR>{<BR>&nbsp; _checkFinal = true;<BR>&nbsp; ValidationRules.CheckRules();<BR><BR>&nbsp; // check rules for children<BR>&nbsp; _childList.CheckFinalRules();<BR>}</P>
<P>And if your object is a collection it would look like this:</P>
<P>internal void CheckFinalRules()<BR>{<BR>&nbsp; foreach (Child child in deletedList)<BR>&nbsp; &nbsp; ValidationRules.CheckRules();<BR>&nbsp; foreach (Child child in this)<BR>&nbsp; &nbsp; ValidationRules.CheckRules();<BR>}</P>
<P>Again, for this to work, you need to use rule priorities:</P>
<OL>
<LI>Your normal rules are at priority 0 (the default)</LI>
<LI>For each property you insert a rule at priority 1 that always returns true, but sets e.StopProcessing to true if _checkFinal is false</LI>
<LI>Your final rules are at priority 2</LI>
<LI>You must set the process through priority threshold value to 2</LI></OL>
<P>Obviously some of this work can be done in your custom base classes (you do have them right? <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" />), because you can put basic CheckFinalRules() implementations in the base classes, and you can set the process through priority threshold change in the base class.</P>
<P>If you aren't adverse to a bit of reflection, you could even automatically insert the _checkFinal short-circuiting rule (step 2) for each property using code in the base class.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sgraham replied on Thursday, July 26, 2007</h2><P>First off, thanks for the rapid response.</P>
<P>Now, excuse my learning curve.&nbsp; I'm catching on..but slowly.</P>
<P>First, regarding the separate use cases being separate objects:&nbsp; as the previous poster also mentioned, the GUI, and 95% of the business logic is the same between the save and submit functions (both need the same properties, rules and&nbsp;data access).&nbsp; So, does it make sense to leverage that code somehow (with some OO technique) or create completely different objects?&nbsp; Maybe I'm missing something but it seems complex to maintain near duplicate objects, right?&nbsp; Would you try to leverage the overlap?&nbsp; If so, how?</P>
<P>Second, I understand the solution you suggested and I like it!&nbsp; I don't mean to get off topic but I'm curious about your comment about having custom base classes.&nbsp; Could you elaborate on that?&nbsp; I'm a somewhat&nbsp;"experienced" developer (several years) who's trying to become more experienced with OO techniques and strategies so that I can guide others in our company (since the company is not at all OO savy).&nbsp; Thanks!</P>
<P>Sean</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 26, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>sgraham:</strong></div><div>
<P>Second, I understand the solution you suggested and I like it!&nbsp; I don't mean to get off topic but I'm curious about your comment about having custom base classes.&nbsp; Could you elaborate on that?&nbsp; I'm a somewhat&nbsp;"experienced" developer (several years) who's trying to become more experienced with OO techniques and strategies so that I can guide others in our company (since the company is not at all OO savy).&nbsp; Thanks!</P>
<P></div></BLOCKQUOTE></P>
<P>As a general rule I recommend that people always create a set of custom base classes that inherit from the CSLA .NET base classes. The primary extensibility mechanism for CSLA .NET is to override methods to customize behavior - and you typically want to do that in a central place.</P>
<P>So I suggest you create base classes (even if they are otherwise empty), and inherit from your base classes in your objects, rather than inheriting from CSLA directly.</P>
<P>namespace MyBaseClasses<BR>{<BR>&nbsp; public abstract class BusinessBase&lt;T&gt; : Csla.BusinessBase&lt;T&gt;<BR>&nbsp;&nbsp;&nbsp; where T: BusinessBase&lt;T&gt;<BR>&nbsp; { }<BR>&nbsp; // ...<BR>}</P>
<P>Namespace MyBaseClasses<BR>&nbsp; Public MustInherit Class BusinessBase(Of T As BusinessBase(Of T))<BR>&nbsp;&nbsp;&nbsp; Inherits Csla.BusinessBase(Of T)<BR>&nbsp; End Class<BR>&nbsp; ' ...<BR>End Namespace</P>
<P>If you do this for BusinessBase, BusinessListBase, ReadOnlyBase, ReadOnlyListBase, NameValueListBase and EditableRootListBase you allow yourself to customize behaviors over time by overriding (or adding) methods in your base classes, thus affecting all your business objects.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 26, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>sgraham:</strong></div><div>First, regarding the separate use cases being separate objects:&nbsp; as the previous poster also mentioned, the GUI, and 95% of the business logic is the same between the save and submit functions (both need the same properties, rules and&nbsp;data access).&nbsp; So, does it make sense to leverage that code somehow (with some OO technique) or create completely different objects?&nbsp; Maybe I'm missing something but it seems complex to maintain near duplicate objects, right?&nbsp; Would you try to leverage the overlap?&nbsp; If so, how?</div></BLOCKQUOTE><br><br>There are a few ways to handle this.&nbsp; One you could create an internal class which the two public BOs use so that the shared behavior is encapsulated there.&nbsp; The other option is to create a base class, and have your BOs inherit their behavior from the base class.&nbsp; You can do that if you don't expect the shared logic to change or if the changes will always have to affect both classes.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>sgraham:</strong></div><div>Second, I understand the solution you suggested and I like it!&nbsp; I don't mean to get off topic but I'm curious about your comment about having custom base classes.&nbsp; Could you elaborate on that?&nbsp; I'm a somewhat&nbsp;"experienced" developer (several years) who's trying to become more experienced with OO techniques and strategies so that I can guide others in our company (since the company is not at all OO savy).</div></BLOCKQUOTE></p><p>You should implement subclasses which match BB, BLB, ERLB, etc.&nbsp; Then your BOs subclass these new subclasses.&nbsp; Your customer business base classes need not add any behavior, but if at some point you require all your BOs to have a certain behavior, you can add it to your base classes.&nbsp; This lets you avoid modifying the Csla framework itself.</p>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 26, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>sgraham:</strong></div><div>
<P>First, regarding the separate use cases being separate objects:&nbsp; as the previous poster also mentioned, the GUI, and 95% of the business logic is the same between the save and submit functions (both need the same properties, rules and&nbsp;data access).&nbsp; So, does it make sense to leverage that code somehow (with some OO technique) or create completely different objects?&nbsp; Maybe I'm missing something but it seems complex to maintain near duplicate objects, right?&nbsp; Would you try to leverage the overlap?&nbsp; If so, how?</P>
<P></div></BLOCKQUOTE></P>
<P>The key is to factor your objects to avoid coupling and to get reuse if you can. Reuse is <EM>not</EM> the dominant goal! Maintainability is the goal, and improper reuse leads to coupling, which is (arguably) the ultimate evil.</P>
<P>So if your two use cases both allow the user to enter/alter all the same data, and the only difference is that the <EM>edit</EM> use case and <EM>post</EM> use case set a different flag in the database, then I'd suggest all you need is a little logic in your DP_Update() method to accomodate the difference. This presupposes that the properties that can be changed, and the rules governing those properties are substantively the same.</P>
<P>But often the <EM>edit</EM> use case is where the user gets to alter values, and the <EM>post</EM> use case is quite different: the user merely selects the item to post, maybe gets to alter a subset of values and then the post occurs. In this case the use cases are quite different and need different objects.</P>
<P>The problem with reusing objects across use cases, is that you effectively couple the use cases. So later, when you change the requirements (and thus the code) for one use case, you run the serious risk of breaking the other use case(s). This kind of fragility is the result of coupling, and is why I say coupling is the ultimate evil.</P>
<P>Worse, notice how the loss of maintainability flowed from <EM>reuse</EM>!! We were&nbsp;all (at least I was) taught that reuse was this wonderful thing, when in reality it has a huge downside that often overwhelms any advantage the reuse might have provided.</P>
<P>"Quicker, easier, more seductive" is the dark side, but not stronger <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
