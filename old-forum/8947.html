<html><header><title>Questions about double-checked locking code inside CSLA and thread-safety</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Questions about double-checked locking code inside CSLA and thread-safety</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8947.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Monday, May 17, 2010</h2><p>Here is an example of the general pattern that has me concerned in the FieldDataManager.&nbsp; I have seen code like this in CSLA (and have used the same pattern myself). </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; private static List GetConsolidatedList(Type type)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List result = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_consolidatedLists.TryGetValue(type, out result))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_consolidatedLists)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_consolidatedLists.TryGetValue(type, out result))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = CreateConsolidatedList(type);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _consolidatedLists.Add(type, result);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<br />&nbsp;&nbsp;&nbsp; }</p>
<p>I&#39;ve run into some threading problems in my implementation lately, and while I don&#39;t necessarily believe CSLA is at fault, I&#39;m not sure I (or we :) should be writing code like this. </p>
<p>Is there any reason to be believe TryGetValue() would be thread-safe? Certainly concurrent TryGetValue() calls work, but might there be a problem is an Add() is executing concurrently with the TryGetValue()?&nbsp; Depending on the internal implementation, if no internal locking is used the I can see how it could&nbsp;return true while the out value is returned as null. </p>
<p>If this is indeed safe, I&#39;d sure welcome a reference I could read to put me at ease. </p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>This has been discussed before (at least twice). The short answer is that this is not 100% safe. The long answer is that, prior to .NET 4 with its new threading collection types, the only solution that is 100% safe requires a lock on every call. The performance implications of doing that are quite high.</p>
<p>The advantage CSLA is working with is that the initialization of these values is rare. In pretty much every case this occurs once per AppDomain, as the type is first accessed. So the practical result is that (to my knowledge) this has never caused any issues. Yes, it is theoretically an issue, but given the way it is applied in CSLA it doesn&#39;t appear to be a real issue.</p>
<p>Sadly, while .NET 4 added new threadsafe types, SL4 did not. So CSLA 4 now has some cases where this type of code still exists on the SL side, but where I&#39;ve been able to leverage the new .NET 4 types for the .NET side. A step in the right direction at least.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, May 17, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>This has been discussed before (at least twice). The short answer is that this is not 100% safe. The long answer is that, prior to .NET 4 with its new threading collection types, the only solution that is 100% safe requires a lock on every call. The performance implications of doing that are quite high.
<div style="CLEAR:both;"></div>
</div></p>
<p>OK, this is good to know (I did a precursory search before posting, but sorry for bringing up a duplicate topic). I know much of the CSLA code is executed just once -- I wasn&#39;t picking on this particular instance, just trying understand if the pattern itself had problems.</p>
<p>Now that I have been doing logging, it turns out that so far all of my own problems are occuring at initialization time and I have eliminated at least one race condition and a possible deadlock. Things work just fine, and then the application pool recycles while a bunch of incoming requests are trying to be processed while all the DLL&#39;s are loading and the BO classes get initialized. </p>
<p>I&#39;ll search for the prior discussions. From today&#39;s intensive reading, I was under the impression that the cost of a lock() was comparatively low as long as there was no contention. (And if there is contention, then it seems like you need the lock anyway). </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>As far as I know, lock() is a Mutex, which is a kernel mode lock - which at a minimum means a context switch out of user mode at the CPU/OS level on each invocation.</p>
<p>That&#39;s yet another .NET 4 feature - a set of cheaper user-mode locks (spinwait locks) that avoid that context switch.</p>
<p>It is true that lock() isn&#39;t ridiculously expensive - unless it is invoked in a tight loop, like during the process of loading your business objects with data from the DAL where you might touch thousands of properties (and thus rules) in what we hope is a fraction of a second. In that case I fear lock() might not be so cheap...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, May 17, 2010</h2><p>I think this was the original thread on this: <a href="http://forums.lhotka.net/forums/p/8474/40306.aspx#40306">http://forums.lhotka.net/forums/p/8474/40306.aspx#40306</a></p>
<p>Also, I found a good discussion (and code which actually breaks this pattern) here if anyone is interested:</p>
<p><a href="http://stackoverflow.com/questions/2624301/how-to-show-that-the-double-checked-lock-pattern-with-dictionarys-trygetvalue-is">http://stackoverflow.com/questions/2624301/how-to-show-that-the-double-checked-lock-pattern-with-dictionarys-trygetvalue-is</a></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
