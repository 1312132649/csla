<html><header><title>Performance of LoadProperty Method</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Performance of LoadProperty Method</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11336.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin posted on Friday, April 27, 2012</h2><p>Hi folks,</p>
<p>My team is working on a WPF application using CSLA 4.2.1 for our business layer implementation. We have one area within our application that currently displays a list of 5633 info objects. This list is taking approximately 3.0 seconds to load. So, I decided to investigate in order to determine what the bottleneck is. I discovered that the culprit is in the LoadProperty(IPropertyInfo propertyInfo, object newValue) method on ReadOnlyBase&lt;T&gt; that is being called to populate the objects from a data reader.</p>
<p>This particular info object has 33 fields which means that LoadProperty is being called 5633 * 33 or 185,889 times in order to create the list we are trying to display. Upon further inspection, I discovered that this LoadProperty method is doing some pretty heavy lifting via reflection in order to set the field manager properties. I also noticed that a lot of this heavy lifting could be done during type initialization rather than each time a property is loaded.</p>
<p>I wanted to try this idea out to see if it would work and to see whether or not the performance would improve noticeably. What I came up with was this:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;"></p>
<p>public class MyInfoObject : ReadOnlyBase&lt;MyInfoObject&gt;<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static readonly Dictionary&lt;IPropertyInfo, System.Reflection.MethodInfo&gt; genericPropertyMethods;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static MyInfoObject()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods = new Dictionary&lt;IPropertyInfo, MethodInfo&gt;();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var methods = typeof(MyInfoObject).GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var loadPropertyMethod = methods.FirstOrDefault(x =&gt; x.Name == &quot;LoadProperty&quot; &amp;&amp; x.IsGenericMethod);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var cslaPropertyFields = typeof(MyInfoObject).GetFields(BindingFlags.Static | BindingFlags.NonPublic).Where(x =&gt; x.FieldType.GetGenericTypeDefinition().IsAssignableFrom(typeof(Csla.PropertyInfo&lt;&gt;).GetGenericTypeDefinition()));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in cslaPropertyFields)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var current = (IPropertyInfo)(item.GetValue(null));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods.Add(current, loadPropertyMethod.MakeGenericMethod(new[] { current.Type }));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void LoadProperty(IPropertyInfo propertyInfo, object newValue)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods[propertyInfo].Invoke(this, new[] { propertyInfo, newValue });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p></pre></blockquote></p>
<p>The goal here is that instead of creating a generic method to access the property storage every time LoadProperty is called, we create all of the generic methods that will be needed one time at type intialization via a static constructor. We then store those methods in a static dictionary so they can be accessed by all instances of the type. Finally, the LoadProperty method is overridden to look up and invoke methods that are stored in the static dictionary rather than using the base implementation which would run through all the reflection code again.</p>
<p>The results of this experiment were exactly what I expected -- faster performance. The time to load the list was reduced from approximately 3.0 seconds to approximately 1.0 seconds.</p>
<p>This particular scenario was just a test that I setup within our system to gauge performance for loading larger lists. We will have other objects that have roughly the same number of properties that get loaded from the database and may eventually have 10-20x as many records returned once the software is fielded. In the interest of keeping our architecture scalable, we are considering implementing this logic in a generic base class such as this:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;"></p>
<p>public class CustomReadOnlyBase&lt;T&gt; : ReadOnlyBase&lt;T&gt;<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static readonly Dictionary&lt;IPropertyInfo, System.Reflection.MethodInfo&gt; genericPropertyMethods;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static CustomReadOnlyBase()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods = new Dictionary&lt;IPropertyInfo, MethodInfo&gt;();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var methods = typeof(T).GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var loadPropertyMethod = methods.FirstOrDefault(x =&gt; x.Name == &quot;LoadProperty&quot; &amp;&amp; x.IsGenericMethod);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var cslaPropertyFields = typeof(T).GetFields(BindingFlags.Static | BindingFlags.NonPublic).Where(x =&gt; x.FieldType.GetGenericTypeDefinition().IsAssignableFrom(typeof(Csla.PropertyInfo&lt;&gt;).GetGenericTypeDefinition()));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var item in cslaPropertyFields)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var current = (IPropertyInfo)(item.GetValue(null));<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods.Add(current, loadPropertyMethod.MakeGenericMethod(new[] { current.Type }));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void LoadProperty(IPropertyInfo propertyInfo, object newValue)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; genericPropertyMethods[propertyInfo].Invoke(this, new[] { propertyInfo, newValue });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p></pre></blockquote></p>
<p>This would allow all of our business objects to have the same behavior. Because of the way .NET handles static members in generic types, I believe that at run time, each read only business object type, T, would get it&#39;s own generic type, CustomReadOnlyBase&lt;T&gt; , which means we would have one static dictionary of methods for each read only business object.</p>
<p>The fact that this implementation is not already in the CSLA ReadOnlyBase&lt;T&gt; makes me question whether or not this is actually a good idea. The performance benefit in my test scenario was obvious, but I&#39;m curious if there are any other implications that I may have overlooked.</p>
<p>So, while this thread was mostly intended to be a discussion, I do still have 2 questions:</p>
<p>1.) Is there a better way to get the performance increase that we are looking for?</p>
<p>2.) Is there a reason the reflection code was being run in every single call to LoadProperty rather than one time for type initialization? Or, to reword this question, is there a reason I should not create a CustomReadOnlyBase&lt;T&gt; with this implementation?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, April 27, 2012</h2><p>How is your PropertyInfo defined and how do you do data access / loading? <br />Show us your code! </p>
<p>The non-generic LoadProperty should normally only be called for Properties with private backing field. </p>
<p>So the recommended way is like this:</p>
<p><i>&nbsp;&nbsp;&nbsp; public static PropertyInfo&lt;int&gt; IdProperty = RegisterProperty&lt;int&gt;(c =&gt; c.Id);<br />&nbsp;&nbsp;&nbsp; public int Id<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(IdProperty); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set { LoadProperty(IdProperty, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; public static PropertyInfo&lt;string&gt; NameProperty = RegisterProperty&lt;string&gt;(c =&gt; c.Name);<br />&nbsp;&nbsp;&nbsp; public string Name<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(NameProperty); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set { LoadProperty(NameProperty, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private void Child_Fetch(ProjectTracker.Dal.ProjectDto item)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id = item.Id;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// or <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(NameProperty,&nbsp; item.Name);<br />&nbsp;&nbsp;&nbsp; }</i></p>
<p>This code will call the generic LoadProperty as the PropertyInfo&#39;s are generic.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin replied on Monday, April 30, 2012</h2><p>JohnnyBee,</p>
<p>I&#39;d prefer to not post the code because this is an army project and I don&#39;t know exactly what the policy would be for posting source code. That being said, our PropertyInfo fields are defined exactly the same way as what you have in your example. My data access is being done via SQL data reader. Using your example, the code to load the data would look like:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;">private void Child_Fetch(IDataReader dr)<br />{<br />&nbsp;&nbsp;&nbsp; LoadProperty(IdProperty, dr.Item[&quot;Id&quot;]);<br />&nbsp;&nbsp;&nbsp; LoadProperty(NameProperty, dr.Item[&quot;Name&quot;]);<br />}<br /></pre></blockquote></p>
<p>The reason this is using the non-generic version of LoadProperty is because the value returned by DataReader.Item[ ] is always of type object.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, April 30, 2012</h2><p>I don&#39;t quite understand.</p>
<p>This code:</p>
<p>&nbsp; public class ROTest : ReadOnlyBase&lt;ROTest&gt;<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;string&gt; S1Property = RegisterProperty&lt;string&gt;(c =&gt; c.S1);<br />&nbsp;&nbsp;&nbsp; public string S1<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(S1Property); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set { LoadProperty(S1Property, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; public ROTest()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(S1Property, &quot;csla&quot;);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; Csla.dll!Csla.ReadOnlyBase&lt;BusinessRuleDemo.ROTest&gt;.LoadProperty&lt;string&gt;(Csla.PropertyInfo&lt;string&gt; propertyInfo, string newValue) Line 1117&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; BusinessRuleDemo.exe!BusinessRuleDemo.ROTest.ROTest() Line 20 + 0x19 bytes&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; BusinessRuleDemo.exe!BusinessRuleDemo.Program.Main() Line 20 + 0x15 bytes&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; [External Code]&nbsp;&nbsp;&nbsp; <br /></p>
<p>Calls the generic LoadProperty method and does NOT use Reflection in order to set the property.</p>
<p>But if your S1Property is defined as <b>IPropertyInfo </b>as in this sample:</p>
<p>&nbsp; public class ROTest : ReadOnlyBase&lt;ROTest&gt;<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;string&gt; S1Property = RegisterProperty&lt;string&gt;(c =&gt; c.S1);<br />&nbsp;&nbsp;&nbsp; public string S1<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(S1Property); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private set { LoadProperty(S1Property, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; public ROTest()<br />&nbsp;&nbsp;&nbsp; {<br /><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IPropertyInfo myS1Property = S1Property;</b><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(myS1Property, &quot;csla&quot;);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; Csla.dll!Csla.ReadOnlyBase&lt;BusinessRuleDemo.ROTest&gt;.LoadProperty(Csla.Core.IPropertyInfo propertyInfo, object newValue) Line 1165&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; BusinessRuleDemo.exe!BusinessRuleDemo.ROTest.ROTest() Line 22 + 0x14 bytes&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; BusinessRuleDemo.exe!BusinessRuleDemo.Program.Main() Line 20 + 0x15 bytes&nbsp;&nbsp;&nbsp; C#<br />&nbsp;&nbsp;&nbsp;&nbsp; [External Code]&nbsp;&nbsp;&nbsp; <br /></p>
<p>the you will hit the generic LoadProperty that uses Reflection. </p>
<p><b>So please check how your PropertyInfo is declared / passed as parameters!!</b></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin replied on Monday, April 30, 2012</h2><p>The PropertyInfo is definitely declared properly. It&#39;s the second parameter that is causing it to use the non-generic overload.</p>
<p>The signature for the generic is:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;">LoadProperty&lt;P&gt;(PropertyInfo&lt;P&gt; propertyInfo, <b>P</b> newValue)</pre></blockquote></p>
<p>The signature for the non-generic version is:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;">LoadProperty(IPropertyInfo propertyInfo, <b>object</b> newValue)</pre></blockquote></p>
<p>I&#39;ll use a modified version of your example:</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;">public static readonly PropertyInfo&lt;string&gt; S1Property = RegisterProperty&lt;string&gt;(c =&gt; c.S1);<br /><br />public string S1<br />{<br />&nbsp;&nbsp;&nbsp; get { return GetProperty(S1Property); }<br />&nbsp;&nbsp;&nbsp; private set { LoadProperty(S1Property, value); }<br />}</p>
<p>public void ROTest()<br />{<br />&nbsp;&nbsp;&nbsp; LoadProperty(S1Property, &quot;csla&quot;);<br />}</pre></blockquote></p>
<p>In this case, the LoadProperty call is overloaded to the generic version because the type parameter, P,&nbsp; is automatically inferred. S1Property is of type PropertyInfo&lt;string&gt; and the string literal &quot;csla&quot; is of course type string as well so everything matches up.</p>
<p>If we change the last method to instead cast &quot;csla&quot; to an object to simulate how the value would be returned from a data reader, the non-generic overload is called.</p>
<p><blockquote style="overflow-x: scroll;"><pre style="margin: 0px;">public void ROTest()<br />{<br />&nbsp;&nbsp;&nbsp; LoadProperty(S1Property, (object)&quot;csla&quot;);<br />}</pre></blockquote></p>
<p>Now, S1property is still OK as PropertyInfo&lt;string&gt; however, the second parameter, newValue, is now of type object so the signature now matches the non-generic version since the type parameter, P, no longer matches the type of the newValue parameter.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, April 30, 2012</h2><p>That&#39;s part of the reason why CSLA offer the SafeDataRader as a wrapper class for IDataReader..</p>
<p>using the SafeDataReader the code would be:</p>
<p>private void Child_Fetch(SafeDataReader dr)<br />{<br />&nbsp;&nbsp;&nbsp; LoadProperty(IdProperty, dr.GetInt32(&quot;Id&quot;));<br />&nbsp;&nbsp;&nbsp; LoadProperty(NameProperty, dr.GetString(&quot;Name&quot;));<br />}</p>
<p>And your code would use the generic methods.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin replied on Monday, April 30, 2012</h2><p>I set up a test to try out the SafeDataReader implementation to see what the performance benefit of the generic version of LoadProperty. The 5633 records were returned in 0.76 seconds. The problem with this however is that it does not handle nullable properties very well.</p>
<p>For example, we have several properties on this object that are defined as PropertyInfo&lt;int?&gt;. The default behavior of the generic version of LoadProperty will set the value to 0 when the data reader returns DbNull.Value. We actually need the property to be set to null in this case and not 0. The non-generic version of LoadProperty actually does set the value to null in this case.</p>
<p>That being said, one of my teammates is currently looking into updating our code generator to use the generic version of LoadProperty as well as handle the nullable types. That will be our ideal solution since it gives the best performance benefit.</p>
<p>So far from this experiment I&#39;ve seen the following results:</p>
<ul>
<li>The generic implementation of LoadProperty is approximately 394% faster than the non-generic implementation of LoadProperty.</li>
<li>My proposed implementation of the non-generic LoadProperty is approximately 300% faster than current implementation of the non-generic LoadProperty.</li>
<li>The generic implementation of LoadProperty  is still approximately 31% faster than my proposed implementation of the non-generic LoadProperty.</li>
</ul>
<p>Based on these observations, it seems like the generic implementation is still the way to go whenever possible. It also seems like the non-generic implementation that I proposed could be used to significantly reduce the performance gap between the two overloads.</p>
<p>You mentioned that the non-generic implementation of LoadProperty is intended to be used with private backing fields. In one of your other posts <a target="_blank" title="here" href="http://forums.lhotka.net/forums/p/10037/47103.aspx#47103">here</a> you suggested overriding the non-generic LoadProperty method to set the private backing field. It seems to me if you are using a private backing field, you have no concept of the IPropertyInfo interface -- in fact, you shouldn&#39;t need it because it would be simpler to just set the backing field directly. You could create your own implementation to support your private backing fields, but why go through the trouble when you can set them directly and use the generic implementation of LoadProperty to handle all of the managed fields. This leaves me wondering what the actual purpose of the non-generic implementation is in the first place.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, April 30, 2012</h2><p>Any field that will have an authorization or business rule MUST have a registered PropertyInfo.</p>
<p>So the recommended solution is to have all registered properties an use RelationshipType.PrivateFiekd for those that have private backing fields.&nbsp;</p>
<p>When you use AddOutValue in business rules you must overload LoadProperty to set the Private backing field and most likely also for using ObjectFactory data access with private felds.&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin replied on Monday, April 30, 2012</h2><p>Gotcha. That&#39;s the part I was missing when I started wondering why the non-generic implementation was needed.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>asp2go replied on Saturday, April 28, 2012</h2><p>What is the use case for which you require such a huge list to be returned? </p>
<p>&nbsp;</p>
<p>These scenarios should typically be handled by server side/ database paging and filtering which is seamless to the user when done properly.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Sunday, April 29, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>asp2go<br></b>What is the use case for which you require such a huge list to be returned?&nbsp; These scenarios should typically be handled by server side/ database paging and filtering which is seamless to the user when done properly.</div></p>
<p>This is the correct answer, IMO.&nbsp; Its unklikely a user is going to shift through over 5000 records, one at a time. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlhiggin replied on Monday, April 30, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>asp2go<br></b></p>
<p>What is the use case for which you require such a huge list to be returned? </p>
<p>&nbsp;</p>
<p>These scenarios should typically be handled by server side/ database paging and filtering which is seamless to the user when done properly.</p>
<div style="clear:both;"></div>
<p></div></p>
<p>I&#39;m not entirely sure yet whether or not we will actually need to return this many records at once. This thread was the result of an experiment to see if our application could handle that number of records gracefully and so far the answer is no. Right now, I&#39;m simply exploring our options to see how we can improve our performance for returning data from tables that may contain a large number of records.</p>
<p>If we decide that handling the issue at the app server or database level is the way to go, then we may implement that in the future. However, the focus of this thread is the performance of the LoadProperty method and improving this performance will be beneficial regardless of whether or not we decide to handle large data sets server side or client side.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
