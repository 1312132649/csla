<html><header><title>CSLA simple unit testing</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA simple unit testing</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9566.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>j0552 posted on Wednesday, September 22, 2010</h2><p>Hi</p>
<p>I&#39;m struggling with how to do some unit testing with CSLA. Most of my BOs use Linq to SQL in the DataPortal_xyz methods, somewhat like the ProjectTracker examples. </p>
<p>Is it possible to create unit tests without modifying the BOs? I assume not unless I was to use TypeMock. A developer licence is $799.00. That&#39;s way outside my budget!</p>
<p>I&#39;m really only concerned with testing the BO and any child objects. There could be validation using CommandObjects which access the database. Also I think I need a way of setting up a custom BusinessPrincipalBase object too.</p>
<p>Are there any examples of unit testing with something like the ProjectTracker samples? What&nbsp;can you recommend?&nbsp;</p>
<p>Thanks<br />Andrew</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, September 22, 2010</h2><p>Realistically, you have to build your BO&#39;s to be &quot;testable&quot; at the start.&nbsp; The ProjectTracker example does not do that, so in that sense it&#39;s not a good template to use.</p>
<p>In your case, that means (at a minimum) moving your LINQ-to-SQL code out of your BO DP methods and into a separate DAL.&nbsp; However, getting testability that&#39;s &quot;simple&quot; mean you&#39;ll want&nbsp;to build that&nbsp;DAL such that you can build out a mock DB layer in your unit tests, which generally means you need to put a set of interfaces &quot;in front&quot; of your real DAL coding.&nbsp; That way, when you create your test cases with NUnit, MSTest, or whatever, you can inject your mock objects as your DAL instead of your real ones.</p>
<p>FWIW, Rocky&#39;s MVVM videos show how to do this pretty neatly using Bxf.&nbsp; The videos talk about testing the ViewModel, but the same basic principles would apply here.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Wednesday, September 22, 2010</h2><p>Well, what I do is use a unit testing framework, but do integration testing. Part of our build scripts creates a database with test data for testing. Then we use a Transaction Rollback to rollback the data to a known state. Some unit testing frameworks have this built in with a Rollback attribute. It&#39;s worked really well for us even in very large projects with over 3000 unit tests (takes about 4-6 minutes to run all the tests). Personally, I find integration testing to be more useful/valuable in terms of time spent vs unit testing (personal opinion,&nbsp;definitely&nbsp;not in the majority..)</p>
<p>HTH</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>triplea replied on Thursday, September 23, 2010</h2><p>If the issue with testing is how to mock the DB I think this is covered in the Data Access vieo: <a href="http://download.lhotka.net/Default.aspx?t=SLVid0106">http://download.lhotka.net/Default.aspx?t=SLVid0106</a></p>
<p>But otherwise I am also in favour of integration testing the way <strong>xAvailx </strong>described it. It does take longer (around 10-15 min for the full ~3000 unit tests) but I did not really optimise them so there might be ways of reducing the times. It does allow for thourough testing though and the results are really good.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>j0552 replied on Thursday, September 23, 2010</h2><p>Hi there</p>
<p>I guess it would be too much work now to move the Linq to SQL stuff out of the DP methods and create the necessary interfaces to mock the DAL properly. </p>
<p>I think the xAvailx approach should work very well for our application. The only downside I see is a delay in running the tests which is more than compensated for by not having to modify the BOs.</p>
<p>Thank you.<br />Andrew</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, September 23, 2010</h2><p>I had to do this myself actually.&nbsp; Its not too much trouble.&nbsp; Basiclly you create an interface like this:</p>
<p>public interface IDataBase : IQueryable&lt;Table1&gt; { get; } IQuerable&lt;Table2&gt; { get; } void SubmitChanges(); void InsertOnSubmit&lt;T&gt;(T entity); // etc. }</p>
<p>You would also need something&nbsp; like ContextManager, but instead of DataContext return IDataBase.&nbsp; This is likely where you&#39;d also use something like StructureMap to create the concreate instance.</p>
<p>It seems to work pretty well so far.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
