<html><header><title>Dollard on code generation</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Dollard on code generation</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/601.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams posted on Wednesday, July 12, 2006</h2><P>I know Kathleen Dollard's book on code generation uses CSLA as the target context.&nbsp; It's also my understanding that she takes the approach that applications should be designed and generated from a business functionality standpoint rather than interpreting or mapping tables into objects like all the rest of them seem to do.&nbsp; </P>
<P>I am an avid supporter of this concept.&nbsp; I also am strongly considering implementing code generation in the major application project about to launch.</P>
<P>So, I'm planning to order her book.&nbsp; I wondered if anyone here has had experience with the book and her generator and could give feedback.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Wednesday, July 12, 2006</h2><P>Don't have her book, but I listened in to a presentation she did about code generation.&nbsp; She's a very sharp individual with a wealth of practical knowledge to share on the topic.&nbsp;</P>
<P>I would expect her book to be equally useful.&nbsp; She did mention in her talk that she wanted to rewrite on of her chapters based upon new insights, so you might want to send her an email to see if she'll send you an electronic copy of the relevant insights.&nbsp;&nbsp;&nbsp;&nbsp; <A href="http://www.gendotnet.com">www.gendotnet.com</A></P>
<P>She also has a free code generation framework you can download.&nbsp; Some very&nbsp;nice features to it.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RRorije replied on Wednesday, July 12, 2006</h2>Hi, the URL you have given, does not seem to work. For me anyway.<br><br>I am also very interested in comments about the book. I am thinking of buying it some time now, but I have not done it yet.<br><br>googling on the book I found a very positive article about the book: <br><br>http://knowdotnet.com/articles/codegenerationdotnet.html<br><br>Sorry, I am being impatient. The URL seems to work now.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Wednesday, July 12, 2006</h2>




<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>I read the book and loved it.&nbsp; But it was a pretty 
tough read.&nbsp; </FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>The book teaches you the choices she made and tools she 
built to create her "generation harness."&nbsp; And they and it are 
awesome.&nbsp; If you aren't an XML guru, she has a great minimalist 
introduction to the topic in an appendix which is really required reading since 
she uses XSLT for much of the harness.&nbsp; </FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>She was talking about doing a book that focused on USING 
the harness more and less on BUILDING it.&nbsp; But I think she has dropped that 
notion.</FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>It was great as an introduction to the topic and gives you 
a great perspective with which to evaluate other tools, too.&nbsp; I think 
everyone doing, or considering, code generation can get some value from 
it.</FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>Another individual here, whose name I can find for you, 
implemented that harness and has (I'm pretty sure) both C# and VB versions for 
CSLA 1.x.&nbsp; But I got an email from him recently and he seems to be heading 
to new worlds with a new application generation tool that may have some 
merit.&nbsp; So he likely is NOT going to do 2.x.&nbsp; Maybe you can handle 
that??? &lt;g&gt;&nbsp; I only found out about his project (and had him send it 
to me) after I had already started down the road of comparing CodeSmith and 
MyGeneration.</FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>You've probably seen my comments on the Dollard engine here 
in other posts so I won't go into detail.&nbsp; But my bottom line is that I 
don't think it's a good match for small programming shops.&nbsp; It's a little 
too technically challenging for that IMHO.&nbsp; If you can work efficiently in 
it an hour or so every two or three weeks, more power to 
you.</FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2>And, if you want his generation harness project, let me 
know and I'll send it along (probably best to a private e-mail 
address).</FONT></SPAN></DIV>
<DIV align=left><SPAN class=906434413-12072006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>msk replied on Wednesday, July 12, 2006</h2><P>QJohnson, Yes I would agree entirely - a good book that tackles&nbsp;the difficult issues facing 'code genners' and yes&nbsp;- a&nbsp;tough read too.&nbsp; </P>
<P>Dan, You may be a little challenged by Kathleen Dollard's take on generating from objects rather than from the database.&nbsp; She takes the pragmatic view that databases tend to exist already and contain a wealth of meta data.&nbsp; She chooses to infer much of her object structures and relationships&nbsp;from the database, only describing where the object model differs from the database.&nbsp; This doesn't preclude the use of a more purist approach, but it does mean that the tools used in the book are more suited to code gen where the database exists already.&nbsp; The concepts discussed in the book remain valid.&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rohancragg replied on Thursday, July 13, 2006</h2>msk's comments agree exactly with my experience of the book. While it was an excellent and informative read I have not ended up using her framework either for the reasons msk highlights above.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Wednesday, July 12, 2006</h2><P class=MsoNormal>Very good book.&nbsp; Recommend it but ignore the ORM section.&nbsp; Don't even try to read it. She has said multiple times that it is awkward and not really worth the effort. But it has been a year since I have read it and new editions may be better.<o:p></o:p></P>
<P class=MsoNormal>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>I don't think the primary value of the book is any particular method but instead the concepts that she uses.&nbsp; One of the main concepts being that it is the Metadata that should drive code generation and that there are numerous sources for this metadata.&nbsp;Database schemas, object interfaces, UML diagrams, hand written files etc.&nbsp; In the end, though, all these sources are probably insufficient for code generation and none match up well with one another.&nbsp; Therefore you should create your own schema then transform the other sources to match yours.<o:p></o:p></P>
<P class=MsoNormal>&nbsp;<o:p></o:p></P>
<P class=MsoNormal>I have built my own based on her ideas and suggestions and am very happy with the results.<o:p></o:p></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Wednesday, July 12, 2006</h2><P>&gt;&gt;&nbsp; In the end, though, all these sources are probably insufficient for code generation and none match up well with one another.&nbsp; Therefore you should create your own schema then transform the other sources to match yours.&nbsp; I have built my own based on her ideas and suggestions and am very happy with the results. &lt;&lt;</P>
<P><O:P>This is exactly why I prefer MyGeneration to CodeSmith.&nbsp; The MyMeta tool makes it so easy to expand your sources of meta data beyond just the tables in a database (although I don't see a way to do it <STRONG>entirely</STRONG> without one).&nbsp; This thing is so powerful in version 1.1.6 that I expect a truly superior product in 2.0. (Maybe the ability to get metadata from a UML source or some other architect/design type products.)&nbsp; </O:P></P>
<P><O:P>And who knows, it may still be free even then &lt;g&gt;.</O:P></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>y0mbo replied on Wednesday, July 12, 2006</h2>I am currently reading her book over my lunch breaks.&nbsp; I'm not very far, only Chapter 2 (of 11). <br><br>She outlines three different methods of code generation:<br>1. Brute force - where you write code that creates code by directly writing the source files.<br>2. CodeDOM - you write code that generates the code using Visual Studio's CodeDOM.<br>3. XSLT - using XML transforms to create the code.<br><br>In all three cases, her source metadata file is created in XML.<br><br>It appears her preference is XSLT.&nbsp; I've done a few projects using XML/XSLT, so I am familiar with how this works, so that option also appeals to me.&nbsp; In the past, I have used Codesmith and Brute Force methods to generating the code.&nbsp; My biggest gripe is how closely tied to the database either of these options are.&nbsp; The XSLT option also allows you to change the template script without recompiling (the other two options are hard-coded, so there's not as much flexibilty).<br><br>I would agree with other posters that this is a dense, technical topic that is not for the junior programmer.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Wednesday, July 12, 2006</h2>I read the book last summer and found the ideas in it to be really good, but I found the implementation in of the code gen harness to be really lacking.&nbsp; My main gripes came from the following:<br><ul><li>Metadata still comes from a database by default</li><li>ORM was written by hand when it did not match the database</li><li>Parent-child relationships cannot be inferred from the database without adding some additional metadata somewhere</li><li>At the last point I looked at it (last autumn) you still could not generate working object graphs with it</li></ul>In the end, I took the concepts from Kathleen's book and wrote my own metadata program that lets you describe the objects and map them to a data source.&nbsp; I then use CodeSmith to generate my stored procedures and the business objects and, when applicable, database tables and foreign keys.&nbsp; Some of the best ideas that I got out of her book were the use of the templated methods and overriding stored procedures and other database objects.<br><br>CodeSmith does not have to work off a database.&nbsp; I drop the business object library from my program into the Addins directory and the CodeSmith templates use the business objects loaded from the metadata file as their data source.<br><br>I personally found CodeSmith to be much easier to work with than XSLT, especially in the use of whitespace, and I have yet to find anything that XSLT can do that cannot be duplicated in CodeSmith.&nbsp; CodeSmith and MyGeneration are only as tied down to a database as you choose to make your templates, and the CodeSmith templates require no more recompilation than XSLT.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, July 13, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Brian Criswell:</strong></div><div>My main gripes came from the following:<BR>
<UL>
<LI>...
<LI>Metadata still comes from a database by default
<LI>...
<LI>Parent-child relationships cannot be inferred from the database without adding some additional metadata somewhere</LI></UL>
<P>...I personally found CodeSmith to be much easier to work with than XSLT, ...</div></BLOCKQUOTE></P>
<P>Metadata has got to come from somewhere!&nbsp; Database definitions are a "poor man's meta-data repository".&nbsp; If that's all you have, it's better than nothing.</P>
<P>If you've got a meta-data repository tool that contains the extra information, and it can act as the datasource for generating&nbsp;your database definitions as well as your class definitions, go for it.&nbsp; </P>
<P>Parent-child relationships can be inferred somewhat more easily if you are consistent in your naming or if you use natural keys instead of computer-generated id columns for the pk.&nbsp; </P>
<P>If part of my PK is a FK to your PK, then I'm much more closely related to you than if I just have an FK column sitting around outside my PK.&nbsp;&nbsp; Natural keys are "out of style" nowadays, so that's a less useful technique than it used to be.&nbsp; </P>
<P>Naming conventions can also be used to deduce the difference between a parent-child relationship and a simple "I use one of them" relationship.&nbsp; Consider Customer and Invoice Header, or Invoice Header and Invoice Line Item.&nbsp; If we use appropriate naming conventions, we can deduce that Invoice Header is a parent of Invoice Line Item, whereas Customer is merely used by Invoice Header.&nbsp; Invoice Type is not a parent of Invoice Header, because Invoice Type contains a "meta-data identifer&nbsp;word" (Type) in its name whereas Invoice Header does not.&nbsp; Tables with words like type, category or group usually refer to application meta-data (reference code) tables whereas tables without those words are more likely to contain "real" user-data.&nbsp; It's a fairly rare case where we would want to change meta-data and user data in the same program.&nbsp; Those are jobs for people with entirely different skill sets and responsibilities ("system architect" vs. "data entry clerk").&nbsp; Invoice Type and Invoice SubType would have a parent-child relationship because they are both meta-data tables.</P>
<P>Hope that gives folks some ideas.&nbsp; In the past, I've found that a parent-child true/false tag added to the relationship meta-data is a really good match with the above naming convention/key deductions.&nbsp; The tags are added only to change the default deduced behavior.&nbsp; That way, you don't have to add lots of tags where it's obvious what you want it to do, you only have to do data entry to record the exceptions.</P>
<P>As for working with XSLT, other than for simple stuff, I think I would rather go to the dentist every day to get my teeth drilled.&nbsp; For simple stuff it's pretty cool, but for complex stuff it's just plain unpleasant for me to work with.&nbsp; </P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
