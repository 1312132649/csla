<html><header><title>Confusion - static Fetch, or Constructor?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Confusion - static Fetch, or Constructor?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/295.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>M&Ns posted on Tuesday, June 06, 2006</h2><P><FONT face=Arial color=#000080 size=2>Hi Everybody,</FONT></P>
<P><FONT face=Arial color=#000080 size=2>I'm confused regarding some of the examples I seen on ProjectTracker vs contents of the book, would appreciate if someone could enlighten me :</FONT></P>
<P><FONT face=Arial color=#000080 size=2>In the book, we see that a ReadOnlyList populates the ReadOnlyChild by invoking the static method ReadOnlyChild.GetReadOnlyChild(datareader), and GetReadOnlyChild in turn creates a new object which invokes the constructor, and the method Fetch(datareader).</FONT></P>
<P><FONT face=Arial color=#000080 size=2>But in the real implementation of ProjectList and ProjectInfo, what happen was the constructor was invoke instead, with the values retreived pass in as the parameters. </FONT></P>
<P><FONT face=Arial color=#000080 size=2>ProjectInfo info = new ProjectInfo(dr.GetGuid(0),&nbsp;dr.GetString(1));</FONT></P>
<P><FONT face=Arial color=#000080 size=2>Both may be doing the same thing - creating a child object and populate the values, but is there any difference? Would there&nbsp;be a poorer performance in the&nbsp;first implementation as compared to the second one, since we're passing around the datareader's reference? Which method do you guys normally used? I personally feel that the second implementation looks much cleaner and saves some code.</FONT></P>
<P><FONT face=Arial color=#000080 size=2>can someone advise on this? Thanks!</FONT></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Massong replied on Wednesday, June 07, 2006</h2><P class=MsoNormal><SPAN>Hi,<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>I used the first implementation like <EM>ReadOnlyChild.GetReadOnlyChild(datareader)</EM> in my CLSA 1.x projects and I remember this from the examples of the old book. Now, where I change all my classes to the new CLSA 2.0 framework anyway, I also change the implementation to <EM>myReadonlyChild = new ReadOnlyChild(datareader)</EM>. There should be no better or worse performance, but like you said, the code looks much cleaner.<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal><SPAN>Greetings,<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN>Christian<o:p></o:p></SPAN></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 07, 2006</h2><P>I'd originally done this by calling the constructor directly. The technical reviewers for the book (at least one of them anyway <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />) disliked this approach because the resulting code doesn't fit into the standard regions I set up in Chapter 6.</P>
<P>Ultimately I do think you should do the actual data loading in a Fetch() method in the Data Access region. And this should be called from your constructor. Whether the parent collection calls that constructor directly, or calls a factory method is (I think) relatively immaterial - it comes down to a matter of style and consistency.</P>
<P>On the whole I do think I favor the factory approach, even though it costs 3 more lines of code, because it provides consistency across all objects in terms of how they are created - but again, that's a matter of style as much as anything.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
