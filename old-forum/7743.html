<html><header><title>Need original property value in DataPortal_xyz and Child_xyz methods</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Need original property value in DataPortal_xyz and Child_xyz methods</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7743.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>j055 posted on Wednesday, October 07, 2009</h2>Hi<br /><br />I'm using 3.7.1. <br /><br />Is there a way without too much work to get original values from managed properties?<br /><br />I want to check equality of old and new values and then log to the database. <br /><br />This isn't really for auditing purposes. There's a specify business use in the object that requires this. <br /><br />A simple example or any better suggestions would be great.<br /><br />Thanks<br />Andrew</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 07, 2009</h2>Jason Bock recently blogged about how to do this. It requires creating your own subclass for PropertyInfo&lt;T&gt; and FieldData&lt;T&gt;, which allows you to manage field values as you choose.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, October 07, 2009</h2>Here is my implementation of this (simpler and more space efficient than implementing your own IFieldData class IMHO):<br /><br />http://forums.lhotka.net/forums/post/24445.aspx<br /><br />Basically, you override OnPropertyChanging() and, if you haven't previously cached the original value, you save the current property value -- before the pending property change is applied -- in a dictionary as the original value. <br /><br />We use this for at least 3 purposes: field-level concurrency in database updates, auditing, and the ability to determine if a property is "really" dirty in business rules (e.g. it handles the case when the user changes something and then changes it back to the original value). <br /><br />The nice thing about it is that there is no impact at all unless a property is changed -- the cache is lazy instantiated -- and then the space requirement is roughly proportional to the number of changed properties. You don't have to double the size of your object (unless, of course, you change every property :)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>j055 replied on Thursday, October 08, 2009</h2>I'm struggling to make much sense of any of this. I suppose what I'm trying to achieve is a method like ReadOriginalProperty or GetOriginalProperty for the business developer to use without needing to know what's going on underneath.<br /><br />Jason Bock seems to be doing much more than sub classing PropertyInfo and FieldData and I'm not sure if that's really necessary for my needs.  As long as the business developer (which is me) can <br />get the original value with a simple method call by using  a sub classed businessbase they can make a decision about what to do with it.<br /><br />I know I could easily create fields for original values in the business class but that seems a little crude to say the least, however it may be the quickest to implement unless you can convince me otherwise :) !!<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, October 08, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>j055:</strong></div><div>I'm struggling to make much sense of any of this. I suppose what I'm trying to achieve is a method like ReadOriginalProperty or GetOriginalProperty for the business developer to use without needing to know what's going on underneath.</div></BLOCKQUOTE><br /><br />That's exactly what the minimal plumbing in my solution is for. You implement an intermediate base class derived from BusinessBase<> to house the original value cache, and then derive objects that require original property caching from that class. If you use CSLA managed properties, then the plumbing works for free. (Otherwise, you have to call OnPropertyChanging in your setters, but that's a code generation issue)<br /><br />In my case, I implement two methods along the lines of what you are asking for:<br /><br />IsDirtyProperty(propertyname) - just returns true if the property is actually different from the original value<br /><br />IsDirtyProperty(propertyname, out originalValue) - returns true if the property has changed and also gives you the original value as an output parametr.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>j055 replied on Thursday, October 08, 2009</h2>Had another look at your code and starting to understand a bit better. For my use I override OnPropertyChanging:<br /><br />        protected override void OnPropertyChanging(string propertyName)<br />        {<br />            base.OnPropertyChanging(propertyName);<br /><br />            if (!IsNew &amp;&amp; !String.IsNullOrEmpty(propertyName))<br />            {<br />                object oldValue = GetPropertyValue(this, propertyName);<br />                CacheValue(propertyName, oldValue);<br />            }<br />        }<br /><br />and created a ReadOriginalProperty method which gets the cached value:<br /><br />        protected object ReadOriginalProperty(IPropertyInfo propertyInfo)<br />        {<br />            if (((propertyInfo.RelationshipType &amp; RelationshipTypes.LazyLoad) != 0) &amp;&amp;<br />                !FieldManager.FieldExists(propertyInfo))<br />                throw new InvalidOperationException("Property get not allowed");<br /><br />            IFieldData info = FieldManager.GetFieldData(propertyInfo);<br />            if (info != null)<br />            {<br />                if (_valueCache != null &amp;&amp; _valueCache.Contains(info.Name))<br />                {<br />                    object cachedValue = _valueCache[info.Name];<br />                    if (!Equals(cachedValue, info.Value))<br />                        return cachedValue;<br />                    return info.Value;<br />                }<br />            }<br />            return null;<br />        }<br /><br />Seems to work with initial testing. At least I can see how things are supposed to fit together a bit better now. <br /><br />Thanks for your help<br />Andrew</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
