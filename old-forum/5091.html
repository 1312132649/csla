<html><header><title>AsyncRuleHandler signature - feedback solicitation</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>AsyncRuleHandler signature - feedback solicitation</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5091.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>justncase80 posted on Monday, July 14, 2008</h2>Hello everyone!<br><br>&nbsp;&nbsp; I am currently working with Rocky on CslaLight and I am working on implementing the ability to have async validation rules. Currently it is mostly working with only a few details left to flesh out. One of these details is the signature of the AsyncRuleHandler delegate.<br><br>&nbsp;&nbsp; To do things asynchronously we have found that we needed to split the argument parameter into an object specifically for "inargs" and one for "outargs". There is also a delegate passed into the method that needs to be called when your asynchronous operation completes successfully. An example implementation of this method might be:<br>
<pre>private static void Rule1(<br>   object target, <br>   AsyncRuleArgs inargs, <br>   AsyncRuleResult outargs, <br>   AsyncRuleResultHandler result)<br>{<br>   BackgroundWorker worker = new BackgroundWorker();<br>   worker.DoWork += (s, e) =&gt;<br>   {<br>      string propertyName = inargs.PropertyName;<br>      object foo = ((Rule1Args)inargs).Foo; // use custom rule args<br><br>      // some asyncrhonous work will be done...<br>      e.Result = true;<br>   };<br>   worker.RunWorkerCompleted += (s, e) =&gt;<br>   {<br>      outargs.Result = (bool)e.Result;<br>      result(outargs);<br>   };<br><br>   // simulating an asynchronous process.<br>   worker.RunWorkerAsync();<br>}<br></pre>
This is interesting because an "outargs" object is passed into the method with defaults such as Severity, Description, PropertyName, etc. But it is also passed back into the result delegate and handled by the broken rules collection.<br><br>There is one alternative to this approach that is, technically, equivalent but is somewhat different stylistically. What I would like to do is show you the alternate scheme and solicit feedback on which of the two is superior and, perhaps, if there is a better scheme that anyone can come up with while still being technically feasible.<br><br>The other approach is to add the inargs and the result handler as members of outargs so your handler might look more like this:<br>
<pre>private static void Rule1(<br>   object target,<br>   AsyncRuleResult r)<br>{<br>   BackgroundWorker worker = new BackgroundWorker();<br>   worker.DoWork += (s, e) =&gt;<br>   {<br>      string propertyName = r.Args.PropertyName;<br>      object foo = ((Rule1Args)r.Args).Foo; // use custom rule args<br><br>      // some asyncrhonous work will be done...<br>      e.Result = true;<br>   };<br>   worker.RunWorkerCompleted += (s, e) =&gt;<br>   {<br>      r.Result ( (bool)e.Result ); // the delegate is on args<br>   };<br><br>   // simulating an asynchronous process.<br>   worker.RunWorkerAsync();<br>}<br></pre>So the question really is, what is more intuitive? What would you prefer to see? Is it intuitive enough to have a method on the incoming argument that must be called, or is it more clear to have it as it's own parameter? Should the incoming arguments be associated with the result object, or is it more clear to be a seperate parameter? What is better, simplicity or being explicit?<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 15, 2008</h2><P>Another option might be to have a method on the args to do the callback in an even more abstract manner:</P>
<BLOCKQUOTE dir=ltr>
<P>r.Complete(true);</P></BLOCKQUOTE>
<P>So really there are at least three options:</P>
<OL>
<LI>callback(outargs); // call delegate directly; delegate is an argument</LI>
<LI>args.Result(true); // call delegate directly, delegate exposed from args</LI>
<LI>args.Complete(true); // call method that calls delegate behind the scenes</LI></OL>
<P>I kind of lean toward option 3 because it totally hides the delegate and potentially provides the best abstraction.</P>
<P>But we've posted this thread to solicit input from others in the community, so chime in if you have an opinion - otherwise you'll have to live with our choice :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 15, 2008</h2><P>I guess some more context might be in order - come to think of it.</P>
<P>In Silverlight all server communication is asynchronous. That's just the way it is.</P>
<P>So CSLA Light has an asynchronous data portal. Instead of Fetch(), there's BeginFetch() with an asynchronous callback that occurs when the operation is complete.</P>
<P>To keep parity, CSLA .NET 3.6 also has an asynchronous data portal - as an option. It has the same API as the CSLA Light version. That's pretty cool by itself imo :)</P>
<P>Sometimes you write a validation rule that has to talk to the server. Perhaps an Exists() check that runs a stored procedure via a Command object or something like that. This is not uncommmon.</P>
<P>Since the data portal is async, this means that the <EM>validation rule must be async too</EM>!!</P>
<P>That's a problem, because the validation rules subsystem is all synchronous now. So Justin has put a lot of work into enabling async rules alongside the sync rules.</P>
<P>The end result is that you can either write a sync rule like today, or an async rule. If you write an async rule, then in the callback you need to tell CSLA Light that the rule is complete - and that's the question here - how do you tell CSLA that the rule is complete (and that it succeeded or failed)?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, July 15, 2008</h2><P>I lean towards #3 also. </P>
<P>I&nbsp;prefer to hide as much complexity as possible. </P>
<P>Keep things as simple looking as possible on the surface.</P>
<P>Joe</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
