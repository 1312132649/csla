<html><header><title>Should I postpone MVVM for now?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Should I postpone MVVM for now?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9692.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Dedrik posted on Sunday, October 31, 2010</h2><p>Some facts first, I am somewhat familiar with the CSLA, somewhat familiar with WPF and not familiar at all with the MVVM pattern, but nevertheless, I am starting a new WPF project that uses the CSLA framework.</p>
<p>In order to try to do the best job I can and not bite more than I can chew, I am thinking of bypassing implementing the MVVM pattern for now and just code the application&nbsp; the old fashion way.</p>
<p>I expect the project to take me about 6 months to complete and during those 6 months I expect to spend considerable amount of time digging dipper into the CSLA/WPF. My hope is that by the end of the 6 months I would have gained enough understanding of the CSLA/WPF technologies that retrofitting the MVVM into the project would be easier for me then.</p>
<p>So I am looking for some advice: </p>
<p><br />*)&nbsp;Is it stupid for me not to start using the MVVM pattern right from the beginning?<br />*)&nbsp;Is it a good idea to delay implementing the MVVM patter for now?</p>
<p>Any advice is greatly appreciated.</p>
<p>Thanks.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Sunday, October 31, 2010</h2><p>Personally I find that the primary benefit of at least basic use of MVVM is that it simplifies my coding effort. Less code, less effort, more productivity. The other benefits like testability are nice as a bonus.</p>
<p>I think the trick to making it reasonably approachable is to avoid being dogmatic. I&#39;ve been quite dogmatic - <em>zero code-behind</em> is my continual goal. But I&#39;m very experienced with CSLA (I hope :) ) and pretty darn good with XAML. So I feel comfortable pursuing this relatively high goal.</p>
<p>But you don&#39;t need to. You can pursue a goal of <em>minimizing code-behind</em>, and follow the mantra that any code-behind is nothing more than glue between the view and viewmodel. That avoids a whole host of advanced XAML concepts you otherwise need to know how to implement (custom controls, attached properties, etc) - without radically compromising the MVVM benefits or overall architecture.</p>
<p>The risk, of course, is that you&#39;ll allow non-glue code to sneak into your code-behind - but as long as your goal is always there, that shouldn&#39;t get too bad.</p>
<p>In short - there are a number of issues you have to solve to really use WPF - including navigation, hookup of the view to the model (or viewmodel), etc. The best solution I&#39;ve seen to these problems is my approach to MVVM - with or without a little code-behind here or there.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
