<html><header><title>BindingSourceNode, adding item to child collection programatically</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>BindingSourceNode, adding item to child collection programatically</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7585.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Tuesday, September 08, 2009</h2>Hi,<br /><br />I'm trying to solve a problem some of my users are having... very odd things that I can't reproduce (as usual).  The problem is that sometimes it seems that what is in the grid on the screen doesn't match whats in memory.  The grid can't remove the row because the "index is out of range," stuff like that.<br /><br />So I'm trying to replace my manual binding / unbinding with BindingSourceNode.  Seems to work fine (well, for me, the same as it was), but I'm hitting a problem I'm not sure how to get around.<br /><br />I have a requirement where uses can rightclick one of the rows in the Addresses grid and say Copy as Billing, Copy as Shipping, etc.<br /><br />This operation works fine, until I have, when I hit an EditLevelMismatch (Edit level mismatch in AcceptChanges) exception.<br /><br />This is the code on how I add the row... the BSN says to only interact via that class with the BO... but I don't see how I can accomplish what I want in that case?<br /><br />        private void CloneAddressAs( string addressType ) {<br />            UltraGridRow row;<br />            ContactAddress address;<br /><br />            if ( AddressGrid.Selected.Rows.Count > 0 ) {<br />                row = AddressGrid.Selected.Rows[ 0 ];<br />            <br />                address = row.ListObject as ContactAddress;<br /><br />                if ( address != null ) {<br />                    address = address.GetCopy();<br />                    address.AddressType = "";<br />                    AddressesBindingSource.Add( address );<br />                    address.AddressType = addressType;<br />                }<br />            }<br />        }</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>miguelcastro67 replied on Tuesday, September 08, 2009</h2>I'm not sure I understand completely, but why don't you work only with your CSLA collection.  If it's bound to a bindingsource it should carry through and onto the grid, should it not?  Can you explain a little better?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, September 09, 2009</h2>Because if you leave the BindingSource out of the equation, it gets confused, and your UI then gets confused.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Wednesday, September 09, 2009</h2>Hi, <br><br>I don't think this is related to the BindingSourceNode at all. It has to to do with databinding in WindowsForms and Csla. <br><br>The IndexOutOfRange <b><i>can </i></b>be triggered from a bug in FilteredbindingList/SortedBindingList on some rare occations. <b>This bug is fixed so grab the lastest version of these classes in Csla 3.7.1 (or 3.8.0) and update your Csla version</b> (triggered because the ItemChanged uses a faulty itemnumber in event to notify the grid of new item - so that when trying to delete the new item the itemnumber does not match the underlying list) . <br><br>You could try to add the following code to your BusinessListBase class: <br><br>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>&nbsp;&nbsp;&nbsp; /// Adds a new item to the end of the collection.<br>&nbsp;&nbsp;&nbsp; /// Uses DataPortal to create instance of Child object so the BO <br>&nbsp;&nbsp;&nbsp; /// developer will no longer need to override this method in BO List<br>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;<br>&nbsp;&nbsp;&nbsp; /// The item that was added to the collection.<br>&nbsp;&nbsp;&nbsp; /// &lt;/returns&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;exception cref="T:System.InvalidCastException"&gt;<br>&nbsp;&nbsp;&nbsp; /// The new item is not the same type as the objects contained in the &lt;see cref="T:System.ComponentModel.BindingList`1"/&gt;.<br>&nbsp;&nbsp;&nbsp; /// &lt;/exception&gt;<br>&nbsp;&nbsp;&nbsp; protected override object AddNewCore()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var item = DataPortal.CreateChild&lt;C&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add(item);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return item;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br>&nbsp;&nbsp;&nbsp; /// Adds an object to the end of the &lt;see cref="T:System.Collections.ObjectModel.Collection`1"/&gt;.<br>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br>&nbsp;&nbsp;&nbsp; /// &lt;param name="item"&gt;The object to be added to the end of the &lt;see cref="T:System.Collections.ObjectModel.Collection`1"/&gt;. The value can be null for reference types.&lt;/param&gt;<br>&nbsp;&nbsp;&nbsp; public new void Add(C item)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set parent reference<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.SetParent(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set child edit level<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Core.UndoableBase.ResetChildEditLevel(item, this.EditLevel, false);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // when an object is inserted we assume it is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // a new object and so the edit level when it was<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // added must be set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.EditLevelAdded = _editLevel;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.Add(item);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InsertIntoMap(item, IndexOf(item));<br>&nbsp;&nbsp;&nbsp; }<br><br>These 2 functions makes the<br><ul><li>bindingSource.AddNew() work without extra code in AddNewCore in your own BO lists<br></li><li>overrides the Add method to keep editLevel on new child in sync with the list.</li></ul>Assuming that address.GetCopy() does a Clone() of the original object&nbsp; I would also suggest that you make sure to call BindingSource or GridView EndEdit() method before you call GetCopy so that the EditState of the CurrentRow is not included in the copy. <br><br>/jonnybee<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, September 09, 2009</h2>I'm already on the latest 3.7 release, so that's not the issue.<br /><br />Adding the BindingSourceNode is an attempt to correct the IndexOutOfRangeException, which I actually haven't been able to reproduce myself.<br /><br />The EditLevelMismatchException is caused by the code I've posted..<br /><br />I think I found a "solution," which is to just set the AddressType prior to adding the instance to the collecton.  I'm still verifying if this works though, because I have rules over the collection, which is why I think I was doing it the way I was.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
