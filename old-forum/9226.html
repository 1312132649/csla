<html><header><title>Initializing Child Collection Objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Initializing Child Collection Objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9226.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil posted on Monday, July 19, 2010</h2><p>Example:</p>
<p>If I have root object (Employee) that has a child collection of objects (Addresses) and the child collection objects (Address) is tied to the root object (Employee) by a guid used as an identification value such that Employee.Id = Address.ParentId.&nbsp;&nbsp;&nbsp;How do I go about populating the ParentId on the Address object?</p>
<p>For example, if a new Employee object is created it will create a new Addresses collection.&nbsp; If the user were to use a grid to create a new address for that collection how is the Employee.Id value passed to the new Address object in the Addresses collection?&nbsp;&nbsp; The Addresses.NewAddresses does take arguments and the AddNewCore() routine (when bound to a datagrid) doesn&#39;t take arguments either.</p>
<p>I&#39;ve been working around this problem by either using Addresses.GetAddresses factory method (even when the Addresses is a new collection on a new Employee object)&nbsp;because that allows parameters.&nbsp; I set a property on the Addresses collection object so that when AddNewCore() is called that value is available for the creation of a child Address object.&nbsp;&nbsp; This all seems so bootleg to me - there must be a better way to populate child collection objects with the Id of the parent object so that the objects are all tied together.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, July 19, 2010</h2><p>A &quot;typical&quot; solution is to utilize the Parent property to walk up the object hierarchy and get the&nbsp;GUID when you need it.&nbsp; While the Parent property on your Address object is the containing collection, the collection also has a Parent property that would point to your Employee object.&nbsp; That way you don&#39;t have to store the GUID on your Address object at all.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, July 19, 2010</h2><p>Scott is correct, though the Parent properties aren&#39;t public prior to CSLA 4, so you need to &quot;re-expose&quot; the property value to gain access in earlier versions.</p>
<p>However, for something like a &quot;foreign key&quot; value as you describe, I don&#39;t have my child objects maintain that at all. That&#39;s not an object oriented sort of thing - it is a relational sort of thing. So I just pass the parent (and thus its key value(s)) to the child objects when I save them (in the DataPortal_Update() methods).</p>
<p>You can see examples of this in the <i>Expert 2008 Business Objects</i> book and in ProjectTracker (and I&#39;m sure in several other samples - this is always the way I handle this sort of thing).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil replied on Wednesday, July 21, 2010</h2><p>Hmmm... that is interesting - I may have learned a little something there about properly programming objects.&nbsp;&nbsp; Thank you for the lesson.&nbsp; I&#39;ll apply it immediately.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DanB replied on Wednesday, July 21, 2010</h2><p>I&#39;ve wrestled with this in my mind.&nbsp; I can&#39;t seem to get my head around the value of doubling or tripling (or worse) the object graph being sent across the wire&nbsp;to maintain&nbsp;OO purity.&nbsp; It seems to me to be kind of a fine line at the end of the day to say relating an object to another via a reference to the other object is&nbsp; different than relating it via the ID of the other object.&nbsp; I guess I mean from a pragmatic perspective it just seems like OO purity for OO purity&#39;s sake, at the expense of performance.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 21, 2010</h2><p>If I have an OrderEdit-&gt;LineItems-&gt;LineItemEdit scenario, there&#39;s absolutely zero value in the LineItemEdit objects maintaining an OrderId property. That value will be the same in every child object, and will be serialized back and forth over the network, but it has no value.</p>
<p>Why?</p>
<p>Because the relationship between OrderEdit and its LineItemEdit objects flows naturally from the structure of the object graph. We <i>inherently know</i> that each LIneItemEdit is a child of a specific OrderEdit - that relationship is literally hardcoded into the object model.</p>
<p>So why would I pay the price in terms of serialization overhead, and complexity of maintaining this OrderId property when I don&#39;t have to? That seems entirely counter-productive to me.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DanB replied on Wednesday, July 21, 2010</h2><p>I have code somewhere that is responsible for adding LineItemEdits, and it certainly knows what OrderEdit it is currently dealing with.&nbsp; Setting the property when the LineItemEdit is created is one line of code.&nbsp; What other &quot;complexity&quot; do you mean?</p>
<p>We&#39;re probably not disagreeing fundamentally, but speaking at a conceptual level...</p>
<p>I don&#39;t disagree at all with the accuracy or appropriateness of what you said, but consider that&nbsp;OrderEdits are likely associated with a Customer, and let&#39;s say like all objects in&nbsp;the application that is&nbsp;associated with a Division, which in turn associated with a Company because the app is multi-company... would you normally start every object graph in the application with a CompanyEdit?&nbsp; At some point don&#39;t you break the chain and establish some parent context in code by setting a property instead of having Parent properties go all the way to a CompanyEdit every time?</p>
<p>So, aren&#39;t we free, and even required,&nbsp;to decide the root of the object graph to&nbsp;best supports a particular use case (including performance, not just OO purity)?&nbsp; Aren&#39;t I always deciding whether a collection is edited through its editable parent... OR ... that the best option overall is a dynamic list used by some managing code that has to set the parent ID when adding new items?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marjon1 replied on Wednesday, July 21, 2010</h2><p>In a normal Parent-Child-Grandchild scenario, the entire object graph containing all 3 objects is sent at the time of calling the relevant DataPortal_XYZ method as part of the save. Therefore when the child or grandchild are passed the any of the 3 objects, &nbsp;there is no additional serialization / network traffic.</p>
<p>The concept of storing an ID, really only works well for the likes of GUID&#39;s otherwise there is a bit more complexity of getting that information into the children objects after the parent has saved and then using it as part of their inserts / updates instead of just always using the Parent.ID value. </p>
<p>Seems more likely to introduce some weird bugs (i.e. an Id isn&#39;t correctly set on a child object or is moved to another list without changing the ID value).</p>
<p>Relating the objects by reference enforces the relationship, if the child is removed from the parent then there is no more relationship; if you add an ID into the mix, then you must also remember to remove this part of the relationship and it becomes your way of&nbsp;identifying the&nbsp;relationship. The fact that it is attached to a parent becomes secondary, which I think is what you want to avoid.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DanB replied on Wednesday, July 21, 2010</h2><p>Well, I thought about this more after my last post, and Marjon&#39;s response confirms to me that we&#39;re saying two different things.&nbsp; In cases where we&#39;re creating the entire object graph I don&#39;t disagree with any of what&#39;s been said.</p>
<p>Let me try my point a different way...</p>
<p>Simply put, in cases where we DON&#39;T need to send the entire object tree to the server anyway, should we favor or strive for designs where we can minimize the traffic?</p>
<p>So, think of a case where you have a Customer which has a child collection of Contacts, each with a child collection of PhoneNumbers.&nbsp; The Customer also has a collection of Addresses.&nbsp; Do we really want to send a graph of 20 objects to the server to change one phone number?</p>
<p>(And yes, by the way, I&nbsp;prefer GUID IDs.&nbsp; I admit and agree&nbsp;my response was tainted by my routine use of them.)</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 21, 2010</h2><p>In this case, you might want to look at the diffgram sample app. It allows for voluntary enlistment by objects in terms of being transferred (in whole or part) to the server, while maintaining (to some degree) the logical structure of the object graph.</p>
<p>When using the diffgram approach, the parent would enlist and provide its key, so the server code (in the DAL) would have access to that key without the need to duplicate that value into every child over the wire.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
