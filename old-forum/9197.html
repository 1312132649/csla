<html><header><title>How to create a custom authorization rule</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How to create a custom authorization rule</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9197.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>mattruma posted on Saturday, July 10, 2010</h2><p>I am working with CSLA 4.0 and would like to allow user to delete records, but only if they are the owner of the record. </p>
<p>I have a property on my object called OwnerId and my custom BusinessIdentity also has a property for UserId ... so I have the criteria to make the comparison, just at a lost at how to implement this exactly.&nbsp; I&#39;m thinking I would just create a new class that inherits Csla.Rules.AuthorizationRule, but struggling after this part.</p>
<p>Any help would be appreciated!</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Sunday, July 11, 2010</h2><p>That&#39;s true, you just subclass AuthorizationRule (or directly implement IAuthorizationRule).</p>
<p>The key is to implement the Execute() method and set context.HasPermission to true or false.</p>
<p>You can use context.Target and/or context.TargetType, plus any of your own properties you define on your type to make the decision about whether to return true or false for HasPermission.</p>
<p>Then just attach the rule to the property(ies) you want to authorize and you should be set.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, July 11, 2010</h2><p>I should point out that context.Target is not always available. It is only available if there&#39;s an actual business object instance present when the permission is checked.</p>
<p>It is not available, for example, for create/fetch operations, or for immediate delete. In none of those cases does a business object exist at all when the permission is being checked.</p>
<p>It is available for save and deferred delete operations, as well as per-property rules, because in those cases a business object does exist so there&#39;s something to be provided in the Target property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mattruma replied on Friday, July 16, 2010</h2><p>Thanks for the response Rocky! Is there an example of this in any of the sample projects?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Saturday, July 17, 2010</h2><p>I don&#39;t think so, though I know Jonny did recently add a sample that demonstrates all the new business rule features, so maybe he included custom authz rules too - I haven&#39;t looked at that sample yet.</p>
<p>I know there&#39;s at least one unit test that uses a custom authz rule, but that&#39;s a test and not a sample, so it may or may not be real useful to you.</p>
<p>Have you looked at this blog post: <a href="http://www.lhotka.net/weblog/CSLA4AuthorizationRules.aspx">http://www.lhotka.net/weblog/CSLA4AuthorizationRules.aspx</a>&nbsp;? </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mattruma replied on Saturday, July 31, 2010</h2><p>I am still struggling with this ... I need to make sure a user can fetch a specific instance of an object ... since the fetch method is static should I just put my check in the FetchObject method? Not sure if the current authorization rules will support this edge case.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, July 31, 2010</h2><p>Blocking the fetch of a <i>specific instance</i> requires that you write code in your server-side fetch method.</p>
<p>There&#39;s no way for the CSLA authorization rules to do this, because they run earlier - when there is no instance of the object yet.</p>
<p>Though that&#39;s an interesting idea.</p>
<p>Right now the data portal runs the rules on the client side, before invoking the server - which is good, because it avoids server calls we know will fail.</p>
<p>But the data portal could run the rules <i>a second time</i> after the create/fetch operations. In this case it would be running the rules on the server. They&#39;d be the same rules of course - but in this second run, a reference to the actual business object would be provided to the rules.</p>
<p>I suppose in the case of failure on the server, the data portal would then throw a SecurityException or something like that, so the data portal call would fail and the exception would be returned to the client - following the normal behaviors of the data portall.</p>
<p>I think I&#39;ll add this to the wish list, as it seems (at least right now, before I&#39;ve had my morning coffee) like this could work.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
