<html><header><title>memory leak - part 2</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>memory leak - part 2</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1317.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>mheere posted on Monday, September 25, 2006</h2><P><FONT face=Arial size=2>Further to my earlier post of a memory leak and 'blaming' the CSLA framework I know have found out that this may be a pure Windows problem.<BR>The problem is - and let me focus on the CSLA part - that when you repeatedly call for a Business Object (BO) that collects its data from various sources and passes it back to the client the memory you use increase. However, when this BO goes out of scope (and you do the Dispose()&nbsp;etc.) you would expect the memory to have gone down to what it was before.<BR>However, what happens here is that I am having to repeatedly call a BO which therefore causes my app to run eventually out of memory.&nbsp;<BR>A remarkable thing to note&nbsp;is that if you minimise and then restore the app it will bring the memory right down again - and so it continues.</FONT></P>
<P><FONT face=Arial size=2>The amazing thing is that this seems to apply to all Windows apps.&nbsp; Start Word, type away, check the Task Manager's memory consumption for this app, now minimise/restore the app and the memory will have come right down.</FONT></P>
<P><FONT face=Arial size=2>This behaviour seems to be known (</FONT><A href="http://www.dotnet247.com/247reference/msgs/35/178959.aspx"><FONT face=Arial size=2>http://www.dotnet247.com/247reference/msgs/35/178959.aspx</FONT></A><FONT face=Arial size=2>) but what I don't understand is that this phenomenon&nbsp;is killing my app so this <STRONG>MUST</STRONG> also happen to other people!</FONT></P>
<P><FONT face=Arial size=2>Has&nbsp;anyone got any suggestions?</FONT></P>
<P><FONT face=Arial size=2>Cheers</FONT></P>
<P><FONT face=Arial size=2>Marcel.</FONT></P>
<P><FONT face=Arial size=2></FONT>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Monday, September 25, 2006</h2><P>Need some clarification here.</P>
<P>First, you wouldn't normally need to implement Dispose() in a BO.&nbsp; Do you have an unusual BO?</P>
<P>Are you using .NET 2.0?&nbsp; According to the link you gave it seems the options are either upgrading to 2.0 or coding some memory management (UGH!) into this stuff you're writing.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, September 25, 2006</h2>If you are implementing the full Dispose pattern, that would include implementing a finalizer. Objects with finalizers are reclaimed by the GC much slower than objects without a finalizer.<br><br>Which is a way of saying that you should avoid implementing the Dispose pattern if you can avoid it!<br><br>You should only implement Dispose/finalizer methods for objects that contain "expensive" resources - like file handles, synchronization primitives, database connections and things of that nature. And then only if those are <i>instance-level</i> fields.<br><br><br>The other issue you are running in to, and this is common across Windows and most other modern operating systems that use virtual memory, is the concept of a "working set". Processes are allowed a certain number of pages of memory they can use. A process can exceed that amount of memory, but the extra pages can be (and likely will be) written out to the page file. The working set is maintained in memory.<br><br>There are other thresholds too - both at the Windows and .NET levels.<br><br>The GC comes in two flavors - client and server. The client version is designed to minimize visible impact to the user, so it tries to only run when it needs to, and when the application is idle. It is also the case that the Windows memory management/paging subsystem flushes the working set in a way to minimize visible impact on the user. Hellen Custer's book on Windows NT (maybe it has been updated since, I don't know) covers this in some detail.<br><br>(as an aside, this mechanism came from OpenVMS on the VAX, and has changed little over time)<br><br>The point being, Windows and .NET are managing the memory on your behalf, following a set of rules. Understanding those rules can help you minimize the impact. The biggest thing you can do is avoid implementing Dispose/finalize on objects unless it is actually necessary.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mheere replied on Wednesday, September 27, 2006</h2><P>Thanks for the quick reply Rockford!&nbsp; After&nbsp;more than a day&nbsp;checking all sorts I&nbsp;found that the problem is probably with the Oracle driver I am using - vs.10.2.0.100.&nbsp; This driver loses memory in the following scenario:</P>
<P>A business object has returned a DataSet to the client.&nbsp;Sending this DataSet directly back to the database seems to&nbsp;cause the leak!!&nbsp;I store the DataSet readymade&nbsp;as a BLOB in the database (for good reasons!! - since&nbsp;I may have manipulated and added lots of additional disparate data into the DataSet).<BR></P>
<P><U>Wrong code (causes the memory leak)</U>:&nbsp; '<FONT color=#008080 size=2>Reports' is the BusinessObject </FONT><BR><FONT color=#008080 size=2>DataSet</FONT><FONT size=2> ds = </FONT><FONT color=#008080 size=2>Reports</FONT><FONT size=2>.ReportRunGetOwnerInfo(EntityType, EntityCode).Results;&nbsp;&nbsp;&nbsp;&nbsp;// retrieves the data<BR></FONT><FONT size=2> </FONT><FONT color=#008080 size=2>Reports</FONT><FONT size=2>.SaveBlobReturnKey(ds);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// saves the DataSet as a blob</FONT></P>
<P><U>Correct&nbsp;code (no leak)<BR></U><FONT size=2><FONT color=#008080>DataSet</FONT> ds = <FONT color=#008080>Reports</FONT>.ReportRunGetOwnerInfo(EntityType, EntityCode).Results;<BR><FONT color=#008080>DataTable</FONT> dtTmp = ds.Tables[0];<BR>ds.Tables.Remove(dtTmp);<BR><FONT color=#008080>DataSet</FONT> dsNew = <FONT color=#0000ff>new</FONT> <FONT color=#008080>DataSet</FONT>();<BR>dsNew.Tables.Add(dtTmp);<BR><FONT color=#008080>Reports</FONT>.SaveBlobReturnKey(dsNew);</FONT></P>
<P>Can you or anyone shine a light on what might be happening here?</P>
<P>Cheers</P>
<P>Marcel</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, September 25, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>mheere:</strong></div><div>However, when this BO goes out of scope (and you do the Dispose()&nbsp;etc.) you would expect the memory to have gone down to what it was before.</div></BLOCKQUOTE><br><br>This isn't quite right, IIRC.&nbsp; The grabage collector in .Net is very <b><i>very </i></b>lazy.&nbsp; It usually won't do anything until you're almost out of memory, which may take quite a while because of virtual memory.&nbsp; Its lazy because collecting garbage is an expensive operation which would degrade the performance of your (and all) .Net applications.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>mheere:</strong></div><div>However, what happens here is that I am having to repeatedly call a BO which therefore causes my app to run eventually out of memory. </div></BLOCKQUOTE><p>Are you actually getting an out of memory exception?<br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>mheere:</strong></div><div>A remarkable thing to note&nbsp;is that if you minimise and then restore the app it will bring the memory right down again - and so it continues.</p>
<p>The amazing thing is that this seems to apply to all Windows apps.&nbsp; </div></BLOCKQUOTE></p><p>This is true of all windows applications and as far as I know is by design.&nbsp; The amount of memory actually doesn't change; the amount of working memory does.<br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>mheere:</strong></div><div>Start Word, type away, check the Task Manager's memory consumption for this app, now minimise/restore the app and the memory will have come right down.</div></BLOCKQUOTE></p><p>Ahhh!!&nbsp; Task Manager is NOT a valid way to determine how much memory an application is using.&nbsp; This is <a href="http://www.itwriting.com/dotnetmem.php">well documented</a>.<br></p><p></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>mheere:</strong></div><div>This behaviour seems to be known (<a href="http://www.dotnet247.com/247reference/msgs/35/178959.aspx">http://www.dotnet247.com/247reference/msgs/35/178959.aspx</a>) but what I don't understand is that this phenomenon&nbsp;is killing my app so this MUST also happen to other people!</div></BLOCKQUOTE></p><p>If your application is running out of memory, its likely because somewhere, somehow you're not disposing of IDisposable objects properly, and / or you aren't releasing all references to objects (Csla based or not) you are using.&nbsp; Check with a fine toothed comb.</p>HTH<br>Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
