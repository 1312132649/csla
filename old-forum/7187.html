<html><header><title>Guidance on MVVM inspired ideas</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Guidance on MVVM inspired ideas</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7187.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Paul Czywczynski posted on Sunday, June 28, 2009</h2>Rocky, a while ago you mentioned you wanted to see where VS2010 is
going regarding the MVVM paradigm. I am not trying to jump on the
popularity wagon with MVVM I do like the advantage of unit testing the
different layers. <br><br>When we started our app WPF was beta and MVVM was a glimmer in a guy's blog post. Currently we're still developing against CSLA 3.0.4 but are planning to move to 3.6 soon. This weekend I decided to start prototyping some of the MVVM features in our old application. My goal is to be able to write a unit test for our CSLA object (done...) and make a form that didn't have a code-behind file but instead use a ViewModel and unit test it. <br><br>Currently I am at a crossroads. Should I use a CslaDataProvider/ObjectDataProvider? In our app we use the DataProviders so we don't have to write async code for working with data. Although with 3.6 I know you have written your own async code to deal with Silverlight and we plan to utilitze that once we move to 3.6. So with 3.6 and a ViewModel do we need to utilize the CslaDataProvider anymore? Seems to me that CslaDataProvider's commands could be replaced with the ViewModel.<br><br>In my prototype ViewModel I have my ReadOnlyList wrapped in a ListCollectionView because I need the ViewModel to act upon selected items. Should I set the form's datacontext directly to the ViewModel and write my own async code until we upgrade to 3.6 or use a CslaDataProvider with IsAsync=true instead? <br><br>I am looking for guidance on how to reach my goals.<br><br>form &lt;-&gt; CslaDataProvider &lt;-&gt; ViewModel &lt;-&gt; CslaObject<br>&nbsp; (I am not sure how to get the commanding to work between the CslaDataProvider and ViewModel yet)<br><br>form &lt;-&gt; ViewModel &lt;-&gt; CslaObject<br><br>or stick with what we have been doing for years<br><br>form w/ code-behind &lt;-&gt; CslaDataProvider &lt;-&gt; CslaObject<br><br>-Paul<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, June 28, 2009</h2><P>I just wrote this in a <A HREF="/forums/post/34224.aspx">non-related thread</A> (so it kind of got buried):</P>
<P>The question is <EM>which</EM> MVVM pattern? There are several variants with different pre-conditions and consequences.</P>
<P>Many of the MVVM pattern variants assume an anemic Model, such as a bunch of DTO/proxy/entity objects you get back from calling a service or something like EF or L2S. Those variants require that you do a lot of work in the VM to overcome the lack of functionality in the Model, and that's fine.</P>
<P>However, CSLA .NET ensures that your Model is far from anemic. In fact, it is incredible rich, with the DataTable being the only thing I know of that comes close. Fortunately there are variants of MVVM where the VM exposes the Model as a property, along with various methods (commands) that can be bound to buttons, etc.</P>
<P>That type of MVVM implementation works really well with CSLA .NET.</P>
<P>On the other hand, if you use one of the "anemic model" variants of MVVM with CSLA objects, you'll have to do <EM>more</EM> work in your VM or sacrifice a lot of functionality. Your VM could have to implement and delegate (bi-directionally) all the data binding interfaces, authorization, business rule and other functionality that is built directly into CSLA.</P>
<P>In <EM>either</EM> case (anemic or rich Model), if your object graph is complex (parent-child-grandchild-etc) your VM can become incredibly complex very rapidly, as you try to flatten or duplicate the shape of the Model.</P>
<P>I've had people argue that the point of the VM is to "reshape" the Model for the UI. And I agree that if your Model was not designed using good OOD (is data-centric rather than respnsibility-driven) then your VM will probably have to do that - which is really lame, and simply means you did a crappy job with your object model.</P>
<P>On the other hand, if you use responsibility-driven design for your business objects, your object model should naturally follow the shape of the use case, as should the UI. Since they follow the same use case, the objects should <EM>already be the right shape</EM>.</P>
<P>Lots of opinion there, but that's my current way of thinking about MVVM.</P>
<P>Yes it is good. Some variants work really well with CSLA. Other variants cause you to do so much work that I can't possibly imagine it is of long-term benefit.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, June 28, 2009</h2><P>Or to put it another way - I think the MVVM pattern is a fine thing. I think the data provider model is not all that different, because a data provider control is just a simple VM.</P>
<P>CslaDataProvider, in particular, is a pretty decent VM for common view/edit screen scenarios.</P>
<P>I much prefer the CslaDataProvider in CSLA .NET for Silverlight, because it isn't constrained by the pre-built data provider model in WPF. The WPF data provider base class is really a limiting factor.</P>
<P>Also, I much prefer the InvokeMethod implementation of commanding that we put into Silverlight, because it is a lot more flexible and powerful than commanding (and at the same time is simpler).</P>
<P>I really don't want CSLA to become a UI framework&nbsp;- my goal has always been to support Microsoft's plumbing (data binding and related components like data providers, data sources, etc).</P>
<P>However, the MVVM pattern today is so incredibly immature that you have to create everything from scratch. And that sucks. I personally don't want to spend that much time writing pages and pages of expendable UI code (because the V and VM are both UI elements).</P>
<P>In other words, I really think MVVM needs to grow up, and be componentized and RADified before I'll find it to be really compelling.</P>
<P>And to answer your other question - I haven't had time to play with the XAML data binding support in VS10, so I don't know if they use MVVM or not. But clearly <EM>my</EM> primary goal will be to make sure CSLA objects play very well with the VS10 designers. </P>
<P>I won't try to make MVVM bad, but until it shows signs of increasing productivity and reducing code, I can't get too excited about it.</P>
<P>All <EM>that</EM> said, I could certainly see something like the Silverlight CslaDataProvider and InvokeMethod controls being added to Csla.Wpf. I'd have to call the data provider something else (CslaObjectManager?), but those two things work so nicely in Silverlight that I really miss them when I have to do any WPF work these days.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
