<html><header><title>How to handle non-serializable exceptions in general way?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How to handle non-serializable exceptions in general way?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11025.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Wednesday, December 28, 2011</h2><p>I have a case where we are using a third-pary component server-side that throws non-serializable exceptions -- none of the custom exceptions implemented by this component are serializable. I did some searching and found Andy&#39;s suggestion to overrride DataPortal_OnDataPortalException()&nbsp;here: </p>
<p><a href="http://forums.lhotka.net/forums/p/5286/25662.aspx#25662">http://forums.lhotka.net/forums/p/5286/25662.aspx#25662</a></p>
<p>However, I&#39;m having a little trouble understanding how that would work. In the version of CSLA I am using (3.5), the SimpleDataPortal seems to unconditionally rethrow the original exception and ignore anything that happens while invoking DataPortal_OnDataPortalException, so I can&#39;t see how to &quot;replace&quot; the original exception with one that is serializable without modifying the SimpleDataPortal implementation. </p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Wednesday, December 28, 2011</h2><p>Yes, that is hard to create in 3.x. </p>
<p>One option is to have your own exception handling in the data access code - catch the non-serializable exceptions and rethrow a new serializable one. . </p>
<p>In 4.0 and onwards you have the IDataPortalExceptionInspector and the Samples\Net\Cs\CustomeErrorHandling shows how to plug into the DataPortal pipeline and log and/or transform the&nbsp; non-serializable&nbsp; exception. </p>
<p>You should be able to downport til to Csla 3.5 or create your own alternative mplementation.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, December 28, 2011</h2><p>OK, thanks. I&#39;ve been backporting selected features for a while as needed so that may be a good approach here. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, December 29, 2011</h2><p>OK, it was trivial to backport the IDataPortalExceptionInspector support back to 3.5, but the plot seems to thicken. </p>
<p>It seems like you can&#39;t really test an Exception for serialization very well.&nbsp; I&#39;m considering just trying to serialize it directly and catching the exception as a method of determing whether it is truly serializable. Is there a better (less expensive?) way?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, December 29, 2011</h2><p>I made the simple assumption to check if the Exception class (and inner exceptions) had Serializable attributte.&nbsp;</p>
<p>The safe and expensive alternative is to serialize the Exception graph and catch serilization exception.&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 29, 2011</h2><p>You can also look at the Silverlight data portal, because no exceptions are serializable in that case. So we always serialize server exceptions. You might find the existing data structure and code to copy the exception data to be useful.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, December 29, 2011</h2><p>Those are both good ideas. I was lamenting the loss of detail (particularly the stack trace) when replacing the unserializable exception, so any solution that might let me capture more information will be an improvement. </p>
<p>Thanks!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
