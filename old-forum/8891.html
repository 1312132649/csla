<html><header><title>Some Web Service DTO questions</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Some Web Service DTO questions</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8891.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ltgrady posted on Thursday, May 06, 2010</h2><p>We have an app using an older version of CSLA. &nbsp;We&#39;ve been working mostly with asp.net forms and we&#39;ve done some web service work but they&#39;re not integrated as much as we would like. &nbsp;We&#39;re working on a new module of the system and we need to expose the same methods via web service as we provide in our forms. &nbsp;So I&#39;m trying to keep as much code in the BL as I can and integrate/re-use code a lot more than we have previously.</p>
<p>Our web services all use DTO parameters, unless there is only 1 or 2 parameters. &nbsp;So if I have a method called addOrder there would be addOrder(dtoOrderItem) and dtoOrderItem will hold all of the parameters for the order we&#39;re trying to create. </p>
<p>A few questions....</p>
<p>1. &nbsp;In the past in my web service .cs file i&#39;ve created an instance of the OrderItem.cs CSLA BO and then looped through dtoOrderItem plugging the values from one to the other. Then in the asp.net form I just create the CSLA BO and load it with form data and save it. &nbsp; &nbsp;However, now that I&#39;d like to create a single AddOrder item for both forms and services I&#39;m wondering if I should just pass the DTO straight into AddOrder BL method and load a DTO in the forms code behind and pass it into the same object. &nbsp;This would centralize the code, however I&#39;m afraid it adds complexity when dealing with required fields and error reporting.</p>
<p>2. &nbsp;Is there a better way to transfer data from DTO to CSLA BO than looping through and mapping properties &nbsp;BO.Name = DTO.Name. &nbsp;Especially when i pass in collections, like AddOrders(dtoOrderItemCollection) I&#39;m wondering if looping through the collection and assigning every property across objects is the most efficient method. &nbsp;Maybe I&#39;m missing something very obvious.</p>
<p>3. &nbsp;How do you deal with required fields and data validation in DTO&#39;s. &nbsp;There is no code allowed. &nbsp;So if I have a web service to add an order and 5 of the properties are required in the dtoOrderItem DTO and 3 aren&#39;t, how do I enforce that validation? &nbsp;Just return an error in the service if they don&#39;t provide it? &nbsp; I thought there may be some way to include some kind of validation specification in the wsdl, but I don&#39;t think there is.</p>
<p>Thanks for any help or advice you can provide.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, May 06, 2010</h2><p>To maintain decoupling and separation of layers, the business object should be unaware of the DTO types. So your existing model is correct.</p>
<p>If you think about the service as being an interface, just like a web or Windows interface, then making the business type aware of the DTO type is like making the business type aware of your web form - total violation of the layer boundary.</p>
<p>You can use Csla.Data.DataMapper to reduce the mapping code, but the mapping still really needs to happen.</p>
<p>In terms of validation, as the author of a service you are defining an interface that is used by your consumers (whoever they are). Your interface consists of:</p>
<ul>
<li>operation contract (your methods)</li>
<li>data contracts (your DTOs)</li>
<li>fault contracts (failure results)</li>
</ul>
<p>Think about it this way. When a user interacts with your Windows Forms UI and they type something into the form, there are really two possible results: success (the form accepts the value) and failure (the form indicates to the user that the value is bad).</p>
<p>When a consumer calls a service there are really two possible results: success or failure. Both are part of the contract.</p>
<p>In WCF the concept of a fault contract is a first-class citizen. In asmx that&#39;s not true, but the idea remains valid. Failure shouldn&#39;t result in an exception - it should result in the service returning a failure result as part of its overall contract.</p>
<p>Consider a service operation that returns a value:</p>
<p>public MyResult MyOperation(MyRequest request)</p>
<p>That operation might succeed - returning a valid MyResult. But it might fail too - for numerous reasons.</p>
<p>In asmx, MyResult should be able to express failure as well as success.</p>
<p>In WCF MyResult can express just success, and you can attach a formalized fault to the operation (using an attribute), and the fault can return a different data contract (DTO) containing the failure informaiton.</p>
<p>The point being that success and failure are both formally part of your contract - but the implementations vary a bit depending on the technology you are using.</p>
<p>The trick with WCF is that most consumers (other than WCF on the client) can&#39;t handle faults. They are part of the WS-* specs, but few service stacks handle them. So the asmx model is the only one that works universally....</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ltgrady replied on Thursday, May 06, 2010</h2><p>Understanding it like that makes quite a bit more sense to me than how I was thinking. &nbsp;Practically speaking my agreement with people using my web service is that I&#39;m either going to provide the expected result set if what they submitted to me was valid and successful or I&#39;m going to provide a separate response if what they&#39;ve submitted was invalid and caused a failure.</p>
<p>My question at this point is applying it in my situation. &nbsp;If I am specifying a specific return object type, how do I return a failure object instead?<br /><br />Stripped down example of my code&nbsp;</p>
<p>&nbsp;&nbsp; &nbsp;[System.Xml.Serialization.XmlInclude(typeof(dtoOrderItem))]<br />&nbsp;&nbsp; &nbsp;[SoapHeader(&quot;Credentials&quot;)]<br />&nbsp;&nbsp; &nbsp;public dtoOrderItem getOrder(Guid orderID)</p>
<p>
<p>&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Login();<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;dtoOrderItem oi = Order_GetOrder(orderID);<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;return oi;<br />&nbsp;&nbsp; &nbsp;}</p>
</p>
<p>if the Order did not exist or there was some error I would want to return a dtoFailure object<br />&nbsp;&lt;dtoFailure&gt;<br />&nbsp;&nbsp; &lt;errorMsg&gt;&nbsp;<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Error does not exist for the ID you provided<br />&nbsp;&nbsp;&lt;/errorMsg&gt;<br />&nbsp;&lt;/dtoFailure&gt;&nbsp;</p>
<p>How do I return that when I&#39;ve specified dtoOrderItem as the return type?</p>
<p>&nbsp;</p>
<p>Also, in the case of adding an order where the dtoOrderItemAdd object has 10 fields, I understand the concept that validation happens on my end and I return back either a success (a new Order ID) or a failure (dtoFailure object). &nbsp;However, is there some vehicle to define for the person consuming my service that the 4 of those 10 fields are required? &nbsp;Does it become trial and error for them otherwise to submit items and keep getting back errors until they realize Field A is required, Field B can&#39;t be longer than 30 characters, Field C needs to be a date? &nbsp;Is that just a question of documentation outside of the wsdl?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, May 06, 2010</h2><p>I tend to define my return value data contract like this:</p>
<p>public class OrderitemResult<br />{<br />&nbsp; public dtoOrderItem { get; set; }<br />&nbsp; public ErrorInfo { get; set; }<br />}</p>
<p>That&#39;s what gets returned from the service. If the service succeeds, ErrorInfo is null, and dtoOrderItem is not. If the service fails then ErrorInfo is not null and dtoOrderItem is null.</p>
<p>This opens up for the answer to the second part of your question - which is how to handle more complex error results - since &quot;ErrorInfo&quot; can be an arbitrarily complex DTO type - even a list of success/fail results if you&#39;d like.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ltgrady replied on Thursday, May 06, 2010</h2><p>That&#39;s a great solution, thanks Rocky.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
