<html><header><title>CSLA Light: Question regarding exception handling in DataPortalClient.WcfProxy</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Light: Question regarding exception handling in DataPortalClient.WcfProxy</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5384.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb posted on Thursday, September 11, 2008</h2>This is a question for the Magenic guys primarily.<br><br>I ran into an interesting issue today while debugging a problem in one of my callback methods.<br><br>Basically my callback method was halfway through exception following a successful dataportal fetch and was then throwing up an unhandled exception.<br>Now I expected this exception to bubble all the way up to a "critical error" handler I had implemented on the Silverlight App class (i.e. the UnhandledException event on the App was attached to Application_UnhandledException in my App.xaml.cs).<br><br>Problem was that instead of the exception percolating up, I found that my callback method <i>was being called again</i>.<br>This was kind of weird but it became clear why this was happening when I stepped through line by line into the WcfProxy to the code below:<br><br><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; private void proxy_FetchCompleted(object sender, Csla.WcfPortal.FetchCompletedEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error == null &amp;&amp; e.Result.ErrorData == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var buffer = new System.IO.MemoryStream(e.Result.ObjectData);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var formatter = new MobileFormatter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T obj = (T)formatter.Deserialize(buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _globalContext = (ContextDictionary)MobileFormatter.Deserialize(e.Result.GlobalContext);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(obj, null, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (e.Error != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ex = new DataPortalException(e.Error.ToErrorInfo());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (e.Result.ErrorData != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ex = new DataPortalException(e.Result.ErrorData);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InvalidOperationException("Server must return an object or an error");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</font><br><br>My issue with the above is that the exception handler will be hit, even if the exception comes from within the <font size="2" face="Courier New">OnFetchCompleted</font> method (i.e. from within my callback).&nbsp; So the exceptions never percolate past the WcfProxy up to the Application_UnhandledException in the Silverlight App.<br>Then to compound my issue, the exception handler then proceeds to invoke the callback <b>again</b>, this time with a blank result, which really isn't great if the exception occurred inside the callback in the first place.<br><br>Now I know what I could do is implement try catch blocks within all my callbacks, and I'm OK with that if this is the desired pattern you guys want CSLA to enforce.&nbsp; <br>But obviously this is extra work I didn't necessarily want to be doing, plus having catchall try blocks in each callback doesn't look very nice to me.<br><br>I'd like to suggest modifying the above WcfProxy code, moving the exception handler to only trap issues encountered with the code prior to invoking the callback method.<br>So something like this:<br><br><font size="2" face="Courier New">private void proxy_FetchCompleted(object sender, Csla.WcfPortal.FetchCompletedEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error == null &amp;&amp; e.Result.ErrorData == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var buffer = new System.IO.MemoryStream(e.Result.ObjectData);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var formatter = new MobileFormatter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T obj = (T)formatter.Deserialize(buffer);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _globalContext = (ContextDictionary)MobileFormatter.Deserialize(e.Result.GlobalContext);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(obj, null, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (e.Error != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ex = new DataPortalException(e.Error.ToErrorInfo());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (e.Result.ErrorData != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ex = new DataPortalException(e.Result.ErrorData);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnFetchCompleted(new DataPortalResult&lt;T&gt;(default(T), ex, e.UserState));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InvalidOperationException("Server must return an object or an error");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br></font><br>This way the exceptions continue up the stack, and there isnt a risk of a callback being invoked twice.<br><br>Thanks<br><br>Paul<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
