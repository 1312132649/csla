<html><header><title>Child Objects remaining Dirty after Update/Save</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Child Objects remaining Dirty after Update/Save</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5320.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Galen posted on Friday, August 29, 2008</h2>Hello,<br><br>This is my first time posting but I have utilized the information on these forums for a few years now and would firstly like to thank everyone for the contributions.<br><br>I've recently started using CSLA 3.6.0 for a hobby project. I haven't used CSLA since version 2 and i'm having problem with a child collection not setting the IsDirty=false to each of it's items during an update.<br><br>A summary of my structure is as so:<br><br>//Root Class<br>public class Property : BusinessBase&lt;Property&gt;<br><br>//Root Class - Property<br>private static PropertyInfo&lt;Collections.PropertyFlorae&gt; PlantsProperty = RegisterProperty(new PropertyInfo&lt;Collections.PropertyFlorae&gt;("Plants"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Collections.PropertyFlorae Plants <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(FieldManager.FieldExists(PlantsProperty)))&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty&lt;Collections.PropertyFlorae&gt;(PlantsProperty, Collections.PropertyFlorae.NewPropertyFlorae());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetProperty&lt;Collections.PropertyFlorae&gt;(PlantsProperty);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>//Root Class -- DataPortal Update Method<br>[Transactional(TransactionalTypes.TransactionScope)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void DataPortal_Update()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var ctx = ContextManager&lt;NativeScape.Data.NativeScapeDataContext&gt;.GetManager(NativeScape.Data.Database.NativeScape))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsSelfDirty)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // insert project data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx.DataContext.updateProperty(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;int&gt;(IdProperty),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;string&gt;(TitleProperty),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;int&gt;(ProfileIdPRoperty),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;SmartDate&gt;(CreatedProperty));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // update child objects<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //DataPortal.UpdateChild(ReadProperty&lt;Collections.PropertyFlorae&gt;(PlantsProperty), this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FieldManager.UpdateChildren(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>//---------Child Collection Class<br>//From my research there is no need to implement any DataPortal methods for //this class<br>public class PropertyFlorae : BusinessListBase&lt;PropertyFlorae, PropertyFlora&gt;<br><br>//public method to add an item to the collection<br>public void Assign(int floraid, int quantity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(Contains(floraid)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyFlora propflr = PropertyFlora.NewPropertyFlora(floraid, quantity);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(propflr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InvalidOperationException("Flora already assigned to property");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br><br>//---------Child Items<br>&nbsp;public class PropertyFlora : BusinessBase&lt;PropertyFlora&gt;<br><br>// Child Item -- DataPortal Update Method<br>&nbsp;private void Child_Update(NativeScape.Library.BusinessObjects.Property data)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var ctx = ContextManager&lt;NativeScape.Data.NativeScapeDataContext&gt;.GetManager(NativeScape.Data.Database.NativeScape))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx.DataContext.updatePropertyFlora(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;int&gt;(IdProperty),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;int&gt;(FloraIdProperty),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (int?)data.Id,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReadProperty&lt;int&gt;(QuantityProperty));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br><br>// In my web user control this is how it's all called:<br>//CurrentProperty is just a static method that reads from an instance of the <br>//property class stored in the session<br>NSProperty.CurrentProperty.Plants.Assign(floraid, qty);<br>NSProperty.CurrentProperty.Save();<br><br><br><br>Ok so as you guys can see, the code is similiar to what's used in the ProjectTracker sample project. And it *does* work, in the sense that the updates all go through to the database fine. <br><br>What doesnt seem to be working is each time a child item is inserted into the collection and then Updated, the item remains dirty.<br><br>Consequently the next time the Save is called the item is inserted into the database again.<br><br>From my debugging and viewing the persisted instance after a Save has occured. The IsDirty properties most definately remain true after the update has occurred.<br><br>any help would be greatly appreciated.<br>galen<br><br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Galen replied on Sunday, August 31, 2008</h2>*bump*<br><br><br>Still having this issue.<br><br>Thanks in advance<br>Galen<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, August 31, 2008</h2><P>The most common reason for this issue (and it is pretty common) is that you are continuing to use the old object after a save. In other words, people often do this:</P>
<P>obj.Save();</P>
<P>Which is wrong. You MUST do this:</P>
<P>obj = obj.Save();</P>
<P>This is discussed in the books, and starting in version 3.5 is mandatory even when using the local data portal configuration (though you can get the older (but technically broken) behavior through a config setting - this is discussed in <EM>Using CSLA .NET 3.0</EM>).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Galen replied on Sunday, August 31, 2008</h2>Thanks Rocky,<br>I do <a href="http://galen.cindustries.com/i/Rocky.jpg">own the book...</a> but obviously missed this simple caveat.<br><br>Regardless it seems a little puzzling to me that an object Save must be called this way?<br><br>I can understand the benefits of having a return object, but having the method not modify the actual instance seems non intuitive.<br><br>Was the primary reason for this to give the developer an option of keeping the 'Unsaved' instance?<br><br>Thanks Again<br>Galen<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, September 01, 2008</h2>






 





<div class=Section1>

<p class=MsoNormal><span>The reason Save() returns another instance is because the .NET
serialization process creates a clone of the object across the network. This is
discussed in Chapter 1. Because the object graph is cloned from client to app
server, and from app server to client, the client ends up with a different
object as a result.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>When using the local data portal CSLA used to just modify the
existing object instance (no cloning). The problem there is a big one: if your
update fails part way through the process, the database will roll back and be
consistent. But the <i>object graph</i> will be very inconsistent. Some objects
will have new timestamps or new database-generated id values, etc. None of
which will be correct. So the object graph (in that case) is totally broken.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>That meant that the UI developer had to write code to determine
if the data portal would be local or remote, and to work differently in those
two scenarios. It also meant that the UI developer had to clone the object
graph before saving when using a local data portal. Not doing that clone was a
bug.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>So in CSLA 3.0 I added the option to have CSLA do the clone for
you (because too many people were forgetting, and that is a bug). And in 3.5 I
switched the default so CSLA defaults to doing the right thing, though you can use
the config setting to revert to the older, broken, behavior for backward
compatibility.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky</span><o:p></o:p></p>

</div>



</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
