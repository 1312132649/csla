<html><header><title>How to validate a data value that should be unique?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How to validate a data value that should be unique?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7509.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>superkuton posted on Tuesday, August 25, 2009</h2>I have a value that should be unique, How should I check for it?<br><br>Are there any existing validation rule/class that can be used?<br><br>Or a commandbase should be created?<br><br>Any sample code for a newbie will help me a lot. Thanks.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Wednesday, August 26, 2009</h2><P>It depends how the value should be unique, based on what?<BR><BR>Anyway, in any case&nbsp;u should have several protections.<BR><BR>- the most important one in the database, an unique constraint on the column.<BR>- another optional one in the data layer using a concurrency manager.<BR>- a csla validation<BR><BR>We are using a "volgorde" which should be unique within a list, example:<BR><BR>Having a businesslist <FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItemList </FONT></FONT>with child business objects called <FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItem</FONT></FONT>. In the child business object there is a validation rule<BR><FONT color=#0000ff size=2><FONT color=#0000ff size=2><BR>#region</FONT></FONT><FONT size=2> Validation Rules<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>override</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> AddBusinessRules()<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValidationRules.AddRule&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItem</FONT></FONT><FONT size=2>&gt;(IsVolgnummerValid, volgnummerProperty);<BR>}<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>bool</FONT></FONT><FONT size=2> IsVolgnummerValid&lt;T&gt;(T target, Csla.Validation.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RuleArgs</FONT></FONT><FONT size=2> e)<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>where</FONT></FONT><FONT size=2> T : </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItem<BR></FONT></FONT><FONT size=2>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>int</FONT></FONT><FONT size=2>? volgnummer = target.ReadProperty(volgnummerProperty);<BR><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RentebladKenmerkItemList</FONT></FONT><FONT size=2> list = target.Parent </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>as</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItemList</FONT></FONT><FONT size=2>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></FONT><FONT size=2><FONT color=#0000ff size=2><FONT color=#0000ff size=2>if</FONT></FONT><FONT size=2> (list != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>foreach</FONT></FONT><FONT size=2> (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>RentebladKenmerkItem</FONT></FONT><FONT size=2> item </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>in</FONT></FONT><FONT size=2> list)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>if</FONT></FONT><FONT size=2> (item.Volgnummer == target.ReadProperty(volgnummerProperty) &amp;&amp; !(ReferenceEquals(item, target)))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Description = </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Volgnummer must be unique."</FONT></FONT><FONT size=2>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>false</FONT></FONT><FONT size=2>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>true</FONT></FONT><FONT size=2>;<BR></FONT>}</FONT></FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, August 26, 2009</h2>All of our table-mapped BO's (e.g. class corresponds to database table) implement an Exists() static method -- implemented via CommandBase derived class -- that returns true if the passed key exists and false otherwise. <br /><br />So, we use this to implement validation rules on all the properties that correspond to foreign keys in the database. <br /><br />Of course, you can let the database do this also, but the user won't get notified until they try to save the object. The validation rule provides advance notification.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, August 26, 2009</h2><P>I have a similar Exists rule. I set its priority to 1 and all the normal rules to 0 by default. That way the rules that hit the database do not even run until all the simple rules pass.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jamie.clayton replied on Wednesday, August 26, 2009</h2>Here is an example of what we do.<br /><br />Option Explicit On<br />Option Strict On<br /><br />Imports System<br />Imports System.Data<br />Imports System.Data.SqlClient<br /><br />Imports Csla<br />Imports Csla.Data<br /><br />''' <br />''' Protect this method from any calling applications as it is too complicated to expose to a higher level app.<br />''' See clsProductClientRules.ClientRuleExists() as that implements this method.<br />''' Provide a simple method to see if a property for a given BO already exists in the database.<br />''' <br />''' <br />''' Things to think of:<br />''' 1/. We get given the id of the record in question as it may already have this value (hence still be unique even though it exists),<br />'''     so have to discount this id when checking.<br />''' 2/. Value may only be unique for a given foreign key, for example financial year for a Target record is unique for a given Consultant ID.<br />''' <br /> Friend Class IsUniqueCommand<br />    Inherits Csla.CommandBase<br /><br />#Region " Business Properties and Methods "<br /><br />    Private mBusinessObject As String<br />    Private mDbFieldToReview As String<br />    Private mValue1ToCheck As Object<br />    Private mExcludeID As Int32<br />    Private mDbField2ToReview As String<br />    Private mValue2ToCheck As Int32<br />    Private mExists As Boolean<br /><br />    ''' <br />    ''' The field to review is most likely to be a member of a unique index or composite unique index (multiple fields)<br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    Public ReadOnly Property Field1() As String<br />        Get<br />            Return mDbFieldToReview<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property BusinessObject() As String<br />        Get<br />            Return mBusinessObject<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property Value() As Object<br />        Get<br />            Return mValue1ToCheck<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property ExcludeID() As Int32<br />        Get<br />            Return mExcludeID<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property Field2() As String<br />        Get<br />            Return mDbField2ToReview<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property Value2() As Int32<br />        Get<br />            Return mValue2ToCheck<br />        End Get<br />    End Property<br /><br />    Public ReadOnly Property Exists() As Boolean<br />        Get<br />            Return mExists<br />        End Get<br />    End Property<br />#End Region<br /><br />    'Private Enum UniqueObject<br />    '    Product<br />    '    Branch<br />    '    FundManager<br />    '    TargetRevenueAndCommission<br />    '    User<br />    'End Enum<br /><br />#Region " Factory Methods "<br /><br />    ''' <br />    ''' We need to check unique indexes (single or composite [Max of 2 unique index fields catered for in this solution])<br />    ''' When using the function in code you should use code like.<br />    ''' <br />    ''' Dim test As IsUniqueCommand = DataPortal.Execute(Of IsUniqueCommand)(New IsUniqueCommand("Product", "ProductCode", "Example", 1, "", ""))<br />    ''' If test.Exists then<br />    '''    ' Logic here<br />    ''' End If<br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    ''' The list is based on the actual CSLA Business objects named in your project. It makes an assumption that the code that calles this function is likely to use reflection to grab some of the details.<br />    ''' The name of the table/field that contains the information we need to check for unique values against.<br />    ''' The value that will be checked to see that it's unique.<br />    ''' When reviewing unique records it's important that you exclude the current record. The Exclude ID assumes that existing records might be changed and then restored back to its original value, which is acceptable. If the record happens to be new, the ExcludeID (jenasys design used negative incrementing numbers) is not going to affect the SQL where clauses filtering of records, so it doesn't matter.<br />    ''' Optional Composite field name.<br />    ''' Optional Composite field value (assumption of int32) as we assume the database has been normalised and uses Identity fields as primary keys.<br />    ''' A maximum of 2 fields in a composite index is covered by this solution at the moment. <br />    ''' In practice this should cover 80% of most database requirements.  At some stage this needs to be extended<br />    ''' so we can have an unlimited amount of fields and values included in the composite index.<br />    Public Sub New(ByVal aBusinessObject As String, ByVal dbField1ToReview As String, ByVal value1ToCheck As Object, ByVal excudeID As Int32, ByVal dbField2ToReview As String, ByVal value2ToCheck As Int32)<br />        mBusinessObject = aBusinessObject<br />        mDbFieldToReview = dbField1ToReview<br />        mValue1ToCheck = value1ToCheck<br />        mExcludeID = excudeID<br />        mDbField2ToReview = dbField2ToReview<br />        mValue2ToCheck = value2ToCheck<br />    End Sub<br />#End Region<br /><br />#Region "Authorisation Rules"<br /><br />    Public Shared Function CanExecuteCommand() As Boolean<br />        Return True<br />    End Function<br /><br />#End Region<br /><br />#Region "Data Access Command"<br />    ''' <br />    ''' The is some logic in this method to help prefill in some of the stored procedure details and to ensure that any code that calls the function is setup correctly.<br />    ''' <br />    ''' <br />    ''' The stored procedure has to return a integer value in the first column with the count of records.<br />    ''' It was very important to ensure than the connection was closed and returned to the connection pool <br />    ''' or Connection pool max/timeout errors occured.<br />    ''' PRE: Value is of the correct type for the expected stored proc we are going to call!<br />    ''' <br />    Protected Overrides Sub DataPortal_Execute()<br />        Dim StoredProcedureName As String = Nothing  ' Set to keep compiler happy.<br />        Dim ExcludeIDParamaterName As String = Nothing  ' Set to keep compiler happy.<br />        Dim DBFieldParameterName As String = Nothing  ' Set to keep compiler happy.<br />        Dim UnexpectedField1Name As Boolean = False  ' Innocent until proven guilty.<br />        Dim DbField2ParamName As String = Nothing  ' Set to keep compiler happy.<br />        Dim UnexpectedDbField2Name As Boolean = False  ' Innocent until proven guilty.<br /><br />        ' Make sure we have a stored proc for the given BO, field to check and foreign id field (if we even expect one).<br />        Select Case mBusinessObject<br />            Case "Product"<br />                If mDbFieldToReview <> "ProductID" Then<br />                    UnexpectedField1Name = True<br />                ElseIf Not String.IsNullOrEmpty(mDbField2ToReview) Then<br />                    UnexpectedDbField2Name = True<br />                Else<br />                    StoredProcedureName = "spProductCodeExists"<br />                    ExcludeIDParamaterName = "@ProductNo"<br />                    DBFieldParameterName = "@ProductCode"  ' SIC, stored proc uses a different name than what the underlying field is.<br />                    'DbField2ParamName = "Not used"<br />                End If<br /><br />            Case "Branch"<br />                If mDbFieldToReview <> "BranchName" Then<br />                    UnexpectedField1Name = True<br />                ElseIf Not String.IsNullOrEmpty(mDbField2ToReview) Then<br />                    UnexpectedDbField2Name = True<br />                Else<br />                    StoredProcedureName = "spIsBranchNameUnique"<br />                    ExcludeIDParamaterName = "@BranchID"<br />                    DBFieldParameterName = "@BranchName"<br />                    'DbField2ParamName = "Not used"<br />                End If<br /><br />            Case "User"<br />                If Not String.IsNullOrEmpty(mDbField2ToReview) Then<br />                    UnexpectedDbField2Name = True<br />                Else<br />                    Select Case mDbFieldToReview<br />                        Case "UserFullName"<br />                            StoredProcedureName = "spIsUserFullNameUnique"<br />                            ExcludeIDParamaterName = "@UserPKID"<br />                            DBFieldParameterName = "@UserFullName"<br />                            'DbField2ParamName = "Not used"<br />                        Case "UserEmail"<br />                            StoredProcedureName = "spIsUserEmailUnique"<br />                            ExcludeIDParamaterName = "@UserPKID"<br />                            DBFieldParameterName = "@UserEmail"<br />                            'DbField2ParamName = "Not used"<br />                        Case Else<br />                            UnexpectedField1Name = True<br />                    End Select<br />                End If<br />            Case Else<br />                Throw New Iims.BL.IimsException(mBusinessObject &amp; " is not an expected Business Object to check for uniqueness.")<br />        End Select<br /><br />        If UnexpectedField1Name Then<br />            Throw New Iims.BL.IimsException(mDbFieldToReview &amp; " is not an expected field to check for uniqueness in " &amp; mBusinessObject &amp; " Business Object.")<br />        End If<br /><br />        If UnexpectedDbField2Name Then<br />            Throw New Iims.BL.IimsException(mDbField2ToReview &amp; " is not an expected field to use as a foreign key in " &amp; mBusinessObject &amp; " Business Object.")<br />        End If<br /><br />        '   LL: The order of the Stored procedure where clause is very important.  If you are checking a composite unique index (multiple fields) then you need to setup the stored procedures where clause to match the order of the fields used in the composite index to ensure SQL Server uses the index appropriately.<br />        Dim cn As SqlConnection<br />        cn = New SqlConnection(Database.PIS_IimsConnection)<br />        Try<br />            cn.Open()<br />            Using cm As SqlCommand = cn.CreateCommand<br />                With cm<br />                    .CommandType = CommandType.StoredProcedure<br />                    .CommandText = StoredProcedureName<br />                End With<br />                With cm.Parameters<br />                    .AddWithValue(DBFieldParameterName, mValue1ToCheck)<br />                    .AddWithValue(ExcludeIDParamaterName, mExcludeID)<br />                    If Not String.IsNullOrEmpty(DbField2ParamName) Then<br />                        .AddWithValue(DbField2ParamName, mValue2ToCheck)<br />                    End If<br />                End With<br /><br />                Dim count As Integer = CInt(cm.ExecuteScalar)<br />                mExists = (count > 0)<br />            End Using<br />        Finally<br />            cn.Close()<br />        End Try<br />    End Sub<br />#End Region<br /><br />End Class<br /><br /><br />You then use the following Business rule to implement that code.<br /><br /> ''' <br />    ''' Ensure given property does not have a value already in use.<br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    ''' <br />    ''' Code this was based on also checked if property had a value - this is out of scope for this validation and should be performed by<br />    ''' either a Csla.Validation.CommonRules.StringRequired or NumericIDRequired.<br />    ''' Things to think of:<br />    ''' 1/. We get given the id of the record in question as it may already have this value (hence still be unique even though it exists),<br />    '''     so have to discount this id when checking.<br />    ''' 2/. Value may only be unique for a given foreign key, for example financial year for a Target record is unique for a given Consultant ID.<br />    ''' LL: If the property that calles this Business rule is the first property edited, then the dirty flag will not be correctly set until the BOName_PropertyChange event. YOU MUST add code into the BOName_PropertyChange event to ensure the business rule is correctly checked a second time with the dirty flag set.<br />    ''' <br />    Public Shared Function IsUnique(Of T As Core.BusinessBase)(ByVal target As T, ByVal e As IsUniqueRuleArgs) As Boolean<br />        Dim result As Boolean<br /><br />        ' LL: Validation gets run when a BO gets read in; when we are reading in a list of them, this can cause a delay when the validator needs to perform<br />        ' SQL to determine validity.  We originally turned off the validation check on Fetch but that had undesirable side-effects.  We now only validate<br />        ' SQL-based validators if the BO is new or dirty, hence circumventing the issue more succinctly.<br />        If target.IsDirty OrElse target.IsNew Then<br />            ' LL: GetProperty() is case-SENSITIVE, get the case wrong and you get a Nothing return!<br />            Dim pi As PropertyInfo = target.GetType().GetProperty(e.PropertyName)<br />            Dim value As Object = pi.GetValue(target, Nothing)<br /><br />            pi = target.GetType().GetProperty(e.PKFieldName)<br />            Dim id As Int32 = DirectCast(pi.GetValue(target, Nothing), Int32)<br /><br />            Dim foreignKeyID As Int32<br />            If Not String.IsNullOrEmpty(e.Field2ToReview) Then<br />                pi = target.GetType().GetProperty(e.Field2ToReview)<br />                foreignKeyID = DirectCast(pi.GetValue(target, Nothing), Int32)<br />            End If<br /><br />            Dim test As IsUniqueCommand = DataPortal.Execute(Of IsUniqueCommand)(New IsUniqueCommand(target.GetType.Name, e.PropertyName, value, id, e.Field2ToReview, foreignKeyID))<br />            If test.Exists Then<br />                ' LL: e.PropertyFriendlyName is not always set.<br />                e.Description = e.PropertyFriendlyName &amp; " value of '" &amp; Stringify(value) &amp; "' already exists and cannot be used."<br />                result = False<br />            Else<br />                result = True<br />            End If<br />        Else<br />            result = True  ' Passed because we did not test it...<br />        End If<br /><br />        Return result<br />    End Function<br /><br /><br />At the SQL Server you would have stored procedures like the following.<br /><br /><br />CREATE PROCEDURE [dbo].[spIsBranchNameUnique]<br />	@BranchName nvarchar(100),<br />	@BranchID int<br />AS<br />BEGIN<br />	SET NOCOUNT OFF<br /><br />	SELECT Count(*)<br />	FROM dbo.tblBranches<br />	WHERE BranchName = @BranchName AND BranchID <> @BranchID<br />END</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
