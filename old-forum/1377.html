<html><header><title>Interfaces</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Interfaces</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1377.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pfeds posted on Tuesday, October 03, 2006</h2><P>Do you ever get the feeling that you're doing things the wrong way, or maybe the right way, and then you get all confused...?</P>
<P>I've developed a number of apps using CSLA and have never felt the need to use interfaces.&nbsp; I'm currently working on a new, fairly large, development so we're at that critical time of starting things off correctly.&nbsp; </P>
<P>My plan was to create an object library, then simply use these objects in the Windows GUI, Web Services and such.&nbsp; This seems like the simplest method to me, and I like to opt for the simplest method.</P>
<P>Other people in the team (including the team leader and other lead developers)&nbsp;are insisting on the use of interfaces which also requires the use of factories.&nbsp; I'm outnumbered, so I'm trying to reason with myself that this is a good method.&nbsp; My instincts are stubborn,&nbsp;so I could really do with someone giving me a good argument why I might be being stupid.</P>
<P>This method will mean our code will need to be something like this (using Customer as an example):</P>
<P>&nbsp;</P>
<P>ICustomer customer = ICustomerFactory.GetCustomer(customerId);</P>
<P>or</P>
<P>ICustomerList customerList = ICustomerFactory.GetCustomerList();</P>
<P>instead of simply:</P>
<P>Customer customer = Customer.GetCustomer(customerId);</P>
<P>&nbsp;</P>
<P>My opinion is that the interface/factory method means more coding aka more complexity, and for what?</P>
<P>Their argument for this is "How else are we going to use mock objects?".&nbsp; I agree that this does add a level of abstraction, but I can't help believing this is unnecessary.&nbsp; Isn't it a simpler solution to just create a mock object library if need be, and use that instead of the production library?</P>
<P>Additionally, I've run into a slight issue with databinding to interfaces...</P>
<P>We now have a definitive interface heirarchy such as this:</P>
<P>IItem (Id, Name, Description)</P>
<P>ICustomer : IItem (adds Address, PhoneNumber etc)</P>
<P>If I&nbsp;add a Data Source to a Customer object then all's well.&nbsp; If I add a Data Source to ICustomer then all I get are the properties definied by ICustomer.&nbsp; IItem properties are ignored. Any ideas???</P>
<P>Thanks in advance&nbsp;for any advice, even if it involves calling me a muppet.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, October 03, 2006</h2>Interfaces are good if you'll have two or more objects which need to be interfaced with in the same way, but otherwise are unrelated.&nbsp; For example, IDbConnection.&nbsp; SqlConnection and OleDbConnection will never need to work together, but it would be nice if we didn't care which kind of connection we used.<br><br>Converse this to inheritence, where you can modify behavior through its use.<br><br>Adding interfaces for the sake of adding interfaces doesn't seem like a good idea to me.&nbsp; You are constraining yourself for no reason up front.&nbsp; If you need that later, fine, add it then.&nbsp; Remember, YAGNI (you aren't going to need it).&nbsp; Any arguement that says 'we <b>may </b>need this later' should be countered by 'then we'll add it later.'<br><br>Why would you mock away your library anyway?&nbsp; That's not going to help you test it at all.&nbsp; I should also point out I believe that in most cases mocking is a waste of time, unless some objects have a complex interaction and you want to make sure that object A is properly using object B.<br><br>Just my two cents.<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pfeds replied on Tuesday, October 03, 2006</h2><P>Andy - thanks for your useful opinion.&nbsp; I have just finished reading your earlier thread on interfaces and data binding which cleared up that issue <img src="/emoticons/emotion-2.gif" alt="Big Smile [:D]" />&nbsp; </P>
<P>I'm not sure I can see&nbsp;the reasoning&nbsp;to&nbsp;prevent data binding to an interface heirarchy (when adding Data Sources).&nbsp;&nbsp;I figured that as an object could have a number of interfaces, why would you try and bind to any number of them when it's far easier just to bind to the concrete object... does that make sense, or am I rambling!?!</P>
<P>For me your comments about YAGNI and 'we may need this later' so 'then we'll add it later' really hit the nail on the head.&nbsp;I'm all for agile development and XP.&nbsp; Unfortunately for us we have legacy software and our developers are constantly saying "We know we'll need this in the future, so lets do it all now".&nbsp; I normally retaliate with "Do we <EM>really</EM> need it, and if so we'll do it when it's needed".&nbsp; Then I get "Don't be daft, that will mean refactoring a lot of the code in the future".&nbsp; I reply "So what?".&nbsp; Hmm.&nbsp; As far as I can see, these interfaces and factories aren't necessary at the moment.</P>
<P>I also agree with you about mock objects. Why create them until we have a need?&nbsp; They're certainly worth while, especially in unit testing.&nbsp; I quite often think they're a waste of effort, but I can't dismiss that proper unit testing is also very useful to have.&nbsp; Besides, I can't see why mock objects are dependant on interfaces... but it seems that other people believe you can't have a mock object without an interface.</P>
<P>Sorry about the rant. And thanks,&nbsp;I really appreciated your 2 cents.</P>
<P>It's very interesting to see other peoples opinions.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Tuesday, October 03, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>pfeds:</strong></div><div> 
<P>Unfortunately for us we have legacy software and our developers are constantly saying "We know we'll need this in the future, so lets do it all now".</P>
<P></div></BLOCKQUOTE></P>
<P>Shame on any developers that creates software parts for the future - guess what - the future might never come.&nbsp; And if they do so, then they are creating more issues for the future, and for what, for something they think they will need!&nbsp; I say if you don't have a use case today, you don't code it today.&nbsp; If you get a new use case tomorrow, you code it tomorrow.</P>
<P>More code = more testing = more bug prone = more refactoring = less efficient code reviews = higher cost of change in the future...</P>
<P>Sorry for the rant here but I fully agree with 'pfeds'- and not necessarily with the developers he is working with :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Tuesday, October 03, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>guyroch:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>pfeds:</strong></div><div> 
<P>Unfortunately for us we have legacy software and our developers are constantly saying "We know we'll need this in the future, so lets do it all now".</P>
<P></div></BLOCKQUOTE></P>
<P>Shame on any developers that creates software parts for the future - guess what - the future might never come.&nbsp; And if they do so, then they are creating more issues for the future, and for what, for something they think they will need!&nbsp; I say if you don't have a use case today, you don't code it today.&nbsp; If you get a new use case tomorrow, you code it tomorrow.</P>
<P>More code = more testing = more bug prone = more refactoring = less efficient code reviews = higher cost of change in the future...</P>
<P>Sorry for the rant here but I fully agree with 'pfeds'- and not necessarily with the developers he is working with :)</P>
<DIV></div></BLOCKQUOTE></DIV>
<DIV>&nbsp;</DIV>
<DIV>There are times when you do, actually, know that you will need that functionality.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Say you are upgrading a system from Borland Delphi using a Pervasive database to .Net and Micorsoft SQL server.&nbsp; You decide to do it in steps converting modules on a specified schedule.</DIV>
<DIV>&nbsp;</DIV>
<DIV>You do, in this case, know that you will need all the functionality of the previous system.&nbsp; You also know what additional functionality you are going to add (because you promised it).</DIV>
<DIV>&nbsp;</DIV>
<DIV>In those cases you can safely "design for the future".&nbsp; And using interfaces does give flexiblity to the intermediate steps.</DIV>
<DIV>&nbsp;</DIV>
<DIV>But outside of that, I agree with you.</DIV>
<DIV>&nbsp;</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Tuesday, October 03, 2006</h2><p class="MsoNormal">A mock object must have the same interface as the real object
because the client should be unaware whether it is using a mock or real object.<span>&nbsp; </span>You can achieve this by using abstract
classes or interfaces. <span>&nbsp;</span>Interfaces are used
to make sure that the mock objects have same interface as their real counterpart.<span>&nbsp; </span>If you create a mock library without using
interfaces you could mess up.<span> This would increase the time spent on debugging the mock library. &nbsp;
</span>IMO, using mock object improves your code because it forces you to
program to an interface.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Tuesday, October 03, 2006</h2><p class="MsoNormal"><span>The other
people on your team are correct.<span>&nbsp; </span>One of
the basic principles of OOP is to program to and interface not an
implementation.<span>&nbsp; </span>By interface, I mean an
abstract class or interface.<span>&nbsp; </span>This will make
your code more flexible and easier to maintain.<span>&nbsp;
</span>Of course you will need to program to concrete classes some times; however,
you should limit this as much as possible.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Tuesday, October 03, 2006</h2>What is their reasoning for wanting to use mock objects? Is it solely for testing?<br><br>I just want to make sure that before we give you any more advice, we clearly understand why they're pushing the interface route.<br><br>If they were saying, "We should use structs instead of objects because, how else are we going to do X" there might really be a legitimate reason if we knew what X was.<br><br>- John<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, October 03, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JHurrell:</strong></div><div>What is their reasoning for wanting to use mock objects? Is it solely for testing?<br><br>I just want to make sure that before we give you any more advice, we clearly understand why they're pushing the interface route.</div></BLOCKQUOTE><br><br>Usually mocks are done when testing.&nbsp; Personally, I rarely mock anything when building unit tests.&nbsp; My reasoning is that I define 'unit' as the class (or classes) which I'm testing.&nbsp; That includes the objects responsiblity to persist itself.&nbsp; <br><br>There is a nice discussion on mocking vs. not mocking in this forum if you search for it.&nbsp; Personally I don't usually see mocking in unit testing as necessary, and so its not a valid reason to create a bunch of interfaces.&nbsp; Abstraction is nice, but too much of it makes things overly complex and hard to maintain. &nbsp;&nbsp; Usually you abstract things that change often.&nbsp; Is Customer going to change a lot? Probably not..&nbsp; you need to find a balance.<br><br>Of course though we don't know all the details of the discussion from the OP, so he'll have to sort out our opinions and apply them himself.&nbsp; The YAGNI prinpical is a pretty good one to stick by; unless you have a case, or will shortly have a case for something, you shouldn't do it.&nbsp; If the coworkers are saying 'maybe' and 'might' in their argument, its a pretty good time to apply YAGNI.<br><br>Again, this is all my opinion, so salt to your liking.<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Tuesday, October 03, 2006</h2>That's also the only reason I can think of for wanting to mock objects.<br><br>If it's the case that they want to mock up objects to simplify unit testing, then I'm of the opinion that it's not appropriate to stress "everthing is an interface" to make testing easier.<br><br>I'm also a big fan of YAGNI and have been supported by futures that never seem to require the changes that somebody wanted to put in "just in case."<br><br>Just throw out the current industry buzzword "refactor" and watch your co-workers' eyes glaze over as they drone, "Yes... we can refactor later."<br><br>- John<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alexh replied on Tuesday, October 03, 2006</h2>The question is, are there multiple implementations of "Customer"?<br><br>If so, then an interface may certainly be in order along with a factory to deliver an implementation.&nbsp; If not, then it sounds a little bit like your team may be following the "silver bullet" methodology.&nbsp; That is, find a technology or practice and insist on applying it in all circumstances.&nbsp; Its attractive in concept - you only have to learn "the way".&nbsp; But you then spend most of your time trying to force everything to fit that picture.<br><br>For example, program to an interface not an implementation is not an edict to apply in all circumstances.&nbsp; Should you create an interface to represent ALL concrete classes?&nbsp; The answer is obviously no.<br><br>The databinding question rings some alarm bells.&nbsp; Is your team attempting to build application related plumbing and infrastructure on top of a construct (interfaces) that is intended to be used to allow programmers to separate interface from implementation?&nbsp; You'll end up struggling against both ends, you'll be constrained in your use of interfaces programmatically, and your plumbing will be constrained by the interface paradigm.&nbsp; Should an interface generally contain properties that represent the state of an object, or should it represent the behaviours that fulfill the responsibilities of the object?<br><br>Mocks can be great, but maybe the "tail is wagging the dog".&nbsp; Are you developers who do testing, or are you really a team of testers who do development?&nbsp; Test methodologies shouldn't drive your development, established development patterns and practices should.<br><br>Just some thoughts,<br>Alex<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
