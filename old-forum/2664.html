<html><header><title>Per-Instance Authorization Re-visited</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Per-Instance Authorization Re-visited</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2664.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Thursday, April 05, 2007</h2><P>I know there have been a few other discussions about per-instance authorization solutions, but I am still working out a few issues and hope to re-visit the topic in a more complete way...</P>
<P>&nbsp;</P>
<P>Let's use the&nbsp;"CanEditObject()" method as the basis for our discussion.&nbsp; In my Quote class, as with all other classes, this method is static and is implemented simply as:</P>
<P><CODE>return ApplicationContext.User.IsInRole("Account Manager");</CODE></P>
<P>which works great for most applications.&nbsp; However, in my case, there are times when the object's state affects the response we want to provide from this method.&nbsp; For example, here would be the full use-case statement:</P>
<UL>
<LI>"Account Managers" may edit Quote objects <STRONG>except</STRONG> when the Quote is locked (because it has been submitted).</LI></UL>
<P>So, I need the CanEditObject method to be more like:</P>
<P><CODE>public static System.Boolean CanEditObject()<BR>{<BR>&nbsp; &nbsp; if (ApplicationContext.User.IsInRole("Account Manager"))<BR>&nbsp; &nbsp; &nbsp; &nbsp; return (State == QuoteStatus.Draft)<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return false;<BR>}</CODE></P>
<P>The problem is that the State property is not static - and can't be as this is a per-instance value.&nbsp; So, how to accomplish this then?</P>
<P>In other posts there was a suggestion to implement two classes, Quote and SubmittedQuote, that would return different responses to the authorization methods.&nbsp; I.e. Quote would simply check IsInRole and SubmittedQuote would always return false.&nbsp; However, when putting this into action there is a problem implementing this as we are displaying a list of QuoteInfo objects from which the user has selected to open one of the listed records (by double-clicking the row, for instance).&nbsp; We pass the ID value from the selected row to the new form which then calls Quote.GetQuote(ID) to instantiate our business object.&nbsp; It seems like we are adding extra code and complications in order to differentiate which type to instantiate.</P>
<P>And what if there are multiple properties that determine whether the object can be edited by the current user?&nbsp; Perhaps not only the object's state matters but also the dollar value.&nbsp; Let's say that a Quote that has been submitted for approval worth more than $1 Million can only be updated by the VP of Sales whereas any Quote with a lower dollar value would be accessible to the Sales Manager for approval.</P>
<P>To further complicate the discussion, we are in the design phase on another application that will require us to implement more traditional access control (per object) security whereby each object will maintain a list of users that are allowed to perform actions upon it.&nbsp; I don't see how we are to have separate classes for each of these cases.&nbsp; Nor can the ACL's be static as they will vary from instance to instance.</P>
<P>How best to accomplish what I've described?&nbsp; Any suggestions?&nbsp; Anyone had any success in these areas???</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 06, 2007</h2>Pirate,<br><br>I've done this by overriding CanWriteProperty, like so:<br><br><font color="#0000ff">public override bool</font> CanWriteProperty( <font color="#0000ff">string </font>propName ) {<br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">bool </font>result;<br><br><font color="#0000ff">&nbsp;&nbsp;&nbsp; if </font>( Locked ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = <font color="#0000ff">false</font>;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">else </font>{<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  result = <font color="#0000ff">base</font>.CanWriteProperty( propName );<br>&nbsp;&nbsp;&nbsp; }<br><br><font color="#0000ff">&nbsp;&nbsp;&nbsp; return </font>result;<br>}<br><br>Now, is that what Rocky intended?&nbsp; I'm not sure, but it seems to work out fine.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, April 06, 2007</h2><P>Actually the CanReadProperty/CanWriteProperty/CanExecuteMethod part isn't a problem because those are not static methods so I can make conditional checks with other properties of the object.&nbsp; My issue has to do with the static CanAddObject, CanEditObject, CanRemoveObject and CanReadObject methods used by the UI to enable/disable menu items, display forms as read-only, etc.</P>
<P>For example, continuing the Quote scenerio described above, when we display our Quote Details (web) form, we use the CanEditObject method to determine if the FormView is in ReadOnly or Edit mode.&nbsp; Our business rules, as shown before, dictate that we:</P>
<UL>
<LI>display the form in Edit mode if the current user is an Account Manager AND the Quote is in Draft status.</LI>
<LI>display the form in ReadOnly mode if the user is an Account Manager and the Quote is in any other state.</LI>
<LI>do not allow access to the form if the user is not an Account Manager.</LI></UL>
<P>Which brings up a second question that has plauged me for a while.&nbsp; I do not make much use of the CanReadProperty, etc. methods because access to the object is blocked by the static methods.&nbsp; However, I understand that having the AuthorizationRules defined provides a safety net in case access is granted despite denial by the static methods - as would be the case if the UI developer failed to include the check!&nbsp; What do you do then?&nbsp; Do you throw an exception?&nbsp; Display an error message?</P>
<P>About 90% of the applications I work on are web apps, so handling an exception is a bit more cumbersome than with Windows apps.&nbsp; And, since I make use of the various xView controls, we are not binding the enabled/disabled state of the individual edit controls to their corresponding properties but rather using the static methods to determine the appropriate template to display.</P>
<P>Make sense?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, April 06, 2007</h2><P>I do not use the Auth rules very much. But when I was looking in to them I decided that for my web app it would make more sense to just blank out the value if CanReadProperty was False. This made more sense to me than throwing an exception and then trying to handle it in the UI. Just let the user see all the values they are supposed to see and blank out the rest.</P><FONT size=2>
<P></FONT><FONT color=#008000 size=2>'CanReadProperty("Desc", True) ' this causes an Exception to be thrown if user is not allowed to Read the Property.<BR></FONT><FONT color=#008000 size=2>'Can be caught in screen - if screen is coded to Catch ex As DataPortalException when fetching or creating a BO.</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>If</FONT><FONT size=2> CanReadProperty(</FONT><FONT color=#ff00ff size=2>"Desc"</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>Then<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> mDesc<BR></FONT><FONT color=#0000ff size=2>Else<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> </FONT><FONT color=#ff00ff size=2>""<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>If</FONT></P>
<P><FONT color=#0000ff size=2>==========================================================================</P></FONT><FONT color=#0000ff size=2>
<P>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Class</FONT><FONT size=2> Check</P>
<P></FONT><FONT color=#0000ff size=2>Private</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> HasPermission(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> permission </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Dim</FONT><FONT size=2> user </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> MyUser = </FONT><FONT color=#0000ff size=2>DirectCast</FONT><FONT size=2>(Csla2.ApplicationContext.User, MyUser)<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> user.HasPermission(permission)<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanAddObject(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> permission </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> HasPermission(permission)<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanGetObject(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> permission </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> HasPermission(permission)<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanDeleteObject(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> permission </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> HasPermission(permission)<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanEditObject(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> permission </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> HasPermission(permission)<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Class</P></FONT>
<P>Rather than write this kind of code in each BO I decided to centralize it so any BO can call it.My user.HasPermission is similar to IsInRole but much finer grained.</P>
<P>I realize this doesn't answer the question about how you also deal with the state of the object. Not sure how you can do that without an instance of the object. Sort of a Catch-22.</P>
<P>Finally - Rocky may enhance IsReadAllowed so that the *default* implementation is the same as today - call IsInRole. But he will do it using a Delegate. This wa y we can write our own IsInRole boolean function and use a dfiferent delegate (which is hooked up on App start). This delegate could return my HasPermission value instead of IsInRole which would allow me to again have finer control over this mechanism.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 06, 2007</h2>Pirate,<br><br>I'm doing WinForms, but I think the same solution applies to WebForms.&nbsp; You would have something similar to ReadWriteAuthorization component, that would disable bound controls on the web form based on the return value of CanWriteProperty.<br><br>Your UI would hide the save button completely though based on your Locked property. In addition, you should probably override save to throw an exection of Locked is true.<br><br>As far as CanReadProperty, I would think its the same as CanWriteProperty; you throw an exception in the property getting if CanReadProperty returns false (well, you tell CanRead to throw for you).&nbsp; The equivolent of RWAuth would handle the control so that exceptions don't get thrown.&nbsp; If the UI developer 'forgets,' well throwing the exception should make it clear what is wrong, and hopefully they will fix their UI during testing.<br><br>I haven't used AllowRead or DenyRead yet though, because my use cases don't stipulate hiding certain data from certain roles, either you have full rights to the data or none... although this may be changing soon.<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, April 06, 2007</h2><P>I still don't see the value in the CanReadProperty and&nbsp;CanWriteProperty methods except as a backup in case the UI developer forgets to check CanReadObject/CanEditObject.&nbsp; I have never run into a case where&nbsp;I need to allow a user access to only a portion of an object's properties while denying others - the user can either read or not and can either edit or not.&nbsp; And with regards to the latter, we already have a safe-guard check in the Save method where we make sure that the user has edit rights before allowing the save.&nbsp; So, again, I'm not looking for answers how to implement these methods as they don't serve my purposes.</P>
<P>Furthermore, we don't really have an equivalent control for web apps as the RWAuth Windows control.&nbsp; In web apps, we make use of the built-in features by utilizing the various xView controls which allow us to define templates for editing and read-only views of the data.&nbsp; This is done "globally", so to speak, in that we are either in edit mode or read-only mode.&nbsp; Again going back to what I referred to before about not working on a per-property basis - as the RWAuth allows&nbsp;us to do in Windows apps (but I've never used cuz it was never applicable).</P>
<P>If anyone has examples of use-cases where you would want to be able to grant edit access to some fields and deny for others within the same instance of a BO, please pass them along because this is one big gray area for me.</P>
<P>&nbsp;</P>
<P>Let me try to make a more concrete example to further the discussion.</P>
<P>In our application, object instances are "owned" by their creator.&nbsp; As such, the creator will always have full rights to the object.&nbsp; He can view it, edit it and delete it.&nbsp; During the object's lifetime, the creator may need to allow others to work with the object, so it can be temporarily "assigned" to another user.&nbsp; This user is granted view and edit rights so long as they are assigned to it.&nbsp; Furthermore, the object has a list of users and roles&nbsp;in which it has been "shared."&nbsp; Any user in this list (or user belonging to a role that is&nbsp;included)&nbsp;is granted read rights.&nbsp; Anyone else can do nothing with the object.</P>
<P>So, our authorization logic is as follows:</P>
<UL>
<LI>CanReadObject:</LI>
<OL>
<LI>Allow if the current user is the instance's owner.</LI>
<LI>Allow if the instance is assigned to the current user.</LI>
<LI>Allow if the current user is contained in the instance's share list.</LI>
<LI>Allow if the current user belongs to a role contained in the instance's share list.</LI>
<LI>Deny otherwise.</LI></OL></UL>
<UL>
<LI>CanEditObject</LI>
<OL>
<LI>Allow if the current user is the instance's owner.</LI>
<LI>Allow if the instance is assigned to the current user.</LI>
<LI>Deny otherwise.</LI></OL></UL>
<UL>
<LI>CanRemoveObject</LI>
<OL>
<LI>Allow if the current user is the instance's owner.</LI>
<LI>Deny otherwise.</LI></OL></UL>
<P>The only authorization method that is not per-instance is the CanCreateObject method which does the simple IsInRole check.</P>
<P>Again, it doesn't make sense for me to implement these rules on each and every individual property accessor.&nbsp; Besides the performance impact of having to evaluate this everytime a property is read or written to, the amount of excess code...!!!</P>
<P>But, you can clearly see that&nbsp;three out of&nbsp;the four authorization methods rely on instance property values.&nbsp; So, how to implement?</P>
<P>Do I make each of the authorization methods non-static?&nbsp; If so, I am now bound to only checking per-instance and no longer have per-type authorization as I still would use for the CanCreateObject method.</P>
<P>Does this example help to illustrate the problem/question better?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 06, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I still don't see the value in the CanReadProperty and&nbsp;CanWriteProperty methods except as a backup in case the UI developer forgets to check CanReadObject/CanEditObject.&nbsp; I have never run into a case where&nbsp;I need to allow a user access to only a portion of an object's properties while denying others - the user can either read or not and can either edit or not.&nbsp; And with regards to the latter, we already have a safe-guard check in the Save method where we make sure that the user has edit rights before allowing the save.&nbsp; So, again, I'm not looking for answers how to implement these methods as they don't serve my purposes.</div></BLOCKQUOTE><br><br>I haven't come across a case myself where CanReadProperty would return something different than static member, but I can see situations where it would.&nbsp; But for CanWriteProperty I do.&nbsp; Some users are allowed to view the detail objects using the same screens that the users which edit use.&nbsp; CanWriteProperty allows me to do just that.&nbsp; Also, after an document in my system is locked, no one may edit it... but they still need to get to the document and look at it with the same screen.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>Furthermore, we don't really have an equivalent control for web apps as the RWAuth Windows control.&nbsp; In web apps, we make use of the built-in features by utilizing the various xView controls which allow us to define templates for editing and read-only views of the data.&nbsp; This is done "globally", so to speak, in that we are either in edit mode or read-only mode.&nbsp; Again going back to what I referred to before about not working on a per-property basis - as the RWAuth allows&nbsp;us to do in Windows apps (but I've never used cuz it was never applicable).</div></BLOCKQUOTE></p><p>So the only question here is a matter of scope; currently I imagine you're using the static CanEditObject to determine which template to use, but I can easily see using CanWriteProperty if you wanted to only lock portions of the objects but still allow edit access.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>If anyone has examples of use-cases where you would want to be able to grant edit access to some fields and deny for others within the same instance of a BO, please pass them along because this is one big gray area for me.</div></BLOCKQUOTE></p>I could see a use case where a sales person could modify some customer information, such as address data, but not other aspects, such as the customer's credit limit, payment terms, etc.

<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>The only authorization method that is not per-instance is the CanCreateObject method which does the simple IsInRole check.</p>
<p>Again, it doesn't make sense for me to implement these rules on each and every individual property accessor.&nbsp; Besides the performance impact of having to evaluate this everytime a property is read or written to, the amount of excess code...!!!</p>
<p>But, you can clearly see that&nbsp;three out of&nbsp;the four authorization methods rely on instance property values.&nbsp; So, how to implement?</p>
<p>Do I make each of the authorization methods non-static?&nbsp; If so, I am now bound to only checking per-instance and no longer have per-type authorization as I still would use for the CanCreateObject method.</div></BLOCKQUOTE></p><p>The only solution I can think of is use Csla and the CanReadProperty / CanWriteProperty, or your static methods will have to take parameters that give enough information to get a result.&nbsp; The parameterless static methods would return in general what someone may do.</p>For example, CanLoadObject would mean the user can load at least some instances.&nbsp; If CanLoadObject is false, then I would think the static factory get methods would throw exceptions always, and your UI would not even show links to pages which load the object details.<br><br>If CanLoadObject is true, then you execute your dataportal fetch as usual, but the first thing you do is some queries to decide if the user may load the instance.&nbsp; If not, throw a SecurityException at that point.<br><br>CanEditObject and CanRemoveObject behave the same; the user may edit or remove instances in general, but each instance still decides for itself if the user may edit or remove it by diong the check in a Save override and throwing an exception if the user does not have permission.<br><br>Does that help at all?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, April 06, 2007</h2><P>I just stumbled across a great blog post related to Microsoft CRM security that has given me a few new thoughts on how to implement this within Csla.</P>
<P>In CRM, authorization is broken into two parts: PrivilegeCheck and AccessCheck.</P>
<P>A PrivilegeCheck would do exactly what the existing static methods are doing: check IsInRole and return true/false based on whether the current user MAY be able to perform the requested action.&nbsp; For instance, if I have a user that is in the Account Managers role, they may be able to edit a Quote object so we would enable the Properties toolbar button and allow them to open the Quote details form/page.</P>
<P>An AccessCheck is where the instance part comes in that I am talking about.&nbsp; An AccessCheck is what determines whether or not the user can actually perform that action on the specific instance of a BO.&nbsp; This would be where we would have to apply&nbsp;the authorization rules that I described and is what would tell me to display the form as read-only and/or disable the Save button, etc.</P>
<P>&nbsp;</P>
<P>What dawned on me in reading this is that my problems may be solved as simply as creating overloaded versions of the static methods that accept the instance being checked as a parameter.&nbsp; For example, to implement the CanReadObject methods given the rules I described previously, I'd have:</P>
<P><CODE>public static System.Boolean CanReadObject()<BR>{<BR>&nbsp; &nbsp; return ApplicationContext.User.IsInRole("Account Manager");<BR>}<BR>&nbsp;<BR>public static System.Boolean CanReadObject(Quote q)<BR>{<BR>&nbsp; &nbsp; if (CanReadObject())<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (ApplicationContext.User.Equals(q.Owner))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp;<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (ApplicationContext.User.Equals(q.AssignedTo))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp;<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (q.ShareWith.Contains(ApplicationContext.User))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp;<BR>&nbsp; &nbsp; &nbsp; &nbsp; // Some check to see if any of the user's roles are in the<BR>&nbsp; &nbsp; &nbsp; &nbsp; // share list (have to figure out later)<BR>&nbsp;<BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>}</CODE></P>
<P>In my UI code, to determine if my FormView, for example, should be displayed in edit or read-only mode, I'd use:</P>
<P><CODE>if ((Quote.CanCreateObject()) &amp;&amp; (DataItem.IsNew))<BR>&nbsp; &nbsp; FormView1.ChangeMode(FormViewMode.Insert);<BR>else if (Quote.CanEditObject(DataItem))<BR>&nbsp; &nbsp; FormView1.ChangeMode(FormViewMode.Edit);<BR>else<BR>&nbsp; &nbsp; FormView1.ChangeMode(FormViewMode.ReadOnly);<BR></CODE></P>
<P>This seems pretty consistant with the description of how it is done within CRM and appears to accomplish what I am after.&nbsp; I will have to go back through my use cases to see that it fits across the board, but I think it will do the trick.</P>
<P>Thoughts?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, April 09, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>A PrivilegeCheck would do exactly what the existing static methods are doing: check IsInRole and return true/false based on whether the current user MAY be able to perform the requested action.&nbsp; For instance, if I have a user that is in the Account Managers role, they may be able to edit a Quote object so we would enable the Properties toolbar button and allow them to open the Quote details form/page.
<p>An AccessCheck is where the instance part comes in that I am talking about.&nbsp; An AccessCheck is what determines whether or not the user can actually perform that action on the specific instance of a BO.&nbsp; This would be where we would have to apply&nbsp;the authorization rules that I described and is what would tell me to display the form as read-only and/or disable the Save button, etc.</div></BLOCKQUOTE></p><p>Hmm, that sound very similar to what I was getting at. <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>What dawned on me in reading this is that my problems may be solved as
simply as creating overloaded versions of the static methods that
accept the instance being checked as a parameter.</div></BLOCKQUOTE></p><p>Pirate, why the static method though (I know, I threw something similar out there as well..)?&nbsp; <br></p>It seems it would be easier if you had instance properties, then you could even bind those properties to the Enabled state of buttons.&nbsp; <br><p>Anyway, it sounds like you're making progress, so that's good</p>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, April 09, 2007</h2><P>Looks like you combined my advice with Andy's. &lt;g&gt;</P>
<P>I said you needed an instance of the BO and Andy said: "your static methods will have to take parameters that give enough information to get a result.&nbsp; The parameterless static methods would return in general what someone may do."</P>
<P>Your detailed explanation was very valuable - it made the "advice" much clearer on how to do it and why.</P>
<P>I am not sure that the sample code at the end matched you original use cases though.</P>
<P>Also - you didn't show *when* you instanitate the instance of the DataItem which is a Quote object.</P>
<P>In your sample code you already had it. Why would you bother creating it if the user wasn't allowed to do something with it? (The paremeterless check.) Once you determine they might be able to do something with it, it makes snese to create an instance and find out exactly what they are allowed to do.</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, April 10, 2007</h2><P>First answer: the static methods follow the Csla approach and are declared as such so that the current user can be authorized without instantiating an object of the specific type.&nbsp; For instance, if I have a New Project menu item, I can check Project.CanCreateObject() and set the menu item's enabled or visible property accordingly.&nbsp; Certainly not someplace you'd want to instantiate an object.</P>
<P>As for having both of the methods I described static, it is mostly for consistency.</P>
<P>Second question, the sample code I shown at the end of my last post is from a real-world application that is (now) running this exact code.&nbsp; I did not copy the rest of the code from the class because it is not relevant and is quite large.&nbsp; Nonetheless, the DataItem property returns the BO that the form is bound to - in this case a Quote object.&nbsp; Since the form is used to display the BO for inserting (creating), editing or in read-only mode, you have to instantiate an object.&nbsp; The only right that isn't included in this is the right to view the object (via CanReadObject).&nbsp; This check is performed in another event handler and throws an exception if the user isn't allowed to view the object.&nbsp; Otherwise, with that right granted, the form is going to be displayed in one of its three modes so we will always need to instantiate the object.</P>
<P>And, ultimately, it was intended as a possible use of the code explained above it and not meant to be comprehensive.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jimbo replied on Saturday, April 14, 2007</h2><br>
We have many cases of the same basic problem where the state of the
instance will override the result of the static canEditObject and
canDeleteObject methods and this is needed to control the state of the
UI. However this cant be transmitted to the UI (developer) without
instantiating the object, which makes the concept of the static method
overloads tempting.<br>
However I am having difficulty seeing how you can enforce the use of
the overload of the static canEdit, canDelete etc methods over the
default method.<br>
<br>
jimbo<br>
<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks replied on Tuesday, April 17, 2007</h2><P>use-cases of a user getting read access to only certain properties:</P>
<P>What about an application that holds personal details like salary - say an HR application? Most users should only be able to view 'public' information like e-mail address, emergency contact details etc. but not be able to see whether they get paid more than the person they are enquiring about! Only HR and high up manager types should be able to see salary details.</P>
<P>Another one is credit card details (held no doubt in an encrypted format and using SecureString!) which should not be visible to most people but may need to be visible to one or two high up managers. As mentioned above, in this instance you might not raise an error but return something different. It might be that some people are able to see all the card numbers but most can see only the last 4 digits.</P>
<P>Here in the UK we are more strict on other personal information like home address etc. than I believe is the default case in the States so this may be another area where this kind of per-property read enablement is beneficial. Again, a return of blank details or some suitable message may be more appropriate than raising an error.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JabbaTheNut replied on Thursday, May 03, 2007</h2><P>SonofPirate,</P>
<P>What did you end up doing?&nbsp; </P>
<P>I have a very similar situation in which I have a User object that can be edited by:</P>
<P>1) Administrator</P>
<P>2) User Admin</P>
<P>3) The user represented by the object (i.e., a user can edit his or her own record)</P>
<P>In the first two cases, I can simply use the static CanEditObject() method.&nbsp; But in the third case, I would need an instance of the object to make the determination that the user was editing his or her own object.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Plowking replied on Thursday, May 24, 2007</h2>Hi JabbaTheNut<br><br>In the particular case you mentioned, where a user is editing their own record, you dont need an object instance! As long as the object you are editing has a unique key corresponding to the application.context.username you can do a check on this, as I indicated! (i.e. there is a one to one relationship between your user and the object)<br><br>
In your canGetInstance static method you supply the username which
uniquely identifies the object you wish to fetch as a parameter. If username parameter matches your logged in username canGetInstance will return true. Use canGetInstance
to deny your user access to the edit instance screen. Once yor user
has reached the edit instance screen, you have an object instance
anyway, so you can in principle use a non shared canEditInstance method to check if they have edit rights, or a shared method where you pass your instances username as a parameter (this is what I was getting at in my last post).<br><br>I'm pretty sure this theory holds, also for an address object etc, just so long as there is a one to one relationship between user and address, simply ensure the address object includes a property which is the users login name.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jamie.clayton replied on Thursday, January 22, 2009</h2><P><FONT face=Arial size=2>I know this post is from a while back, but I'm looking at the problem as a row level database security situation.</FONT></P>
<P><FONT face=Arial><FONT size=2>For my two cents it would seem that the having an overloaded&nbsp;CanEditObject(typeof(CSLA BusinessObject)) means that the cat is out of the bag and another CSLA business object (Collection/list etc)&nbsp;has already read and retrive the data incorrectly for a user role.</FONT></FONT></P>
<P><FONT face=Arial><FONT size=2>Being a defensive programmer I can see other ways to stop users from reading/editing and use the CSLA AuthorizationRules.</FONT></FONT></P>
<P><FONT face=Arial><FONT size=2>During the DataPortalFetch methods, reading the data and then calling throwing Security.SecurityExceptions or explicity setting the AuthorisationRules after the data retrieval attempt.&nbsp; This way the BO isn't going to pass information back to the client application and expose data.</FONT></FONT></P>
<P><FONT face=Arial size=2>Alternatively the SQL text/storedprocedure used by the dataportal fetch could pass security information and then also "block" returning data if the user wasn't allow to get at it.</FONT></P>
<P><FONT face=Arial size=2>If the CSLA solution was exposed to the world via a Web service, there is no way I would allow the BObject to pass information out.</FONT></P>
<P><FONT face=Arial size=2>Example code that applies AuthorizationRules in another part of the business object ( I don't see why that's not a logical and easiest&nbsp;thing to do?).</FONT></P>
<P><FONT face=Arial><FONT size=2><FONT size=2></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> DenyPaidRecordUsers </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2>() = {</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>My</FONT></FONT><FONT size=2>.Resources.Role_User</FONT><FONT size=2>}</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> EditPaidRecordsUsers </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2>() = {</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>My</FONT></FONT><FONT size=2>.Resources.Role_Admin}</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</FONT></FONT><FONT size=2> HasBeenPaided </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Then</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>With</FONT></FONT><FONT size=2> AuthorizationRules</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' More importantly if a record has been paid general users can not edit or delete it.</P></FONT></FONT><FONT size=2>
<P>.DenyExecute(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"DeleteRecord"</FONT></FONT><FONT size=2>, DenyPaidRecordUsers)</P>
<P>.AllowExecute(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"DeleteRecord"</FONT></FONT><FONT size=2>, EditPaidRecordsUsers)</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' In defensive mode, lets block the user from saving the record (just case they have loaded a record [or created one from scratch])</P></FONT></FONT><FONT size=2>
<P>.DenyExecute(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Save"</FONT></FONT><FONT size=2>, DenyPaidRecordUsers)</P>
<P>.AllowExecute(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Save"</FONT></FONT><FONT size=2>, EditPaidRecordsUsers)</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' If there is a payment, then don't allow all the fields to be edited.</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' Admin user role should be allowed to change some information.</P></FONT></FONT><FONT size=2>
<P></FONT>
<P><FONT size=2></P>.AllowWrite(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"SaleDate"</FONT></FONT><FONT size=2>, EditPaidRecordsUsers)</P></FONT><FONT size=2>
<P></FONT>
<P><FONT size=2></P>.DenyWrite(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"SaleAccountBal"</FONT></FONT><FONT size=2>, DenyPaidRecordUsers)</P>
<P></FONT>
<P><FONT size=2></P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>With</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</P></FONT></FONT></FONT></FONT>
<P><FONT face=Arial><FONT size=+0>&nbsp;</P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jamie.clayton replied on Thursday, January 22, 2009</h2><P>Let me add to my previous post. The CSLA 3.x AuthorizationRules add entries only, so you can't change them after you create the object. I do however need to change authorization based on OB instance data.&nbsp;To get the Deny properties to work I've had to use AuthorizationRules.InstanceDenyWrite("PropertyName") and Shadow&nbsp;the&nbsp; CanWriteProperty("propertyName",Boolean) as follows</P><FONT color=#008000 size=2><FONT color=#008000 size=2>
<P>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;summary&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' Need to change this call to ensure that Deny property entries took preference over Write authorization.</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;/summary&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;param name="propertyName"&gt;&lt;/param&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;param name="throwOnFalse"&gt;&lt;/param&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;returns&gt;&lt;/returns&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;remarks&gt;&lt;/remarks&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Shadows</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</FONT></FONT><FONT size=2> CanWriteProperty(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> propertyName </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2>, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> throwOnFalse </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean</FONT></FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> result </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean</FONT></FONT><FONT size=2> = CanWriteProperty(propertyName)</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</FONT></FONT><FONT size=2> throwOnFalse </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>AndAlso</FONT></FONT><FONT size=2> result = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>False</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Then</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> ex </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>New</FONT></FONT><FONT size=2> System.Security.SecurityException( _</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2>.Format(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"{0} ({1})"</FONT></FONT><FONT size=2>, </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Property set not allowed"</FONT></FONT><FONT size=2>, propertyName))</P>
<P>ex.Action = System.Security.Permissions.SecurityAction.Deny</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Throw</FONT></FONT><FONT size=2> ex</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Return</FONT></FONT><FONT size=2> result</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;summary&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' CSLA tests for write/read authorisation and ignores deny</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' As we want to apply instance authorisation (rules that look as BO data) we add deny(Property) calls</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' and then check to see if a property was denied and make sure it has priority.</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;/summary&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;param name="propertyName"&gt;&lt;/param&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;returns&gt;&lt;/returns&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>''' </FONT></FONT><FONT color=#808080 size=2><FONT color=#808080 size=2>&lt;remarks&gt;&lt;/remarks&gt;</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Shadows</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</FONT></FONT><FONT size=2> CanWriteProperty( _</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> propertyName </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>String</FONT></FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> result </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Boolean</FONT></FONT><FONT size=2> = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>MyBase</FONT></FONT><FONT size=2>.CanWriteProperty(propertyName)</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' Deny authorization should be check for the property</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>' In most security mechanisms deny overpowers and read/write privalages.</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</FONT></FONT><FONT size=2> AuthorizationRules.IsWriteDenied(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"SaleProgress"</FONT></FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Then</P></FONT></FONT><FONT size=2>
<P>result = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>False</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Return</FONT></FONT><FONT size=2> result</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Function</P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Plowking replied on Tuesday, April 17, 2007</h2>&nbsp;&nbsp;&nbsp; This is much like the suggestion to pass an instance of the object into the shared function . I kind if implemented this in a reverse sense, instead of passing an instance into a shared function , I created a class level function which can be called on an instance<br><br>&nbsp;&nbsp; In this example, a user can edit an instance if their Username matches the instances mUserName property, OR they have CanEditObject rights.<br><br>&nbsp;&nbsp;&nbsp; mUserName as String<br><br>&nbsp;&nbsp;&nbsp; Public Function CanGetInstance() As Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return ApplicationContext.User.Identity.Name.Equals(mUserName) Or CanGetObject()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Function<br><br>Anyone comment on this as good OO design, or is passing an instance into a shared function better?<br><br>Ian<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
