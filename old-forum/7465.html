<html><header><title>Basic DataPortal / Client/Server Guidance Required...</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Basic DataPortal / Client/Server Guidance Required...</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7465.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor posted on Monday, August 17, 2009</h2><P>Hi,</P>
<P>I wonder if anybody can help point me in the right direction as regards setting up the data portal in a simple client / server environment.</P>
<P>We are in the process of converting an internal&nbsp;business application from Visual Foxpro to DotNet, and we have used CSLA as our base framework.&nbsp;All DotNet code is WinForms based and we have not written anything using ASP, and have no requirement to have the&nbsp;application accessed externally via the web (&nbsp;for the time being at least ).</P>
<P>Initially as we have begun coding, the DataPortal worked out of the box, and we left it alone as our priority was to migrate some key parts of our old application to the new DotNet environment. As the application has begun to take shape its clear that data access can sometimes be slow, and there is an obvious requirement to look at the configuration of the data portal, and ideally we would like to set the business objects up to be mobile, and have the data access layer running separately on the database server and not the client workstation. Presumably everything is running&nbsp;on the client machine at present,&nbsp;as all forms and&nbsp;business objects etc.&nbsp;are all compiled into one application.</P>
<P>There is a lot of information in the book regarding the data-portal, but I wondered if someone could help point me in the right direction as to how I set the data portal up and indeed how the application should be structured to get it to work as a true client&nbsp;/ server application. I suspect its fairly straight forward, but some help would be greatly appreciated....</P>
<P>Many thanks,</P>
<P>Nick&nbsp;&nbsp;&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, August 17, 2009</h2>Hi,<br><br>Look at the ProjectTracker solution the samples download for Csla. <br><br>In the app.config of the PTWin client you will find setting for RemotingProxy, WcfProxy and WebServiceProxy along with sample services (and the services contain almost no code to support MobileObjects). <br><br>/jonnybee<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Monday, August 17, 2009</h2><P>Thanks,</P>
<P>I will take a look and let you know how I get on...</P>
<P>Nick</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, August 17, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>NickTaylor:</strong></div><div> 
<P>As the application has begun to take shape its clear that data access can sometimes be slow...</P>
<P></div></BLOCKQUOTE></P>
<P>FYI -the use of a remote DataPortal will slow things down even further. (Up to 50% slower, as I recall).&nbsp;You pay a performance penalty for the flexibility of using a remote portal which gains you scalability. There is always a tradeoff.</P>
<P>Also, virtually every complaint I have ever read about CSLA being "slow" has been due to coding errors on the part of the user. CSLA is faster than Datasets. CSLA can use ADO.Net dtaareaders which are the fastest possible way to extract data from a database. If something is slow you are probably doing something incorrectly. The #1 mistake is to fill the BO using *Properties* when in fact you should be using *Fields*. By filling the BO in the dataportal using properties you unnecessarily trigger a ton of events which are not needed (yet).</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Monday, August 17, 2009</h2><P>Hmmm, perhaps I had better just close the book and go and do something else instead...! :o(</P>
<P>Remember too that I am not using SQL, I am actually accessing my FoxPro data via OleDb, and my business object DataPortal commands all use this methodology. I'm forced to go this route as we are migrating away from VFP&nbsp;one form at a time, and its very handy to be able to write new forms which access the existing VFP data.</P>
<P>Typically I find two distinct requirements for accessing data, 1) via the normal CSLA business objects, i.e BoCustomer.GetByID(string customerID), and 2). via queries which return datasets such as GetAllCustomers() or GetAllSuppliers(). These are returned as DataTables rather than populated&nbsp;list objects, however all these queries are routed through a single ExecuteQuery object which is <SPAN>essentially</SPAN> a CSLA command object which has a single static method i.e. GetDataTable(string sqlSelectCommand). This accepts the&nbsp;SQL command as its input parameter and returns me a DataTable. I use these read only DataTables all over the place for populating combos for example, and for driving navigation within my maintenance forms.</P>
<P>There are however&nbsp;many instances&nbsp;where I return a DataSet following the entry of some information from a user. For example the ShowPartTransactionHistory() form requires the user to&nbsp;enter a part number after which I return a datatable containing all part transactions against that specific part. Whilst the data returned may only be a few hundred records, the underlying datatable is pretty large ( 500K records + ), the form&nbsp;can appear go to sleep ( it actually goes blank ) for 5 seconds or so whilst the data is returned. This doesn't make for a&nbsp;good user experience, and I&nbsp;had assumed that adopting a proper client / server architecture would be the way to&nbsp;go and might resolve this problem.</P>
<P>Perhaps I need to re-evaluate the issue, as I don't want to slow the application even more. We typically only have 50-users&nbsp;accessing the system, so it's not as if we have hundreds of people all hammering the system at the same time.</P>
<P>Can I also ask that even though I am running C# Winforms code, I should be considering the DotNet&nbsp;remoting technology&nbsp;which according to Rocky's book I should be hosting&nbsp;via IIS and ASP.NET. Is that right or am I barking up the&nbsp;wrong tree ( again )...?!</P>
<P>Thanks,</P>
<P>Nick&nbsp;&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, August 17, 2009</h2><P><FONT face=Tahoma size=2>How you host your remote DataPortal depends on a lot of factors.&nbsp; The current "best practice" from Microsoft is to use WCF, which the DataPortal can happily accommodate.&nbsp; And you can certainly use IIS and ASP.NET - that's probably the simplest hosting option, and the one you can probably get up and running the quickest (given that there are examples of doing so).&nbsp; WCF configuration is more than a PITA, so any help you can get to get up and running will make your life easier.&nbsp; Hosting via IIS isn't going to run any slower than the other hosting options.</FONT></P>
<P><FONT face=Tahoma size=2>In terms of improving your response time, Joe is right - adding a remote call is not going to make your app go faster.&nbsp; You've added a whole new communication layer that requires that objects be serialized and de-serialized.&nbsp; So if you're getting slow response now, going to an "n-tier" arrangement isn't going to make it faster.&nbsp; What you're probably running into for speed is simply the amount of data you're dealing with.&nbsp; In addition, since you're accessing FoxPro data, you probably aren't getting any help from any indexes you may have.&nbsp; I have a limited amount of&nbsp;experience accessing dBase data&nbsp;in .NET, and IIRC indexes were pretty much ignored.&nbsp;&nbsp;So your OLE DB driver is likely doing a table scan - and in the case of your transaction-history table, that's a lot of data to move through.</FONT></P>
<P><FONT face=Tahoma size=2>Outside of that, I'd also take Joe's recommendation to move my CSLA data-access code away from DataTables/DataSets and into DataReaders if possible.&nbsp; You'll eliminate a data-transformation step - ADO.NET uses DataReaders internally, so your data path currently looks something like this: DataReader -&gt; DataTable -&gt; CSLA object.&nbsp; If you cut out the middleman (DataReader -&gt; CSLA object),&nbsp;you will also see some speed improvement.</FONT></P>
<P><FONT face=Tahoma size=2>Finally, you can look into asynchronous access.&nbsp; Ultimately, all these suggestions aren't likely to get you the speed you need (though I'd still do as many of them as you can.)&nbsp; So you need to move the data access off the main thread, so that your UI doesn't block while it waits for data.&nbsp; The data won't return any&nbsp;faster, but the form won't freeze on you, so it will feel to the users like the app is more responsive.&nbsp; There are a bunch of techniques for doing that, though in the WinForms world the easiest is probably to utilize the BackgroundWorker component.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Tuesday, August 18, 2009</h2><P>Thank you both for your reply...</P>
<P>I'm certainly going to have a look at the BackgroundWorker component as I haven't used this before. There are only certain forms&nbsp;which&nbsp;are causing problems, and as you would expect they are the ones that are accessing data from within large tables.</P>
<P>Just to clarify the point regarding the data objects, typically each table in my FoxPro application now has an associated CSLA business object. Just to make matter worse our old application is written in FoxPro ver 2.6 which had no concept of a database, so all the tables are free tables thus eliminating the user of stored procedures etc.&nbsp;(ouch!). In fact I have a helper/developer routine that&nbsp;reads the table structure and then generates the basic business object class for me so I dont have to keep writing essentially the same code over and over. Every fetch/insert/update command has the same basic structure, typically for a fetch command something along the lines of:-</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> DataPortal_Fetch(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Criteria</FONT></FONT><FONT size=2> criteria)</P>
<P>{</P>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbConnection</FONT></FONT><FONT size=2> connection = </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>KELplanAPP</FONT></FONT><FONT size=2>.Connection;</P>
<P>connection.Open();</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>// Command object</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbCommand</FONT></FONT><FONT size=2> Command = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbCommand</FONT></FONT><FONT size=2>(criteria.SelectCMD, connection);</P>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbDataReader</FONT></FONT><FONT size=2> dr = Command.ExecuteReader();</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>// Update BoUserTitle</P></FONT></FONT><FONT size=2>
<P>dr.Read();</P>
<P>_key_id = (</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2>)dr[</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"key_id"</FONT></FONT><FONT size=2>];</P>
<P>_title_ref = dr[</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"title_ref"</FONT></FONT><FONT size=2>].ToString().Trim();</P>
<P>_title = dr[</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"title"</FONT></FONT><FONT size=2>].ToString().Trim();</P>
<P>_comments = (</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2>)dr[</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"comments"</FONT></FONT><FONT size=2>].ToString().Trim();</P>
<P>_active = (</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>bool</FONT></FONT><FONT size=2>)dr[</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"active"</FONT></FONT><FONT size=2>];</P>
<P>connection.Close();</P>
<P>}</P></FONT><FONT size=2>
<P>So I am updating the BO straight from the datareader, and this should be in line with your suggestions (hopefully) ?</P>
<P>However when I just want to fetch some data for the purposes of populating a grid or allowing the user to browse something, I use my ExecuteQuery command object. Here I have no choice other than to return a DataTable as the datareader is active only while the connection is open isn't it ? The main methods looks like this:-</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataTable</FONT></FONT><FONT size=2> GetDataTable(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2> selectCMD)</P>
<P>{</P>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ExecuteQuery</FONT></FONT><FONT size=2> result;</P>
<P>result = </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortal</FONT></FONT><FONT size=2>.Execute&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ExecuteQuery</FONT></FONT><FONT size=2>&gt;(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ExecuteQuery</FONT></FONT><FONT size=2>(selectCMD));</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> result.ResultData;</P>
<P>}</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>override</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> DataPortal_Execute()</P>
<P>{</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>// Open the conection</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbConnection</FONT></FONT><FONT size=2> connection = </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>KELplanAPP</FONT></FONT><FONT size=2>.Connection;</P>
<P>connection.Open();</P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>// Command object</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbCommand</FONT></FONT><FONT size=2> Command = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbCommand</FONT></FONT><FONT size=2>(_selectCMD, connection);</P>
<P></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>OleDbDataReader</FONT></FONT><FONT size=2> dr = Command.ExecuteReader();</P>
<P>_dtResult.Load(dr);</P>
<P>_rowCount = _dtResult.Rows.Count;</P>
<P>connection.Close();</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2>;</P>
<P>}</P>
<P>So I dont think I can do anything else but return a DataTable object from this method. If i'm missing the point here let me know as I would be interested to learn if there is a better way of doing this...</P>
<P>Thanks again for your input...</P>
<P>Nick</P>
<P>&nbsp;</P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, August 18, 2009</h2><P>The first part looks fine.</P>
<P>The 2nd part with the Datatable does work but...</P>
<P>Why aren't you building a CSLA collection instead? A collection can be populated with a datareader which reduces the overhead of using a dataset. (Not a huge difference - but not zero either.) Also a CSLA collection could be readonly or read/write. Either way the contained object could have fewer fields than an entire table (maybe your datatable does not have all fields either.)</P>
<P>Finally, is there any way to get the command to use the Fox indexes? That could speed things up if you could avoid table scans. Google is your friend here.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Tuesday, August 18, 2009</h2><P>Ok Joe,</P>
<P>I will now launch myself into another discussion...</P>
<P>At present in addition to the normal CSLA business object ( one per table ), I have another set of objects that I call "entity" objects. A customer gets one, inventory gets one, a job gets one, a user gets one and so forth. Typically these "entity" objects contain lots of static methods that simply return datasets to my application. For example: Inventory.GetInventoryByPartNumber(string partNumber) looks like:</P><FONT size=2>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>// Returns all inventory for the specified part number</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataTable</FONT></FONT><FONT size=2> GetInventoryByPartNumber(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2> partNumber)</P>
<P>{</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>string</FONT></FONT><FONT size=2> selectCMD = </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"SELECT Stkfile.key_id, Stkfile.issue_no, Stkfile.bin_id, Stkfile.bin_number, Stkfile.locn_code, "</FONT></FONT><FONT size=2> +</P>
<P></FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Stkfile.lot_number, Warehous.title, Warehous.location, Stkfile.qty_in_stk, Stkfile.inspect_id "</FONT></FONT><FONT size=2> +</P>
<P></FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"FROM stkfile LEFT OUTER JOIN warehous ON Stkfile.locn_code = Warehous.locn_code "</FONT></FONT><FONT size=2> +</P>
<P></FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"WHERE Stkfile.our_partno = '"</FONT></FONT><FONT size=2> + partNumber + </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"' ORDER BY lot_number"</FONT></FONT><FONT size=2>;</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ExecuteQuery</FONT></FONT><FONT size=2>.GetDataTable(selectCMD);</P>
<P>}</P>
<P></FONT>I think this feels right, and its fairly scalable as I can just keep slotting in new methods as and when required. I thought initially that&nbsp;having a collection object&nbsp;and subsequent child object type&nbsp;for each query&nbsp;might be more difficult to manage and hence I steered clear of that strategy.&nbsp;Is this the way you do it ?</P>
<P>I will have to do some more research on the Fox indexes issue. As you correctly point out a trawl around Google will probably throw something up...</P>
<P><BR>Many thanks,</P>
<P>Nick&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 19, 2009</h2>Well, to take full advantge of Csla, you shouldn't be returning any Sytem.Data classes to your UI layer; you should be returning Csla based objects instead.  This will decouple your data access from the UI, which is exactly what you want.  <br /><br />Build the BOs according to what you need to fulfill a use case, and your UI should ONLY use those BOs to fulfull the use case.  <br /><br />If you do this, in the end you can then move away from Foxpro, and you'll only need to change code in your DataPortal_XZY methods... your UI will remain unchanged.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Wednesday, August 19, 2009</h2><P>Ok, I see the logic in that. I guess I am being a bit lazy by returning datatables rather than&nbsp;CSLA collections and this will inevitably catch up with me later down the line&nbsp;when I&nbsp;undoubtedly want to change my application. The CSLA collections should decouple the UI completely. Understood.</P>
<P>But all of the data I return via my datatable methods is read only. Its only used for displaying grid based data or for populating combo's etc. You are&nbsp;suggesting that every query requires a collection and associated business object. In the case of the GetAllCustomerSales() method&nbsp;for example then I would still require a collection class for this, and a bespoke&nbsp;business object which contains the relevant properties populated by the DataPortalFetch() method. As this is a reporting&nbsp;requirement only ( and not a true business object )&nbsp;it wouldn't&nbsp;need any&nbsp;DataPortal_Insert() and DataPortal_Update() methods as they will never be used for the purposes of updating the underlying database.</P>
<P>Have I read you correctly...?</P>
<P>Thanks,</P>
<P>Nick&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 20, 2009</h2>Yes, thats absolutely correct.  You have a use case which customers sales need to be returned and display, you should have some Csla business objects which can fulfill that use case.  For this, you'd create subclasses of ReadOnlyBase and ReadOnlyListBase, which would only implement fetch methods. <br /><br />The advantage is that it doesn't matter where your data comes from your BOs "know" where to get the data to assembly the model of the data.  If you leave Foxpro, only the data access code in the BOs needs to change.  Your UI can remain unaffected.  Also, you can then throw away your UI, keeping your investment in the business layer.  For example, if you had a WinForms csla app, and then want to move to WPF, you can do that without losing all your business logic.  With your current setup, you likely have business rules in the UI, so any change to your database or UI can break the whole app.<br /><br />Its unlikely the concept / use case around customers sales will change, but your UI can, and your database might.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Thursday, August 20, 2009</h2>Just to add my 2 cents; If you use some sort of code generation tool then the creation of these read-only CSLA collection/child classes that map directly to your database, becomes a trivial exercise.&nbsp; There are various tools out there with varying initial up-front investment (in money and setup), including CodeSmith and MyGeneration.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Friday, August 21, 2009</h2><P>Thank you again...</P>
<P>I realise that whilst I am part way to my n-tier structure, I am not where I should be and there is still too much sitting in the UI layer... I think the business list suggestion will also help rationalise some of my current object organisation which has become a bit messy in places. For examply my new CSLA&nbsp;CustomerSales object can have a bunch of static methods which return all sorts of different sales analysis as the underlying CSLA list properties will be the same in each case. Currently these sit as methods in a Customer "entity" object which is not really a true BO.</P>
<P>In respect of the code generation tools, then I wrote a FoxPro program which generates CSLA object code for each of my free tables. It works a treat. I will extend this to&nbsp;produce list objects too :o)</P>
<P>Many thanks again for your advice. I can see the logic of your thinking...</P>
<P>Nick&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 19, 2009</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>In terms of improving your response time, Joe is right - adding a remote call is not going to make your app go faster.&#160; You've added a whole new communication layer that requires that objects be serialized and de-serialized.&#160; So if you're getting slow response now, going to an "n-tier" arrangement isn't going to make it faster.</div></BLOCKQUOTE><br /><br />Well, that's not necessarly true.  Assuming your database server is not on the client machine, remoting or wcf CAN make the application faster.  The reason is that db communication by its very nature is exteremly chatty.  I hit this exact wall when some of my users moved to our other office location in the next town.  The builders are linked via a T1, but performance from there was awful.<br /><br />Enabling remoting + compression DID improve the speed of the application, at least in the network communication pieces.<br /><br />Instead of sending 30 to 50 sql commands back and forth one by one, remoting sends a compressed stream, all the db access occurs on the app server, and then one more message is sent back with the new object graph.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
