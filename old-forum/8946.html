<html><header><title>Setting SuppressRuleChecking to true should clear existing errors</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Setting SuppressRuleChecking to true should clear existing errors</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8946.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch posted on Monday, May 17, 2010</h2><p>In CSLA 3.6, I notice that if I set <span style="font-size:x-small;">SuppressRuleChecking = false, the current list of errors remains, even if I call <span style="font-size:x-small;">CheckRules() after that. I would have assumed that changing this setting to false would make all rules defacto &quot;not in error&quot; and so it should clear the current error list. But, that may not be quite enough - in order to get DataBinding to re-check the field, the framework needs to notify property changed on every property currently in error that is becoming &quot;not in error&quot; as a result of the supression. And, conversely, if all I am doing is turning the suppression off, a supsequent call to CheckRules() needs to notify on each property found to be in error.</span></span></p>
<p><span style="font-size:x-small;"><span style="font-size:x-small;">Is this something that might be different in the current release of CSLA? Is there anyone out there that understands my request that can help me out? Basically, I have a BO that can go &quot;offline&quot; and when offline, it is not in any state of error. When the BO comes back online, I need to re-run the rules and notify changes because that is the only time DataBinding seems to come and ask for that properties errors.</span></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>The scenario SuppressRuleChecking is designed to support is batch loading of an object - specifically it was added for web-based scenarios where you are handing a page postback or a web service call and you are loading data from the call into the object. It is designed for this sort of flow:</p>
<ol>
<li>Get the inbound data (from postback or service call)</li>
<li>Create an instance of the business object</li>
<li>Suppress rule checking</li>
<li>Load all the properties of the business object</li>
<li>Stop suppressing rule checking</li>
<li>Call CheckRules() to invoke all rules</li>
</ol>
<p>The reason for this feature is to prevent multiple runs of the rules - especially expensive ones - that might otherwise occur as each property is set. If you have dependent properties, many of your rules may end up running many times, which is great in a smart client scenario, but very inefficient in a batch load scenario like the web.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Monday, May 17, 2010</h2><p><span style="font-size:9pt;color:black;font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;">That is all very well, but does not preclude the SuppressRuleChecking&nbsp;property from being usable in an Online/Offline mode as well. That is, they are two distinct features that can be accomplished via that one property. Additionally, I would&nbsp;guess that you&nbsp;might agree that&nbsp;a business object should be&nbsp;&quot;in the appropriate state&quot;&nbsp;after successfully setting one of its properties, no? And there is no restriction from setting SuppressRuleChecking = true any old time and just leaving it that way&nbsp;(albeit, I understand,&nbsp;not its intended purpose). So, if I can set the property and leave it, come back later and set it back and leave it, the business object should correctly reflect those changes in state, and in this case it can without losing any of the current functionality. I had used the Ocean Framework once and easily modified that framework to it. I am not as well versed in CSLA, but it looked on the surface that it should be easy in&nbsp;it as well.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Monday, May 17, 2010</h2><p>Here is a quick little app hacked to show the basic conditions. NOTE: I grabbed as little as possible from here and there to make this work - sorry if those parts and not pretty or perfect. You have to change the reference to the CSLA project - I did not upload that cause I figured I didn&#39;t need to.</p>
<p>What I would expect to happen, is for my error adorners to jump back and forth with the enabled TextBoxes. I believe there are two parts to making that happen. One, is to change the what&nbsp; SuppressRuleChange does when changed and the other is that you need to fire (I believe) a NotifyPropertyChanged on each property when the BrokenRule is added and removed or else WPF will not come back and ask for the latest errors.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>I guess I wasn&#39;t clear - what I was saying in my previous post is that there&#39;s a specific scenario SuppressRuleChange is designed to address. I don&#39;t think you are in that scenario, so it doesn&#39;t surprise me that it isn&#39;t meeting your needs.</p>
<p>It might be better to step back and help me understand your needs to see if there&#39;s an existing solution.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Monday, May 17, 2010</h2><p><span style="font-size:9pt;color:black;font-family:Arial;">I understood your point and I appreciate that is what it is used for currently. Unfortunately, it is called&nbsp;SuppressRuleChange and not HoldUpErrorsWhileLoading, or just plain Loading. Given it&#39;s name, and its name being a useful property as named, the object should be in a state of suppressing all errors when it is set to TRUE (or better said, error free)&nbsp;and return to an appropriate error state when FALSE. That would make it do things like I need and still be totally useful for its current purpose.</span></p>
<p><span style="font-size:9pt;color:black;font-family:Arial;">My app shows how I intend on using it. In my app, I have objects I want to keep in memory, as the active DataContext, but that are waiting for external dependencies in order to be considered useful. While the object is waiting for these external dependencies, I do not want it to be in error. The sample app shows why, the IsEnabled of the controls (via the IsEnabled of their container in reality) is bound to the objects Online property (not really called that) and disabled controls should not be in error.</span></p>
<p><span style="font-size:9pt;color:black;font-family:Arial;">I guess you could make a point that there should be a ShortCircuit Rule for stopping further Rules checking per property. That is, a Rule that says if TRUE, the property is not in error and no more error checking is required. This would allow for internal states that say some portion of the object is not currently in use, although that is not my need or point at this time.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>I think the property name and xml comments are reasonably clear:</p>
<p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Gets or sets a value indicating whether calling<br />&nbsp;&nbsp;&nbsp; /// CheckRules should result in rule<br />&nbsp;&nbsp;&nbsp; /// methods being invoked.<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;value&gt;True to suppress all rule method invocation.&lt;/value&gt;<br />&nbsp;&nbsp;&nbsp; public bool SuppressRuleChecking</p>
<p>You are right - the correct answer, especially when you look forward to CSLA 4, is to implement a gate condition rule that stops most of your rules when your object&#39;s state is such that rules shouldn&#39;t be applied. That&#39;s how the rule system is supposed to work - rules should be expressed, literally, as rules.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Tuesday, May 18, 2010</h2><p>Ok, that almost seems to suggest that I should remove my rules, or disable them maybe,&nbsp;when they are not in effect, but there does not seem to be any way to do that.&nbsp;A quick test with my three custom Rules showed that: if Rules could be &quot;turned off&quot; (in my test I added&nbsp;very crude control property&nbsp;and they return TRUE if they are off), then the current system would work just fine. The rules all still get called, which is a&nbsp;little inefficent, but because they all returned true, everything is hunky-doory.</p>
<p>I think I can stand by my first observation: If I am suppressing all rule checking, then my object can not possibly be&nbsp;in error. And furthermore, to make sure everyone knows that, any currently&nbsp;reported&nbsp;errors should be cleared out.</p>
<p>One of the other things I have not looked into&nbsp;from a&nbsp;CSLA point of view is delaying the checking of errors until they attempt to save the object for the first time. This feature might be usefull in that instance as well, although it is complicated by software errors (like required filed missing). Leaving me wonder if adding a <span style="font-size:x-small;">ValidationRules.</span>MaximumPrioirty integer property would not be the best. As Validation is running the Rules, it would &quot;act as if Rule returned TRUE&quot; if the Rule.Priority is &gt; than the current MaximumPrioirty. That might be self-explainitory but I can provide more info if not.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Tuesday, May 18, 2010</h2><p>A quick test showed that indeed&nbsp;that a new property of&nbsp;&quot;public int MaxPrioirty = int.MaxValue;&quot;&nbsp;added to ValidationRules gave me exactly what I wanted. I can now easily control the depth of Rule checking based on the state of the B.O. I also added these code fragments (I was not sure the best way to handle the aysnc ones):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ruleResult = rule.Priority &gt; MaxPriority ? true : rule.Invoke(_target);</p>
<p>and</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rule.Priority &gt; MaxPriority || e.Result)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Remove(rule);</p>
<p>
<p><span style="font-size:x-small;"><span style="font-size:x-small;">
<p>&nbsp;</p>
</span></span>
<p>&nbsp;</p>
</p>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 18, 2010</h2><p>You need to use priorities and short-circuiting to stop rule processing. Create a pri&nbsp;-1 rule that acts as a gate rule, setting e.StopProcessing=true to stop further rules from running for that property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Tuesday, May 18, 2010</h2><p>I thought e.StopProcessing is only used if the Rule returns false, which means that an error exists (Description should have a string in it - no?).&nbsp;Looking at the code though I see it should work either way. But does that mean I need one of these per property? It still will not cuase the&nbsp;PropertyChanged() notifications required.&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Gets or sets a value indicating whether this<br />&nbsp;&nbsp;&nbsp; /// broken rule should stop the processing of subsequent<br />&nbsp;&nbsp;&nbsp; /// rules for this property.<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;value&gt;&lt;see langword=&quot;true&quot; /&gt; if no further<br />&nbsp;&nbsp;&nbsp; /// rules should be process for this property.&lt;/value&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;remarks&gt;<br />&nbsp;&nbsp;&nbsp; /// Setting this property only has an effect if<br />&nbsp;&nbsp;&nbsp; /// the rule method returns &lt;see langword=&quot;false&quot; /&gt;.<br />&nbsp;&nbsp;&nbsp; /// &lt;/remarks&gt;<br />&nbsp;&nbsp;&nbsp; public bool StopProcessing</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 18, 2010</h2><p>At some point, and I don&#39;t remember the specific version, but it is in 3.8, the check rules behavior was changed to return a list of affected property names by the rule run, and PropertyChanged is raised for each property in that list (if your property changed mode is set to Xaml - the default is Windows).</p>
<p>Since you are doing WPF (right?), I assume you&#39;ve changed the property changed mode to Xaml?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Tuesday, May 18, 2010</h2><p>I had meant to, but, had not - sorry for that. That solved my AddDependentProperty() rule now doing what I want it to but...</p>
<p>It seems that&nbsp;behavior is only&nbsp;in the per-property version of CheckRules(), the place I have been looking is in the one&nbsp;for re-checking all rules. That one does not collect property names of previously broken rules which are&nbsp;now not broken, and newly detected broken rules. After I change online states, I was calling the all rule version where, quite likely, all that has changed is the broken rules collection.</p>
<p>I have to say, I am really digging the MaxPriority concept. It provides a very nice control. And, more importantly, I very&nbsp;<span style="font-size:9pt;color:black;font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;mso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;">appreciate all</span>&nbsp;of your assistance.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 18, 2010</h2><p>After you call CheckRules(), you can also call OnUnknownPropertyChanged() to get the properties to refresh.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rweyrauch replied on Tuesday, May 18, 2010</h2><p>One last caviate - it almost does everything that is needed. I forgot to remove all my try-it-to-see-what-effect-it-has code. After I reduced the demo to just the new functionality described above, I am left with on eof the problems I described earlier.</p>
<p>If the only thing that has changed is the error string for a bound property - that is, the properties value did not change but the error string did - then the framework MUST signal a PropertyChanged with the name of the property whos error changed. I know what to do for this but not sure I can add it easily to CSLA.</p>
<p>In the past I have ran a HashSet&lt;string&gt; to collect property names. I collected names for any property that changed value, and, the important part, names for any properties that adding OR REMOVING&nbsp;error states. Then after the work is done, I send a PropertyChanged() for each string in the HashSet. The goal is to only signal a given property once, even if it has changed value and error state, making sure to signal it at least once if any of these conditions happen.</p>
<p>Related to that, I was looking at ValidationRules.AddDependantProperty&nbsp;but it did not seem to setup what I was hoping for. I have dependant properties where I want the dependant property B to signal a PropertyChanged when ever property A does so. Right now, I am watching my own OnPropertyChanged()&#39;s and raising the extra event for B&nbsp;when the property name of A&nbsp;comes in. Is there a better way to so join 2 properties?<span style="font-size:x-small;"></span></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
