<html><header><title>Issues with ApplicationContext.ContextManager when calling DataPortal memebers in a Thread created from  ASP.Net web app</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Issues with ApplicationContext.ContextManager when calling DataPortal memebers in a Thread created from  ASP.Net web app</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9231.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>uma posted on Tuesday, July 20, 2010</h2><p>&nbsp;We are experimenting CSLA 4.0 RC0. In our web application (ASP.Net 4.0),on click of a button we create a Thread to do some lengthy calculations in the background . </p>
<p>&nbsp; In the thread we found that all DataPortal operations are failing because GetPrincipal() is trying to retreive HttpContext.Current.User instead of Thread.CurrentPrincipal. On further debugging we found that ApplicationContext.ContextManger gets an instance of Csla.Web.ApplicationContextManager instead of Csla.ApplicationContextManager as the thread is created from ASPNet.</p>
<p>&nbsp;As a work-around , we set ApplicationContext.ContextManger=null while creating every business object to force CSLA to reload ApplicationContext.ContextManger. Not sure whether this is a good idea.Any suggestions?</p>
<p><br />&nbsp;</p>
<p>&nbsp;</p>
<p><br />Code Skeleton</p>
<p>&nbsp;protected void button_Click(object sender, ImageClickEventArgs e)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread thread = new Thread(new ParameterizedThreadStart(StartTask));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread.Start();<br />&nbsp; <br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;private static void StartTask(object param)<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp; // When you check at this point ApplicationContext.ContextManger it is</p>
<p>&nbsp; &nbsp;// Csla.Web.ApplicationContextManager instead of csla.ApplicationContextManager<br />&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, July 20, 2010</h2><p>That&#39;s interesting. The reason there&#39;s a web-specific ApplicationContext is because ASP.NET doesn&#39;t reliably set Thread.CurrentPrincipal. The only safe way to get the principal in ASP.NET is via HttpContext. Similarly, storing context on TLS isn&#39;t safe, again HttpContext is the only safe location.</p>
<p>Now if you are creating your own threads, then you manage their lifetimes, so the rules are different - but the ASP.NET managed threads aren&#39;t safe.</p>
<p>The scenario where failure occurs is an edge case, having to do with early parts of the page lifecycle processing. And when I dug into this it was 4-5 years ago, so I don&#39;t remember the specifics. But it is a very real scenario, and at the time I made the change it was in response to someone hitting the problem (of course).</p>
<p>Back to your threads though - if you are explicitly creating them, then you control their lifetime, so using TLS should be fine - which means the non-web ApplicationContext should be fine.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>uma replied on Wednesday, July 21, 2010</h2><p>We can safely use the Csla.ApplicationContextManager . But switching between Csla.Web.ApplicationContextManager&nbsp; and Csla.ApplicationManager is where it gets tricky.</p>
<p>Now we have to do something like the following in our application to force the contextManager property to load everytime before DP operations.</p>
<p>&nbsp; public&nbsp; class MyBusinessBase&lt;T&gt; : Csla.BusinessBase&lt;T&gt; where T: MyBusinessBase&lt;T&gt;<br />{<br />&nbsp;&nbsp;&nbsp; protected MyBusinessBase() <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.ContextManager = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />}</p>
<p><br />IMHO, it would have been better if CSLA did the following </p>
<p><br />&nbsp;public static IContextManager ContextManager<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_contextManager == null || !_contextManager.IsValid)&nbsp; // No point in using a invalid contextManager<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var webManagerType = Type.GetType(&quot;Csla.Web.ApplicationContextManager, Csla.Web&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (webManagerType != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _contextManager = (IContextManager)Activator.CreateInstance(webManagerType);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_contextManager.IsValid) _contextManager = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_contextManager == null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _contextManager = new ApplicationContextManager();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _contextManager; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { _contextManager = value; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p><br />And in Csla.ApplicationContextManager change the IsVsalid property to check whether it is ASPNET worker thread or non-ASPNET worker thread.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 21, 2010</h2><p>Well it is actually a little more complex than that if you get right down to it.</p>
<p>I suspect what most people would actually <i>expect</i> to happen, is that some things (most notably GlobalContext and User) would automatically flow into the background thread.</p>
<p>If all CSLA does is make sure there&#39;s a valid (but empty) ApplicationContext on the thread, that still won&#39;t really solve the problem, and we&#39;d be having a discussion about why CSLA doesn&#39;t solve the <i>actual</i> problem <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>The reason is simple: most experts recommend against spinning up threads on the web server. It generally harms scalability and isn&#39;t reliable for long-running tasks (since things get real messy if the AppDomain is recycled, and that happens quite a lot on most web sites).</p>
<p>So enabling something most experts recommend against has never been high on my priority list.</p>
<p>All that said, Jonny has a prototype of a BackgroundWorker implementation that would automatically move ClientContext, GlobalContext and User to the background thread (from the thread pool of course - this is a BackgroundWorker). I don&#39;t think any of us considered it for use on a web server, so it may not fully address your issue - it is designed for smart client scenarios like WPF and Silverlight where background tasks are increasingly common.</p>
<p>Unfortunately this didn&#39;t make it into CSLA 4 due to time constraints, but it is something that I&#39;m sure will find its way into a point release in the relatively near future.</p>
<p>I&#39;m pretty sure Jonny is on holiday at the moment though, otherwise I&#39;m sure he&#39;d share his thoughts as well.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>uma replied on Wednesday, July 21, 2010</h2><p>Rocky, Thanks for your reply. I am hopping to see Johnny&#39;s input in this.</p>
<p>For now, can we safely do the following ?</p>
<p>&nbsp;public&nbsp; class MyBusinessBase&lt;T&gt; : Csla.BusinessBase&lt;T&gt; where T: MyBusinessBase&lt;T&gt;<br />{<br />&nbsp;&nbsp;&nbsp; protected MyBusinessBase() <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.ContextManager = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />}</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 21, 2010</h2><p>I don&#39;t know if you can safely do that or not. You&#39;ll have to test and see if it works reliably. I don&#39;t have time to do any real research into this at the moment, sorry.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, July 26, 2010</h2><p>I&#39;ve been doing a little digging around on this issue, and the issue is somewhat broader than what you are seeing.</p>
<p>Not only does the current implementation complicate using background threads, but it causes issues in a mixed-mode app where you have both web UI elements and smart client elements (like Silverlight) using the data portal hosted in the web app.</p>
<p>Your suggested change is quite sufficient to resolve the data portal issue - and that causes no undesirable side-effects, since the data portal sets all the context values (they flow from the client).</p>
<p>I am still somewhat concerned about creating a new and empty context on a background thread. I&#39;m thinking though, that this is not a new problem - anyone creating background threads knows they need to manually shift any UI thread data to the background thread as they create it. So perhaps there&#39;s no natural assumption that ApplicationContext would automatically flow across.</p>
<p>Following that train of thought, i think I&#39;ll add the !IsValid check to 4.0.1 and we&#39;ll see how that goes.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, July 27, 2010</h2><p>Hi,</p>
<p>I have a reworked&nbsp;CslaBackroundWorker ready as per comments and dicussions I had with Rocky earlier.&nbsp; It is aimed at Rich clients as Rocky mentioned but I believe it should work fine in ASP.NET too - especially if you are already using the&nbsp;standard BackgroundWorker. My implementation is a wrapper around a &nbsp;BackgroundWorker that sends the ClientContex, GlobalContext an User to the background thread. </p>
<p>I will return from holiday on the&nbsp;2.8 and will do a quick check on the code. You may send me an email at jonny.bekkum(a)gmail.com and I can send you the code for testing under ASP.NET.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 27, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b></p>
<p>I have a reworked&nbsp;CslaBackroundWorker ready as per comments and dicussions I had with Rocky earlier.&nbsp; It is aimed at Rich clients as Rocky mentioned but I believe it should work fine in ASP.NET too - especially if you are already using the&nbsp;standard BackgroundWorker. My implementation is a wrapper around a &nbsp;BackgroundWorker that sends the ClientContex, GlobalContext an User to the background thread. </p>
<p></div></p>
<p>The only thing you <i>might</i> need to do in ASP.NET is create your own synchronizationcontext object before using the component (unless ASP.NET creates one for you - which is possible).</p>
<p>The big thing that all the smart client technologies do to protect their UI thread is to create a synchronizationcontext for it. That is what allows the BackgroundWorker to find the UI thread again, when the background task is complete.</p>
<p>Environments that don&#39;t have a pre-existing synchronization context (to my knowledge everything <i>except</i> Windows Forms, WPF and Silverlight) need to create their own context if they want the BackgroundWorker to call back on the same thread.</p>
<p>But Web Forms might also have a context - I guess we&#39;ll find out <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>uma replied on Wednesday, July 28, 2010</h2><p><em>Thanks Rocky and Johnny.&nbsp; After thinking more about spawing a Thread from ASP.Net&nbsp; application, we re-wrote that piece of code with async WCF calls with no callback.</em></p>
<p><em>But still I feel Context.IsValid should be checked as there is no point in using an invalid context</em></p>
<p><em>While doing further testing , we found it is not safe to do the following as dpContext is set before&nbsp; proxy.Fetch&nbsp; for obvious reasons.</em></p>
<p><em></em></p>
<p><em>&nbsp;public&nbsp; class MyBusinessBase&lt;T&gt; : Csla.BusinessBase&lt;T&gt; where T: MyBusinessBase&lt;T&gt;<br />{<br />&nbsp;&nbsp;&nbsp; protected MyBusinessBase() <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.ContextManager = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />}<br /></em></p>
<p><em>
<p>&nbsp;</p>
</em></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
