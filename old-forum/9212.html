<html><header><title>Feature request: New RelationshipType for FieldManager</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Feature request: New RelationshipType for FieldManager</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9212.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>joemorin73 posted on Thursday, July 15, 2010</h2><p>I was wondering if it&#39;s possible to add an additional relationshiptype to the enum to allow the exclusion of CSLA objects from being updated.</p>
<p>I have a child object in a class that I use as a reference.&nbsp; My parent class will refer to it, but I do not want .Save() to call the update on the class.&nbsp; I tried to find a way to do this via RegisterProperty, but I noticed the framework will update all IEditableBusinessObject and IEditableCollection in the FieldManager&#39;s collection.</p>
<p>My current solution was to simply make an unregistered private field which prevented CSLA from tring to save the object.</p>
<p>Should this be the preferred method, or would a relationshiptype bit be better to flag what we don&#39;t want saved?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 15, 2010</h2><p>There&#39;s a big difference between a containment/aggregation relationship and a using relationship, and the type of relationship should be reflected in your object model.</p>
<p>When an object maintains a persistent reference to another object, that&#39;s an implementation of containment. The other other <i>is part of</i> the containing object. CSLA supports this type of relationship through managed properties. But even if you use a private field to implement the same thing, you are creating a containment relationship.</p>
<p>A <i>using</i> relationship should be implemented differently, and shouldn&#39;t involve one object having a persistent reference to another object. Nor should one object expose a property so code can navigate to the used object - those sorts of things are not part of a using relationship implementation.</p>
<p>Instead, the object using another object should have some formal way to get access to the used object when necessary. This is typically done through a factory method, IoC, a locator service or other techniques. Another technique is to have an over-arching unit of work object for your use case, where this UoW object retrieves both the using and used object, and acts as sort of a local locator service so the using object can find the used object.</p>
<p>If the used object is read-only and (generally) unchanging, you can implement caching in your factory method to avoid re-fetching it on each use. I do this quite frequently, and discuss the technique in <i>Expert 2008 Business Objects</i>.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
