<html><header><title>WebServicePortal problem with custom principal and mixed C++ DLL</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>WebServicePortal problem with custom principal and mixed C++ DLL</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7252.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Thursday, July 09, 2009</h2><P>This one is very strange, because it works fine client side. </P>
<P>Our application is mostly in C#, but&nbsp;it includes a small mixed mode managed/unmanaged C++ DLL (long story).</P>
<P>Evidently the C++ runtime initialization is complaining that it cannot resolve the type of our custom principal on the first call to the DLL that occurs on the server side of the portal. </P>
<P>The error being reported is below. The C++ DLL contains no references to the assembly or type shown in the "Additional information", so the runtime initialization seems to be picking up the custom princpal we are using for authentication.&nbsp;Even more strangely, the C# assembly which is calling the C++ DLL and getting this error is the very one that contains the class for the custom principal (e.g. it's the BOL assembly shown in the error). </P>
<P>Any thoughts on how to resolve this?</P>
<P>Error information ------------------&gt;</P>
<P>&nbsp;A first chance exception of type 'System.Runtime.Serialization.SerializationException' occurred in msvcm90.dll</P>
<P>Additional information: Type is not resolved for member 'Company.Application.BOL.CustomPrincipal,BOL, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 09, 2009</h2><P>These problems can be a real bear.</P>
<P>The issue is probably that the thread does a context switch (or an AppDomain switch), and so .NET serializes all objects attached to the thread (most notably the principal) to the new context. This is done using the BinaryFormatter.</P>
<P>The BinaryFormatter has an interesting feature/limitation, where the deserialization process doesn't always find all assemblies loaded in the AppDomain. This is because (I'm told) there are actually four lists of loaded assemblies, and the BF doesn't check the list for 'dynamically loaded' assemblies, and on the server that almost always includes your business assemblies.</P>
<P>The Enterprise Services data portal host (server-side code) actually includes a workaround for this issue, because otherwise it wouldn't work at all. Normally you don't encounter this issue in a WCF/remoting/asmx host - but you are doing something a bit different with this C++ code, so there's probably some sort of context switch.</P>
<P>Search the CSLA project for "serialization workaround" to find the code I'm talking about.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, July 10, 2009</h2><P>Thanks! I'll look for the known serialization workaround. </P>
<P>I did some more investigating after my original post and proved it was the custom principal causing the problem. Wrapping the call that triggered the C++ DLL load with the following code avoided the exception, so perhaps I can figure a way to use this as a workaround if the other serialization workarounds aren't feasible:</P>
<P>var principal = Csla.ApplicationContext.User;<BR>try<BR>{<BR>&nbsp;&nbsp;&nbsp; Csla.ApplicationContext.User = GetGenericPrincipal();</P>
<P>&nbsp;&nbsp;&nbsp; //&nbsp;Error used to occur here....<BR>&nbsp;&nbsp;&nbsp; LoadProperty&lt;string&gt;(LicenseSummaryProperty, GetSummary());<BR>}<BR>finally<BR>{<BR>&nbsp;&nbsp;&nbsp; Csla.ApplicationContext.User = principal;<BR>}<BR></P>
<P>EDIT: Followup</P>
<P>The workaround in this thread appears to have solved the problem: <A HREF="/forums/2/29700/ShowThread.aspx">http://forums.lhotka.net/forums/2/29700/ShowThread.aspx</A></P>
<P>However, in this case, the workaround didn't describe how to do the "real" serialization part, which I assume would be necessary since you want your custom principal to be fully serializable, yes? </P>
<P>So, I implemented serialization of the individual fields per examples in CSLA. It also seemed that I needed to implement a deserialization constructor, like this one for my custom principal class:</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>protected</FONT></FONT><FONT size=2> MyPrincipal(System.Runtime.Serialization.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>SerializationInfo</FONT></FONT><FONT size=2> info, System.Runtime.Serialization.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>StreamingContext</FONT></FONT><FONT size=2> context) :</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>base</FONT></FONT><FONT size=2>((</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IIdentity</FONT></FONT><FONT size=2>)info.GetValue(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"Identity"</FONT></FONT><FONT size=2>, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>typeof</FONT></FONT><FONT size=2>(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IIdentity</FONT></FONT><FONT size=2>)))</P>
<P>{</P>
<P>}</P></FONT>
<P>Am I on the right track with this?</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
