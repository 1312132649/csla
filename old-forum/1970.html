<html><header><title>Need reality check</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Need reality check</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1970.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Wednesday, December 13, 2006</h2>Ok, <br><br>I have a business object (a readonly object) that has a property.&nbsp; Basically its a boolean indicating if there is a current support contract associated with the object.<br><br>We need to allow purchasing of new support contracts.&nbsp; My first thought is that the UI can check this property before it even tries to create the support contract.. but this also feels like a business rule.<br><br>So, should I have the UI check that property and alert the user, or should I just always call the NewSupportContract factory method (which accepts the object, and checks the same property and will throw an exception if there already is a contract).<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, December 13, 2006</h2><P>I guess I would consider both viable.&nbsp; Since you already have the property, you can easily use it to disable whatever command button/link you have in the UI that triggers the operation (i.e. no "purchase support contract" button/link).</P>
<P>But, I would also apply the "business rule" that you describe in your factory to ensure that a new contract is not created (and assigned?) to an object that already has one.&nbsp; I think this is totally consistent with the application of business rules and ensures that the rule is followed even if the UI doesn't block the action.</P>
<P>Then, you'd have the option of using the exception that is thrown as a trigger for a message on the UI.&nbsp; Best of both worlds.</P>
<P>HTH.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Wednesday, December 13, 2006</h2><P>There might be another approach that you want to consider as well.&nbsp; One of the concepts that CSLA.NET seems to encourage is to <EM>not</EM> throw exceptions the moment a business rule is violated.&nbsp; This is especially true when validation rules are broken during data entry.&nbsp; The only time an exception related to a business rule occurs is if one attempts to commit (Save) an <EM>invalid </EM>business object (or object model) to the database, and BusinessBase.Save throws this automatically.&nbsp; </P>
<P>Instead of throwing that exception, you would have a broken rule in your BrokenRulesCollection that would be keeping your business object in an invalid state.&nbsp; The IsValid property could then be tied to whatever button would be used to Save or commit the business object.</P>
<P>~pete</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, December 13, 2006</h2><P>I guess the question is how Andy is using the factory.&nbsp; Sounds to me like the Contract factory accepts the BO as a parameter which means that the operation is not triggered by a call to the BO itself.&nbsp; If the operation is performed by something like:</P>
<P><CODE>ContractFactory.CreateNewContract(myBO);</CODE></P>
<P>Then the business rule is being tested outside of the BO in question if the factory checks the boolean property and blocks creation of the new contract when the condition is invalid (possibly raising an exception).&nbsp; On the other hand, if the factory delegates to a method on the BO for the actual assignment, such as (in the factory):</P>
<P><CODE>Contract newContract = new Contract();<BR>myBO.Contract = newContract;</CODE></P>
<P>or,</P>
<P><CODE>myBO.AssignContract(newContract);</CODE></P>
<P>then the rule could be checked in the BO but you suffer added performance and resource requirements becuase you've created a contract object that you won't be using.</P>
<P>Now, if the operation is performed by something like this (in the BO):</P>
<P><CODE>public void AddContract()<BR>{<BR>&nbsp; &nbsp; // Maybe Contract's set accessor has private or protected scope so this method must be called<BR>&nbsp; &nbsp; Contract = ContractFactory.CreateNewContract();<BR>} </CODE></P>
<P>then it is easy to apply the rule within the BO and have it exposed as a broken rule rather than an exception.</P>
<P>I agree that it is sometimes more graceful to use the validation rules, but in this case it will depend (IMO) on how the operation is being performed and whether the condition is a "show-stopper" or not.&nbsp; If so, then an exception is certainly appropriate.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Wednesday, December 13, 2006</h2>I would definitely throw the exception in the bo layer, since that's where you can validate that.<br>You could also opt to just have a business rule there that will always return false if appropiate, but that's just a way of avoiding the exception. Personally I'd opt to throw the exception.<br><br>Anyway, that is no excuse for not blocking the button in the ui. You have the information you need in order to make the ui more friendly and avoid the exception. Some people may consider that replicating business rules in the UI, but to me that's just part of making the UI friendlier.<br><br>You could disguise that by having a method in your readonly object (or in the root object) like "CanCreateThatObject", but that's just overkill. You can always bind your button to the property in the readonly item, and that's it!<br><br>Andr√©s<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 14, 2006</h2>Andres,<br><br>I agree, this wasn't an xor question.&nbsp; The exception will be thrown, because the only way to really know if there's a support contract is to look it up in the database, so this is one DP_C method that actually doesn't use RunLocal for me.<br><br>Using the boolean to disable the button would just provide a friendlier UI as you mention.&nbsp; My only concern was that at some point creating a new contrac might be more limiting.&nbsp; For example, we may not allow conracts to be created for a product which is more than 10 years old.&nbsp; In that case, whether or not a contract exists is not sufficent to decide if any buttons should be disabled.<br><br>I've also thought of something this morning; there really is no 'editing' of a support contract.&nbsp; You can create it new, or ask it to extend itself (the amount of extension is up to the BO, not the user).&nbsp; That's it.. so as I mentioned in my other relplies, perhaps these two needs are best served by command objects?<br><br>What does everyone think of that?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Thursday, December 14, 2006</h2><P>So, if I understand this right, a contract can either be extended (if one already exists in the database) or created (if ones doesn't), with the possibility of more future rules that disallow contracts to be created for old products.&nbsp; </P>
<P>What if you had a single factory method on Contract class called Fetch that, like you suggested, used a command object to query the database to determine one of the three possible outcomes:</P>
<OL>
<LI>A contract exists in the database; Fetch would return a Contract instance that represents the existing contract.&nbsp; You said that existing contracts could only be updated and the update changes were determined by the BO.&nbsp; Therefore this Contract instance could have those new updates applied, but the Contract instance would be dirty and not committed to the database until Save was called.</LI>
<LI>No existing contract exists; Fetch would return a Contract instance that represented a new contract (IsNew = true).</LI>
<LI>No existing contract exists but the product is too old (so a new contract cannot be created).&nbsp; This option might be a little tricky.&nbsp; You could return null, but that doesn't tell the user why a contract could not be created.&nbsp; Or you could return a new Contract instance that had a broken rule explaining why the contract cannot be committed back to the database.&nbsp; Either way, you'll be preventing the user form actually saving a new contract back to the database.</LI></OL>
<P>I suppose another option would be to provide a factory method that just returns the command object.&nbsp; Then the UI could examine the command object to determine what was possible.&nbsp; Then that command object instance could be used to create an actual Contract instance.</P>
<P>~pete</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 14, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>twistedstream:</strong></div><div>So, if I understand this right, a contract can either be extended (if
one already exists in the database) or created (if ones doesn't), with
the possibility of more future rules that disallow contracts to be
created for old products.</div></BLOCKQUOTE><br><br>Yes, that's right, although the addtional rules is just something I'm thinking of for the future.. no one else has mentioned anything like such a rule.&nbsp; But I am considering the possiblity to help keep me from desiging my objects improperly.<br><br>You're right about the three options (although three is just there to force me to think about maintance), and those options are the ones that exist now.&nbsp; Given that, does it make sense to have an object that can only be fetched or created, and forcing save.&nbsp; <br><br>That is, what is the purpose of keeping the object in memory, since it cannot be edited at all?&nbsp; There will be no screen to show what the contract will look like until after it already exists.<br><br>Andy<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 14, 2006</h2>Pirate,<br><br>My factory method is the as you describe first, it accepts an object of ISerialNumber (because contracts are tied to serial numbers).<br><br>Once its created, you really can't do any normal editing.&nbsp; You can save it if its new, or call Extend and then save if its existing (the expiration date is decided by code, and cannot be entered manually).<br><br>Maybe a few command objects would be better in this case?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 14, 2006</h2>Well the only thing here is that there really is no editing for the BO in question (the new support contract).&nbsp; I thought about bringing up a screen and having a way to assign a serial number to the new contract, but that just seemed like overkill.&nbsp; I'm also not sure if I should have created a few command objects.&nbsp; The only thing you can do to a support contract independately is create it or extend it.&nbsp; Other than that, there's&nbsp; no behaviors.&nbsp; <br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
