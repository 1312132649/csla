<html><header><title>Question about instatiating a static bo list</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Question about instatiating a static bo list</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1266.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>dstarkey posted on Tuesday, September 19, 2006</h2><P>The project tracker application has an instance where a roles object is built as a static list and used throughout the class.&nbsp; What happen when/if two or more users try to access this object at approximately the same time?&nbsp; Imagine the roles object as being a larger object so that it would take more time to build initially?&nbsp; Do both user instances try to build the list??&nbsp; I would like to know what happens in this case?&nbsp; Thanks for your help.</P>
<P>Don</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, September 19, 2006</h2>Each user would have the code running locally and thus would have their own seperate instances of that list.&nbsp; Neither instance would know about the other.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, September 19, 2006</h2><P>I don't have the Project Tracker in front of me - it may not give consideration to thread safety since it's just a simple application. It being in many respects a singleton, there are different ways to make it thread safe and I recently was referencing an on-line article on this. </P>
<P>Here is a URL that describes making a singleton thread-safe through a sequence of examples: </P>
<P><A href="http://www.yoda.arachsys.com/csharp/singleton.html">http://www.yoda.arachsys.com/csharp/singleton.html</A>&nbsp;</P>
<P>&nbsp;</P>
<P>Edit: I'm living in the Web world right now so that's&nbsp;where my comments are coming from&nbsp;- Andy is correct w/ respect to Windows. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dstarkey replied on Tuesday, September 19, 2006</h2>I am referring to a&nbsp; web application.&nbsp; I believe that this static list would be shared by all users, rather than built for each user.&nbsp; Please correct me if I am wrong.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, September 19, 2006</h2><P>On a side note, if you are using an application server, the singleton does&nbsp;persist on the application server between remoting calls (after it gets created for the first time on the app server). </P>
<P>(This is something that I didn't know for sure and did a test some time back to verify it).</P>
<P>---</P>
<P>Rocky, just how expensive is it to do this lock? You've mentioned it a few times now. If I have a simple "namevaluelist" type with only 50 records or so, am I better off just letting the object get created twice? </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, September 19, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div><p>Rocky, just how expensive is it to do this lock? You've mentioned it a few times now. If I have a simple "namevaluelist" type with only 50 records or so, am I better off just letting the object get created twice? </p></div></BLOCKQUOTE><br><br>Locking is expensive, and becomes more expensive with more users, and with increased use of the item being locked. So it is impossible to give any objective number, because too many factors enter into the equation.<br><br>But suppose your shared object was used on every page. And suppose you were handling 50 requests per second. Some of those requests would be delayed, waiting for the lock, and the result is a performance hit. If this happens enough, a queue can develop as threads wait for the lock, compounding the problem. If this happens enough, scalability (throughput) gets hurt as well.<br><br>On the other hand, if your shared object is used only on a few pages, that most users aren't using at the same time, then the issue becomes less critical.<br><br>You also need to evaluate how often the shared object needs to be recreated. If it is created once when the AppDomain comes up, and tends to remain in memory and unchanged for hours, days, weeks - then the cost of a possible one-time duplicate load seems totally trivial.<br><br>On the other hand, if the object gets flushed on a regular basis, every few minutes or something, then the cost (and odds) of a duplicate load become worse.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, September 19, 2006</h2>A static/Shared field is a per-AppDomain construct. <br><br>In any smart client scenario, it isn't shared across 2 or more users, because there can only be one user of an AppDomain in that case.<br><br>In a web server scenario, the field is shared across all users of the AppDomain, which really means the virtual root. So in this case threading issues do matter.<br><br>My implementation in the book avoids locking, but can end up constructing the object multiple times. This was a concious choice on my part, because locking is expensive and multiple creation of the object is unlikely to occur and wouldn't cause any harm were it to happen.<br><br>If the object in question is very expensive to create, then the equation could change. You might choose to implement locking and pay that continual price to avoid the possibility of creating multiple instances of the object.<br><br>Let's be clear. In my implementation, if 2 users hit the web site at the same time, and no Roles object had previously been loaded, then they could both attempt to load the Roles object at the same time. Since I have no locking, but threads could detect that _roles is Nothing/null, and both could call Roles.GetRoles(), resulting in the object being created/loaded twice. But (and this is important), both threads would set _roles, and the slower thread's version of Roles would be kept in that field. Any subsequent threads (even a millisecond later) would <i>not</i> create/load a new object, because _roles wouldn't be null.<br><br>So the chance of a duplicate load is very small. And since Roles is very static data, the duplicate objects would almost certainly be identical, so no harm would be done. Both threads would get the same result, albiet with different object instances.<br><br>It is also important to realize that the faster thread (the one that set _roles first) would use and then release its reference to the Roles object it created. That object would then be destroyed, because any and all other threads would be using the _roles value set by the slower thread. In other words, the duplicate object would exist only for a fraction of a second.<br><br>But your issue could be different, because the cost of creating the shared object might be very high. You have to weigh that against the cost of using locking on each and every access to the object. If the object in question is used by many or most of your pages, this could cause a scalability/performance issue - and you need to be aware of that up front.<br><br>To implement locking isn't hard - just alter the code in ProjectTracker with this:<br><br>&nbsp; Private Shared mList As RoleList<br><b>&nbsp; Private Shared mListLock As New Object</b><br><br>&nbsp; Public Shared Function GetList() As RoleList<br><br><b>&nbsp;&nbsp;&nbsp; SyncLock mListLock<br></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If mList Is Nothing Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mList = DataPortal.Fetch(Of RoleList) _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (New Criteria(GetType(RoleList)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return mList<br>&nbsp;<b>&nbsp;&nbsp; End SyncLock<br></b><br>&nbsp; End Function<br><br>This ensures that only one thread can execute the factory method at a time, so only one object will be created.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
