<html><header><title>Best Practice Advice On Application Business Objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Best Practice Advice On Application Business Objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7335.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor posted on Friday, July 24, 2009</h2>Hi,<br /><br />I wonder is someone can offer some best practice advice / guidance on the following please:-<br /><br />I am in the process of converting an internal application from Visual FoxPro to DotNet using the CSLA framework. Given that our existing application is written Foxpro 2.6, tables are free and are not contained in a database. Typically I have one CSLA business object per individual table and I access / insert / update table data via OLEDB. The business objects work very well, and the factory methods provide simple entity retrieval methods such as ( in the case of BoCustomer ): GetCustomerByName(string Name), or GetCustomerByID(string ID).  Again this works very well, and is very scalable.<br /><br />However as my application is growing I have a increasing requirements for lots of “command” type objects. For example, I may wish to retrieve a datatable containing a list of all customers with open sales orders ( i.e. data from multiple tables ), or a list of customers with  open sales invoices. Some of these may be simple SQL select commands, but some may be more complicated operations requiring data from a number of tables and a degree of coding to produce the resulting fabricated dataset. I then have transactional requirements which may require multiple tables to be updated as a result of a specific method requirement.<br /><br />I started by creating an “entity” object which contained multiple methods relating to a common theme. I might have a Customer entity object or a Supplier entity object each of which contains a bunch of static methods relevant to that particular entity. Very quickly I found that each entity object requires lots and lots of methods, and it all starts to get a bit complicated from a coding point of view ( you end up with hundreds and hundreds of lines of code ). It is logical however to be able to call something like: Customer.GetOpenOrders(), or Customer.GetOrdersShipped().<br /><br />I now wonder if I should have a command object for each requirement. In other words I have one object that performs a single function such as the GetOpenOrders() requirement, and another one to perform the GetOrdersShipped() requirement. This is much cleaner from a coding perspective but will result in me having hundreds of command objects.<br /><br />I wondered if anyone could offer some suggestions of how they have tackled this issue and what works best and is most scalable...?<br /><br />Thanks,<br /><br />Nick<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, July 24, 2009</h2>One technique I can suggest is that you can just implement a common base class so that all that is really different is the parameter passed to the command (if any) and the server side processing. <br /><br />You can also contruct simple derived classes that basically just implement the server side processing (even via a delegate). <br /><br />So, what you end up with is a large number of methods to be executed by your commands and very simple CommandBase-derived class implementations to execute them. <br /><br />I can post samples if you want to see this.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NickTaylor replied on Saturday, July 25, 2009</h2><P>Hi,</P>
<P>Yes that would be great thanks, I would be very interested to see how you have structured this...</P>
<P>Many thanks,</P>
<P>Nick</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>whelzer replied on Saturday, July 25, 2009</h2>We had/have a very similar situation.<br>
<br>
In a fairly large financial application we have a requirement to have
numerous currency lists (mostly for combobox population) , ie a list of currencies (ccyId, ccyName), we
have a CurrencyLst object, that has many factory methods and many DP
fetches, so we'll have GetCcysByStatus, GetCcyByTradeType,
GetCcyBySomethingElse...<br><br>Sounds to me that you merely need a CustomerList object that has many factory methods and many Dp_Fetches (getCustomersBySales, getCustomersByWhatever, what happens inside the DP_Fetches is entirely up to you, get data from main Db, get data from xml file, get data from static flat file system, , a combination of all these - it shouldn't (and doesn't) matter where the data comes from. <br><br>You probably end up with more code (more methods anyway) doing this but you get a very clean, easy to expand, easy to use solution.<br>ie I need a list of currencies - use CurrencyList object - if my particular list/method is not there - just create it - slots in no bother.<br><br>(We code gen 90% of the csla stuff - meaning we just build the Dp_fetch code manually which would typically be a new stored proc and DAL code.)<br><br>Edit - I ended going down this route based on this thread&nbsp; http://forums.lhotka.net/forums/thread/25488.aspx <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Saturday, July 25, 2009</h2><P>Yes, if you're just fetching an object, no matter how complex internally, I think this is best done via a BusinessBase derived class (or one of xxxxListBase classes if you are fetching a collection).&nbsp; Then you can implement static factory methods that execute the appropriate DataPortal_Fetch.</P>
<P>On the other hand, complicated server side updates can be done either as CommandBase or BusinessBase derived classes. If input from the user is expected, a BusinessBase class is better because it is bindable and has validation rule capability. CommandBase classes have neither. You can do whatever you want server side in DataPortal_Execute method of a CommandBase or DataPortal_Update of a BusinessBase. </P>
<P>Here is a sample command implementation. We do internal transaction management, so think of TransactionContext as just something that can Begin/Commit/Rollback and knows if a transaction in progress or not. </P>
<P>Base Class (the "harder" one)</P>
<P>using System;</P>
<P>namespace Csla.WORMapper<BR>{<BR>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<BR>&nbsp;&nbsp;&nbsp; /// Execute a command with a generic argument in a database transaction, automatically enlisting in <BR>&nbsp;&nbsp;&nbsp; /// current one if active<BR>&nbsp;&nbsp;&nbsp; /// <BR>&nbsp;&nbsp;&nbsp; /// Usually, derived classes need only override the Execute(TransactionContext context) method<BR>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<BR>&nbsp;&nbsp;&nbsp; /// &lt;typeparam name="T"&gt;A class that inherits from &lt;see cref="TransactionalCommand{T,V}"/&gt;.&lt;/typeparam&gt;<BR>&nbsp;&nbsp;&nbsp; /// &lt;typeparam name="V"&gt;An argument of any type.&lt;/typeparam&gt;<BR>&nbsp;&nbsp;&nbsp; [Serializable()]<BR>&nbsp;&nbsp;&nbsp; public class TransactionalCommand&lt;T, V&gt; : CommandBase where T : TransactionalCommand&lt;T, V&gt;<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected V _arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected string _databaseKey;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected TransactionalCommand()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : this("Base")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected TransactionalCommand(string databaseKey)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _databaseKey = databaseKey;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static V Execute(V arg )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Execute(arg, "Base");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _autoBeginTrans = true;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual bool AutoBeginTrans<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _autoBeginTrans; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { _autoBeginTrans = value; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public V Argument<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _arg; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static V Execute(V arg, string databaseKey)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must retrieve via data portal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransactionalCommand&lt;T, V&gt; command = Activator.CreateInstance&lt;T&gt;();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command._arg = arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command._databaseKey = databaseKey;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Execute&lt;TransactionalCommand&lt;T,V&gt;&gt;(command)._arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void DataPortal_Execute()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransactionContext.ExecuteInTransaction(_databaseKey, Execute, AutoBeginTrans);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected virtual void Execute(TransactionContext context)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new System.NotImplementedException("Method Execute() must be implemented in derived class");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>-----------------</P>
<P>Derived classes can be very simple and just implement and override of Execute(). Here is a command nested in a class I have called ReceiveOneItem that sends the item to inspection:</P>
<P>The command argument for the base class can be anything, but in this case it's an actual BO that implements a normal save operation (the receive item transaction). In this case I don't want to save it normally but instead do a different transformation on it on the server (send it to inspection where someone can verify it's condition and either receive it or reject it).</P>
<P>As you can see, the derived command implementation is trivial. It just calls a method on the argument. You can compose these yourself almost abitrarily.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Serializable]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private class SendToInspectionCommand : Csla.WORMapper.TransactionalCommand&lt;SendToInspectionCommand, ReceiveOneItem&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void Execute(Csla.WORMapper.TransactionContext context)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _arg.ToInspectOneItem(context);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal void ToInspectOneItem(Csla.WORMapper.TransactionContext transaction)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;..<BR>&nbsp;.. DO WORK HERE<BR>&nbsp;}</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Saturday, July 25, 2009</h2><P>Yes, if you're just fetching an object, no matter how complex internally, I think this is best done via a BusinessBase derived class (or one of xxxxListBase classes if you are fetching a collection).&nbsp; Then you can implement static factory methods that execute the appropriate DataPortal_Fetch.</P>
<P>On the other hand, complicated server side updates can be done either as CommandBase or BusinessBase derived classes. If input from the user is expected, a BusinessBase class is better because it is bindable and has validation rule capability. CommandBase classes have neither. You can do whatever you want server side in DataPortal_Execute method of a CommandBase or DataPortal_Update of a BusinessBase. </P>
<P>Here is a sample command implementation. We do internal transaction management, so think of TransactionContext as just something that can Begin/Commit/Rollback and knows if a transaction in progress or not. </P>
<P>Base Class (the "harder" one)</P>
<P>using System;</P>
<P>namespace Csla.WORMapper<BR>{<BR>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<BR>&nbsp;&nbsp;&nbsp; /// Execute a command with a generic argument in a database transaction, automatically enlisting in <BR>&nbsp;&nbsp;&nbsp; /// current one if active<BR>&nbsp;&nbsp;&nbsp; /// <BR>&nbsp;&nbsp;&nbsp; /// Usually, derived classes need only override the Execute(TransactionContext context) method<BR>&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<BR>&nbsp;&nbsp;&nbsp; /// &lt;typeparam name="T"&gt;A class that inherits from &lt;see cref="TransactionalCommand{T,V}"/&gt;.&lt;/typeparam&gt;<BR>&nbsp;&nbsp;&nbsp; /// &lt;typeparam name="V"&gt;An argument of any type.&lt;/typeparam&gt;<BR>&nbsp;&nbsp;&nbsp; [Serializable()]<BR>&nbsp;&nbsp;&nbsp; public class TransactionalCommand&lt;T, V&gt; : CommandBase where T : TransactionalCommand&lt;T, V&gt;<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected V _arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected string _databaseKey;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected TransactionalCommand()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : this("Base")<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected TransactionalCommand(string databaseKey)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _databaseKey = databaseKey;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static V Execute(V arg )<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Execute(arg, "Base");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool _autoBeginTrans = true;</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual bool AutoBeginTrans<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _autoBeginTrans; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { _autoBeginTrans = value; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public V Argument<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _arg; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static V Execute(V arg, string databaseKey)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Must retrieve via data portal<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransactionalCommand&lt;T, V&gt; command = Activator.CreateInstance&lt;T&gt;();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command._arg = arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command._databaseKey = databaseKey;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Execute&lt;TransactionalCommand&lt;T,V&gt;&gt;(command)._arg;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void DataPortal_Execute()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransactionContext.ExecuteInTransaction(_databaseKey, Execute, AutoBeginTrans);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected virtual void Execute(TransactionContext context)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new System.NotImplementedException("Method Execute() must be implemented in derived class");<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>}</P>
<P>-----------------</P>
<P>Derived classes can be very simple and just implement an override of Execute(). Here is a command nested in a class I have called ReceiveOneItem that sends the item to inspection:</P>
<P>The command argument for the base class can be anything, but in this case it's an actual BO that implements a normal save operation (the receive item transaction). In this case I don't want to save it normally but instead do a different transformation on it on the server (send it to inspection where someone can verify it's condition and either receive it or reject it).</P>
<P>Invocation is simple: (ReceiveOneItem implements a SendToInspection method that calls the command on itself and returns the transformed object)</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ReceiveOneItem SendToInspection()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SendToInspectionCommand.Execute(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>Below,&nbsp;the derived command class&nbsp;implementation is trivial. It just calls a method on the argument. You can compose these yourself almost abitrarily, and your objects can support either simple server side operations or different flavors as needed.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Serializable]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private class SendToInspectionCommand : Csla.WORMapper.TransactionalCommand&lt;SendToInspectionCommand, ReceiveOneItem&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void Execute(Csla.WORMapper.TransactionContext context)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _arg.ToInspectOneItem(context);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal void ToInspectOneItem(Csla.WORMapper.TransactionContext transaction)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;.. DO WORK HERE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
