<html><header><title>Versioning Objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Versioning Objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7652.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bkirkman posted on Friday, September 18, 2009</h2>I have a project where whenever an EDIT takes place, the object and its children should be versioned. What I mean by "versioned" is a new unique identifier is created, inserting a new record and all the information is the same for the object except its version # is incremented and the PK is new. <br />I've looked into overriding the UPDATE method but am not sure how to change the PK of the object and return it. I am really doing an Insert instead of an Edit to the object. <br />Has anyone coded something like this before in CSLA?<br />TIA</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, September 18, 2009</h2>Interesting requirement.  Probably what I would do is in the root object, override OnChildChanged and call MarkNew on the root, and then call an internal method SetNew on all its child objects (which would just cause the object to call its MarkNew).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tom_W replied on Friday, September 18, 2009</h2>You've no doubt got this well in hand, but just in case; I've done something like this in the past with versioning sales quotes (but not with CSLA) and the real pain point was making sure that anything that had a relationship to the record (i.e. PK/FK db relationship) stayed pointing at the right version.&nbsp; <br><br>In our app there were records that had a FK relationship to the quote (which was the record getting versioned) and we wanted these relationships to point to the current version of the quote, not the historical one.&nbsp; <br><br>After a lot of faffing it occured to us that it was better to keep the original version as the current record at all times and update it's version number, and to make a copy of the record with the new id which then became the historical audit record.&nbsp; That way records with a FK to the quote didn't need to be updated too.<br><br>Obviously all of that depends on your particular UCs, I just mention it in case it saves you some of the pain we went through!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, September 18, 2009</h2>Actually thta's what I've done too.  When a user locks and then chooses to revise a quote, i copy the existing values to another table for history reasons, and then allow them to change the values on the "real" table.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tom_W replied on Friday, September 18, 2009</h2>The other solution I have used for this in the past is to have a 'stub' record that just contains say the QuoteId and the QuoteNo and then a QuoteRevs child collection that contains the actual data for each revision of the quote (i.e. Rev No and all of the actual quote contents such as values, descriptions etc).<br><br>That works well if you want 'live' access to the previous versions most of the time, but it's overkill if you only rarely want to see the previous versions and they aren't displayed on the main edit form say.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bkirkman replied on Friday, September 18, 2009</h2>Tom,<br />Very interesting idea. So, If I understand this correctly you create a new object that is a duplicate of the existing one - inserting it with the current version, lets say "2", then "edit" the object and increment its version # so you are still working with the current record. <br />I do like this - everything is still in synch with the children and the actual insert is the "old" version of the object while the current one is the last edited version.<br />Is that correct?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tom_W replied on Friday, September 18, 2009</h2>Exactly so.&nbsp; <br><br>You should be able to wrap the whole lot up in a transaction too to ensure the version numbers can't get messed up if there's a db write issue, although as I say I haven't done this in CSLA so I'm not sure exactly how you'd do that bit!<br><br>Incidentally, if you are writing the objects via stored procedures, it may be easier just to do the whole audit version creation there.&nbsp; Normally I don't favour too much logic in sprocs, but in this case if you don't need the old version's data in the UI it may make more sense to shunt the work off to the db server and save sending essentially the same data twice across the network.&nbsp; Also, if you make any modifications to the fields retrieved by the sproc you are probably more likely to remember to update the code that makes the copy of the object if it is in the same sproc.<br><br>EDIT:&nbsp; Although if there are child collections that aren't written in the same sproc then that probably gets more tricky, in which case I would just make the copy in the business object.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, September 18, 2009</h2>I have a sproc that copies to the history tables.  That's probably the best way to go, as all the data stays within the database server's memory, instead of having to be read by an application only to be written to a different table.  Regarding childs, I have other procs called by the main proc to handle copying of child data. </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bkirkman replied on Friday, September 18, 2009</h2>Tom and ajj,<br />I am going to go through the code now to see how to best update the children. I do prefer to do this through a stored proc but just have to analyze now how to handle this. Excellent ideas and I appreciate the assistance, Thank you.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Friday, September 18, 2009</h2><P>I've found the easiest way to do this is to approach things backwards. :)</P>
<P>Create "new" history data that stores the old values and relationships, then update data based upon the existing data to match the new values/relationships.</P>
<P>In other words, the object you just edited always, always, remains the latest version.&nbsp; When it is changed, it creates prior versions.</P>
<P>It's much simpler.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
