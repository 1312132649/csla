<html><header><title>Transactional Problems Afterword - Is this elegant?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Transactional Problems Afterword - Is this elegant?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4532.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick.Roeper posted on Thursday, March 20, 2008</h2>The past couple of days I have been hit pretty hard with sorting out bugs from using the Transactional attribute on my dataportal methods. Everything was due to instantiating more than one database connection within the lifetime of a transaction. I've been trying to work out an elegant solution that is reusable and leverages features of the framework/C# so I would like to hear suggestions on how to improve what I have come up with already.<br><br>The place where everything starting is when I was making my accounting system more tolerant to failure. Example: When a user receives a payment in the system, I need to save the payment, create a new journal entry, update any credits that were applied, create any credits if the payment was an over payment, update all invoice balances to reflect the payment, ... the list continues. My way of handling this was to make an InvoicePaymentPoster command object who's responsibility was to make sure each of these items happened. I wrapped the DataPortal_Execute with a [Transaction] so that if any part of the entire process failed, nothing would ever be committed to the database.<br><br>Each one of these different objects I am working with from within DataPortal_Execute is a root object of its own, so during a fetch/update in any of these objects I am instantiating a new SqlConnection object which is where everything hit the fan. I read some posts on the forums and I saw Rocky mention the LocalContext object and how it could be used to share objects in the AppDomain. The next challenge was to come up with something that would fix my problems now, be elegant, efficient, and be something I could possible put into my codegen templates. So here is what I came up with:<br><br>&nbsp;&nbsp;&nbsp; public static class Database<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static string Accounting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return ConfigurationManager.ConnectionStrings["Accounting"].ConnectionString; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static bool NewConnection(string connectionString, out SqlConnection cn)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ApplicationContext.LocalContext.Contains(connectionString))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cn = (SqlConnection)ApplicationContext.LocalContext[connectionString];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cn = new SqlConnection(connectionString);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; public delegate void CommandHandler(SqlConnection cn);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void CallCommand(string connectionString, CommandHandler commandMethod)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SqlConnection cn;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NewConnection(connectionString, out cn))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (cn)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cn.Open();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.LocalContext.Add(connectionString, cn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try { commandMethod(cn); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finally { ApplicationContext.LocalContext.Remove(connectionString); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commandMethod(cn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>This makes all of my root level DataPortal_XYZ methods look something like...<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Transactional(TransactionalTypes.TransactionScope)]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void DataPortal_Update()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database.CallCommand(Database.Accounting, CommandUpdate);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void CommandUpdate(SqlConnection cn)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (base.IsDirty)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExecuteUpdate(cn, null);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //update child object(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateChildren(cn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>Everything is working in my application now; database connections are being shared across the multiple root objects, the code is repeatable and easy to implement for anyone after me, and I can put this into my codegen templates. Also, when it comes to fetching objects, I had to deal with the extra filter criteria parameter so I did the following:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public delegate void CommandHandlerWithCriteria&lt;T&gt;(SqlConnection cn, T criteria);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void CallCommand&lt;T&gt;(string connectionString, CommandHandlerWithCriteria&lt;T&gt; commandMethod, T criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SqlConnection cn;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (NewConnection(connectionString, out cn))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (cn)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cn.Open();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.LocalContext.Add(connectionString, cn);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try { commandMethod(cn, criteria); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; finally { ApplicationContext.LocalContext.Remove(connectionString); }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; commandMethod(cn, criteria);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>And the root implementation looks like....<br><br>private void DataPortal_Fetch(Criteria criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Database.CallCommand(Database.Accounting, ExecuteFetch, criteria);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void ExecuteFetch(SqlConnection cn, Criteria criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (SqlCommand cm = cn.CreateCommand())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ....<br><br>So I am only a junior developer (been out of college for all of 2 months now <img src="/emoticons/emotion-2.gif" alt="Big Smile [:D]" />) and I am sure there is some code smell I haven't gotten a wiff of. I would appreciate any insight to potential problems this implementation could cause as well as suggestions on ways to make it better (e.g. standards I am not adhering to). When I make the jump to .NET 3.5 I plan on using the Action&lt;T&gt; since it supports multiple parameters in .NET 3.5; that would allow me to drop my delegates and make the code a little cleaner. <br><br>Thanks!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 21, 2008</h2><P>Look at the Csla.Data.ConnectionManager class in CSLA 3.5 - it is designed to help in this situation by automatically reusing an already-open connection if there is one. That class should back-port all the way to .NET 2.0 will little or no change.</P>
<P>The one thing though, is that ultimately you do have ONE root object for the transaction - that's the single option where the data portal calls your DataPortal_XYZ method. That method MUST keep the connection open for the life of the transaction - which again is easy with ConnectionManager:</P>
<P>protected override void DataPortal_Update()<BR>{<BR>&nbsp; using (ConnectionManager&lt;SqlConnection&gt; ctx = <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConnectionManager&lt;SqlConnection&gt;.GetManager("mydatabase"))<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; // the database is now ctx.Connection, which is open and ready to go<BR>&nbsp;&nbsp;&nbsp; // do all database work (and call other objects) here<BR>&nbsp; }<BR>}</P>
<P>Each object (root or child) should use this same pattern with the using block and a ConnectionManager. This using statement will open the connection if it isn't open, or will reuse an already open one if it is open.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick.Roeper replied on Friday, March 21, 2008</h2>Rocky,<br><br>I just read over the implementation of your connection manager class and I am going to implement this in my solution in place of what I came up with above. I did have a couple questions however...<br><br>public class ConnectionManager&lt;C&gt; : IDisposable where C : IDbConnection, <b>new()<br><br></b>What does the "new()" portion of the line above do/mean?<br><br>Second, where would using GetCurrentManager be prefered over using GetManager? The only difference is GetCurrentManager throws an exception if you try to access a shared database connection that doesnt exist; where would a developer want to take advantage of that rather than initializing a new connection?<br><br>Last, I am trying to think further down the road to new data access technologies that microsoft has on their product roadmap, specifically the entity framework. I haven't read much on the actual implementation of a DAL using the entity framework, but do you expect to be able to control the database connection that the entity framework would use to talk to the database? If not, couldn't this transactional problem resurface?<br><br>Thanks as always.<br>Patrick<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, March 21, 2008</h2><P><FONT face=Tahoma size=2>I can answer one part of this...</FONT></P>
<P><FONT face=Tahoma size=2>The "new()" portion is another generic constraint.&nbsp; It means that the type that "C" represents must have a public parameterless constructor.&nbsp; That way you are guaranteed the ability to create instances of that type.&nbsp; Since the ConnectionManager class&nbsp;wraps a database connection, Rocky's code needs to be able to create an instance of the connection class.&nbsp; "IDbConnection" is an interface, and thus&nbsp;does not guarantee the ability to create an instance of the type by itself.</FONT></P>
<P><FONT face=Tahoma size=2>(FWIW, switching it to use the "DbConnection" base class wouldn't do it either - its constructor is protected.&nbsp; So you'd still need the "new()" constraint.)</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 21, 2008</h2>






 





<div class=Section1>

<p class=MsoNormal><span>GetCurrentManager was an experimental concept that won&#8217;t
be in 3.5 &#8211; so the answer is to not use it at all :)<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

</div>



</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
