<html><header><title>Silverlight4 - MVVM - item drag &amp; drop implementation question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Silverlight4 - MVVM - item drag &amp; drop implementation question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10095.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mr X posted on Monday, February 21, 2011</h2><p>Hi,</p>
<p>I am currently looking to implement drag &amp; drop functionality in a Silverlight 4 application (in this particular case a treeview) &nbsp;using MVVM (and CSLA 4.0.1).&nbsp; So far I found a number of examples for Silverlight&nbsp;including the folowing:</p>
<p><a href="http://www.dotnetcurry.com/ShowArticle.aspx?ID=511">http://www.dotnetcurry.com/ShowArticle.aspx?ID=511</a></p>
<p><a href="http://timheuer.com/blog/archive/2009/10/19/silverlight-toolkit-adds-drag-drop-support.aspx">http://timheuer.com/blog/archive/2009/10/19/silverlight-toolkit-adds-drag-drop-support.aspx</a></p>
<p>but none of them make use of MVVM, just XAML and code behind.&nbsp;&nbsp; The link&nbsp;<a href="http://forums.lhotka.net/forums/p/6742/32511.aspx">http://forums.lhotka.net/forums/p/6742/32511.aspx</a>&nbsp;was very helpful but does not provide any indication on the binding for the UI or MVVM usage.</p>
<p>Please help.&nbsp; Any lead would be appreciated.</p>
<p>&nbsp;</p>
<p>Thanks,</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, February 21, 2011</h2><p>I haven&#39;t tried to do this, so I can&#39;t provide a specific answer.</p>
<p>But I can offer some general guidelines.</p>
<p>First, you need some way to route arbitrary UI events to your viewmodel. This is what the CSLA (or Bxf) TriggerAction control does for you.</p>
<p>Second, sometimes you need some way to cause the UI to do something that would normally be a method call on a UI control, but with MVVM it has to be something triggered by a property changing in the viewmodel. I usually work around this by creating an attached property that knows how to bind to a property, and how to call a method on the UI control when that property changes. This attached property is purely part of the View.</p>
<p>For example, I use this second technique to integrate the Silverlight navigation framework with MVVM, because navigating to a new page requires a method call, but my viewmodel just exposes a URI property and sets that property to the page to be displayed. My attached property sees that the URI property has changed, and calls the Navigate method on the UI frame control.</p>
<p>This is in the Bxf Silverlight sample named UsingBxfNav (<a href="http://bxf.codeplex.com">http://bxf.codeplex.com</a>).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, February 21, 2011</h2><p>OK... I&#39;m going to ask a question that is very thinly related to the OP, so if I need to move this to a new post, then let me know.</p>
<p>(And, for those who are confused, the &quot;you&quot; in this is Rocky...)</p>
<p>As I muddle through my thoughts on MVVM, I understand your goal of &quot;no code-behind in views&quot;, and I understand the&nbsp;rationale for it.&nbsp; I agree with it rather wholeheartedly.&nbsp; However, I&#39;m wondering if this specific instance is taking it a little too far.</p>
<p>While I have no problems creating the requisite &quot;verbs&quot; on the VM to manage the copy/move/whatever operation is defined by the drag-and-drop, I don&#39;t understand why the basics of the drag-and-drop <em>visual</em> work can&#39;t be done within the view.&nbsp; Why should I go to the trouble of creating attached properties, TriggerActions, commands, etc. to route a bunch of mouse-related events to a VM?</p>
<p>I ask this because I&#39;ve heard discussions that you have had in this area where you&#39;ve mentioned the one caveat to your rule - &quot;UI-specific actions&quot;.&nbsp; Your examples in those discussions were animations.&nbsp; But why would this not also fall under that arena?</p>
<p>Again, I realize the pro&#39;s of not having code-behind in your XAML views.&nbsp; But a drag-and-drop operation is awfully UI-specific, and while most any control can be a drop target, realistically it only applies in a very few select situations.&nbsp; Yes, being able to abstract that could help if your designer changes your UI on you, but my response to that is that many users&#39; expectations of drag-and-drop behavior are defined by the controls they are interacting with, so a change in the control set likely requires a change in the underlying DND code anyway.&nbsp; And given the varying kinds of drop targets (treeview nodes, listbox items, text controls) and their very different meanings, I&#39;m not sure how you&#39;d successfully abstract that notion away anyway...</p>
<p>The last response I see would be from a testing perspective.&nbsp; But how do you realistically test your mouse-related verbs... without a mouse?&nbsp; Yes, you can run tests to make sure your appropriate properties are set, but what does that really get you?&nbsp; That you can set VM properties in response to a method call?&nbsp; That hardly seems like code worth testing...</p>
<p>I totally realize the slippery-slope nature of the question.&nbsp; And I&#39;m not surprised that finding MVVM-related examples of DND is hard, given what I see as Microsoft&#39;s view of MVVM (and how CSLA&#39;s view differs).&nbsp; Maybe it&#39;s enough for me to say &quot;this is my line in the sand&quot; and be done with it.&nbsp; But if I&#39;m going to use CSLA in my programming, some level of &quot;compliance&quot; is realistically required in these areas, and to be honest I would have a hard time justifying this situation to another developer if asked without some form of &quot;because I said so&quot;...&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-42.gif" alt="Confused" /></p>
<p>What am I missing?&nbsp; Or am I completely mis-understanding?</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, February 21, 2011</h2><p>I do think this can get tricky, because there is some grey area here...</p>
<p>In my mind the goal for a viewmodel should be that it is a business focused presentation construct. In other words, it shouldn&#39;t be a simple replacement for code-behind (other than to enable testing maybe), but instead should exist at a higher level of abstraction.</p>
<p>So instead of an Item_Click method, it should have things like a ShowDetail method. What happens when you &quot;show detail&quot; could be quite different on a phone vs a tablet vs a 50 inch screen, so the abstraction is useful.</p>
<p>But in my navigation example, there are a couple things going on. There are all sorts of UI gestures that might cause navigation to a new view - all of which can be abstracted by methods in a viewmodel (such as ShowDetail). Of course the viewmodel needs an abstract way to navigate, such that at runtime the Frame control&#39;s Navigate method is called, and at test time there&#39;s no attempt by the viewmodel to interact with the Frame conrol (because it isn&#39;t even there at test time).</p>
<p>And this brings us down to brass tacks. We can talk about a fine line between &quot;pure view&quot; and less pure presentation/navigation code or whatever. But at the end of the day the goals are to be able to test the code in the viewmodel, and to test as much code as possible.</p>
<p>Code behind a view can only be tested by a human - so that&#39;s expensive and error-prone.</p>
<p>Code in a viewmodel can be tested using automation. BUT ONLY IF all interaction with any actual UI or view types is abstracted away. In other words, a viewmodel can NEVER do something like MessageBox.Show or CurrentFrame.Navigate(url) - because those things make the viewmodel untestable.</p>
<p>Back to my navigation example, the viewmodel needs to be able to initiate navigation, but it can&#39;t call the Navigate method. So something needs to sit between the XAML and the viewmodel to hear the viewmodel&#39;s PropertyChanged event and to call the Navigate event (at runtime), or to record the attempt to navigate (at test time).</p>
<p>With drag-and-drop I totally see what you are saying. And if the drag-and-drop functionality only needs to interact with the viewmodel or model at the point of drop completion (for example), then putting the code in code-behind is arguably better because there is no <em>business</em> abstraction for the drag-drop concept that would belong in the viewmodel.</p>
<p>I guess I&#39;m kind of rambling - my head is in a different space (working on the data access book) - so I&#39;m not very focused...</p>
<p>In short - I still think code-behind should be avoided if at all possible, and I&#39;d rather write some helper controls or attached properties to minimize code-behind. But the viewmodel should consist of abstract <em>business task oriented</em> verbs, and shouldn&#39;t be an event handler replacement for the code-behind.</p>
<p>Custom controls, attached properties and the viewmodel - these are all far more testable than code-behind. That, and custom controls and attached properties can be used by the UI designer, while they probably can&#39;t write or fix code-behind as they rework the UI over time.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
