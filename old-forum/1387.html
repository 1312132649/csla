<html><header><title>Sanity Check - Highly Configurable App</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Sanity Check - Highly Configurable App</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1387.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Wednesday, October 04, 2006</h2><P>We are developing an application that has become highly configurable (for a variety of reasons) and I need a sanity check on our thought process.</P>
<P>The application is a simulator.&nbsp; The UI allows the user to select from a list of pre-defined models, enter test specifications then view the results.&nbsp; The "rules" governing the specifications are configurable.&nbsp; For instance, one of the spec's is Displacement.&nbsp; In the app's config file, we have a setting that defines the acceptable Min and Max values&nbsp;as well as&nbsp;the default value for the field.</P>
<P>The question is where best to put this information?&nbsp; I see one of two approaches:</P>
<P>1. The Min and Max values for each specification basically define a validation rule.&nbsp; So, we have already created a&nbsp;ValueBetweenRuleArgs class which accepts the min and max values and validates against them.&nbsp; For each spec&nbsp;property in our "model" class, we would add a ValueBetween validation rule using the configured min and max values.&nbsp; Then, when the object is validated, the property would pass or fail the test and the issue reported back to the UI following the same lines as other validation rules.&nbsp; (This is my preferred route because of its consistency).</P>
<P>2. Use the configuration information to drive the UI.&nbsp; In other words, either use a validator control (web app - btw) or, since we are using Infragistics' WebNumericEdit control, set the max and min values of the control to the configured values.&nbsp; The&nbsp;initial value&nbsp;of the control would be set to the configured default.</P>
<P>As I mentioned, I like the first approach better but am struggling with the interaction between the object and the configuration information, for one, and applying the default on object creation (which kind of relates back to the first issue).</P>
<P>Everywhere else that we have implemented custom configuration settings, they are decoupled from the objects they relate to.&nbsp; In other words, the object doesn't know about or depend upon the configuration information - the values are set by a "third-party".&nbsp; For example, we have an application that supports the concept of policies to control the application's behavior.&nbsp; The application's SecurityManager class "reads" the configuration information and create a new Policy object for each settings in the config file and adds it to the application's Policies collection).&nbsp; Neither the Policy nor PolicyCollection class know anything about the fact that they are being instantiated based on configuration information.&nbsp; Our goal would be to decouple our specifications in the same manner.</P>
<P>However, I see an issue having a "third-party" object setting business rules for&nbsp;our "model" object - one of which is that our ValidationRules property is protected.&nbsp; Is this something that belongs in an object factory or is it appropriate for the object to be directly coupled with the configuration settings?</P>
<P>One of the reasons for this, btw, is that the min, max and default values apply to that specification for all "models" - so it's not configurable per model.&nbsp; This is probably something where ther per-type validation rules in CSLA 2.1 will come in handy, but right now I'm more concerned with following the right approach rather than worrying about per-instance vs. per-type.</P>
<P>Your thoughts?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 04, 2006</h2><P>With your min/max example, it seems to me that this min/max rule is an object in its own right.</P>
<P>Conceptually <EM>all</EM> business rules are technically objects btw. The fact that we implement them with delegates in .NET is for convenience - but <EM>logically</EM> you should think of a rule as an object!</P>
<P>If you think of your min/max rule as an object, then it has its own responsibility, and behaviors to support that responsibility. Your business object is collaborating with this rule object to validate the property value.</P>
<P>Since the rule is now truly behavioral, you can consider that loading its min/max values becomes part of its behavior - necessary to implement its responsibility.</P>
<P>Does that help?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, October 04, 2006</h2><P>Yea, kind of...</P>
<P>I agree completely about a rule being an object, which is why it made sense to implement it using our ValueBetweenRuleArgs class &amp; delegate.&nbsp; I like the fact that the necessary validation behavior is decoupled from the UI and the approach remains consistent with the way we handle it elsewhere.&nbsp; My question, I guess, is in regards to the fact that these "rules" are defined outside of our business objects.</P>
<P>I am thinking that you either touched on this in the book or a previous post - the idea that the rules could come from a database or some other source rather than having to be hard-coded into the BO.&nbsp; If this is the case, though, aren't we tasking the BO with responsibility for loading those rules?</P>
<P>Let's say, for example, that my BO has the following&nbsp;three properties:</P>
<P><CODE>Displacement<BR>Compression Ratio<BR>Drive Ratio</CODE></P>
<P>In our configuration file, we would have the following settings:</P>
<P><CODE>&lt;displacement min="0.1" max="16" default="2.5"&gt;<BR>&lt;compressionRatio min="6" max="20" default="10"&gt;<BR>&lt;driveRatio min="0.1" max="20" default="2.5"&gt;</CODE></P>
<P>(I'll spare you the rigors of how this is done...)</P>
<P>When a new BO is created, these properties should be initially set to the values of the "default" attribute in the appropriate element and when validated, the values of the "min" and "max" attributes define the limits that should be imposed.</P>
<P>Should the BO be designed so that the constructor is (something like):</P>
<P><CODE>public MyObject()<BR>{<BR>&nbsp; &nbsp; _displacement = Configuration.Displacement.Default;<BR>&nbsp; &nbsp; _compressionRatio = Configuration.CompressionRatio.Default;<BR>&nbsp; &nbsp; _driveRatio = Configuration.CompressionRatio.Default;<BR>}</CODE></P>
<P>Then we'd have:</P>
<P><CODE>protected override void AddBusinessRules()<BR>{<BR>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<BR>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("Displacement",<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.Displacement.Max,<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.Displacement.Min)<BR>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<BR>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("CompressionRatio",<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.CompressionRatio.Max,<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.CompressionRatio.Min)<BR>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<BR>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("DriveRatio",<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.DriveRatio.Max,<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.DriveRatio.Min)<BR>}</CODE></P>
<P>But in doing this, we've added the responsibility for obtaining the values from the configuration file (or any other source) to our object.</P>
<P>Would it be better to have the configuration file parsed and the validation rules set by another object whose primary role is doing this?</P>
<P>Part of what bothers me with this design is that I've broken encapsulation a bit by making the class dependant upon the configuration settings (and classes).&nbsp; For instance, if the &lt;displacement&gt; tag was missing from the configuration file, where do the defaults come from?&nbsp; I could setup the properties in the config class as Nullable so that I can check HasValue before using it, but the code just keeps getting more complex.</P>
<P>On the other hand, maybe this is <EM>exactly</EM> the right approach.&nbsp; That's why I referred to this as a sanity check.</P>
<P>(What about the idea of having an external Validator class that contains a list of business rules by type then accepts the object in its Validate(object) method?&nbsp; Then we've encapsulated everything to do with validation in another object.&nbsp; Bad idea?&nbsp; I'm assuming so since this wasn't the approach taken for CSLA.)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Wednesday, October 04, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div><p>Should the BO be designed so that the constructor is (something like):</p>
<p><code>public MyObject()<br>{<br>&nbsp; &nbsp; _displacement = Configuration.Displacement.Default;<br>&nbsp; &nbsp; _compressionRatio = Configuration.CompressionRatio.Default;<br>&nbsp; &nbsp; _driveRatio = Configuration.CompressionRatio.Default;<br>}</code></p>
<p>Then we'd have:</p>
<p><code>protected override void AddBusinessRules()<br>{<br>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<br>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("Displacement",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.Displacement.Max,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.Displacement.Min)<br>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<br>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("CompressionRatio",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.CompressionRatio.Max,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.CompressionRatio.Min)<br>&nbsp;&nbsp;&nbsp; ValidationRules.Add(CommonRules.ValueBetween,<br>&nbsp; &nbsp; &nbsp; &nbsp; new ValueBetweenRuleArgs("DriveRatio",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.DriveRatio.Max,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Configuration.DriveRatio.Min)<br>}</code></p></div></BLOCKQUOTE><br><br>My opinion, which doesn't count for much...<br><br>Storing these values in a configuration file is an implementation detail that you may want to abstract out of your primary business object (MyObject). What happens if you decide in the future to store the configuration values in a database, or they need to be retrieved from an external service? With the configuration file logic in the primary business object, you'll have to edit the primary business object. If you have this similar scenario in many business objects, you will be facing a monumental task if you change the location of these min/max constraints.<br><br>Based on what I know from your description, I might consider creating a separate class that has the logic that reads from the configuration file. The class would probably have generic methods to retrieve a max value, a default value, and a min value. Each of these objects would take an argument so it knows whether it should load the DriveRatio, CompressionRatio, or Displacement. Your calls to the configuration file would be replaced by calls to the new object.<br><br>This makes more code for you to write today, but it will be a huge blessing when you elect to no longer store the defaults in a configuration file. If you are extremely confident you will always use a configuration file to store the values, then the approach you have described will be fine.<br><br>If your constraints for MyObject are unlikely to change, I might introduce a business object that has 9 properties for the values instead of having parameterized functions. This would make the code even easier to read.<br><br>This isn't much different than choosing to use a DAL for your data access.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, October 05, 2006</h2><P>I'm right there with you in regards to the possibility that the settings may exist in a config file now but move later - to a database, for instance.&nbsp; In fact, we have a project on the drawing board where we make this an option during installation for clients with higher security requirements.&nbsp; That is exactly where my concerns were coming from, so thanks for articulating it better than I was.</P>
<P>It is/was my opinion that our BO shouldn't care or be dependant on where the information comes from but how to accomplish this has been giving me fits.&nbsp; Ironically, I am back on the forum looking to see if anyone had anything because yet again, I am back to addressing this issue.</P>
<P>The thought that occurred to me earlier was an attempt to look at this from a behavioral perspective.&nbsp; And, again, I come back to the two possibilities of how these limits (we'll ignore defaults for now) are "enforced":</P>
<P>1. If used as a business rule, we would validate the value entered by the user and report a broken rule back to the UI.</P>
<P>2. Or, if tied to the UI, we can limit the possible values right on the UI.</P>
<P>So, I guess I'm kinda asking a couple of questions.</P>
<P>We already make use of methods like CanAddObject to enable/disable controls on the UI, doesn't it make sense to be able to make use of data entry "constraints" in the same fashion?&nbsp; I realize that we can show a message indicating that "the displacement must be between 0.1 and 16" after the user tries to submit a value of 27 but, thinking as a user, wouldn't it be much nicer to save the user the trouble and not even allow&nbsp;that value&nbsp;in the first place?&nbsp; And, when dealing with a web app, to enforce the validation rules we must incur a round-trip postback whereas setting the MaxValue/MinValue properties on our data entry field allows these contraints to be enforced on the UI.</P>
<P>That aside, getting back to how to create the validation rules from the config file or other external source brings me back to my original dilemma of how best to handle establishing these rules from "outside" our business object.</P>
<P>hurcane mentioned creating a separate class that handles this.&nbsp; I am thinking that you are not talking about externalizing the ValidationRulesCollection but having another class that sits in the middle of our BO's and whatever source we are using for configuration data.&nbsp;&nbsp;Even then, if the location of the settings changes, we have to make a code change - but, we would only have to change it there and none of our BO's would have to change.&nbsp; Am I on the same page?</P>
<P>I'm still trying to picture how this would work.&nbsp; We would need to translate the information in this new object into validation rules for our BO.&nbsp; So, we would add this into the AddValidationRules method (?) to query the new object for any "constraints" that apply to that BO, create the rule and add it to the BO's ValidationRules collection...&nbsp; And, by doing this, we've maintained encapsulation and kept the ValidationRules property protected...</P>
<P>Then, it would be up to our new object to "pull" the information from whatever source applies.</P>
<P>I think I'm getting it, but I'm still wishing we could make the UI more responsive.</P>
<P>Thoughts?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 05, 2006</h2>It seems to me that there is a business object which will handle reading the configuration options.&nbsp; All your classes which need configuration information should then be able to use this class.&nbsp; If one class cannot handle all the different options, it sounds like you many need many classes for each kind of option.&nbsp; <br><br>Your other BOs could then translate from these objects to figure out how to build its business rules.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Thursday, October 05, 2006</h2><BLOCKQUOTE><div><img src="/Themes/alternate1/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div><br>I think I'm getting it, but I'm still wishing we could make the UI more responsive.<br>&nbsp;</div></BLOCKQUOTE><br><br>Pirate,<br><br>I haven't had a chance to really dive into 2.1, but I do know that there is a new ToString() inplementation in ValidationRules that returns a list of the rules and their values. With is, you should be able to drive the extents of controls in the UI.<br><br>Check out the <a href="http://www.lhotka.net/Article.aspx?area=4&amp;id=f12cc951-0452-42d1-96a6-cfa7656863b1">change log for 2.1</a> and look for "Csla - Validation Rules (getting a list of rules)".<br><br>- John<br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
