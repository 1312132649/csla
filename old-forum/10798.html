<html><header><title>Ideas on loading structure 6 layers deep?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Ideas on loading structure 6 layers deep?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10798.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>TScorpio posted on Sunday, October 23, 2011</h2><p>I am struggling with loading a structure made of 6 layers of data.<br />The load pattern is easy enough to code, but the process always errors our with a &quot;transaction aborted&quot; message. We calculate there&#39;s over 500K individual fetch requests being issued and the connection simply won&#39;t stay open long enough.</p>
<p>I&#39;ve only faced two layers of data before and ended up constructing the database query that generates 2 return sets. The first set is a list of parent records with an index, the next is a set of child records with their parent index numbers attached. This works great for Parent &amp; Child (We&#39;ve seen load times drop from 4 minutes to 2 seconds!!!). </p>
<p>Currently I have the query modified to return all 6 layers as 6 return sets. Each record in each set has index numbers pointing to it&#39;s parent in the layer above it, But I&#39;m beginning to realize that index numbers don&#39;t work past parent/child. From the grandchild layer on down, the index numbers assigned by the query no longer map to the collection index numbers in CSLA. </p>
<p>Anybody have any insight/ideas/experience on how to load the other 4 layers? Like I said before, this is my first time dealing with anything beyond 2 layers. If possible, I would like to keep it as one query because of the speed.<br />Thanks!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Sunday, October 23, 2011</h2><p>First what&#39;s the reason to load all data in a transaction? Transaction-less is usually faster. <br />But anyway this wouldn&#39;t speed it up so much.</p>
<p>I have similar problem aeras. One category is the type of &quot;static&quot; (or almost) data. For these the entiry list is fetched once and cached and then all factory methods run against the cache using Linq-to-object. </p>
<p>Now, for some remaining I haven&#39;t implemented a solution yet. But my plan is as follows: <br />If I had to fetch all parents I also fetch all children, and then assign the children to their parents. I expect doing this by their foreign key relationship (as above in memory with Linq-to-object). </p>
<p>Currently I have 3 or 4 levels. I can share my experiences with you probably this week. </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, October 25, 2011</h2><p>You can use one query (if you can construct the query to return all 6 result sets). You just need to build your DAL code to do multi-pass loading of your object graph.</p>
<p>Pass 1 - load the root</p>
<p>Pass 2 - load the children</p>
<p>Pass 3&nbsp;- for each child, load its children</p>
<p>Pass 4 - for each child, for each grandchild, load its children</p>
<p>etc.</p>
<p>I&#39;ve done this before, and would only encourage it if performance of multiple database queries is an issue. The code isn&#39;t complex, but it is tedious.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TScorpio replied on Thursday, October 27, 2011</h2><p>What you say is very <span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">intriguing and I would like to know more. </span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I currently have the query that returns all 6 sets. </span><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I was trying to build the <span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Structure </span>one level at a time. (ie-load&nbsp;ALL the roots, then&nbsp;ALL the children of those roots, then&nbsp;ALL the grandchildren, etc), but if&nbsp;I understand you correctly, you are saying I should&nbsp;load a &quot;family branch&quot; at a time? (Load Root&nbsp; 1, children for Root 1, grandchildren for child&nbsp; 1 of root 1, etc, then go back and&nbsp;do the same for root #2?)</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">So that would mean you are jumping around in the datareader object alot or using LinQ to filter the applicable records?</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;"></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>asinc replied on Thursday, October 27, 2011</h2><p>There is a sample called Deep Data which demonstrated parent, child, grandchild that may assist you. This was there in the 3.8 version at least and if I recall correctly there was also a video where he discussed this on Dnrtv.</p>
<p>HTH</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, October 27, 2011</h2><p>DeepData is fairly old, but does cover this, yes.</p>
<p>I am not suggesting jumping around in the datareader - you can&#39;t do that. The datareader only supports linear reads.</p>
<p>I am suggesting that you write code that reads the datareader in a linear fashion, and jumps around <em>in the object graph</em> to load the correct objects.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Thursday, October 27, 2011</h2><p>I just want to check, if I&#39;ve understood the multi pass idea correctly. </p>
<p>Is it correct, that I first query the database and the result (in my case using DTOs) having the DTO for the root and a list of DTOs for every layer? </p>
<p>Then within for example the root ObjectFactory I do in multi passes find the children for each parent, load the DTO&#39;s data into a child BO and assign it to the parent BO? </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TScorpio replied on Tuesday, November 01, 2011</h2><p>One of our other developers suggested building the tree from the bottom up instead of top down.<br /><br />Each record in each level has an index number to the parent directly above it, so we can iterate through level 6 children and add them to their level 5 parents. Then iterate level 5 and connect them to level 4, then 4 to 3, etc.. As we add children to parents, the structure under the child carries with it. After a child is added, it&#39;s index number becomes useless, but that&#39;s OK since it&#39;s now in it&#39;s proper parent container.<br /><br />Because we&#39;re using multiple return sets and&nbsp;index numbers the whole process is VERY fast...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Tuesday, November 01, 2011</h2><p>I don&#39;t understand the advantage of the bottom up approach. </p>
<p>I understand the &quot;index number&quot;, that&#39;s usual if a foreign key relationship exist. But, if you add the children from level below (initially the bottom) to their parents, the parents need already to exist. </p>
<p>So, do you mean, you create (a list of) BOs for every return set and the add the child to its parent, and the CSLA parent/child meachnism stands for the foreign key relation of a database? Then, I just can&#39;t see any difference between adding top down and bottom up. </p>
<p>But I think if you can create return sets in the right order (indices), that&#39;s propably a speed up.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Thursday, October 27, 2011</h2><p>Is this a read-only structure?</p>
<p>Are the items all of the same type with respect to the 6 levels deep, and with each item there is some notion of &quot;Parent ID&quot;?</p>
<p>If so, I&#39;d recommend personally just loading them all into a single collection, and have nonserializable private fields for parent item and child items (generic list) - on deserialization/fetch, have a method that basically swoops through and establishes the parent and child references.&nbsp; It makes things really super simple and the algorithm can be quite efficient (really linear order to the maximum depth of your tree).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Thursday, October 27, 2011</h2><p>No, they are all editable and beside an editable root, all levels below are editable children. On every level the children are of its BO. </p>
<p>Because I&#39;m fetching existing data, all foreign key values are present and correct. And CSLA sets the Parent property correctly by adding a child object / collection. </p>
<p>My idea is to have locally in the Fetch method one collection per level and add children to their parent&#39;s collecetion level by level. </p>
<p>The question (to Rocky) has been, if this idea is really the same as his multi pass description above.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Sunday, January 15, 2012</h2><p>Hi TScorpio,</p>
<p>CslaGenFork is an OpenSource code generator. As of the latest public build, it can handle deep data scenarios. The DeepLoad sample tests a data structure 6 levels deep. It could have used a depth of just 4 levels - the extra 2 levels were added as a reaction to this thread.</p>
<p>Anyway the sample is available at <a href="http://cslagenfork.codeplex.com/releases/view/79758">http://cslagenfork.codeplex.com/releases/view/79758</a></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
