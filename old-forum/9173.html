<html><header><title>Async Server Call with Tracking capability</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Async Server Call with Tracking capability</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9173.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>amir.gheibi posted on Monday, July 05, 2010</h2><p>I&#39;m creating a Windows desktop application (not using WPF) and I&#39;d like to make async server calls from client with tracking&nbsp;capability. Let me explain using an example:</p>
<p>I have a few service classes (inherited from&nbsp;CommandBase) in which I initiate a long-running tasks. Each service is dedicated to certain server-side functionalities of the application.</p>
<p>I need these services to start their task on server side (delegate it to another thread on the server) and come back quickly. Then whenever is requested by the client, these services can go back to the server and find out about the progress of the task.</p>
<p>I know for the fact that server side code is stateless. But is there any solution that I can add to CSLA&#39;s implementation to gain such capability? Is &quot;Message Queue&quot; my only solution?</p>
<p>I&#39;ve also seen suggestion about using BackgroundWorker. But I can&#39;t use that. Cause it initiates the processing from the client side. I want this to be as&nbsp;loosely&nbsp;coupled with client as possible.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Monday, July 05, 2010</h2><p>Can u be more specific?</p>
<p>As i understand u want to know the current state of a long running&nbsp;task running at a server (might be load balancing so u don&#39;t know which one). U have to save states to a shared location, a database would be best to use imho. </p>
<p>The simplest way is:<br />- Keep state at the server;<br />- Let the client poll at a regular interval.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, July 05, 2010</h2><p>If I understand you correctly, this isn&#39;t really a CSLA question as much as a &quot;how do I implement long-running tasks on a Windows Server&quot;?</p>
<p>Anything running in IIS/ASP.NET really won&#39;t be long-running. It would be nice if you could just launch a workflow or something - but that&#39;s not realistic.</p>
<p>So you have to get the task out of IIS and into some other process.</p>
<p>Windows has a couple pre-built process models for this - one is MSMQ (System.Messenging) and the other is COM+ (System.EnterpriseServices). Though you should look at the new Windows AppFabric stuff, as that might now be a third option. Oh, one detail - MSMQ itself needs you to provide a host process - which is either COM+ or a custom Windows service.</p>
<p>Of these options, hosting MSMQ in COM+ is the most robust because they automatically provide retries, dead/poison message queues, etc. I wrote an article for MSDN about this a long time ago (probably in 2002), and it is a little complex, but very cool.</p>
<p>If you host MSMQ in your own service, you&#39;ll have to implement retries and some sort of dead/poison message handling, etc.</p>
<p>I haven&#39;t had time to look into AppFabric yet, but it may provide a simpler answer - I just don&#39;t know.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>amir.gheibi replied on Monday, July 05, 2010</h2><p>Thanks Rocky.&nbsp;</p>
<p>I need something way simpler than AppFabric. On the other hand, as you pointed out, I have to run these tasks outside IIS. I guess MSMQ on COM+ is what I can go with. But I&#39;m not sure if MSMQ provides any mean to track details about execution of tasks that are&nbsp;represented&nbsp;by those messages. By that I mean customized details about how the task execution is progressing, provided by the task itself (perhaps passed to the Queue manager or something like that). &nbsp;I&#39;m not very familiar with it. But a quick Googling (or Binging if you like) tells me there is something called Queue&nbsp;Journal. Do you have any better suggestion?</p>
<p>Thanks,</p>
<p>Amir</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, July 05, 2010</h2><p>Again, I haven&#39;t looked&nbsp;at AppFabric enough to know - but it might be simpler than MSMQ/COM+, because that&#39;s not simple...</p>
<p>No external task mechanism is going to provide automatic execution status information. That sort of information is relative to the nature of the task itself - to your code - so you&#39;ll have to manage that.</p>
<p>Keeping in mind that we&#39;re talking about two processes running independently from each other, your best best for status information is probably to write &quot;log entries&quot; of a sort into a status table in your database. The polling business app can just check that table for status, and the task can write entries as it goes - including the final &quot;I&#39;m done&quot; entry.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>amir.gheibi replied on Tuesday, July 06, 2010</h2><p>Thanks. Very much appreciate it.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>amir.gheibi replied on Tuesday, August 09, 2011</h2><p>Just a quick update for other readers&#39; sake. I managed to do this using Quartz .NET.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
