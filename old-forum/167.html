<html><header><title>Inviting some thought on Rocky's reply to razorkai </title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Inviting some thought on Rocky's reply to razorkai </h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/167.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele posted on Monday, May 22, 2006</h2><TABLE class=MsgTable>

<TR class=MsgHeader>
<TD><B>2 / 3 - From:</B> RockfordLhotka <B>Posted: </B>4/21/2006 9:43:00 AM</TD></TR>
<TR class=MessageBlockEven>
<TD>
<P>This isn't a supported approach really... <BR><BR>What I do in such a case (because you have two different use cases here - just with a convenient navigation path from Company to CompanyAddress - not a parent-child relationship), is to have a GetAddress() method rather than a property. <BR><BR>Public Function GetAddress() As CompanyAddress <BR>Return CompanyAddress.GetAddress(mCompanyId) <BR>End Function <BR><BR>Notice that I DO NOT store this reference in an instance field - this is merely for navigational convenience. <BR><BR>Don't confuse parent-child (containment) with navigation (using) relationships. <BR><BR>Rocky <BR></P>
<P>&nbsp;</P>
<P>I have done a huge amount of what was recommended NOT to do up above...and I wondered if some of you experienced OOP guys could comment on this.</P>
<P>My CEO wanted a design&nbsp;where you can access and edit a lot from one screen without a bunch of popups with separate apply buttons.&nbsp; So we designed an object hierarchy that goes about 5 levels deep using many switchable objects in order to accomodate the one save / cancel button.&nbsp;</P>
<P>&nbsp;Project Tracker is designed to look at one thing...and edit related things in popups...not have the power of a related thing as a property on the object currently being edited.&nbsp; I didn't know any other way to handle this problem of not being allowed to use popups and fairly frequent CRUD operations.&nbsp; My app has one form that shows one main thing and all related things in grids organized in ExplorerBars.&nbsp; It is a lot of power...but the objects have turned out to be harder to manage this way to be sure.</P>
<P>Sean</P></TD></TR></TABLE>&nbsp;&nbsp;&nbsp;</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DavidDilworth replied on Tuesday, May 23, 2006</h2><P>I'd say that both approaches have merit to meet different requirements.</P>
<P>Clearly the requirement you have to build a very complex screen and have a whole bunch of objects that are editable/savable on the same screen means you have to build a complex business object.&nbsp; That's what your use case is telling you.&nbsp; And that's what your CEO wanted.</P>
<P>However, the other approach is equally right as it meets the requirements of easy to read code (i.e. Company.CompanyAddress), as well as having distinct processes to edit/update the CompanyAddress object separately from the Company object.&nbsp; That's essentially what the Project Tracker example code demonstrates.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Tuesday, May 23, 2006</h2><P>Thanks David,&nbsp; it helps to hear from others about this issue.&nbsp; I agree that both are right...just a matter of complexity and payoff.</P>
<P>I wonder if anyone has had success creating a flat ui that 'seemingly' edits one object fetch...but behind the scenes is actually following the 2nd approach you noted.&nbsp; My gut says this is a UI problem that should be solved in the UI not in the business object.&nbsp; If my objects really SHOULD be setup in a using relationship...then the UI needs to figure out how to hide that complexity right?</P>
<P>Sean</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, May 23, 2006</h2>I had something similar, although not nearly as complex.<br><br>I just finished a contact management system (which will soon grow itno much more).<br><br>The users wanted to enter the company and department which the contact belonged to, but they wanted it all on one screen.&nbsp;&nbsp; Other requirements dictated that Company and department be their own tables in the database.&nbsp; My problem was taht they wanted to enter any old company and department, without going to the other parts of the application to setup the company first. (Which is totally valid; they need to get all the data in as quick as possible).<br><br>What I ended up doing was having a company / department comboboxes which allowed free text.&nbsp; If TextUpdate was fired (which is only the case if the user enters text NOT already in the Items for the combo), i used some tricker to set the in memory contact objects' department id property to an invalid value.&nbsp; When both combo boxes were filled in, i could either set the DepartmentId to that of an existing department (if those chose one of the items) or to some fake (but valid) id.<br><br>When saving, i check the SelectedIndex properties, and if they are null i create a new company and or department before telling the contact to save.&nbsp; It was much more complex to setup, but they seem happy with it, and it works pretty well.<br><br>Andy<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 23, 2006</h2><P>I think the answer lies in your use cases. It is absolutely the case that some objects exist primarily as data containers and for navigation. But those are responsibilities that should flow from the use case.</P>
<P>It is also certainly true that some parts of a "use case" are actually user experience artifacts, not business artifacts. A requirement that you use or don't use modal windows is a user experience artifact, and so (in general) should be solved by UI objects, while the underlying business objects continue to focus on the business aspects of the use case (which should be largely independant of the user experience).</P>
<P>A way to think about this is whether your business objects would work with a different user experience - to achieve the exact same business goal. If they can do that then your objects are probably pretty good.</P>
<P>That's not to say that they automatically trivialize the UI development effort. Which may mean creating extra UI objects.</P>
<P>There's another thread about wizard UI's. Many wizards cover just one use case, but some wizards have optional sub-flows that are actually separate use cases. But those use cases could be expressed in various types of UI, not just a wizard. So the wizard requirement is a user experience issue, not a business issue. So separating those concerns is important.</P>
<P>The right answer (imo) is to have a business object that matches the overall use case. Then you might choose to create one UI object per wizard panel. These UI objects are "wrappers" over the business object - each one providing a bindable view against the set of properties required by the specific panel. The idea being that you can still use data binding (against the UI object), without compromising the business object itself, which remains focused on the business use case.</P>
<P>While many forms can be created directly on top of business objects, that is not always true. The key is to keep the objects focused on the business, and potentially create intermediate UI objects to provide specialized views of the underlying objects for cases where the UI's requirements are substantially different from the straight use case.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
