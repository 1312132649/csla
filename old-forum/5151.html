<html><header><title>Input requested: #if vs partial class</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Input requested: #if vs partial class</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5151.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka posted on Thursday, July 24, 2008</h2><P>As we work on CSLA Light (CSLA .NET for Silverlight), there's (at least) one continuing point of debate in the team - so I thought I'd gather more input.</P>
<P>One goal of CSLA Light is to allow the majority of your business code to be the same in Silverlight and .NET. The data portal runs between the two platforms, and your business objects literally move from .NET to Silverlight and back again. Very cool stuff!</P>
<P>This means that the same <EM>physical class file</EM>&nbsp;is included in two projects - a Silverlight Class Library and a .NET Class Library. We do this using the ability in VS to "Link" a file from one project into another, so the file exists once, but is in two projects. Pretty easy once you do it.</P>
<P>That all works nicely - for code that is 100% compatible with CSLA Light and CSLA .NET. This includes your property declarations, validation rules (mostly) and authorization rules.</P>
<P>This <EM>does not include</EM> your factory methods (usually) or your data access code. Silverlight doesn't even have the data access technologies available on .NET, so that code simply can't compile or work in Silverlight.</P>
<P>What this means is that, for a given business object like CustomerEdit, you could have three types of code:</P>
<OL>
<LI>Shared code that runs in Silverlight and .NET</LI>
<LI>Code that only runs in Silverlight (rare but possible)</LI>
<LI>Code that only runs in .NET (data access at least)</LI></OL>
<P>So that linked class file will at least contain the shared code.</P>
<P>Using compiler directives like "#if SILVERLIGHT" and "#if !SILVERLIGHT" the linked class could contain <EM>all three types of code</EM>. It is just that some of it won't compile on Silverlight or .NET obviously.</P>
<P>Another solution is to use partial classes. In this case there'd literally be three different files. The linked one with the shared code, a partial class in the Silverlight Class Library for the SL-only code, and a partial class in the .NET Class Library for the .NET-only code.</P>
<P>Either solution gets the same end result - all three types of code are there. The compiled results are the same either way.</P>
<P>We're really just talking about coding style - which is easier to understand, read, and explain?</P>
<P>Would you prefer to see all your code in one file, with sections blocked out with #if statements?</P>
<P>Or would you prefer to split your code into three files, each one with clear meaning?</P>
<P>(please note that CSLA Light will support either model - but all our examples, etc will be in one mode or the other - we're just trying to figure out what to "recommend" as the best approach)</P>
<P>Your input is <EM>very</EM> welcome!!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 24, 2008</h2>I think I'd prefer partial classes.&nbsp; <br><br>You could have Person.cs, Person.SilverLight.cs and Person.Net.cs.&nbsp; All relevant code is tucked away in an easy to find spot, vs. being intermixed with compiler directives, which seem messier to me.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>FatPigeon replied on Thursday, July 24, 2008</h2>I would vote for partial classes, each file is kept as&nbsp;simple as possible, and you can tell from the file name where the code will end up rather than trying to keep track of where you are in the file in relation to the compiler directives.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, July 24, 2008</h2><P>I, personally,&nbsp;would also definitely prefer partial classes.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ShawnCamp replied on Thursday, July 24, 2008</h2>Partial Classes are much easier to read and manage than Compiler Directives in my opinion.&nbsp; Although having 3 different files could be a little confusing, I still think its a better approach.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>chrisghardwick replied on Thursday, July 24, 2008</h2>I would prefer partial classes.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Thursday, July 24, 2008</h2>Cast another vote for partial classes.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Thursday, July 24, 2008</h2>I'll go against the grain here and say that compiler directives would be my preferred approach.<br><br>I've been looking through the test harness for CSLALight (which uses the partial class approach) and when trying to follow the code from SL to .Net for a single business object class, I have to have 2-3 tabs open in VS.&nbsp; After looking at a few business objects, my VS tabs were pretty crowded.<br><br>If you structure your code well enough - i.e. use regions and keep your
SILVERLIGHT and !SILVERLIGHT sections together, then you have the
advantage of all the code being visible in one screen in VS - i.e. just like a normal CSLA.Net class file.&nbsp; <br>Such seperation can be enforced easily enough using code templates.<br><br>This argument seems semantically similar to an argument one can have about seperating data access code out of your CSLA.Net class file into a partial class.&nbsp; <br>Instead the recommended approach for CSLA is to have it all in one class file and use regions and good coding structure to keep the logical seperation clear.<br><br>Why go in a different direction with the compiler directives?<br><br>Another point is that using partial classes will cause projects to bloat by roughly a factor of 2 in terms of files listed in the VS solution explorer.&nbsp; <br>With the size of application I am working on - probably going to have in the order of 300+ business object classes when we done - minimising the number of project files is a key concern for us in terms of readability and management of the solution structure.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lalit replied on Friday, July 25, 2008</h2><P>My vote for partial class to make life easier. :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mr_lasseter replied on Friday, July 25, 2008</h2>I like the idea of being able to use the same code for both .Net and Silverlight, but doesn't what you are asking seem a bit hackish?&nbsp;&nbsp; It might be a slippery slope...</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, July 25, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>mr_lasseter:</strong></div><div>I like the idea of being able to use the same code for both .Net and Silverlight, but doesn't what you are asking seem a bit hackish?&nbsp;&nbsp; It might be a slippery slope...</div></BLOCKQUOTE></P>
<P>I don't think so.</P>
<P>We're working very hard to make sure the property declaration, validation rules and authorization rules concepts from CSLA .NET appear the same in CSLA Light. Specifically so those regions of your objects can run in both environments.</P>
<P>My goal is to enable mobile objects between SL and .NET, and that means as much shared functionality as possible.</P>
<P>Yes, it is possible for someone to write some SL-only or .NET-only code in there, but the dual-project with linked files technique tends to catch that immediately when you build the solution. And if you stick with 'standard' CSLA property declarations and other techniques this is not likely to start with.</P>
<P>The only place you can get into trouble is with business or validation rules that interact with the data portal. This is because the SL data portal is <EM>only</EM> asynchronous, and that means this type of validation rule must be async too.</P>
<P>But we've added an async data portal and async validation rules to CSLA .NET too, so even <EM>that</EM> code will be common between the two environments.</P>
<P>In the end, only your constructor, factory methods and data access code are different between the two environments - which loops us back to the #if vs partial class question.</P>
<P>And even there, either technique works great. We're using some of each in testing (got to make sure). But there'll be actual samples in the near future, and they need to be consistent - one way or the other.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, July 25, 2008</h2><P>I already have "too many files" in my app.</P>
<P>I have a code gen layer and then a layer of derived classes with a possible 3rd layer of more derived classes. If I have to triple each of them in order to support Silverlight, that could get out of hand. So I am leaning toward the compiler directives and keeping things in their proper regions of the BO.</P>
<P>If I only had a single set of BOs then I would definitely prefer partial classes but I don't so I won't.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geeky replied on Thursday, February 19, 2009</h2>I know this is a bit late - only just started on CSLA Light but I would favour complier directives.&nbsp; IMHO partial classes are just a hack by M$ to enable designer files ;-)&nbsp; A file should contain one type and one type should be in one file.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Wednesday, February 10, 2010</h2><p>I see many people are voting for partial classes, i agree for&nbsp;regular csla code.&nbsp;But I disagree when using the objectfactory pattern since in that case there won&#39;t be any data access in the shared business classes.</p>
<p>I&nbsp;do hate the fact that there will be ALOT more classes. We have a generated project with around 3000 classes and it takes ages to get from TFS and to work with in Visual studio, Visual studio often crashes when we include the project and building isn&#39;t any fun.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cdkisa replied on Wednesday, February 10, 2010</h2><p>I vote partial classes. It would be like an nTier class (business logic, data access logic, whatever else logic).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, February 10, 2010</h2><p>For those just joining in, this &quot;vote&quot; happened almost a year and a half ago, so I&#39;m not sure how much impact further voting will have.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, February 10, 2010</h2><p>Very true Andy <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p>
<p>I can share what we learned from building and maintaing CSLA .NET for Silverlight over the past quite-a-few months (it has been almost 2 years - wow!!)</p>
<p>We did some of each - some compiler directives, some partial classes.</p>
<p>In the end, at least within the framework, the compiler directive approach is far superior. Having class code spread into 2-3 different files makes it too hard to find and maintain bits of code over time. And it makes it harder to manage the file linking.</p>
<p>Now with CSLA 4 there&#39;s csla.client, csla.core and csla.silverlight - so we&#39;re talking about the potential for 1 core file and 3 partial files, which would just compound the challenge.</p>
<p>There are obviously differences between building business apps and frameworks, but from a framework perspective CSLA is shifting (slowly) entirely to a #if solution and away from the partial class approach.</p>
<p>However, for business solutions I think partial classes are a very workable solution. The reason for this is that I use them to separate out entire regions of code (like the DataPortal_XYZ methods and synchronous factory methods). There&#39;s very clear delination within the standard business class structure as to which code is server-only and which is shared. So, unlike framework code, the results are very clear.</p>
<p>The problem with framework code is that the differences between SL and .NET are often very subtle, and we&#39;re changing just one line of code, or one part of a method implementation. That&#39;s very different from the typical business class scenario, and doesn&#39;t lend itself well to partial classes...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, February 11, 2010</h2><p>That&#39;s a great insight.&nbsp; I haven&#39;t delved into SL yet, but I&quot;m hoping to in the very near future. </p>
<p>For developing the business library, I was leaning toward the partial class method, and its reassuring to hear that it sounds like the way to go.&nbsp; </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
