<html><header><title>Unable to set a business object public property using an Internal accessor</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Unable to set a business object public property using an Internal accessor</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8670.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lloydm posted on Tuesday, March 16, 2010</h2><p>I&#39;m getting&nbsp;the compile time exception: &quot;Property or indexer&nbsp;cannot be assigned to -- it is read only&quot; when attempting to set a business object&#39;s property using an internal setter. I&#39;m using a data access factory method defined in a separate assemby that derives from the CSLA&#39;s ObjectFactory to return a populated business object.&nbsp; </p>
<p>I used the ProjectTrackerWithObjectFactory sample app as a&nbsp;template which uses an internal setter for&nbsp;the Resource business object&#39;s Id integer property and the project compiles, but&nbsp;mine won&#39;t.&nbsp; Class visability and accessors in my project appear to match those in the sample app, so I&#39;m not sure what the issue is.<span style="color:#2b91af;font-size:small;"><span style="color:#2b91af;font-size:small;"></span></span></p>
<p><strong>My CSLA business object property declaration:</strong></p>
<p>public static PropertyInfo&lt;int&gt; ItemIdProperty = RegisterProperty&lt;int&gt;(p =&gt; p.ItemId, &quot;ID&quot;, 0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int ItemId<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty&lt;int&gt;(ItemIdProperty); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal set { LoadProperty(ItemIdProperty, value); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p><strong>My CSLA business objects Fetch factory method:</strong></p>
<p>&nbsp;public static BusinessObjectType GetWidgetItem(int id)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Fetch&lt;BusinessObjectType &gt;(new SingleCriteria&lt;BusinessObjectType , int&gt;(id));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p><strong>My data factory method(defined in a separate assembly):</strong></p>
<p>public BusinessObjectType Fetch(SingleCriteria&lt;BusinessObjectType, int&gt; criteria)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var widgetItem= (BusinessObjectType)Activator.CreateInstance(typeof(BusinessObjectType), true);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string sql = &quot;SELECT description, notes FROM widgets w WHERE w.item_id = @id&quot;;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var conn = new OracleConnection(Database.WidgetsConnection))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (OracleCommand dbCmd = new OracleCommand(sql, conn))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbCmd.Parameters.Add(&quot;@id&quot;, OracleDbType.Varchar2, 50).Value = criteria.Value;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbCmd.CommandType = CommandType.Text;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conn.Open();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var olReader = new SafeDataReader(dbCmd.ExecuteReader(CommandBehavior.CloseConnection)))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (olReader.Read())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks(dataFoundryItem))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; widgetItem.ItemId = criteria.Value;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; widgetItem.ItemName = olReader.GetString(&quot;data_foundry_desc&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; widgetItem.ItemNotes = olReader.GetString(&quot;data_foundry_notes&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; olReader.Close();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MarkOld(widgetItem);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return widgetItem;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>Does anyone have an idea about what I&#39;m doing wrong?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>skagen00 replied on Tuesday, March 16, 2010</h2><p>Well, you&#39;re saying that Widget.ItemId is marked as internal and you&#39;re trying to set it from another assembly, which is basically not valid because the very nature of an internally marked property is that it can only be used by classes within the same assembly.</p>
<p>I have not used a separate data access tier as you appear to be trying to do (versus putting it in the designated places in the CSLA business objects) - so I am definitely not the expert - but I&nbsp;thought the advised approach in this case is to return a data-access object that your CSLA business object will use to populate itself with. </p>
<p>You might want to check out Rocky&#39;s Deep Data example.</p>
<p><a href="http://www.lhotka.net/weblog/DNRTVShowOnCSLANETAndDataAccess.aspx"><span style="color:#003399;">http://www.lhotka.net/weblog/DNRTVShowOnCSLANETAndDataAccess.aspx</span></a></p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, March 17, 2010</h2><p>This is correct; internal only grants access to members&nbsp;within the same assembly, unless you also use the InternalsVisibleTo assembly level attribute to open internals up to another, trusted assembly.&nbsp; I would however recommend to steer clear of this, as it seems to cause more problems than it solves.&nbsp; Here&#39;s the MSDN page:&nbsp; <a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute.aspx">http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute.aspx</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Wednesday, March 17, 2010</h2><p>Instead of using ByPassPropertyChecks u can also use LoadProperty for each IPropertyInfo</p>
<p>LoadProperty(widgetItem, WidgetItem.ItemIdProperty, criteria.Value);<br />etc..</p>
<p>Lhotka used to&nbsp;make the static PropertyInfo registrations internal but now he&nbsp;recommends to make them public just like u have. Since they are public now u can just call the LoadProperty. </p>
<p>PS: Your factory must be inherited from ObjectFactory.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, March 17, 2010</h2><p>Oh good point, I didn&#39;t see that they were trying for ObjectFactory.&nbsp; In that case making the PropertyInfos public would be the right way to go.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, March 18, 2010</h2><p>Hi, </p>
<p>First -&nbsp; Id recommend to make the PropertyInfo&#39;s public accessible (and not private). </p>
<p>Then you must make a choice on how to hide/prevent write to properties from UI and still be accessible Factory methods.You alternatives are: </p>
<p>1. Consider properties on BO as contract, ie hide properties some from UI and only make them visible to factory methods:</p>
<ul>
<li>make properties you want to hide from UI to be internal</li>
<li>use &quot;InternalsVisibleTo&quot; attribute on your assembly to allow factory methods to access these properties</li>
</ul>
<p>2. Make all properties public(and visible to UI)</p>
<ul>
<li>override CanWriteProperty to &quot;lock&quot; properties from being modified by UI .</li>
<li>factory methods that use &quot;BypassPropertyChecks&quot; can still write the value. </li>
</ul>
<p>3. Create private properties on those you want to hide from UI</p>
<ul>
<li>and use LoadProperty/ReadProperty to access the property values. </li>
</ul>
<p>In the ProjectTrackerWithObjectFactory I chose the first alternative for the internal timestamp values that I didn&#39;t want to expose to the UI while still being able to use the &quot;Named parameters&quot; construct on BO&#39;s (and avoid LoadProperty). </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lloydm replied on Thursday, May 13, 2010</h2><p>Sorry it took so long for me to reply, but thanks very much!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
