<html><header><title>Database-based authorization?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Database-based authorization?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1981.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert posted on Friday, December 15, 2006</h2>Does anyone have an example of a pattern to store role authorization rules information in tables? We'd like to replace the hard-coded authorization rules checks in the authorization region. <br><br>We're in a Novell environment so we're not using Active Directory. We have the option, maybe, to use Novell's Identity Manager, but will most likely end up creating our own infrastructure using SQL Server. We would, however, like to abstract this part of it in case the data source changes.<br><br>Are there any CSLA-specific solutions? Is there anything in the Security Application Block of the Enterprise Library that would solve this? Any insights would be very much appreciated.<br><br>Barry Gilbert<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, December 15, 2006</h2><P>The basic structure of the solution is to create a read-only object that represents the authorization rules/roles for a given business object type. This read-only object would consist, at least, of the business object type name, and then a list of the properties of the object. For each property, you'd have four lists of roles (allow read, deny read, allow write, deny write).</P>
<P>The data structure I'm describing is not overly complex - just lists of lists.</P>
<P>If you construct this object as a ReadOnlyBase-derived object, you can load it via the data portal, just like any other object. Though you might load it from your custom database or whatever.</P>
<P>If you are using only per-type rules (in version 2.1) then you don't need to worry about caching these authorization infomation objects - CSLA .NET will cache the results once you load them into the actual object in AddAuthorizationRules().</P>
<P>If you are using per-instance rules then you might want to cache the authorization information objects. Though that's debatable, since the only reason to use per-instance rules is if the rules differ on a per-instance basis, which could make any sort of caching entirely impossible.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 15, 2006</h2><P>I've actually taken this a step further to facilitate globalization and to prevent tampering.</P>
<P>All of the rights/roles/priviledges (whatever you want to call them) are defined in an embedded resource file as string resources.&nbsp; This allows the text description of the right/role to be globalized in the event that you provide a UI displaying what rights/roles a user has/is in.</P>
<P>All code uses the resource key to identify the right/role that you are checking for.&nbsp; In our case, these are typically "rights" like "Can add projects" that are assigned to the various roles/groups in the application but sometimes contain the actual role names instead.</P>
<P>What this does is allow the code to remain consistent regardless of the language being used and, because the rights/roles are embedded as resources, they can't be tampered with!&nbsp; Granted one can argue that this is overkill because we could use DB security, etc. to limit access to the database tables but I have worked (and am working now) in corporate environments where there are many hands involved and with access to the databases.&nbsp; In fact, developers at the company I am consulting with now only have access to the databases through SQL Server Management Studio.&nbsp; The IT guys and DBA's have direct access and admin rights to the systems and databases.&nbsp; So, it's best to be safe. (I should mention these are all remote servers - located in another state!)</P>
<P>In our database, when we "map" or assign the rights/roles to a user, we simply use the text that corresponds to the resource key.&nbsp; This way when we read the information back from the database it can be passed just like the resource key.</P>
<P>As Rocky described, our user (Principal object) has a list of rights/roles assigned and it is a matter of doing a simple string comparison to determine if the user has the desired right / is in the desired role.&nbsp; So&nbsp;we have code&nbsp;like:</P>
<P><CODE>public static System.Boolean CanAddProjects<BR>{<BR>&nbsp; &nbsp; get<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; return SecurityManager.Authorize(Resources.CanAddProjects);<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>Our SecurityManager class is a collaborative object used to offload the common task of checking the current user's credentials.</P>
<P>Because the data pulled from the DB will match the string identified by the resource key, we will successfully authorize (or deny) the user.&nbsp; And, our code is not subject to the contents of the database.&nbsp; So, if some smart-alek DBA comes through and wipes out the table, everyone gets denied access and our app keeps right on running.</P>
<P>The one thing I am looking to do is standardize the text that is written to the DB.&nbsp; We have dynamic, run-time user admin in most of our apps, so the records in our database our written on-the-fly.&nbsp; This means that the string that we pass to the DB will match that admin user's culture.&nbsp; So far this hasn't caused a problem because the admin is always in the same region, BUT.....</P>
<P>Not to mention, reading the database table is a lesson in multi-linguistics!</P>
<P>So, my next step is to change the admin portion that writes the data to the database to use a culture-invariant form of the resource and our SecurityManager converts the resource string that is passed in the same way.&nbsp; I am considering a custom ResourceProvider but am not sure yet.&nbsp; Always more work to do...</P>
<P>HTH</P>
<P>&nbsp;</P>
<P>P.S. Sorry, I forget to mention the "access" rules for CanReadProperty, etc. contained in the AuthorizationRules collection.&nbsp; This works the same way as in the book, except that we use the resource key when adding the rule to the collection.&nbsp; So instead of Add("PropertyName", "Project Manager"), we would have Add("PropertyName", Resources.CanModifyProjects) or something like that.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Friday, December 15, 2006</h2>Rocky,<br />Thanks for the reply. I guess I wonder how to handle a user that is a<br />member of two roles that have conflicting permissions. Would I need to<br />handle it the way SQL Server does, with implicit as well as explicit<br />permissions? It seems that the logic starts to get complex.<br /><br />Have you considered including this sort of functionality for a future<br />version?<br /><br />Thanks,<br />Barry Gilbert<br /><br />>>> "RockfordLhotka"   12/15/06 12:12 PM >>><br />The basic structure of the solution is to create a read-only object that<br />represents the authorization rules/roles for a given business object<br />type. This read-only object would consist, at least, of the business<br />object type name, and then a list of the properties of the object. For<br />each property, you'd have four lists of roles (allow read, deny read,<br />allow write, deny write).<br /><br />The data structure I'm describing is not overly complex - just lists of<br />lists.<br /><br />If you construct this object as a ReadOnlyBase-derived object, you can<br />load it via the data portal, just like any other object. Though you<br />might load it from your custom database or whatever.<br /><br />If you are using only per-type rules (in version 2.1) then you don't<br />need to worry about caching these authorization infomation objects -<br />CSLA .NET will cache the results once you load them into the actual<br />object in AddAuthorizationRules().<br /><br />If you are using per-instance rules then you might want to cache the<br />authorization information objects. Though that's debatable, since the<br />only reason to use per-instance rules is if the rules differ on a<br />per-instance basis, which could make any sort of caching entirely<br />impossible.<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Saturday, December 16, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>bgilbert:</strong></div><div>I guess I wonder how to handle a user that is a member of two roles that have conflicting permissions. Would I need to handle it the way SQL Server does, with implicit as well as explicit permissions?</div></BLOCKQUOTE></P><FONT size=2>
<P></FONT>Ummm... conflicting permissions... How is that possible.</P>
<P>Usually what you'll end up having is a user that is in more than one security group, with each group having its own list of roles which either grants or denies access to a specific functions or tasks in your application. Typically you should create a list of all the grants from every groups a user belongs to. Then carefully replace any grant roles by its respective deny roles if one is present.</P>
<P>Consider the following security groups and associated roles.</P>
<P>Group 'Administrator' ::: CanReadWine, CanAddWine, CanEditWine, CanDeleteWine</P>
<P>Group 'Buyer' ::: CanReadWine, CanBuyWine, CanAskQuestionsAboutWine</P>
<P>Group 'Alcoolic' ::: CanReadWine, DenyBuyWine</P>
<P>Group 'GrandMa' ::: DenyReadWine,&nbsp;CanReadBrandy, CanBuyBrandy</P>
<P>So...</P>
<P>1) If your user is the groups 'Administrator' and 'Buyer' they should end up with the following roles...</P>
<P>CanReadWine, CanAddWine, CanEditWine, CanDeleteWine, CanBuyWine</P>
<P>2) If your user is the groups 'Buyer' and 'Alcoolic' they should end up with the following roles...</P>
<P>CanReadWine, DenyBuyWine, CanAskQuestionsAboutWine</P>
<P>In this second example all grants were added and then the DenyBuyWine trumped the CanBuyWine role.</P>
<P>3) If your user is the groups 'GrandMa' and 'Alcoolic' they should end up with the following roles...</P>
<P>DenyReadWine, DenyBuyWine, CanReadBrandy, CanBuyBrandy</P>
<P>In this example the DenyReadWine role from the 'GrandMa' group trumps the CanReadWine role from the 'Alcoolic' group.</P>
<P>Poor grand ma, she's alcoolic, she can't buy wine but she's smilling all the time nonetheless... she can buy brandy :)</P>
<P>Hope this helps.</P>
<P>Can you tell I'm a wine enthusiast :)</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Saturday, December 16, 2006</h2>Guy,<br /><br />Thanks for your reply. I'm very familiar with the concept of least<br />priviledge and how this works in SQL Server. What I'm trying to<br />determine is the best way to implement this logic in a custom class in<br />code, storing the roles/groups in a table. At first glance, it seems<br />like a bunch of if/then's. <br /><br />Barry<br /><br />>>> "guyroch"   12/15/06 11:53 PM >>><br />bgilbert:I guess I wonder how to handle a user that is a member of two<br />roles that have conflicting permissions. Would I need to handle it the<br />way SQL Server does, with implicit as well as explicit permissions?<br /><br />Ummm... conflicting permissions... How is that possible.<br /><br />Usually what you'll end up having is a user that is in more than one<br />security group, with each group having its own list of roles which<br />either grants or denies access to a specific functions or tasks in your<br />application. Typically you should create a list of all the grants from<br />every groups a user belongs to. Then carefully replace any grant roles<br />by its respective deny roles if one is present.<br /><br />Consider the following security groups and associated roles.<br /><br />Group 'Administrator' ::: CanReadWine, CanAddWine, CanEditWine,<br />CanDeleteWine<br /><br />Group 'Buyer' ::: CanReadWine, CanBuyWine, CanAskQuestionsAboutWine<br /><br />Group 'Alcoolic' ::: CanReadWine, DenyBuyWine<br /><br />Group 'GrandMa' ::: DenyReadWine, CanReadBrandy, CanBuyBrandy<br /><br />So...<br /><br />1) If your user is the groups 'Administrator' and 'Buyer' they should<br />end up with the following roles...<br /><br />CanReadWine, CanAddWine, CanEditWine, CanDeleteWine, CanBuyWine<br /><br />2) If your user is the groups 'Buyer' and 'Alcoolic' they should end up<br />with the following roles...<br /><br />CanReadWine, DenyBuyWine, CanAskQuestionsAboutWine<br /><br />In this second example all grants were added and then the DenyBuyWine<br />trumped the CanBuyWine role.<br /><br />3) If your user is the groups 'GrandMa' and 'Alcoolic' they should end<br />up with the following roles...<br /><br />DenyReadWine, DenyBuyWine, CanReadBrandy, CanBuyBrandy<br /><br />In this example the DenyReadWine role from the 'GrandMa' group trumps<br />the CanReadWine role from the 'Alcoolic' group.<br /><br />Poor grand ma, she's alcoolic, she can't buy wine but she's smilling all<br />the time nonetheless... she can buy brandy :)<br /><br />Hope this helps.<br /><br />Can you tell I'm a wine enthusiast :)<br /><br /> <br /><br /> <br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Saturday, December 16, 2006</h2><P>No, it's actually quite simple - just check for "Deny" rights first.&nbsp; Like so:</P>
<P>1. Check if current user is denied the right to read wine (i.e. assigned DenyReadWine).&nbsp; If so, fail.</P>
<P>2. Otherwise, check if the user is granted the right to read wine (i.e. assigned CanReadWine).&nbsp; If so, succeed.</P>
<P>3. Otherwise, fail.</P>
<P>I believe this is what is already being done in Rocky's code.</P>
<P>Using Guy's example, if the user is in both the "Grandma" and "Alcoholic" groups and tries to "ReadWine", then your authorization code fails because the DenyReadWine (via the Grandma group) right supercedes the CanReadWine right provided by the Alcoholic group.</P>
<P>No extra conflict resolution is required.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
