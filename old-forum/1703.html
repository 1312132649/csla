<html><header><title>Object model design &amp; inheritance</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Object model design &amp; inheritance</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1703.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, November 07, 2006</h2><P>I have a question regarding the approach used when constructing a set of base classes with slightly different behavior.&nbsp; In my experience, the reason you would use inheritance is to achieve code reuse and leverage the behavior that exists in the base class while adding some new functionality (of value) in the derived class.&nbsp; However, there has been a lot of talk in this forum about shying away from inheritance unless it is clear that this is true - I get that.</P>
<P>Where my confusion comes from is the contradiction that I see in the core .NET framework and the approach Rocky has taken with regards to collection classes.</P>
<P>As I see it, you have four basic types of collections:</P>
<OL>
<LI>Collection - unordered group of objects, no indexing,&nbsp;accessed using an enumerator</LI>
<LI>List - indexed group of object accessed by position (index) or enumerator</LI>
<LI>Keyed(Collection or List) - group of objects that may be accessed using a key value that is found in one of the object's properties</LI>
<LI>Dictionary - group of objects that may be accessed using a key value that is not part of the object itself and is stored in a key/value pair</LI></OL>
<P>Given this explanation, a List is simply a Collection that adds indexing and a KeyedCollection is a Collection that adds support for keys.&nbsp; (Likewise, a KeyedList would be a List with support for keys).&nbsp; A Dictionary is out there on its own except that it is a Collection whose items are Key/Value pairs instead of the actual object itself.</P>
<P>For the Dictionary, it is clear that inheritance is not appropriate as most of the Collection class' methods would have to be overridden to support the key/value nature of the Dictionary.&nbsp; So, very little code reuse and/or behavior is being preserved.&nbsp; However, in the case of the Collection-&gt;List-&gt;KeyedList (let's say), I can see how all of the behavior in the Collection class is reused by the List class with the value added indexing capability.&nbsp; And likewise with the KeyedList to the List class where you would need to override the Add() method but still delegate to the base class functionality to actually add the item once the key was pulled out and stored.</P>
<P>In CSLA, inheritance is used by having the ReadOnlyListBase inherit ReadOnlyBindingList. I am curious why BusinessListBase does not inherit ReadOnlyListBase and add write capability?&nbsp; Isn't this a candidate for inheritance based on the same concepts?&nbsp; It would leverage the behavior that already exists in ReadOnlyListBase but add new behavior such as Add(), Insert(), Clear(), Remove(), etc.&nbsp; Can anyone explain the rationale behind not inheriting?</P>
<P>To further confuse me, Microsoft almost <U>never</U> uses inheritance&nbsp;for the collection classes in the FCL.&nbsp; With the exception of System.Collections.ObjectModel.KeyedCollection&lt;K,T&gt;, System.Collections.Specialized.NameValueCollection and System.ComponentModel.BindingList&lt;T&gt;, <U>none</U> of the myriad of collection classes use inheritance.&nbsp; I'm thinking there is a ton of code duplicated amongst these objects and am struggling to understand why inheritance wouldn't be used here.</P>
<P>So, as I am working on my own classes, I am struggling with when it is and when it isn't appropriate to use inheritance in cases when it seems intuitive to me to do so.&nbsp; Any thoughts?</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Tuesday, November 07, 2006</h2>Hey there,<br><br>Let's see if I can make some sense of this ....<br><br><BLOCKQUOTE><div><img src="/Themes/alternate1/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div><p>In CSLA, inheritance is used by having the ReadOnlyListBase inherit ReadOnlyBindingList. I am curious why BusinessListBase does not inherit ReadOnlyListBase and add write capability?&nbsp; Isn't this a candidate for inheritance based on the same concepts?&nbsp; It would leverage the behavior that already exists in ReadOnlyListBase but add new behavior such as Add(), Insert(), Clear(), Remove(), etc.&nbsp; Can anyone explain the rationale behind not inheriting?</p>
<p></div></BLOCKQUOTE></p><p>The main focus of ReadOnlyLists is to be lean and mean. This not only involves the list, but also the objects contained in the list (ReadOnlyBase sub-classes). The main driving force behing BusinessListBase and BusinessBase is all the fancy CSLA stuff: authorization, validation, CRUD, etc. etc. Two (highly) different scenario's, so there is your argument in favor of two distinct objects. <br></p>Probably you <i>could</i> make BusinessListBase derive from ReadOnlyListBase. And then (because of the use of generics) you should also have to make BusinessBase derive from BusinessBase. Then all the cool stuff would be added at the BusinessBase level. But this yields one potential problem: you would be able to put BusinessBase classes in your ReadOnlyListBase list. Ouch...... The opposite solution (make ReadOnlyListBase and ReadOnlyBase derive from BusinessListBase and BusinessBase) is even less desirable: your readonly objects become way too bulky (by inheriting all the business-fanciness).<br><p>
<br>
<BLOCKQUOTE><div><img src="/Themes/alternate1/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div></p><p>To further confuse me, Microsoft almost <u>never</u> uses inheritance&nbsp;for the collection classes in the FCL.&nbsp; With the exception of System.Collections.ObjectModel.KeyedCollection&lt;K,T&gt;, System.Collections.Specialized.NameValueCollection and System.ComponentModel.BindingList&lt;T&gt;, <u>none</u> of the myriad of collection classes use inheritance.&nbsp; I'm thinking there is a ton of code duplicated amongst these objects and am struggling to understand why inheritance wouldn't be used here.</p></div></BLOCKQUOTE><br><br>The core Collection classes in the framework are heavily optimized for performance. It is not just an augmented array or so, there is a lot of background adminstration going on in order to ensure maximum performance for each of these classes (Collections/Lists/Dictionaries). So the strategies employed internally in each of these classes to maintain the set of items are very specific and don't lend themselves for reuse. In addition: list behavior is rather straightforward (Add/Remove/Item(index) ...), so the code that <i>could</i> still be reused (despite the specific optimizations) is not really a big gain.<br><br>So apparently Microsoft chose to comply with some interfaces (like IList) instead of deriving from the same base class. Also: since the introduction of Generics it would become a bit combersome to program against base-classes. You would have to go the 'generics'-way throughout your own code if you wanted to be agnostic to a particular list type.<br><br>Hope this clarifies a bit.<br><br>Regards,<br>Bayu<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
