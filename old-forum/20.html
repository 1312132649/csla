<html><header><title>Use ActiveCache to minimize transfered data?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Use ActiveCache to minimize transfered data?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/20.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick posted on Monday, May 08, 2006</h2><div><font size="2"><font size="4">Hi,<br><br><span class="127282506-08052006">how would it be </span>possible 
to work with the following&nbsp;<span class="127282506-08052006">caching 
</span>scenario in CSLA.NET?<br></font>
<ul><li><font size="4">Lets say I would like to load a very big customers collection 
with their photos from the Data Portal via a Web Service.</font></li><li><font size="4">Now I change some of the customers on the client and save the 
changes. The client only sends back the changed customers to the Data 
Portal.<br></font></li><li><font size="4">Now I would like to refresh the customer collection on the 
client but I would like the Data Portal to only send changed customers (updated, 
deleted, inserted) back and not all the customers again (to save 
bandwidth).</font></li></ul><font size="4">Is it&nbsp;<span class="127282506-08052006">for example </span>possible to use ActiveCache from 
ActiveObjects in this scenario or are there any other<span class="127282506-08052006"> tools some of you use</span>?</font><br><font size="4"><br>Thanks a lot<br>Patrick<br></font></font></div></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>glenntoy replied on Monday, May 08, 2006</h2><P>Hi Patrick, I would like to help and give you idea but we have different cases. In&nbsp;CSLA&nbsp;1.0, &nbsp;I was able to implement a caching of lookup tables. What I did is to do a binary serialization and save the object&nbsp; to client's workstation. Everytime it runs the application, it compares the table cache file against the table cache in the database to check what are the necessary lookup tables that where modified. If there are no changes it&nbsp;deserialized the saved object ad load&nbsp;it into csla object. Oherwise it deletes the saved seralized file and retrieves a new one in the server.&nbsp;It was implemented with .NET&nbsp;Remoting.</P>
<P>But in your case, you want only to have the changes (updated/inserted/deleted), I'm not quite sure if it will be an efficient way. I suggest to use TCP/UDP and incorporate it with your application</P>
<P>When a user login and use the application, it saves the PC NAME or IP address (to a table named tblCustomeSessions) that are currently using the customer module. Create a trigger or incorporated in your stored procedure in database that everytme there is an update/edit/delete it will send a UDP&nbsp;message to the IP addresses that record ID 12345 - DELETED/INSERTED/UPDATED</P>
<P>The customer module then receives this message and try to parse the message for further action. if it was an insert/update it retrieves the record in the database and updates the collection only&nbsp;otherwise if it is deleted then it will only remove in the collection.</P>
<P>Cheers,</P>
<P>Glenn</P>
<P>P.S. I'll be delayed in my replies cause we are from different timezones.. ;-)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lakusha replied on Monday, May 08, 2006</h2><P>&nbsp;</P>
<P>What we do is a bit differently:</P>
<P>All tables have columns about the last update time and who did it (useful for many things like auditing and replicating with other systems).</P>
<P>The client application can ask for all records modified since its last cache update. 1 table maintain the max update timestamp for each cached table; you can keep it up to date easily if you are using stored procedures for your CRUD operations, or you could use triggers or even a materialized view. To minimize contention on that table, try not to update that table as part of a larger transaction; it should be a post-commit step. It is an atomic operation with no integrity dependency (meaning that updating without reason would not cause any problem other than forcing client apps to check for updated data).</P>
<P>With .NET 2.0 (in 2 tiers) you can also use ADO notification to know that an object has changed. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Monday, May 08, 2006</h2><P>Take a look ar this post from Andrés (a.k.a xal).&nbsp; It might be worth you time.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Monday, May 08, 2006</h2>It wasn't me!! I SWEAR!! :P <br>
Now seriously, what post!?<br>
<br>
I'm not sure I've ever posted anything on that subject, but anyway, here's what I think:<br>
<br>
Are you using a read only collection for this list? I hope you are...<br>
So, saving different items in that case would mean that you're using editable root objects (not collections), and that you edit / save them one at a time.<br><br>In that scenario, if it really is so critical to you that all your other clients recieve notification of this update, then you should consider having a service that your app can talk to. In there you could implement something like the observer petar created, but in a client server fashion, where you can trigger events in a "server channel". There is some complexity in <i>creating</i> all this, but it's not terrible. Using it should be as simple as one line of code. The big issue comes with implementation and clients requirements.... but that's a whole other subject...<br><br><br>Andrés<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, May 30, 2006</h2><P>I may be a little late to the topic, but here's my two cents nonetheless...</P>
<P>We have incorporated multi-level caching into a hybrid-CSLA framework.&nbsp; With our strategy, caching is handled within the DataPortal mechanism as an alternate data source for objects versus Activator.CreateInstance.&nbsp; Depending on how the specific application is setup, we have a switch to a) enable/disable caching altogether (when disabled&nbsp;it behaves just as the DataPortal is described in the books) and b) indicate if caching is done locally, remotely or both&nbsp;(on the client and/or on the app server).</P>
<P>If caching is enabled and intended to run locally (either local only or in conjunction with the app server), the client-side data portal will attempt to retrieve the object from the local cache before deferring the request to the data portal proxy.&nbsp; So, if the object exists in the local cache, you get the expected performance benefit and none of the data portal code executes.&nbsp; If it cannot find the object, it defers to the proxy.</P>
<P>If caching is to run remotely (or both and there is no local copy), the server-side data portal will likewise attempt to retrieve the object from the cache on the app server.&nbsp; Only if it is not found do we create a new instance of the object using Activator.CreateInstance and pull the data from the data store (DataPortal_Fetch).</P>
<P>On the flip side, when the object is created using Activator.CreateInstance and data pulled from the data source, before returning, the server-side data portal will check to see if a copy is supposed to be cached on the app server and, if so, will do just that.&nbsp; The same will be done by the client-side data portal so that under all possible configurations the object will be cached in its proper place.</P>
<P>The benefit of dual caching is realized with multi-user/multi-client applications.&nbsp; Under these scenarios the client application will be running on multiple physical boxes that are all accessing the same app server so the copy cached there will be retrieved by any of those clients that do not already possess a copy of their own.</P>
<P>Any time a change is made to the object and persisted to the data store (via the Save() method, for instance), the data portals know to update the cached copy accordingly.&nbsp; For new objects, the object is added to the cache where applicable, updated objects have their cached copies replaced with the new version and deleted objects are removed from cache.&nbsp; This eliminates any need for any bubbling up from the data store to make sure that we've updated the cached copies.</P>
<P>The expiration policies attached to each object are used to ensure that the data is as current as possible and only data that can safely be cached are handled this way.&nbsp; Typically we set shorter expiration periods for client-side caches and longer for server-side as the server-side copy will have been updated automatically whenever any other user applies a change to the object.&nbsp; When the client-side object has expired, it will be refreshed from the server-side cache.&nbsp; Under optimal conditions, the only time the data store is used is when changes are applied.&nbsp; For infrequently changing objects, this amounts to a significant performance gain.</P>
<P>We have a CacheAttribute that defines settings on a per object basis and our objects and collections have Refresh() methods which force the object to retrieve its data from the data store to update both the cached and in-memory copies of the object.</P>
<P>As far as tools, etc. - all of this is based on extending the CSLA framework and the caching features provided by the MS-Enterprise Application Blocks.&nbsp; As you can see, however, there is no provision to partially cache or partially update a cached object under this strategy.&nbsp; But, because it operates so transparent to the user (&amp; developer) and the overall performance gains outweight the hit when updating a few large data sets, we couldn't be any happier with the approach.</P>
<P>Hope this helps in some way.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick replied on Wednesday, May 31, 2006</h2><p><font size="3">Hi,<br><br>thanks for all the helpful responses. I like the idea very much 
from SonOfPirate to build a client and AppServer cache . It seems quite possible 
to connect this with the possibility to do partially updates. The client 
DataPortal could just send the dirty business entities back to the AppServer on 
Updates transparently.<br>And when a cached collection issues a refresh command 
it would be possible to just get the changed rows from the database (using 
Lakushas idea with a last changed column in each table). Each collection would 
have a field with the timestamp of the last time it was updated.<br><br>Thanks 
again<br>Patrick <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></font></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>marklindell replied on Tuesday, July 25, 2006</h2>That is an aggresive approach caching if you are attempting to update middle tier cache based from client requests.<br><br>This all works fine until you attempt to load balance your DataPortal.&nbsp; This goes against the "S" portion of CSLA and I would not recommend it.<br><br>Developing caching systems for updatable data is not a trivial task.&nbsp; Start with client-side read-only list caching before examining other senarios.<br><br><br>Mark Lindell<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick replied on Thursday, May 08, 2008</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I may be a little late to the topic, but here's my two cents nonetheless...We have incorporated multi-level caching into a hybrid-CSLA framework.&nbsp; <br></div></BLOCKQUOTE><br>I'm even later <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />... If you are still around the forum... It's still an interresting topic for me and so I would love to get in contact and chat about some of the details of your solution.<br><br>Thanks a lot,<br>Patrick<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tymberwyld replied on Sunday, July 30, 2006</h2>Hi, I may be a little late in this subject, but this actually has absolutely nothing to do with Caching.&nbsp; You can get the most current information from the database after saving a DataRow back to the database in ONE network round-trip.&nbsp; This all depends on what side the data is saved from (Client vs. Server).&nbsp; Here's how it's done:<br><br>1.)&nbsp; You need to setup a Stored Proc for saving you data.&nbsp; I typically do not create different Procs for "Insert" vs. "Update", I usually just create one "spSaveCustomer".&nbsp; Keep in mind that this Proc will be used for saving one Row only.&nbsp; At the very end of each Procedure you need to write, you'll place a select statement that returns the current data for the Row.&nbsp; In most of our designs, the Data is retrieved from a View on the Database, the Proc needs to update the table with info, and the the Proc returns the current info from the view for the current row being updated.<br><br>ex.&nbsp; Select * From vuCustomers Where ID = @ID<br><br>2.)&nbsp; You'll need to setup a DataAdapter for saving your Data into the Database.&nbsp; In the DataAdapter, your Insert and Update Commands will be exactly the save, so typically I initialize the InsertAdapter and then set the Adapter.UpdateCommand = Adapter.InsertCommand.&nbsp; These Commands will be of Type "StoredProcedure" and their CommandText will be your Stored Proc (i.e. spSaveCustomer).&nbsp; Next, you'll go through the process of setting up the Parameters for the command.&nbsp; We have this all built into our DAL so it's actually one line of code for all this...<br><br>3.)&nbsp; Here's the important part.&nbsp; The DataAdapter's Commands have a Property called "UpdatedRowSource".&nbsp; You'll want to set this to "FirstReturnedRecord".&nbsp; There are other options and by default it's set to "OutputParameters", but really, just doing Output Params is not enough in all scenarios.<br><br>this.dbAdapter.InsertCommand.UpdatedRowSource = UpdateRowSource.FirstReturnedRecord;<br>this.dbAdapter.UpdateCommand.UpdatedRowSource = UpdateRowSource.FirstReturnedRecord;<br><br><br>Now, you're all set.&nbsp; Becuase the "UpdatedRowSource" on your Commands is set to "FirstReturnedRecord" and the last line in the Procedure to run is "Select * From vuCustomers Where ID = @ID", you're DataRow will be auto-magically populated with the current info from the DB without and additional Round-Trip or even using the DataAdapter's "Fill" method again.<br><br>I hope this has helped...<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Sunday, July 30, 2006</h2><P>You have aptly described how the basic framework data classes, DataAdapter/DataSet, work and are absolutly correct that you can easily track which rows have been changed and take advantage of some of the automatic wiring within these objects.&nbsp; However, there are several boats that you've missed with this.</P>
<P>First, the point of the thread was an inquiry about using cache to reduce the number of round trips to the database.&nbsp; In particular, a Refresh function to update a large data set after changes are made to some of the items.</P>
<P>Second, the use of Mobile Business Objects which is contrary to using DataSets and DataAdapters, etc. as these objects work on collections and data "sets".&nbsp; MBO encapsulate all of the data access logic so that the individual objects manage themselves.</P>
<P>Third, the question is not how do we get the data to/from the data base or recognize what has changed, but what do we do with the changes and how do we refresh our local/client objects with the returned data.</P>
<P>While we have focused on and bantered how caching could be implemented to eliminate round-trips and network hops to retrieve data, we have lost sight on the real issue here.&nbsp; I will refer you to a number of other threads that hash out the subject of refresh given the data portal mechanism as provided by Rocky in CSLA.&nbsp; The issue that has led to these other threads as well as the basis for the original post is the need to be able to update the objects on the client to accurately reflect changes made to the database.</P>
<P>It seems to me that reviewing Patrick's original points may help boil this down:</P>
<UL>
<LI><FONT size=4>Lets say I would like to load a very big customers collection with their photos from the Data Portal via a Web Service.</FONT> 
<LI><FONT size=4>Now I change some of the customers on the client and save the changes. The client only sends back the changed customers to the Data Portal.</FONT>
<LI><FONT size=4>Now I would like to refresh the customer collection on the client but I would like the Data Portal to only send changed customers (updated, deleted, inserted) back and not all the customers again (to save bandwidth).</FONT></LI></UL>
<P><FONT size=3>It sounds to me like the question really has to do with refreshing the customer collection on the client.&nbsp; The reason for this is that using the CSLA framework, only those ITEMS that have been changed in some way are sent back to the database via the data portal (#2).&nbsp; This occurs, presumably when the customers collection's ApplyChanges (or whatever name) method is called.&nbsp; The behavior provided by CSLA is very much like what a DataSet does in that it iterates through its items (rows) and executes whatever operation is necessary on each object (if it's new: Insert; removed: Delete; modified: Update).&nbsp; This passes control of the actual operation to the individual objects and leads us to where the problem arises.</FONT></P>
<P>When we execute a data portal method, we end up with a second copy of our object in the data portal's return value.&nbsp; As a result, the customers collection hold references to our original, pre-data operation objects and somehow needs to be updated with the copies that were returned from the data portal.</P>
<P>As I mentioned, there are a number of other discussions on this topic that you may refer to for more discussion on this point.&nbsp; But, if you narrow the scope of this question down to what it is really about, we can focus on this same issue as the cause of our concerns.</P>
<P>There are many solutions proposed including Rocky's implementation where the collection should be updated to refer to the new object rather than the old - which is handled by the object itself once the new object is received from the data portal.&nbsp; However, our solution was to implement a protected virtual MergeWith method in our business objects that accepts an object of the same type as the owner.&nbsp; Using this method, we can "copy" whatever properties we need to from the return object into our original object and preserve all references to that object.&nbsp; We call this method from our data portal methods and pass the returned object as an argument.&nbsp; This approach has worked well for us.</P>
<P>A couple of additional thoughts.&nbsp; This only really matters if there is some new or different information contained in the returned object.&nbsp; This might be the value of an identity column, timestamp or something set as a result of logic in the stored procedure being used for the operation.&nbsp; If this is not the case, then the original collection is up-to-date and doesn't need to be refreshed.</P>
<P>The subject of caching, which has shrouded the real issue here, is still valid and can still be used to reduce the amount of network traffic required for the application.&nbsp; We implement caching on our fetch methods to optionally retrieve the requested item(s) from the cache rather than requiring a round-trip to the database.&nbsp; We automatically update the cached copy of the object(s) whenever we apply an Insert, Update or Delete operation.&nbsp; As a result, our cached copy will be concurrent with the database&nbsp;- which is the goal.</P>
<P>Finally, it is my personal opinion that having a SELECT * statement at the end of your Insert/Update procedure is adding undo network traffic rather than reducing it.&nbsp; If you have a large table or a large view with many columns this will be returning a lot of data that you already have.&nbsp; My suggestion is to limit this statement to only return columns that have been affected by the procedure.&nbsp; In our case, we have a datetime field for concurrency checks that is automatically updated by the sproc everytime a record is updated.&nbsp; This is the only value that is returned (by default) from our Insert &amp; Update procedures.&nbsp; Our base class implementation of MergeWith(...) copies the returned value to the local object so it remain concurrent with the database.</P>
<P>You can certainly do it the way that tymberwyld has described, but as is said above, you will have to deal with DataAdapters, etc. for this approach.</P>
<P>I certainly hope that clears things up for everyone and helps in some way.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tymberwyld replied on Monday, July 31, 2006</h2>All your points are valid.&nbsp; I probably didn't explain well enough.&nbsp; My suggestion was not so much for caching (which would be addressed in a different way - DataCachingBlock from MS?&nbsp; which each "cache" can have a Timeout to determine when it needs refreshed again?).&nbsp; I was just trying to suggest another way to reduce round-trips.&nbsp; I now understand that the original question is returning "ALL Customers that have changed since he last retrieved data".&nbsp; In this scenario he'd have to store a current date everytime he retrieved data and then get all Customers that have a modified date &gt;= last retrieved date.<br><br>More or less, I was trying to explain that retrieving a new copy of the data from the Database is easy to do with the built in ADO.NET functionality.&nbsp; What I didn't go in-dept about is how we manage concurrency checking within the Stored Proc.&nbsp; Yes, we use a ModifiedDate and we pass-in Current AND Original values of the data for concurrency checking so that conflicts can be Merged as much as possible before a "true" data conflict occurs.&nbsp; Having the additional "Select * From..." at the end of the Procedure will not cause that much of a performance hit when you're retrieving one record and also you've added a "Set NOCOUNT On" call at the begining of the procedure (which you should be using in every Proc becuase if not, you're causing unnecessary network traffic anyway).&nbsp; <br><br>Also, the reason for doing this may be that the View that the data is being retrieved from may have a Computed / Calculated column that would just be too difficult to implement in a custom business object's property.&nbsp; Say for example a Property changes on your object that then causes the need for another property to be updated.&nbsp; For example, I change the First Name of a Contact and now the "ContactFullName" Property needs to be refreshed.&nbsp; This is a simple example but there are others where a Computed column in a view may come from a totally different table or even another database.&nbsp; I don't want that kind of logic in a BO.<br><br>Also, the other reason for implementing the "FirstReturnedRecord" vs. only "OutputParameters" is that I've personally had situations where the Output params did NOT get updated and after reviewing the T-SQL for hours I could find nothing wrong with it.<br><br>This all comes down to 2 implementations:<br>&nbsp;&nbsp;&nbsp; 1.)&nbsp; Have the Stored proc return a refreshed copy of the database<br>&nbsp;&nbsp;&nbsp; 2.)&nbsp; Issue the Insert / Update and then retrieve the updated rows in another Select command.&nbsp; Which means you not only have to wait for the Insert / Update to finish, but also the Select / re-population of buisness objects..<br><br>This all just keeps re-affirming why I don't like BO's.&nbsp; Having a strongly-typed DataTable with custom business logic built in is much better (no need to repopulate other objects, the Strongly-Typed DataRow IS the object).<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, July 31, 2006</h2><P>I agree with your approach with the understanding that we all have subtle nuances to the way we implement the same concepts. You accurately state that this approach uses the built-in ADO.NET features and there is certainly nothing wrong with that. However, you are posting to a forum for and about CSLA which is ALL about BO’s and how to follow a different approach than using the built-in ADO.NET stuff.</P>
<P>I don’t know if you’ve read the book and certainly won’t assert that you haven’t, but Rocky does do a tremendous job of explaining all of the “why’s” for this approach. And while I have not implemented everything the way he has (those subtle nuances), I can’t argue that his reasoning is solid when backed up with thorough explanation most of the time.</P>
<P>All of that being said, again, there is nothing wrong with using the tools built-in and supplied by Microsoft. And, if they are serving your needs, that is great. But, as I said, remember where you are posting and that most users in this forum are not using straight-up ADO.NET for their applications and are making extensive use of BO’s to serve their needs.</P>
<P>Thanks for sharing nonetheless.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
