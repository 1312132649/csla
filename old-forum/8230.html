<html><header><title>Why is Dataportal_Create an override while other Dataportal_XYZ are not ?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Why is Dataportal_Create an override while other Dataportal_XYZ are not ?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8230.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lukky posted on Tuesday, December 29, 2009</h2>Hi Rocky,<br /><br />I was watching CSLA Core video #3 at about 44:00 minutes, and it fell on me that Dataportal_Create is implemented in the BO as an override, while all other Dataport_XYZ are not.<br /><br />I had never noticed it since I use a code generator and never had to code a BO manually. The templates I use do follow this pattern, I just never noticed.<br /><br />The question is why the different approach for Create ? I've looked in the book, but it doesn't seem to be explained.<br /><br />Thanks<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, December 29, 2009</h2><P>In the early days of CSLA (pre 2005) the data portal only had one method signature for each DP_XYZ method - and they all took parameters of type object.</P>
<P>Starting with CSLA .NET 2.0, the data portal got a lot smarter, and implements method overloading, so your DP_XYZ methods are strongly typed and you can overload them. I think that was a huge improvement.</P>
<P>But in the 1.x days I'd implemented protected methods for the only set of valid signatures to make it easier, and I didn't remove them because I didn't want to break existing code.</P>
<P>I think that was a mistake, because it leads to confusion. On the other hand, DP_Create is a special case, because 90% of the time people don't implement it, and so having a base implementation is actually useful.</P>
<P>So in 4.0 I may very well remove the protected virtual DP_Fetch/Update/Insert/etc - but I'll probably still leave DP_Create because it is actually useful.</P>
<P>Or in 4.0 I may just leave it all alone, because the confusion isn't <EM>that</EM> great, and backward compatibility is terribly nice.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Tuesday, December 29, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><br /><P>But in the 1.x days I'd implemented protected methods for the only set of valid signatures to make it easier, and I didn't remove them because I didn't want to break existing code.</P><br /><P>I think that was a mistake, because it leads to confusion.</P><br /></div></BLOCKQUOTE><br /><br />No doubt, I totally agree with you, it was a mistake to keep them :)<br /><br /><br /><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><br /><P>So in 4.0 I may very well remove the protected virtual DP_Fetch/Update/Insert/etc - but I'll probably still leave DP_Create because it is actually useful.</P><br /></div></BLOCKQUOTE><br /><br />Yes, *PLEASE* remove them and avoid the confusion. And when I when I say remove them I mean *ALL* of them. This way we will be consistent in a manner that if a user doesn’t implement a needed DataPortal_XYZ, the CSLA will throw an error for all of them and not just some.<br /><br />I would personally prefer to have a class level attribute that was something like [UseDefaultDataPortalCreate] for the class to use a predefine pluming... And yes, I realize that nobody will like it and even if they did the effort to add that feature is not worth it and blah, blah it but I wanted to express my opinion anyway :)<br /><br /><br /><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><br /><P>Or in 4.0 I may just leave it all alone, because the confusion isn't <EM>that</EM> great, and backward compatibility is terribly nice.</P><br /></div></BLOCKQUOTE><br /><br />Now what makes you think that the confusion isn’t <EM>that</EM> great Rocky? I had the same question for a while only I never care to post the question because I figured that the reason why that was left like that was due to the worst thing that could happen to software development and humanity known as “backward compatibility” or should we say “awkward compatibility”?<br /><br />Changing things may break “backward compatibility” but it won’t break “feature compatibility”, people will still be able to accomplish the same thing if you where to remove the DataPortal_XYZ methods, all they will have to do is to implement it manually. Big deal, copy and paste, get over it.<br /><br /><br />And yes Andy, I know I am not the only one using the CSLA ;)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, December 29, 2009</h2><P>Since the base DataPortal_Create() actually does something real, removing it seems wrong. Any base method that actually does something should remain in the base, and should (maybe) be virtual.</P>
<P>The other DP_XYZ methods in the base don't do anything - they just throw exceptions. That has no value any longer (and hasn't since 2.0), so removing them is clean-up work.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 30, 2009</h2>Ya, I'd like to see the Create stay.&nbsp; In the cases where you don't need to initialize everything (which I imagine is fairly common), the default implementation makes sense, and removing it would just create a lot of busy non-productive work for everyone.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lukky replied on Wednesday, December 30, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><P>Since the base DataPortal_Create() actually does something real, removing it seems wrong. Any base method that actually does something should remain in the base, and should (maybe) be virtual.</P><br /><P>The other DP_XYZ methods in the base don't do anything - they just throw exceptions. That has no value any longer (and hasn't since 2.0), so removing them is clean-up work.</P></div></BLOCKQUOTE><br /><br />Rocky,<br /><br />Correct me if I'm wrong, but the only thing that the base implementation of Dataportal_Create does is call ValidationRules.CheckRules().<br /><br />Couldn't this be done by the Dataportal itself, just like calling MarkOld() in Dataportal.Fetch() ?<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, December 30, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>lukky:</strong></div><div></P>
<P>[...] the only thing that the base implementation of Dataportal_Create does is call ValidationRules.CheckRules(). Couldn't this be done by the Dataportal itself, just like calling MarkOld() in Dataportal.Fetch() ?</div></BLOCKQUOTE></P>
<P>That's true, and that is a valid point.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 30, 2009</h2><P>Is there a case where someone wouldn't want the rules to run though?&nbsp; As it is, you can override and do nothing.&nbsp; If moved, you'd lose that ability.&nbsp; Of course maybe that's not an issue.&nbsp;</P>
<P>Although I do have some code where in the&nbsp;Create or Fetch, I set a flag prior to calling ValidationRules.CheckRules, so that some rules don't process in those methods, because they should only run in response to the user changing properties.&nbsp; That could screw me up..</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lukky replied on Wednesday, December 30, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><P>Is there a case where someone wouldn't want the rules to run though?&#160; As it is, you can override and do nothing.&#160; If moved, you'd lose that ability.&#160; Of course maybe that's not an issue.&#160;</P><br /><P>Although I do have some code where in the&#160;Create or Fetch, I set a flag prior to calling ValidationRules.CheckRules, so that some rules don't process in those methods, because they should only run in response to the user changing properties.&#160; That could screw me up..</P></div></BLOCKQUOTE><br /><br />That is a valid point. In any case, I'm not really advocating a change right now. My only concern was that I didn't understand the reason behind having DP_C be different than the other DP_XYZ methods.<br /><br />Now that I understand the reason behind it, it doesn't puzzle me. The thing is though, new users will probably have to go through the same questionning over and over. In this case, it might be more elegant to have a pattern that exposes more clearly the intention.<br /><br />For example, Dataportal.Create() could have an overload with a boolean flag to indicate whether to execute validation rules or not. The default parameterless method simply calling it with "true". I don't know. What do you think ?<br /><br />On the other hand, I wouldn't mind having to manually call ValidationRules.CheckRules in DP_C, just as I have to in DP_F. This would standardise the way we have to write our DP_XYZ methods. <br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 30, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>lukky:</strong></div><div>That is a valid point. In any case, I'm not really advocating a change right now. My only concern was that I didn't understand the reason behind having DP_C be different than the other DP_XYZ methods. Now that I understand the reason behind it, it doesn't puzzle me. The thing is though, new users will probably have to go through the same questionning over and over. In this case, it might be more elegant to have a pattern that exposes more clearly the intention. For example, Dataportal.Create() could have an overload with a boolean flag to indicate whether to execute validation rules or not. The default parameterless method simply calling it with "true". I don't know. What do you think ? </div></BLOCKQUOTE></P>
<P>That wouldn't help me; its not that I don't want rules to run, its that I don't want SOME rules to run.&nbsp; So the rules which are validation always run, but the other rules check that flag (which is only set during the Create or Fetch methods).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Wednesday, December 30, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>lukky:</strong></div><div><br />Correct me if I'm wrong, but the only thing that the base implementation of Dataportal_Create does is call ValidationRules.CheckRules().<br /></div></BLOCKQUOTE><br /><br />Thats not the only thing that the default Dataportal_Create method does, it also instructs CSLA to run the method locally [RunLocal]. I believe that if you don't have that attribute there the CSLA will make a call to the server for nothing (of course this may only really matter if you have the server on different physical tier).<br /><br /><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><br />the default implementation makes sense, and removing it would just create a lot of busy non-productive work for everyone.<br /></div></BLOCKQUOTE><br /><br />Andy,<br /><br />It is NOT non-productive work for everyone. The key here is that we will have consistency on how all the DataPortal_XYZ behave. Inconsistence is the root of all evil.<br /><br />You and I and a handful or other people may know exactly whats going on behind the scenes but PLEASE CONSIDER the people that are new to the CSLA. <br /><br />Yes, I agree that is kind of awkward to have to include a method that does nothing or some method that its just pluming but it is also awkward to have automagical code doing things behind your back that you are not aware of until you run into an issue and spend 2 hour trying to figure the issue out.<br /><br />As I have stated before, my main motivation for some of this changes is to try to make it easier for new people adopting the CSLA to get up to speed and have it easier, I am not just trying to piss people off. I already know the stuff, if it was just about me I could not care less if thing changed or not.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, December 30, 2009</h2><P><FONT face=Tahoma size=2>Andy can certainly step in and tell me if I'm wrong, but I believe his "non-productive work" comment relates to your apparent distaste for the concept of "backwards compatability" - namely, that you seem to be standing&nbsp;up and shouting that backwards compatability is a terrible concept that should be summarily abandoned.</FONT></P>
<P><FONT face=Tahoma size=2>(I also don't happen to agree with your "inconsistency is the root of all evil" comment, but that's a different discussion.)</FONT></P>
<P><FONT face=Tahoma size=2>This is the rock upon which you will split with a lot of developers.&nbsp; Forcing me to go back and change code that is&nbsp;already working&nbsp;in a production environment just because you don't happen to like&nbsp;a method&nbsp;signature is quite frankly asking a lot.&nbsp; You're telling me that I have to go in and potentially introduce an error in code to "fix" something that is already working - and&nbsp;that <EM>gains me nothing in doing so.</EM>&nbsp; Sure, I might save a developer down the road some maintenance time because they might not have to scratch their head and wonder what's going on.&nbsp; But all that code changing, testing, and pushing&nbsp;to production that I would have to do to my entire CSLA-based codebase in order to conform to "the new rules" is time I have to spend that does not move my projects forward one inch, as far as my customers are concerned.</FONT></P>
<P><FONT face=Tahoma size=2>And yes, I realize that there's nothing forcing me to move to a new version of the framework.&nbsp; I could happily continue in my world with whatever version I'm on, dealing with all the inconsistencies/issues/etc. that exist there.&nbsp; But code that stays stagnant is eventually replaced, becomes unsupported, or any of a hundred other possibilities that makes my life harder.&nbsp; I cannot bury my head forever.</FONT></P>
<P><FONT face=Tahoma size=2>We all realize that upgrading to a new version of something can take time, and usually our customers understand that as well.&nbsp; And I have nothing against cleaning up an API.&nbsp; But the easier the transition to the new API is, the better it's going to go.&nbsp; Backwards compatability is not the most important concept in developing a framework - but it's still an important&nbsp;one.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lukky replied on Wednesday, December 30, 2009</h2>I'm a bit humbled to see all the buzz around my question :-)<br /><br />While I do understand the need to preserve existing code base, I think it raises the question if we should maintain backward compatibility forever and a day.<br /><br />With the coming release of CSLA.NET 4.0, I see a great opportunity to clean up the API. Let's face, whether we want it or not, 4.0 is going to introduce breaking changes. Let's just consider the splitting of the collections between WinForms and WPF/Silverlight, and I'm sure that'll introduce breaking changes.<br /><br />Would it be that bad to have a fresh start ? I see 4.0 as a major release, one that will probably tie Rocky's hands for many years. Shouldn't we welcome the opportunity ?<br /><br />Just my $0.02 :-)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 30, 2009</h2><P>I think Scott summed up the argument pretty well.</P>
<P>And for those of us that have been with Csla for a while, I don't think any of us are against breaking changes, so long as those changes get us something good in return.&nbsp; There have been a number of times a breaking change is proposed, everyone knew it would be painful, but the gain was deemed well worth it.</P>
<P>A slightly cleaner API, which only benefits you at the start of learning Csla, well, there are other things I'd rather Rocky focus on.&nbsp; Especially when this particular issue is easily solved by using the material that's out there.&nbsp; Its one of the things you learn when you learn Csla; you&nbsp;learn how to create&nbsp;DataPortal_xyz methods, via the book or videos.&nbsp; </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil replied on Wednesday, December 30, 2009</h2>Interesting discussion.<br />It has confused me a bit though because in the 3.8.1 Templates section the EditableRoot.cs has this code:<br /><br />    protected override void DataPortal_Create()<br />    {<br />      // TODO: load default values<br />      // omit this override if you have no defaults to set<br />      base.DataPortal_Create();<br />    }<br /><br />    private void DataPortal_Fetch(SingleCriteria criteria)<br />    {<br />      // TODO: load values<br />    }<br /><br />    [Transactional(TransactionalTypes.TransactionScope)]<br />    protected override void DataPortal_Insert()<br />    {<br />      // TODO: insert values<br />    }<br /><br />    [Transactional(TransactionalTypes.TransactionScope)]<br />    protected override void DataPortal_Update()<br />    {<br />      // TODO: update values<br />    }<br /><br />    [Transactional(TransactionalTypes.TransactionScope)]<br />    protected override void DataPortal_DeleteSelf()<br />    {<br />      DataPortal_Delete(new SingleCriteria(this.Id));<br />    }<br /><br />    [Transactional(TransactionalTypes.TransactionScope)]<br />    private void DataPortal_Delete(SingleCriteria criteria)<br />    {<br />      // TODO: delete values<br />    }<br /><br /><br />As you can see, the DataPortal_Update, Insert, and DeleteSelf all use the override.  Is the template incorrect?  What am I missing here?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Wednesday, December 30, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><br />Forcing me to go back and change code that is&#160;already working&#160;in a production environment just because you don't happen to like&#160;a method&#160;signature is quite frankly asking a lot.&#160; You're telling me that I have to go in and potentially introduce an error in code to "fix" something that is already working - and&#160;that gains me nothing in doing so.<br /></div></BLOCKQUOTE><br /><br />I never said to make a change just because “I don’t like a method signature”, my argument for the change was to gain consistency and therefore potentially making the CSLA code easier to understand. For you that may mean very little, for me that is gold.<br /><br />Also note that I would not want these type of changes done from within minor CSLA version, this types of changes could fit very well when going from CSLA 1.0 to 2.0 to 3.0 to 4.0 etc.<br /><br /><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><br />Backwards compatability is not the most important concept in developing a framework - but it's still an important one<br /></div></BLOCKQUOTE><br /><br />And I agree with you, thats why I made a distinction before between my *personal* definitions of "backwards compatibility" and "feature compatibility". If Rocky was to decide to no longer support DataPortal_XYZs and totally removed the methods from the framework AS WELL as no longer support that concept then I would consider that to break "backward compatibility". Bu that is not really the case here is it?, I mean, things would remain the same and the concept would still be supported with the exception that now you would have to make a *minor* code change and to me that is preserving "feature compatibility" which is what I believe its whats most important....... Ok, yes I get it, I get it, it still breaking "backwards compatibility" but I hope I did a good enough job to get my point across.<br /><br />Also note that this is not the only place where the CSLA exhibits inconsistent/awkward behavior due to backward compatibility, too many of those and things  can start to get complicated.<br /><br /><br />Listen guys, I do understand where you guys are coming from, I do respect your opinion, but like lukky said it, this is a great opportunity to move forward an make things better (assuming changes like this are really improvements), why not embrace it?<br /><br />And by the way, for all of those that said the Rockys time would be best off spent implementing new feature, I would ask Rocky a simple question, how much time do you spend dealing with backward compatibility issues while supporting the code? I bet it must be significant, such time could be spent doing those new and worthy improvement. Also, how ofter have you had to settle for a mediocre implementation of a feature for the sake of preserving backwards compatibility?<br /><br />Thank you.<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, December 30, 2009</h2>Yeah, I still tend to think it is best to leverage the power of OOP rather than relying overmuch on data portal magic.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
