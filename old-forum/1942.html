<html><header><title>Authentication problems in web app</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Authentication problems in web app</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1942.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Monday, December 11, 2006</h2><P>We are in the process of implementing a form of integrated security in our web app where we rely on the default IIS authentication ("Windows") to verify the user's credentials on the network then attempt to match-up the IIS-authenticated user against a list of valid users for the application.&nbsp; When validated for the application, we are able to retrieve the appropriate group membership, roles, rights, etc. (semantics) for that user and we return a populated IPrincipal object.</P>
<P>We have put the following code into the Global.asax file.&nbsp; It is slightly different from what is in the book because we are not using Forms Authentication.&nbsp; Instead, as I mentioned, we rely on IIS to pre-authenticate the user then perform our custom authentication to complete validate the user.&nbsp; If the user passes the IIS test but is not found in our database (i.e. they are a valid user on the network but not setup in the application), we set the current user to an unauthenticated user (Guest).</P>
<P>In Global.asax:</P>
<P><CODE>protected void Application_AcquireRequestState(object sender, EventArgs e)<BR>{<BR>&nbsp; &nbsp; System.Security.Principal.IPrincipal principal;<BR>&nbsp;<BR>&nbsp; &nbsp; try<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; principal = (System.Security.Principal.IPrincipal)HttpContext.Current.Session["CurrentPrincipal"]'<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; catch<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; principal = null;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; if (principal == null)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (!SecurityManager.Authenticate())<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SecurityManager.Logout();<BR>&nbsp; &nbsp; &nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; HttpContext.Current.Session["CurrentPrincipal"] = ApplicationContext.User;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; ApplicationContext.User = principal;<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>This works great initially but ends up running about 6 times before the page actually loads and only the first call has a valid Session.&nbsp;&nbsp;To prevent the Null exceptions, we added a condition at the beginning to ensure that HttpContext.Current and HttpContext.Current.Session are not null.&nbsp; But, in the end the HttpContext.Current.User is reset on us by IIS so we end up getting&nbsp;the IIS authenticated user and our custom portion&nbsp;is ignored.&nbsp; This was verified by accessing the page using an authenticated network user that was not setup in our application.&nbsp; As expected, the first pass correctly attempted to authenticate the user, failed and&nbsp;saved our Guest user into Session.&nbsp; But, none of the additional calls could retrieve this value from Session because they always failed the null condition and our application wound up making use of the "unauthenticated" IIS-supplied user instead.</P>
<P>Any ideas where this is going wrong?&nbsp; Why is the AcquireRequestState event occurring multiple times?&nbsp; Suggestions how to remedy?</P>
<P>Thx in advance.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, December 12, 2006</h2><P>Pirate,</P>
<P>When I upgraded from ASP.NET 1.1 to 2.0 I ran into the same issue regarding extra firings of Global_AcquireRequestState. I always had 2 of them in 1.1 but now I have 3 of them. The 3rd one fails to contain the Session object so I added the same trap at the top to bail out when Session is Nothing.</P>
<P>My web app is capable of using Forms authentication and Windows authentication. It was not a very simple solution but it seems to do what you are asking about. For Windows, we get the token from IIS and read the username and split it into Domain and User strings. These credentials must exist in our DB - we use them to grab the unique UID in our DB (and skip the password because Windows handled it already) and then log the user in and give them a cookie.</P>
<P>We got a lot of good ideas from this article:</P>
<P><A href="http://15seconds.com/issue/050203.htm">http://15seconds.com/issue/050203.htm</A></P>
<P>The key idea is that the ExternalAuthentication virtual directory needs to be under the main app virtual directory. It looks like you are trying to both things from the same virtual.</P>
<P>(If it was an easy setup I would post some code - but it is a rather ugly mess under the hood.)</P>
<P>Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, December 12, 2006</h2><P>Yea, I just came back online because I found the following blog article on the subject:</P>
<P><A href="http://blogs.msdn.com/praveeny/archive/2006/11/26/asp-net-2-0-acquirerequeststate-fires-multiple-times.aspx">http://blogs.msdn.com/praveeny/archive/2006/11/26/asp-net-2-0-acquirerequeststate-fires-multiple-times.aspx</A></P>
<P>The article you mentioned does have some great content as well.</P>
<P>Turns out, or at least it appears, that the AcquireRequestState is fired for each resource that is requested from the server.&nbsp; So, if you have embedded resources, javascript files, images (?), css (?), etc. this event will fire again.</P>
<P>What I don't understand - and maybe it is because of the different handlers used to process the different resources - is why Session is available only to the first request.&nbsp; It is obvious that the HttpContext is reset between requests but since we can't get access to Session, there is no way to reset the current principal; therefore, when we get around to asking to the current user, we get the WindowsPrincipal instead of our custom one.</P>
<P>So, my thoughts are to move the login logic to another event but I'm not sure what would be appropriate.&nbsp; Anyone who may know better, please advise.</P>
<P>Frankly, though, I am surprised no one else has run into this.&nbsp; It sounds like the multiple executions is prevalent based on what triggers it.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RobKraft replied on Friday, March 30, 2007</h2><P>I found the following blog that gives a little more insight into what is happening; and we&nbsp;implemented the solution they recommend with success:</P>
<P><FONT color=#008000 size=2><A href="http://blogs.msdn.com/praveeny/archive/2006/11/26/asp-net-2-0-acquirerequeststate-fires-multiple-times.aspx">http://blogs.msdn.com/praveeny/archive/2006/11/26/asp-net-2-0-acquirerequeststate-fires-multiple-times.aspx</A></P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>if</FONT><FONT size=2> (</FONT><FONT color=#2b91af size=2>HttpContext</FONT><FONT size=2>.Current.Request.Url.AbsoluteUri.Contains(</FONT><FONT color=#a31515 size=2>".axd"</FONT><FONT size=2>))</P>
<P>{</P>
<P></FONT><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;return</FONT><FONT size=2>;</P>
<P>}</P></FONT></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
