<html><header><title>ReadOnlyBase and WCF</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ReadOnlyBase and WCF</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6899.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rcollette posted on Tuesday, May 05, 2009</h2>I was trying to return a ReadOnlyBase object as part of a WCF JSON service and realized that my properties cannot be readonly for WCF to work.<br><br>From Rocky's book, I understand the philosophy that BusinessObjects should be copied to WCF specific objects (DTOs?).&nbsp; I understand the reasoning for doing so.<br><br>Regardless of the philosophy, how is it that DataPortal is capable of transferring a ReadOnlyBase using WCF whereas I am not?&nbsp; I know, I should trace it but don't have time to set up a test case at the moment.<br><br>At the moment, I am making the properties read and write and throwing a not suppported execption in the setter.&nbsp; I know someone is going to have issue with that but until something more elegant is presented, that is where I am at.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 05, 2009</h2><P>The data portal uses a different serializer that is designed for rich client/server communication, not contract-based public service communication.</P>
<P>The data portal uses either the BinaryFormatter or the NetDataContractSerializer (depending on technology and configuration choices on your part). Both of these serializers work at the field level, not the property level, and are capable of serializing compex .NET types that can't necessarily be represented by SOAP or JSON.</P>
<P>The XmlSerializer, DataContractSerializer, JsonDataContractSerializer and all the similar variants are absolutely not designed for the rich communciation model required by the data portal. They are all designed to support public contract-based interface models, which is an entirely different scenario from the data portal.</P>
<P>You will really regret exposing your business objects through a public contract-based interface, and I strongly recommend you do the right thing as I discuss in Chapter 21. Obviously it is your choice - I'm just making sure I'm in a position to say "I told you so" when it fails later :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rcollette replied on Tuesday, May 05, 2009</h2>Now I understand what is going on.&nbsp; And thank you for the prompt response!&nbsp;&nbsp; <br><br>So if the object is only going to be used to return read only data to a client via JSON, perhaps I should not be constructing a BusinessObject at all.&nbsp; In this particular scenario I am not using any of the features of a BO and the purpose is more just a DTO.<br><br>I realize that by implementing a BO, I give myself the option in the future of doing data binding in another client type perhaps.&nbsp; However, one of the design priniciples I've come across is not to implement unused functionality.&nbsp; In this case I would be contructing a BO and a DTO when a simple DTO would suffice.<br><br>Code to requirements vs future proofing.&nbsp; Which does experience tell you to lean towards?&nbsp;&nbsp; I know this is a situation I would have to be able to justify to peers.<br><br>Finally, is there a list or easy way to tell which CSLA.NET objects are serializable via DataContractSerializer and variants thereof and which are not?&nbsp; I was able to pass a NameValueList to the CascadingDropDown ms ajax toolkit control no problem but I am finding that ReadOnlyBase does not serialize, resulting in the error:<br><br>'Csla.Core.FieldManager.FieldData`1[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' with data contract name 'FieldDataOfstring:http://schemas.datacontract.org/2004/07/Csla.Core.FieldManager' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer.'.<br><br>I have a feeling I am going to have a proliferation&nbsp; BO-DTO mappings when implementing a primarily AJAX client.&nbsp;&nbsp; Is the unneasy feeling I have about that unjustified?<br><br><br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rcollette replied on Wednesday, May 06, 2009</h2>I tried the following in terms of creating a "lightweight" DTO and it seems to work well.<br><br>Extract an interface from the BO<br>Create a service specific DTO that implements the interface<br>Pass in the BO to the constructor of the DTO and store in a member variable<br>Delegate the properties in the DTO to the BO<br><br>This way, I am only allocating a single object reference for each BO within the DTO and WCF doesn't complain about any non-serializable members.&nbsp; Still a bit of work especially if you have a deep object hierarchy but at least this way it's not doing a ton of memory allocation and data copying to construct the DTOs.<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
