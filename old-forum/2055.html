<html><header><title>WPF DataModel for CSLA?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>WPF DataModel for CSLA?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2055.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Dirk.Rombauts posted on Sunday, December 31, 2006</h2><P>I read the CSLA.NET 2.0 book (C# version) some six months ago, and now I started reading it again in preparation of finally getting my hands dirty with Csla.</P>
<P>I have also been immersing myself into WPF, specifically by reading Petzold's book and trying out the archticture proposed by Dan Crevier (<A href="http://blogs.msdn.com/dancre/archive/2006/10/11/datamodel-view-viewmodel-pattern-series.aspx">http://blogs.msdn.com/dancre/archive/2006/10/11/datamodel-view-viewmodel-pattern-series.aspx</A>).&nbsp; One comment Dan makes when talking about the DataModel is "When data is expensive to fetch, it abstracts away the expensive operations, never blocking the UI thread (that is evil!)".</P>
<P>At first sight, CSLA objects seem perfect as DataModels: they implement INotifyPropertyChanged, and a lot more besides. But: if I understand CSLA correctly, everything runs synchronously on the main (UI) thread by default.&nbsp; If I understand CSLA correctly, there's nothing in CSLA that enables me to perform expensive operations (like network hops) asynchronously.</P>
<P>For Windows Forms 2.0, it's of course possible to use the Background Worker component.&nbsp; For ASP.NET 2.0, it's possible to use asynchronous pages.&nbsp; Both techniques prevent blocking the UI thread, be it Windows Forms UI or the ASP.NET working process thread pool.&nbsp; But now we have WPF, and as far as I know, there's no Background Worker component/class/whatever for WPF.</P>
<P>Since Dan Crevier specifically states "All of [the DataModel's] public APIs must be called on the UI thread only", I'm forced to make a decision here.</P>
<P>Alternative 1): use CSLA objects as DataModel on the UI thread, and live with the fact that I block the UI thread.&nbsp; This is a big trade-off, because there's a lot going on behind the scenes with Dependency Properties and the like. So my assumption is that blocking the UI thread in WPF is a far worse offense than in WinForms.</P>
<P>Alternative 2): use CSLA objects on a background thread, and hope WPF figures out the databinding across threads.&nbsp; This would blatantly disregard Dan's statement about public API on the UI thread.</P>
<P>Alternative 3): Implement a proxy class for each CSLA object I want to use, abstracting away expensive operations and such.&nbsp; This would have the advantage of being able to convert all properties to dependency properties.&nbsp; But it has the same huge disadvantages of the "Class in Charge" pattern.&nbsp; Even with a generator, this would be a non-trivial thing to implement.</P>
<P>Alternative 4): Create a DataModel&lt;T&gt; where T : BusinessBase&lt;T&gt; that exposes a property "Entity" of type BusinessBase&lt;T&gt; with our business object.&nbsp; DataModel&lt;T&gt; would then call the "expensive" operations on a background thread.&nbsp; WPF Databinding should then prefix all path strings with "Entity".</P>
<P>Alternative 4 seems like the lesser evil to me.</P>
<P>Have you encountered such a situation?&nbsp; Do you see any other alternatives?&nbsp; What did or would you do?&nbsp; Thanks!</P>
<P><BR>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Paul Czywczynski replied on Sunday, December 31, 2006</h2>Here is some basic code we prototyped with. It covers async databinding and saving. We're binding to plain 'ol CSLA business objects.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Details_DataBind()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp; (PageJournal.Current.PrimaryKey != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (_odp.DeferRefresh())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _odp.ObjectType = typeof(EmployeeDetails);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _odp.MethodName = "GetEmployeeDetails";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _odp.IsAsynchronous = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _odp.DataChanged += new EventHandler(_odp_DataChanged);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.MainGrid.DataContext = _odp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void _odp_DataChanged(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_odp.Error != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw _odp.Error;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Save()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BackgroundWorker bwSave = new BackgroundWorker();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bwSave.DoWork += new DoWorkEventHandler(bwSave_DoWork);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bwSave.RunWorkerCompleted += new RunWorkerCompletedEventHandler(bwSave_RunWorkerCompleted);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bwSave.RunWorkerAsync();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void bwSave_DoWork(object sender, DoWorkEventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (StatusBusy busy = new StatusBusy("Saving..."))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get business object from data provider<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EmployeeDetails data = (EmployeeDetails)_odp.Data;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // validate that there are no broken rules<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data.BrokenRulesCollection.Count &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(data.BrokenRulesCollection.ToString());<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data.IsSavable)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EmployeeDetails temp = data.Clone();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp.ApplyEdit();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = temp.Save();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _odp.Refresh();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Csla.DataPortalException ex)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(ex.BusinessException.ToString(), "Error saving", MessageBoxButton.OK, MessageBoxImage.Exclamation);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void bwSave_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw e.Error;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Dirk.Rombauts replied on Monday, January 01, 2007</h2><P>Thanks for your reply.&nbsp; I have a couple of questions, though.</P>
<P>What exactly is _odp?&nbsp; A CSLA object? (but then, where does "IsAsynchronous" come from?)&nbsp; A custom object?</P>
<P>_odp serves as datacontext for the MainGrid.&nbsp; That means all its public API should be called on the UI thread.&nbsp; Yet you call _odp.Refresh() in bwSave_DoWork, which is called on a different thread.&nbsp; Or does _odp.Refresh automatically invoke itself on the UI thread if needed?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Paul Czywczynski replied on Monday, January 01, 2007</h2>Sorry, I forgot to post the declaration of _odp.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private ObjectDataProvider _odp = new ObjectDataProvider();<br><br>The ObjectDataProvider automatically checks which thead it is on and will invoke across threads if it needs to. We prefer to use it because it is so much easier to use across threads because we don't need to think about it.<br><br>http://www.beacosta.com/2006/03/why-should-i-use-objectdataprovider.html<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Dirk.Rombauts replied on Tuesday, January 02, 2007</h2><P>Great.</P>
<P>To summarize: when using the ObjectDataProvider, I sort of get the combined benefits of Windows Forms's BackGroundWorker and Object Binding.&nbsp; ObjectDataProvider can be made to work asynchronously, so I can use CSLA as it is.&nbsp; Moreover, I don't need to prefix my binding paths with "Entity" or something because the ObjectDataProvider knows it should defer binding paths to the object it is wrapping.</P>
<P>This sounds like the best of both worlds to me. Now all I have to do is create a subclass of ObjectDataProvider that knows which CSLA methods to call and I'm all set.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
