<html><header><title>Reflection/Proxy Based Attack Possible?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Reflection/Proxy Based Attack Possible?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3164.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>muaddib posted on Tuesday, July 10, 2007</h2><P>I am using CSLA&nbsp;for a&nbsp;click-once app and&nbsp;the DataPortal is hosted on IIS.&nbsp; As usual, after authentication, a Principle and an Identity objects are sent to and&nbsp;fro the Dataportal to perform&nbsp;security at the Server.&nbsp; I am wondering what you would do to defend against the following attack:</P>
<P>&nbsp;&nbsp;&nbsp; A user downloads my click-once, decompiles it, and adds a reflection call somewhere in the app to change&nbsp;the Identity object to have whatever rights they desire.&nbsp; The user then logs in normally, invokes the method, and uses this modified Identity to make all further calls.&nbsp; They have not actually modified the CSLA assembly in any manner so Strong Naming does not help directly.&nbsp; Is it possible to setup the CSLA assembly to only be allowed to be run by my app?&nbsp; </P>
<P>&nbsp;&nbsp;&nbsp; Similary,&nbsp; the user sets up a local&nbsp;DataPortal masquerading as the foreign DataPortal.&nbsp; When the click-once is run it initially authenticates against the real DataPortal, but afterwords the local web service is started.&nbsp; Thereafter the click once hits the local DataPortal, which then desiralizes the call, writes a new Identity and forewards it onto the foreign DataPortal.&nbsp; Same fix as above?</P>
<P>&nbsp;&nbsp;&nbsp; Finally, setup an http socket in the middle, reads in the byte stream, modifies it accordingly and passes it on to the foreign server.&nbsp; No CSLA in the middle involved, just hacking together a modified message.</P>
<P>&nbsp;&nbsp;&nbsp; Why is the Identity even being passed back and forth anyways, why not&nbsp;store it in the Session object at the server, where the client can't get at it?</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Thanks all for considering this, it is much appreciated.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;Muaddib</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 10, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>muaddib:</strong></div><div>
<P>&nbsp;&nbsp;&nbsp; A user downloads my click-once, decompiles it, and adds a reflection call somewhere in the app to change&nbsp;the Identity object to have whatever rights they desire.&nbsp; </P>
<P></div></BLOCKQUOTE></P>
<P>If you don't trust the client, then you must stop and rethink. </P>
<P>Client/server and n-tier architectures include the client as part of the architecture, and thus by definition the client exists within the application's trust boundary.</P>
<P>If your client is actually outside your trust boundary, then it <EM>can not be part of your application</EM>. Instead, the client must be viewed as being a separate application that is communicating with your server application. This is the foundation of SOA, and is (imo) the correct way to view this scenario.</P>
<P>In this model, your "real" application (the one on the server) doesn't trust anything coming from the client. It assumes that the client is incorrect - either by accident or due to malicious intent.</P>
<P>The client application might well include a lot of code. It might have all the business logic, so it can provide the user with a great experience. But the server must <EM>always</EM> recheck everything, acting under the assumption that the client was compromised.</P>
<P>This is the world of SOA.</P>
<P>The best way to accomplish this, with CSLA, is to literally implement everything twice. Once on the server, with a service-oriented interface (see chapter 11), and once on the client, where the clinet-side objects have DataPortal_XYZ methods that merely call the services provided by the server application.</P>
<P>If you are clever (and are willing to break a major rule of SOA), you can share most/all of your business objects between client and server. See the DeepData sample app for ideas on how to use data transfer objects (DTOs) to entirely separate data access from your business objects. Using that technique, your DAL in the client app calls web services, while the DAL on the server talks to the database - but the objects are the same either way.</P>
<P>Obviously there's a lot of duplicate processing and inefficiency introduced in this model. But it is safe, because the server always runs all the business logic (authorization, validation, etc), so if the client is compromised it doesn't matter.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>muaddib:</strong></div><div> </P>
<P>Why is the Identity even being passed back and forth anyways, why not&nbsp;store it in the Session object at the server, where the client can't get at it?</P>
<P></div></BLOCKQUOTE></P>
<P>Because most app servers are entirely stateless. Imposing the requirement of Session is a pretty high bar for most app servers, and does imply you are hosting in ASP.NET. Not everyone does - nor does the data portal require it. Some people host in custom Windows services, and in the future I think most people will host in WAS, skipping IIS/ASP.NET entirely.</P>
<P>But honestly, if you don't trust your client, changing the identity is the least of your worries. They can mount replay attacks and all sorts of fun stuff if they control the client.</P>
<P>This is why SOA is the right answer. A well-implemented, highly paranoid server application (which almost no one actually does, because it is too expensive, but still...) can address these issues.</P>
<P>One of the best places to look for <EM>really</EM> good implementations of this sort of thing are online games. Especially the MMORPGs, because they learned long ago how to defeat exploits by rabid, dishonest, gamers who control the client and feel free to hack and break code, create man-in-the-middle modules and all sorts of stuff.</P>
<P>There's a series of books by Charles River Media on game design (a couple series actually) and some of those books have good chapters dealing with this stuff.</P>
<P>Of course, as with all security issues - make sure you do a good threat assessment first. Preventing some of these hacks is <EM>really hard</EM> and thus <EM>really expensive</EM>, and so you need to make sure the cost and likelihood of compromise is high enough to offset the cost of prevention.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
