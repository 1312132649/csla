<html><header><title>Silverlight Native Child Window</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Silverlight Native Child Window</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12165.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil posted on Friday, September 27, 2013</h2><p>I&#39;ve a record on display in my main Silverlight window.&nbsp; I can flip through the records and while I do so I&#39;d like native child windows to update with details.&nbsp; This is no problem for a ChildWindow control but it is a different matter for a child window (native) proper.</p>
<p>Anyone else done this or know of a good article on it?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Friday, September 27, 2013</h2><p>When you are talking about native child windows vs ChildWindow, what is your distinction?&nbsp; What do you mean by native child window?</p>
<p>In our application we do utilize a multiple browser capability - i.e. one can spawn additional instances of the application in multiple browser windows (open record in new window sort of thing)&nbsp;and the different browser windows (app instances)&nbsp;end up talking to each other.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil replied on Monday, September 30, 2013</h2><p>The &#39;native windows&#39; are additional browser windows.</p>
<p>That is different (as you well know) than an instance of a child window class which cannot leave the parent window.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 30, 2013</h2><p>Every child window that opens up, we pass in the query string a Guid-type value that says &quot;this is your listener ID&quot;.&nbsp; During the startup, this child window (new browser window/new instance of the app) creates and registers its receiver with the &quot;intra application communication manager&quot; that we created.</p>
<p><span style="font-family:Consolas;color:#2b91af;font-size:x-small;"><span style="font-family:Consolas;color:#2b91af;font-size:x-small;"><span style="font-family:Consolas;color:#2b91af;font-size:x-small;">LocalMessageReceiverManager</span></span></span><span style="font-family:Consolas;font-size:x-small;"><span style="font-family:Consolas;font-size:x-small;">.CreateReceiver(_thisListenerId, </span></span><span style="font-family:Consolas;color:#0000ff;font-size:x-small;"><span style="font-family:Consolas;color:#0000ff;font-size:x-small;"><span style="font-family:Consolas;color:#0000ff;font-size:x-small;">true</span></span></span><span style="font-family:Consolas;font-size:x-small;"><span style="font-family:Consolas;font-size:x-small;">, MessageReceivedHandler);</span></span></p>
<p>This call basically is a factory method to get a &quot;LocalMessageReceiver&quot; with the name of that Guid.&nbsp; It also subscribes to the MessageReceived event and then turns itself on - (Listen()).</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static LocalMessageReceiver CreateReceiver(string receiverName, bool keepAlive, EventHandler&lt;MessageReceivedEventArgs&gt; handler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (String.IsNullOrWhiteSpace(receiverName))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException(&quot;receiverName&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (handler == null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException(&quot;handler&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalMessageReceiver receiver = new LocalMessageReceiver(receiverName, ReceiverNameScope.Global, LocalMessageReceiver.AnyDomain);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; receiver.MessageReceived += new MessageHandler(handler, keepAlive).HandleMessage;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; receiver.Listen();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return receiver;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>In Isolated Storage we keep a list of &quot;queued&quot; messages, which each new window checks too - &quot;are there any messages waiting for me to process&quot;.&nbsp; We also keep a list of the listener IDs&nbsp;there so that we know who we need to broadcast to.</p>
<p>Generally we then broadcast messages - which are often times to notify that a record changed (which may require the window to refresh/adjust itself) or even things like &quot;shut down/log out&quot;.&nbsp; This mechanism of communicating across application instances has worked extremely well for us.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Broadcasts the indicated message to all listeners.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name=&quot;message&quot;&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Message to broadcast.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/param&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static void BroadcastMessage(IntraApplicationMessage message)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var info = GetIsolatedStorageFile();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (string listener in info.ListenersList)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalMessageSender messageSender = new LocalMessageSender(listener, LocalMessageSender.Global);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; messageSender.SendCompleted += (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The message did not sent successfully - remove the listener.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UnregisterListener(e.ReceiverName);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Fire off the message.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; messageSender.SendAsync(message.ToString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>Hopefully that&#39;s enough to stir some ideas, but generally the LocalMessageReceiver is the area I&#39;d suggest exploring.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil replied on Monday, September 30, 2013</h2><p>That does stir some ideas.&nbsp;&nbsp; I&#39;d like to get your thoughts on one other thing though.&nbsp;&nbsp; My &#39;main&#39; window is showing the record and the child windows will show &#39;detail&#39;.&nbsp;&nbsp; How is the &#39;detail&#39; retrieved?&nbsp;&nbsp; Should the detail be retrieved async or should I just pass the detail (already loaded on the record) to the child window somehow?&nbsp;&nbsp; How do you handle this?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 30, 2013</h2><p>Oh do you have basically an list in your master window and clicking on a row displays details in the other window?&nbsp; And your list isn&#39;t actually an info list, you actually have all the details you want to show in the child window?</p>
<p>If you didn&#39;t have all the details (it sounds like you do), I would probably basically broadcast to the child to &quot;show details for record ID 5&quot;.</p>
<p>(If I understand you correctly).</p>
<p>Since you have the details - I don&#39;t know what the limitation is in terms of size for the messaging... you could potentially try MobileFormatter.Serialize and pass the object through the listener - deserialize it and you have it in your other app instance.&nbsp;&nbsp; I&#39;ve never tried something like that but it might work.</p>
<p>Another alternative would be to use MobileFormatter.Serialize and then compress it, put it into Isolated Storage under some defined key, and broadcast to your child window to &quot;get the object from Isolated Storage&quot;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 30, 2013</h2><p>One followup - max size is 40K.</p>
<p><a href="http://msdn.microsoft.com/en-us/library/dd833063(v=vs.95).aspx">http://msdn.microsoft.com/en-us/library/dd833063(v=vs.95).aspx</a></p>
<h3 class="subHeading"><em>&quot;Sending complex messages</em></h3>
<div class="subsection">
<p><em>With local messaging, you can send any string up to 40 kilobytes in length. In many situations, the message will only need to be a simple notification or a simple set of values that the receiver can parse and interpret easily. However, within the 40 kilobyte limit, you can send arbitrarily complex messages, including serialized objects and encrypted messages. &quot;</em></p>
<p>If you still have the compression libraries in place, 40K can actually be a fairly meaningful object (serialized and compressed).&nbsp; If you don&#39;t or your object could likely exceed 40K compressed, you may want to shuttle it along via Isolated Storage (if you want to not have to refetch in the child window)</p>
</div></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MadGerbil replied on Monday, September 30, 2013</h2><p>The isolated storage solution works very well.&nbsp;&nbsp;&nbsp; Thank you.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
