<html><header><title>Data Portal Memory Leak?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Data Portal Memory Leak?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9384.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rob.polak posted on Monday, August 16, 2010</h2><p>I recently had to create a Multi-Threaded CSLA process that updates an object based on a long-running webservice call.&nbsp; Based on what is returned from the webservice we may or may not update the object (only if something has changed).&nbsp; I am using the C# ThreadPoolManager to make the application multi-threaded.&nbsp; </p>
<p>I noticed that when there was a significant amount of changes that the memory of my program jumped up a significant amount.&nbsp; I traced the memory increase to the &quot;Object&quot;.Save() method.&nbsp; To rule out all my code I changed the logic to look like this:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Object&quot;.Save()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Transactional(TransactionalTypes.TransactionScope)]<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void DataPortal_Update()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>I eliminated any possible user code that could cause a memory leak.&nbsp; My collection has about 4000 objects and by the time the process is done the memory usage is approaching 3gb in size.&nbsp; I explicitly make sure all of the objects are de-referenced and GC.Collect() is being called.&nbsp; Any other tips on what I can do to reduce my memory footprint?</p>
<p><b>Versions:</b></p>
<p>CSLA Version: 3.8.2</p>
<p>.Net : 3.5 SP1</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Thanks!</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>rob.polak replied on Tuesday, August 17, 2010</h2><p>So after hours of trying to figure this out I found out what was the issue.&nbsp; For a local dataportal the CSLA framework creates a clone of itself incase of data corruption.&nbsp; </p>
<p><span style="text-decoration:underline;">Dataportal.cs</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!proxy.IsServerRemote &amp;&amp; ApplicationContext.AutoCloneOnUpdate)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // when using local data portal, automatically<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // clone original object before saving<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ICloneable cloneable = obj as ICloneable;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cloneable != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj = cloneable.Clone();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>This was causing my multi-threaded application to hog up memory (as the data structure is quite complex).&nbsp; So I added the following config setting to remedy the issue:</p>
<p>&lt;add key=&quot;CslaAutoCloneOnUpdate&quot; value=&quot;false&quot;/&gt;</p>
<p>This should really be called out more clearly, because this option set to true has HUGE performance impacts on applications.&nbsp; With this option set to true my memory was spiking to 2gb and it was taking 2-3 seconds per save.&nbsp;&nbsp; With this option set to false my memory is hovering around 50 meg and each save is taking 40-50ms.&nbsp; </p>
<p>I really suspect that the memory is not getting correctly disposed with the cloned object.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, August 18, 2010</h2><p>It&#39;s certainly true that cloning the object has a performance impact, but the alternative is worse IMHO.</p>
<p>If you turn this off an encounter an exception anywhere during the save process, then your object is left in an indeterminate state. The database may have rolled back the update, but changes made to your objects during the save would be retained. For example, if you were inserting a new object, then child objects in the graph might be marked as old and been assigned autonumbering (e.g. IDENTITY with SQL Server) values that don&#39;t exist in the database because the insert was rolled back. If you tried to repeat the save operation, then these objects would be presumed clean and not be saved. This is a disaster in the making. </p>
<p>Also, the AutoCloseOnUpdate setting really only has an effect when using the local data portal. If you are scaling up to 3 or more tiers, then the equivalent processing is being done to serialize the object to the remote server. So, turning this off has no impact except when using a local dataportal -- if you ever switch to using&nbsp;a remote portal, you&#39;ll incur the &quot;clone&quot; overhead anyway. </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
