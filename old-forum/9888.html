<html><header><title>CSLA 4 PropertyHasChanged breaking change</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 4 PropertyHasChanged breaking change</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9888.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans posted on Sunday, December 19, 2010</h2><p>As we are upgrading to CSLA 4, I&#39;m happy to see the changes in CSLA 4 result in much more concise and strongly typed code. I cannot place enough emphasis on the value of this, especially at compile time!</p>
<p>With the Rules system it is a bit more difficult to ensure type safety at compile time especially with regard to getting the property value from the input properties collection from inside the Execute override. This bit requires that you cast the property value to the correct type, but that will give you runtime pain if you changed the type without remembering to update the rule Execute override accordingly. But that&#39;s another matter altogether and I digress.</p>
<p>A change I noticed was that PropertyHasChanged now only accepts parameters of type PropertyInfo (instead of string before). This is great and helps guide the framework user to use a more type-safe world and helps trouble scenarios where property names change.</p>
<p>I do have a few scenario&#39;s where I have &quot;calculated&quot; properties on business objects. These are really formula fields that I do not want to define as a CSLA Property (ie. RegisterProperty) as they are not stored at all, and should also not be serialized. Often these &quot;calculated/formula&quot; properties are dependent on one or more CSLA properties, and to ensure that any binding to&nbsp;a &quot;calculated/formula&quot; property is updated/refreshed when one/or more of the properties it depends on changes, I could &quot;PropertyHasChanged( &quot;CalculatedProperty&quot; )&quot;, or setup a dependency property rule based on the string name of the property.</p>
<p>An example of this is a FullName calculated property that is a combination of Last and Firstname or an Age calculated property that is based on the DateOfBirth property:</p>
<pre style="font-family:consolas;"><span style="color:blue;">        public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;<span style="color:purple;">FullName</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:darkcyan;">get</span>&nbsp;{&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">string</span>.<span style="color:darkcyan;">Format</span>(&nbsp;<span style="color:#a31515;">&quot;{0},&nbsp;{1}&quot;</span>,&nbsp;<span style="color:red;">LastName</span>,&nbsp;<span style="color:red;">FirstName</span>&nbsp;);&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">int</span>&nbsp;<span style="color:purple;">AgeInDays</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:darkcyan;">get</span>&nbsp;{&nbsp;<span style="color:blue;">return</span>&nbsp;(<span style="color:darkblue;">DateTime</span>.<span style="color:purple;">Now</span>&nbsp;<span style="color:darkcyan;">-</span>&nbsp;<span style="color:red;">DateOfBirth</span>).Days;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre>
<p>From the above, using CSLA 3.8 I would simply setup a dependency property using strings, or if in a business rule I would call PropertyHasChanged(&quot;FullName&quot;) to let any subscribers know that the value needs refreshing.</p>
<p>Enter CSLA 4 and PropertyHasChanged no longer accepts string based properties - a change I wholeheartedly agree with, especially for the 85% case. I did notice that there is a is an overload for:</p>
<pre style="font-family:consolas;"><span style="color:darkcyan;">OnPropertyChanged</span>( string propertyName )</pre>
<p>Would I be able to safely use this for my &quot;edge&quot; cases?</p>
<p>Would there be a case for a Csla.Rules.CommonRules.<strong>Dependency</strong> rule that accepts a params[] string dependentProperties ?</p>
<p>Just thinking about it, a really powerful one would be to have a <strong>PropertyHasChanged</strong> overload and something similar for the Dependency rule, that uses a LambdaExpression that points to a property on the same class. (Much like RegisterProperty does). This would really give excellent protection against the magic string literals and solve the limitations I now have. How about that?</p>
<p>Thanks</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, December 20, 2010</h2><p>Hi Jaans, </p>
<p>So you have created a dependency rules that only raise PropertyHasChanged to notify UI?
 </p>
<p>You should be aware that PropertyHasChanged does a number of operations:</p>
<p>1. Marks the object as dirty<br />2. Call business rules for the property (and dependencies)<br />3. Calls OnPropertyChanged to notify UI (and others)</p>
<p>Whereas OnPropertyChanged only does:</p>
<p>1. Raise the PropertyChanged event to notify UI and other event listeners.</p>
<p><b>So in your edge case - you should safely call OnPropertyChanged as it only raises the PropertyChanged event. </b></p>
<p>But - even if you create a PropertyInfoObject - you would only allocate an empty slot (null) in FieldManager that would only be a marginal memory consumption unless you load a very large number of objects. </p>
<p>The Rule engine in CSLA4 expects only IPropertyInfo so if you need a rule then you really should declare a PropertyInfo for that object. </p>
<p>So in my opinion - NO we should not create a standard Dependency rule that accepts a params[] string dependentProperties. The existing Dependency rule is there to call Rules on the dependent properties -&nbsp; this would not work with an array of string propertyNames in the rule engine.</p>
<p>You may create your own &quot;dependency&quot;&nbsp; type rule that ONLY calls OnPropertyChanged for a params string list of PropertyNames.</p>
<p>One other reason for using PropertyInfos is speed. In the &quot;older&quot; Csla version we had a PropertyHasChanged() - no parameters - that used reflection to get the PropertyName. That was incredibly expensive !!! Having a PropertyHasChanged that accepts a Lambda expression may seem good but might actually use refection to get propertyname and be quite slow. That is one of the reasons the PropertyInfo object was introduced - to keep the propertyName in a static variable and not use reflection on every call. </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Monday, December 20, 2010</h2><p>Hi Jonny</p>
<p>Thank your for the detailed info. <br />It helps to know how the two implementations differ, and that I could go with &quot;OnPropertyChanged&quot; for lightweight change notification in scenarios where I want to be very &quot;light&quot; (at the cost of maintainability).</p>
<p>So you are you saying that if I create a CSLA PropertyInfo property (using RegisterProperty) for these &quot;calculated/formula&quot; properties but never actually load a value into the property (via LoadProperty / SetProperty) that the FieldManager would be holding a NULL value for the field and thus it&#39;s &quot;payload&quot; with regard to memory and serialisation is slight? </p>
<p>If that&#39;s the case and depending on how small the &quot;payload&quot; is, it&nbsp;would be preferable to do it this way. That simplifies things&nbsp;a lot and avoids my inelegant suggestion. Futhermore it enables scenarios where I could attach rules to such &quot;calculated&quot; properties.</p>
<p>A PropertyInfo implementation would cover the &quot;90% case&quot;, but on the odd occasion keeping that serialization payload / memory footprint low is a primary goal and so it would be useful to try and quantify the cost of this &quot;empty slot&quot;. Any indication of what that may be?</p>
<p>Thanks again,<br />Jaans</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, December 20, 2010</h2><p>Hi Jaans, </p>
<p>FieldDataManager allocates a memory slot of type:&nbsp;</p>
<pre style="font-family:consolas;"><pre style="font-family:consolas;">&nbsp;[<span style="color:#7587a6;">NonSerialized</span>()]<br />&nbsp;<span style="color:#cda869;">private</span>&nbsp;<span style="color:#7587a6;">List</span>&lt;<span style="color:#7587a6;">IPropertyInfo</span>&gt;&nbsp;_propertyList;<br /><span style="color:#cda869;"> private</span>&nbsp;<span style="color:#7587a6;">IFieldData</span>[]&nbsp;_fieldData;<br /></pre>
<pre style="font-family:consolas;">&nbsp;_fieldData&nbsp;=&nbsp;<span style="color:#cda869;">new</span>&nbsp;<span style="color:#7587a6;">IFieldData</span>[_propertyList.Count];<br /></pre>
</pre>
<p>But the actual fielddata for a property is created the first time a property is reference (in f.ex LoadProperty,&nbsp; GetProperty, ReadProperty or SetProperty). <br />The FieldDataManager also hold a consolidated list of PropertyInfos but is this list is not serialized over the wire. </p>
<p>So it should be a minimal impact in memory. </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
