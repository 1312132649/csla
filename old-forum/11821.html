<html><header><title>BeginFetch and FetchAsync on local DataPortal</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>BeginFetch and FetchAsync on local DataPortal</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11821.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm posted on Tuesday, February 05, 2013</h2><p>Rocky,</p>
<p>You confirmed the following for the next CSLA release at&nbsp;( <a href="http://forums.lhotka.net/forums/p/11814/54722.aspx#54722">http://forums.lhotka.net/forums/p/11814/54722.aspx#54722</a>&nbsp;):</p>
<p>&quot;All that said, the <em>local</em> data portal will be changing in the next release of 4.5. Currently when you do an async call (BeginFetch or FetchAsync) against a local data portal the call is ultimately synchronous unless <em>your</em> DP_Fetch code does something async. That behavior is fundamentally different from the remote data portal behavior, and is already the cause of substantial confusion.</p>
<p>As a result, what I&#39;m working on right now is making the local data portal <em>always</em> spin work off to a background thread if the top-level call was BeginFetch or FetchAsync. That way the local data portal directly emulates the remote data portal to eliminate that source of confusion.&quot;</p>
<p>Personally I&#39;m totally against this move and I believe it can degrade the number of CSLA use cases. Let me explain briefly.</p>
<p>When implementing async methods in libraries (especially general frameworks like CSLA), they should guarantee asynchronity rather than offloading such as invoking or wrapping synchronous method asynchronously.</p>
<p>If you look at majority of BCL that&#39;s exactly how it&#39;s done i.e. WCF proxy or&nbsp;file stream&nbsp;will not put your async&nbsp;call on the worker thread just because you called async method variant.</p>
<p>This brings in two major questions. </p>
<p>1) Is local data portal capable of delivering real async functionality?</p>
<p>2) What&#39;s the ultimate goal you want to achieve with this offloading?</p>
<p>With regards to the remote data portal with which you&#39;re looking to provide call symmetry, its source of asynchronity is particular network stack (usually WCF proxy). From the local data portal perspective, there&#39;s no such component and so the need for asynchronity is very questionable. However, data access as implemented by business developer can be implemented as async most commonly by opening db connections or file / network streams. In that case, local data portal is expected to follow that async path.</p>
<p>That brings us to the second question. If the only aim is to offload data portal invocation from the UI thread&nbsp;then I&#39;m affraid CSLA&#39;s client - UI technology&nbsp;agnosticism is&nbsp;being jeopardized here.</p>
<p>Consider my service or server-side data portal code that invokes client data portal. Do I really want to have this invocation taking possible two threads from thread pool and allocating / switching contexts just because it&#39;s configured to use local data portal there?</p>
<p>var yesterdayOrders = await Orders.GetOrdersAsync(yesterdayCriteria);</p>
<p>var unpaidOrders = await Orders.GetOrdersAsync(unpaidCriteria);</p>
<p>On the other hand, consumer of synchronous method GetOrders can always easily control offloading off UI thread by invoking it from Task.Run.</p>
<p>I know that nowadays people take async methods as &quot;invoked on the new thread&quot; easily, but I strongly believe this will align itself once it gets established. However, CSLA shouldn&#39;t make API surface even more confusing.</p>
<p>I would like to hear your thoughts.</p>
<p>Thanks,</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, February 06, 2013</h2><p>Many of my design thoughts were captured in my blog as I was doing the work for .NET 4.5 last year. For example: </p>
<p><a href="http://www.lhotka.net/weblog/CSLADataPortalChangesInVersion45.aspx">http://www.lhotka.net/weblog/CSLADataPortalChangesInVersion45.aspx</a></p>
<p>There are two basic goals.</p>
<p>First, on the client-side data portal I want to enable the use of the await keyword when calling the data portal. To this end the data portal exposes CreateAsync, FetchAsync, UpdateAsync, ExecuteAsync, and DeleteAsync methods. As a side-effect, the pre-existing BeginXYZ methods (such as BeginFetch) now delegate to these new async methods behind the scenes.</p>
<p>Second, the DataPortal_XYZ and factory object methods should support the async keyword. For example:</p>
<p>private async Task DataPortal_Fetch()<br />{<br />}</p>
<p>It is important to remember that there is <em>never</em> a direct flow-through of the client-side data portal to the server-side data portal. The client-side business object graph is cloned, and that&#39;s what flows to the logical server. The term &quot;flow&quot; is implemented by a proxy/host channel. The simplest channel is the LocalProxy, and the most widely used is probably WcfProxy. Ultimately the call to the &quot;server&quot; (the host) is synchronous. This is because the server is assumed to be an actual server, and the call is assumed to be a network call on which we wait for a response.</p>
<p>In the new 4.5.11 prerelease I just put online the LocalProxy now ensures that the logical server-side code is running on a background thread from the thread pool, thus emulating the remote data portal. Really it was a bug when I removed this behavior in the original 4.5 release, but I was trying to be clever. As it turns out, my being clever just caused confusion and heartburn - not only for a lot of people on this forum, but for myself as well (I was burned a couple times by my own breaking change...).</p>
<p>Fwiw, my goal for the past 17 years has been for the data portal to abstract the concept of the network. Every single time I&#39;ve deviated from that goal (each time for noble ideals) I&#39;ve ended up returning to the core goal: when you call the client-side data portal you should get the same logical behavior regardless of whether the &quot;server-side&quot; code runs local or remote.</p>
<p>What exists now in 4.5.11 is extremely consistent and straightforward.</p>
<p>When the client calls BeginFetch or FetchAsync you <em>know</em> that it won&#39;t be a blocking call - the logical server-side code will <em>not</em> run on the UI thread. You don&#39;t know if it will run locally or remotely, but you can be assured that it won&#39;t block the UI thread so there&#39;s no difference in behavior between local and remote data portal configurations.</p>
<p>When the client calls Fetch you <em>know</em> that it will be a blocking call. You don&#39;t know on what thread (or physical location) the server-side code will run, but you are assured that the Fetch call itself is blocking.</p>
<p>When you implement your DP_XYZ method you can implement it as sync or async. If you implement it as sync (void) it is no different from the behavior you&#39;ve had since 2001. If you implement it as async (async Task) you can be assured that the data portal will await your result, and within your DP_XYZ code you can do all the fancy task/await stuff you desire.</p>
<p>The other area of interest here is exception handling. This is because exceptions that occur during an async operation are not singular, they are a collection. The data portal is aware of this, and it is aware how you called the data portal. If you called the data portal using one of the new async methods then the entire exception collection flows back (well, on a pure .NET app - not so in WinRT, WinPRT, Silverlight, WP8, or .NET using MobileFormatter). But if you called the data portal with a sync method or a BeginXYZ method the data portal strips the top exception out of the collection and returns it - thus preserving backward compatibility with pre-4.5 behaviors.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>Rocky,</p>
<p>Thank you for clarifying the design goals. </p>
<p>I read that blog article a while ago. While it points very clearly to the way you unified Data Portal with its new async support, it really doesn&#39;t touch this topic we&#39;ve got going on here at all.</p>
<p>I completely agree that one of the main goals behind Data Portal is to abstract the concept of the network (although 17 years is too much even for something as complex as network is hehe, just kidding).<br />Once you accept to abstract something then in some ways you take responsibility for all those abstracted bits and pieces. Abstracting the network is good thing for sure, but providing faux asynchronity in the name of symmetry is probably not so good in my opinion. It&#39;s been said that too many sacrifices are created by always pursuing software symmetry.</p>
<p>Philosophy aside, I think I was right when pointing out that the basis of the issue is pretty much UI i.e. offloading of UI thread. That&#39;s probably the biggest issue I&#39;ve got with this decision. Why would you assume that client-side Data Portal is always invoked from interactive client i.e. the one with UI thread? Isn&#39;t this pretty big coupling for something as generic as Data Portal is?</p>
<p>Also you mentioned above that one of the goals was to enable the use of the await keyword when calling the Data Portal. That&#39;s exactly what I want to use here, but you ultimately require offloading to the other thread in order for me to await the method.</p>
<p>The reason I posted this topic isn&#39;t really just to express my concern behind this design decision but rather to stress out how my scenarios will suffer in the light of new changes.</p>
<p>Let&#39;s say I&#39;ve got Order BO. When it&#39;s on the server-side Data Portal, prior to its persistence, it has to coordinate interaction with several other BOs such as Customer, ProductList and GeneralLedger. Order simply calls factory method on each of those objects in order to fetch them. Since server-side Data Portal is using local proxy, fetching will be done on the very same physical tier:</p>
<p style="padding-left:30px;">protected new async Task DataPortal_Update()<br />{<br />&nbsp;var customer = await Customer.GetCustomerAsync(_customerId);<br />&nbsp;// Interact with customer<br />&nbsp;var product = await ProductList.GetProductListAsync(this);<br />&nbsp;// Interact with product<br />&nbsp;var generalLedger = await GeneralLedger.GetGeneralLedgerAsync(_tranId);<br />&nbsp;// Interact with generalLedger<br />&nbsp;<br />&nbsp;// Persist Order<br />}</p>
<p>So, in this very common scenario where client Data Portal is used with non-interactive client such as server-side Data Portal, these three requests will be offloaded to at least three potentially different threads. I say potentially because they would come from thread pool and therefore might be reused. I also say at least because if I had my data access in these three objects implemented to do its work on seperate thread that would add to the number of involved threads.<br />More complex interaction such as when some of these objects interact with some other objects would just keep multiplying potentially used threads.</p>
<p>Pretty much, a lot of context switching, queue synchronization and allocation of the other objects just for the sake of offloading if there happens to be an interactive client on the UI thread.</p>
<p>Let&#39;s consider for a sec that everything stays like it was in v4.5.10. The very same scenario above would be executed on the request thread unless there&#39;s async data access implementation.</p>
<p>- ngm</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>ngm<br></b>
<p>Let&#39;s say I&#39;ve got Order BO. When it&#39;s on the server-side Data Portal, prior to its persistence, it has to coordinate interaction with several other BOs such as Customer, ProductList and GeneralLedger. Order simply calls factory method on each of those objects in order to fetch them. Since server-side Data Portal is using local proxy, fetching will be done on the very same physical tier:</p>
<p>[...]</p>
<p>So, in this very common scenario where client Data Portal is used with non-interactive client such as server-side Data Portal, these three requests will be offloaded to at least three potentially different threads. I say potentially because they would come from thread pool and therefore might be reused. I also say at least because if I had my data access in these three objects implemented to do its work on seperate thread that would add to the number of involved threads.<br /></div></p>
<p>That is a very good point. I had a feeling there was some issue I was missing by changing LocalProxy, but hadn&#39;t figured out what it was.</p>
<p>I wonder if one solution to this is to only spin the work onto a background thread if the LogicalExecutionLocation isn&#39;t Server. I think that&#39;d address this issue, and will do some experimentation to see.</p>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>Yes, this appears to work quite well as a solution. Once the flow of execution has crossed from logical client to logical server the LocalProxy stops spinning work onto the thread pool, allowing normal async/await behaviors to work as expected.</p>
<p>Of course that&#39;s still a little risky - but in a way I&#39;m happy to accept. It is &quot;risky&quot; because if you do something that causes the TPL to spin you off onto a thread you do lose ApplicationContext. But you should know that you wrote code that caused that to happen, so you can take steps to flow the context to the new thread.</p>
<p>One relatively easy way to accomplish this is to use Csla.Threading.BackgroundWorker, because it dispatches work onto the thread pool, but also ensures that ApplicationContext flows to the new thread.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>Yes, this appears to work quite well as a solution. Once the flow of execution has crossed from logical client to logical server the LocalProxy stops spinning work onto the thread pool, allowing normal async/await behaviors to work as expected.</p>
<p>Of course that&#39;s still a little risky - but in a way I&#39;m happy to accept. It is &quot;risky&quot; because if you do something that causes the TPL to spin you off onto a thread you do lose ApplicationContext. But you should know that you wrote code that caused that to happen, so you can take steps to flow the context to the new thread.</p>
<p>One relatively easy way to accomplish this is to use Csla.Threading.BackgroundWorker, because it dispatches work onto the thread pool, but also ensures that ApplicationContext flows to the new thread.</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>I see where you&#39;re coming with LogicalExecutionLocation.</p>
<p>However, I still believe that SynchronizationContext would be much better thing to lean against. It would enable even scenarios where interactive client with UI thread compose several invocations wrapped in new task such as:</p>
<p>await Task.Run(async () =&gt; {</p>
<p>_orders = await Orders.GetOrdersAsync();</p>
<p>_product = await Product.GetProductAsync(id);</p>
<p>_transactions = await Transactions.GetTransactionsAsync();</p>
<p>});</p>
<p>LogicalExecutionLocation will not help here, still all three requests will be spinning a thread. If you inspect SynchronizationContext.Current, it should be null since user invoked a new task.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>Well, I&#39;m not quite sure you&#39;ve got LogicalExecutionLocation established at the point in LocalProxy where you need to decide whether to offload onto background thread, right? </p>
<p>Probably you meant ExecutionLocation which is based on the proxy itself i.e. whether the proxy is remote or not.</p>
<p>However, the issue I explained above that really multiplies as the number of objects you&#39;re interacting with grow, is really not specific to server-side interaction at all. That can easily become a bottleneck on the interactive client which uses local proxy as well.</p>
<p>Consider having Unit of Work object (BTW I like that concept of yours), UI developer might be calling single async factory method on it:</p>
<p style="padding-left:30px;">var ot = await OrderTransactionUoW.GetOrderTransactionUoWAsync(tranId);</p>
<p>The data portal works locally i.e. via local proxy. Here&#39;s how UoW object&#39;s data access looks like:</p>
<p style="padding-left:30px;">private async Task DataPortal_Fetch(Guid transactionId)<br />{<br />&nbsp;&nbsp;var tranInfo = await TransactionInfo.GetTransactionInfoAsync(transactionId); // 1st LocalProxy.FetchAsync<br />&nbsp;&nbsp;var gl = await GeneralLedger.GetGeneralLedgerAsync(); // 2nd LocalProxy.FetchAsync<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;if (gl.AreItemsLoaded) <br />&nbsp;&nbsp;&nbsp;await gl.LoadItemsAsync(); // 3rd LocalProxy.FetchAsync - lazy loaded collection<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;var glItems = gl.Items;&nbsp; // can&#39;t call await on lazy loaded property, must load it otherwise will get null here<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;if (tranInfo.AreDetailsLoaded)<br />&nbsp;&nbsp;&nbsp;await gl.LoadDetailsAsync(); // 4th LocalProxy.FetchAsync - lazy loaded collection<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;foreach (var tranDetail in tranInfo.Details)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;this.GeneralLedgerItems.Add(dlItems[tranDetail.GeneralLedgerPostId]);<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;this.Customer = await Customer.GetCustomerAsync(tranInfo.CustomerId); // 5th LocalProxy.FetchAsync<br />}</p>
<p>This will become thread switching nightmare. Everything is happening on the client. WP or RT machines are not going to be happy with this for sure ;)<br />From UI developer&#39;s perspective, she just wants to get single UoW object and that object&#39;s interaction with the other BOs is not terrible complex here, although not the smartest design for sure.</p>
<p>Now, think for a second, if every single of those involved BOs have their data access async &quot;by the book&quot; i.e. opening connection or file stream asynchronously. That&#39;s exactly why I&#39;m doing all those awaits in DataPortal_Fetch after all. But those asynchronous IO benefits would be totally neutralized by the fact that in order for me to await anything I&#39;ve got to be coming from another thread and that&#39;s per every single await.</p>
<p>And again, all this spinning just for the sake of saving UI guy from invoking:</p>
<p>Task.Run(async () =&gt; <br />&nbsp;&nbsp; await OrderTransactionUoW.GetOrderTransactionUoWAsync(tranId));</p>
<p>That would achieve offloading of UI thread and it will still be getting the best possible scalability depending of the data access strategy in BOs.</p>
<p>But even after this, if you&#39;re still in the game of bringing client Data Portal closer to the UI, then I would probably use SynchronizationContext.Current to determine if there&#39;s one before offloading. That should be able to provide the &quot;dual personality&quot; behavior of LocalProx ? <br />In my opinion, that&#39;s 100% the job of ViewModel and it&rsquo;s not a concernt of CSLA&#39;s inner channel such as LocalProxy for sure.</p>
<p>Take care,</p>
<p>- ngm</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>ExecutionLocation is <em>physical</em>, and LogicalExecutionLocation is <em>logical</em>.</p>
<p>So if I&#39;m on a client using the local data portal then ExecutionLocation is always Client. But LogicalExecutionLocation changes as the processing flows through the data portal to reflect the logical switch from &quot;client&#39; to &quot;server&quot;. </p>
<p>As a result, the first time LocalProxy is invoked the logical location is Client because the flow of processing hasn&#39;t traversed to the logical server.</p>
<p>Subsequent times LocalProxy is invoked (from your code in your DP_XYZ methods) the logical location is Server, regardless of the <em>physical</em> location.</p>
<p>The same logical location change occurs regardless of whether the data portal is configured to run local or remote.</p>
<p>&nbsp;</p>
<p>btw, your Task.Run example is invalid UI code, because the ApplicationContext won&#39;t automatically flow onto that background thread. If a UI developer <em>does</em> write that line of code they have introduced a bug.</p>
<p>If they really want to manually spin the work onto a background thread they need to either write their own task launcher, or use Csla.Threading.BackgroundWorker to achieve the correct result.</p>
<p>Finally, I should point out that 4.5.10 isn&#39;t actually the desired behavior. Since 2007 the BeginFetch and similar methods have spun the data portal call onto a background thread. The 4.5.10 behavior broke/changed that behavior, causing an obvious backward compatibility issue. This is because I didn&#39;t want to implement and maintain <em>three</em> entirely different data portal process flows. Two is bad enough, and it turns out that async/await can be used to simulate the old-style event-based model.</p>
<p>Again, in the final analysis the data portal needs to provide consistent behavior regardless of local or remote configuration. 4.5.10 broke that contract, and that&#39;s the bug I&#39;m fixing in what will be the 4.5.20 release.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>I understood what you want to achieve with LogicalExecutionLocation. But again, if you come to the root of an issue as I pointed out already, it&#39;s really not related to whether it&#39;s executing on the logical server or logical client side. Even you pointed out that it can be too fragile.</p>
<p>What you really want to determine is whether the invocation to async method on client Data Portal comes from UI thread, if so, it will offload that work. That would cover both&nbsp;execution on logical server and logical client side.</p>
<p>You&#39;re right that the Task.Run example is invalid. Personally, I would be much more worried because of that issue than offloading of UI thread i.e. I cannot use typical .NET async mechanisms such as APM, Thread, ThreadPool or most importantly Tasks because the context doesn&#39;t flow. I have to use BackgroundWorker which is getting back into old era of event driven asynchronity.</p>
<p>I think you should reconsider alterntaive methods of passing context, one that is&nbsp;compatible with .NET infrastructure. I pointed out to CallContext in one of the previous posts. </p>
<p>This looks like achilles heel of CSLA now when it opened its async doors. The&nbsp;wider you accept asynchronity throughout CSLA plumbing the more issues you&#39;ll have when relying onto TLS for storing context. BackgroundWorker really just postpones the issue.</p>
<p>- ngm</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>We need to take this one step at a time. Continually changing the goal is ok, as long as the first mole is whacked before the next one shows up.</p>
<p>With that in mind, the change I made to LocalProxy earlier today solves the UoW scenario.</p>
<p>You are right, it doesn&#39;t solve the scenario where the UI developer makes numerous calls - those calls will spin onto the thread pool of the client.</p>
<p>The thing is, this isn&#39;t really as bad as you make it sound. Mostly because the overhead of serialization/deserialization and network overhead (or file I/o) is almost infinitely higher than the cost of transitioning the work to a thread on the thread pool. Yes, this behavior might cost a few nanoseconds, but that&#39;s noise compared to the milliseconds (or seconds) involved in the rest of the process.</p>
<p>Now if we can find a way to intelligently eliminate that overhead I want to do that - I&#39;m not lobbying for worse performance :)&nbsp;&nbsp; I am just suggesting that this issue isn&#39;t really a big one in the scheme of things - where the UoW scenario _was_ a big deal.</p>
<p>&nbsp;</p>
<p>It is probably worth exploring the synchronizationcontext idea. That&#39;s tricky though, because those work differently (or not at all) in various environments CSLA supports, such as:</p>
<ul>
<li>Console apps</li>
<li>Windows service apps</li>
<li>Windows Forms</li>
<li>ASP.NET</li>
<li>Unit test runners</li>
<li>WPF</li>
<li>Windows Workflow</li>
<li>ASP.NET MVC</li>
<li>Silverlight</li>
<li>WinRT</li>
</ul>
<p>I know that LogicalExecutionLocation works consistently across these environments, because I&#39;ve made that happen as they&#39;ve each arrived on the scene over the years. I also know that synchronizationcontext does <em>not</em> work consistently across these environments. Thus the effort involved in testing its use across all these scenarios with local and remote data portal configurations is pretty large.</p>
<p>fwiw, I&#39;m under time pressure to get 4.5.20 online. Enough so that I know for sure I can&#39;t test all those scenarios to see how synchronizationcontext changes between them (and to find corresponding workarounds where it doesn&#39;t provide the right solution).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p>fwiw, on WinRT the CSLA BackgroundWorker uses async/await for its underlying implementation :)</p>
<p>I agree that flowing context is a problem. I have yet to find a solution that&#39;ll work in all the environments where CSLA is used...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Thursday, February 07, 2013</h2><p>Your challenge here is kind of bigger than CSLA, that is to get huge chunk of plumbing unified and consistent across all emerging and legacy platforms. That&#39;s very bold goal nowadays. Take MobileFormatter for example, that thing can be used to simulate NDCS across new constrained platforms without using CSLA at all.</p>
<p>I didn&#39;t even think for a split of a second that you have to implement what I suggest here, nor do I know if it works or makes sense because as you&#39;re stating above, someone needs to look the wholistic picture and that&#39;s gotta be you my friend ;)</p>
<p>Also I&#39;m not here to criticize, far away from that. CSLA made me and my teams delivering and maintenanting mission impossible projects over years and years. Even when not using CSLA due to client&#39;s specific requirements, the concepts and overall paradigm that you established made my way through.</p>
<p>Finally, I&#39;m here to see how you&#39;re gonna solve that next platform fragmentation issue around the corner :)</p>
<p>That being said, these days I&#39;m deep into evaluating CSLA&#39;s new goodies for upcoming assignments and that&#39;s the reason I&#39;m throwing&nbsp;my&nbsp;suggestions from time to time, hoping CSLA can benefit out of them at some point.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 07, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>ngm<br></b>
<p>That being said, these days I&#39;m deep into evaluating CSLA&#39;s new goodies for upcoming assignments and that&#39;s the reason I&#39;m throwing&nbsp;my&nbsp;suggestions from time to time, hoping CSLA can benefit out of them at some point.</p>
</div></p>
<p>Well that is a done deal - you found and helped solve (at least for now) what would have been a nasty bug on the server-side data portal. I really appreciate that!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
