<html><header><title>CSLA with UDP Networking</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA with UDP Networking</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1598.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>wjcomeaux posted on Wednesday, October 25, 2006</h2><P>Do you guys think CSLA would be a good fit in a UDP networking infrastructure? I am using CSLA at work as we all like the framework and ease of code generation it allows. At home I work on various hobby applications, one of which is a client/server game using UDP.</P>
<P>Admittedly, it's mostly in design and planning ATM and I am investigating frameworks for it and strongly considering CSLA. However, I wonder how well CSLA would scale for UDP over sockets?</P>
<P>Basically, the client performs some action that should get sent to the server for processing and a result is returned to the client (typical). However, the amout of traffic could be very high and sending each command over individually could eat up too much mandwidth (UDP header on each packet for each object). I am thinking that between the client and server I will have sender/listener code (actually on both the client and the server). The client sender code will accumuate non-priority commands into a buffer (for x amount of time or until x data size is reached). Then send this over as a batch. The server simply listens for the batch and processes it. It should be easy to break apart the packet into it's basic business objects. Since CSLA serializes out to a byte stream this seems like it would fit right in. I'm just wondering if the overhead may not be too great. I don't want to progress too far with CSLA just to find out that it isn't fast enough for my needs.</P>
<P>Can provide more detail if helpful.</P>
<P>Thanks,</P>
<P>Will</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>figuerres replied on Wednesday, October 25, 2006</h2><P>Hmmm....</P>
<P>Well I guess you could; a few things though to think about:</P>
<P>CSLA as-is was designed to use the network to follow a "request-reply" model</P>
<P>TCP has packet-re-try and such that work to make that model work</P>
<P>UDP is more of a "FIRE and FORGET" model</P>
<P>so you might want to look at what data you are working with and have both a TCP and UDP game connection - UDP for broadcast data</P>
<P>TCP for connected data.</P>
<P>your "OVERHEAD" will be in how you handle packets, binary/ text and such.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>wjcomeaux replied on Wednesday, October 25, 2006</h2><P>Yes, I am aware of the connectionless state of UPD as opposed to connected TCP. I do plan to use both as there are times when packet ordering and guaranteed delivery will be necessary. For the most part though UDP is going to be my primary method. Most of the packets will be things like "User is running forward". This can be sent a bunch of times if the user is holding down the UP arrow. Depending on how I interpret and process. I think it might be better to send a "User is running forward" when the upser presses the UP arrow and then send a "User has stopped running forward" when they release the key. Of course, things like this will have to be checked routinely for cases where the "stop running" packet is dropped on the network, but that's another issue alltogether.</P>
<P>My main concern ATM is whether or not CSLA will be a good fit. Obviously I will need business objects on the client and the server for things like Character, NPC, Item. The server actually sends updates to the client and responds to requests. The client presentation layer simply displays the current state of those business objects and responds to user input. I don't currently see any reason why CSLA won't work out but it's still in design and I'm sure I'm not seeing every facet clearly.</P>
<P>Will</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 26, 2006</h2>I would think that this would not work..&nbsp; if you use remoting over udp, and one of packets simply never arrives, I don't think the .net runtime will be able to deserialize your object.&nbsp; Obviously you can't work with part of an object's state missing, and I'd think that .Net itself would complain (that is, remoting isn't going to like it, never mind even getting to the Csla part).<br><br>That's really what you'll have to research; can remoting run over Udp.&nbsp; If it can, then give Csla a shot.. but you'll have to find a way to force errors to see how it reacts when that occurs.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>wjcomeaux replied on Thursday, October 26, 2006</h2><P>Well, no matter what method I use, the end result will have to be the same. There will be a .dll on the server and one on the client that is a library of the business objects. </P>
<P>For the most part, the finite state of things will be on the server. The client will simply send messages to the server for processing. The server itself can use remoting for it's various layers and that should work just fine.</P>
<P>On the client side, the business objects will be used but the messages between the client and server will not necessarily be serialized business objects (because of the UDP limitation). The client will simply send a message stating something like "Character11334 moved forward". The server would deserialize this packet and update the appropriate business object on it's end with this new information.</P>
<P>Regardless of how this works, I will need a consistent framework on both the client and server.</P>
<P>Also, I will definitely use the framework AS IS for administration applications (data entry and management).</P>
<P>I will investigate building in more functionality to the business objects to handle sending and recieving them over the wire (UDP style). I don't see where it will be very difficult.</P>
<P>Will</P>
<P>P.S. I've got a lot of work done on the templates for C# code generation. Right now I am trying to find where Kathleen embedded the VB comments at the top of each file indicating that it was automatically generated and should not be changed. VB comments don't work so well in a C# application. :)</P>
<P>&lt;EDIT&gt;Found it, TargetLanguage tags in the harness file.&lt;/EDIT&gt;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Friday, October 27, 2006</h2>Hey wjcomeaux,<br><br>Several months ago I implemented a robotics application for our participation at the RoboCup Rescue. In the end we chose for a cross-platform compatible C++ implementation, but before that I had also a look at dotnet. <br><br>Since we had a team of robots that needed to communicate, networking performance was one of the key parts of our investigations prior to choosing our approach. We didn't want the hassle of checking for lost messages as we would have to with UDP, so we only considered TCP connections. I have conducted several tests with the networking classes of dotnet (v2.0), and I found excellent performance.<br><br>Check System.Net.Sockets, the TcpClient and TcpListener classes. They let you implement your own low-level communication protocol and as far as we tested performance is fine. No need for UDP and all the overhead it brings when no package-loss is desired. The only reason we didn't choose dotnet was for the cross-platform compatibility of C++ that we favoured.<br><br>Bayu<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
