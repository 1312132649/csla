<html><header><title>CSLA and the new ASP.NET Web API</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA and the new ASP.NET Web API</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11201.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF posted on Tuesday, February 28, 2012</h2><p>I was going through some of the examples on the new web API that is part of the asp.net mvc 4 beta release.&nbsp; Does CSLA fit with the Web API model?&nbsp; I&#39;m new to ASP.NET MVC and am trying to figure out if I should consider the web API for use with CSLA.&nbsp;&nbsp;Thanks.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, March 02, 2012</h2><p>How do you want to use it?</p>
<p>I can see two ways it may be useful.</p>
<p>First, you can expose a web api that is backed by CSLA business objects. I haven&#39;t looked into this, but it makes sense to do this because a web api is just a service endpoint, and many people already implement their services (asmx or WCF) using CSLA objects. I expect the web api services will be very similar.</p>
<p>Second, the data portal might use the web api as a transport at some point. If the web api becomes the preferred model for communication or service hosting (over WCF) then it makes sense that the data portal would support a web api channel. That shouldn&#39;t really affect the way the data portal works - it would be another option in addition to WCF, asmx, Remoting, and Enterprise Services. (though to be fair, I essentially deprecated everything but WCF starting with CSLA 4).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>artsd replied on Sunday, March 04, 2012</h2><p>I am also interesting in building an ASP.NET Web API with CSLA. I am reading the CSLA 4 books (especially MVC) to try to understand this. I am hoping that there is a way to make the api without creating data transfer objects for every CSLA object I want to expose to the api. It looks like&nbsp;CSLA&nbsp;MVC has the CslaModelBinder that lets you directly use the CSLA objects themselves. I don&#39;t yet understand how the MVC controller knows that the posted data matches a particular object (when using the strong model binding technique). But that is a generic MVC question I have, not CSLA specific.</p>
<p>I also don&#39;t understand all the trouble the CSLA MVC Controller goes through to update an existing object by creating a new object. From the book:</p>
<p style="padding-left:30px;">An edit operation requires creating an instance of the business object, loading its properties with the postback data, and saving the object to update the data. This is a little challenging, because the default value of the IsNew property is true and so there needs to be a way to force a &ldquo;new&rdquo; object to be updated, not inserted.</p>
<p>Why not just load the object, update changed properties, and save? Doing the above technique prevents the use of optimistic concurrency using a &quot;last modified&quot; timestamp. It also seems to trust that the client is providing trusted input.</p>
<p>Any chance we will see a Csla.Web.Http.ApiController to match the Csla.Web.Mvc.Controller?</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, March 04, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>Arthur Dumas<br></b>
<p>Any chance we will see a Csla.Web.Http.ApiController to match the Csla.Web.Mvc.Controller?</p>
<p></div></p>
<p>I suspect that&#39;ll happen.</p>
<p>The thing to remember is that we only have so much time to work on this stuff, and there&#39;s a lot of things going on. ASP.NET MVC 4, Web API, .NET 4.5 (with big changes to Web Forms and the whole new async/await stuff), WinRT. And pretty soon another version of Windows Phone.</p>
<p>Perhaps even more important, I am happy to accept help :)&nbsp;&nbsp; </p>
<p>At some point I&#39;ll get time to research Web API. I can&#39;t say exactly when. In the meantime, I welcome any specific insight into the sorts of helpers necessary to make it work smoothly with CSLA objects. Or even more importantly, things that need to happen to core CSLA to support platform features.</p>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>artsd replied on Sunday, March 04, 2012</h2><p>I totally understand where you are coming from. When I look at the additions to CSLA just within the last year to support WinPhone, Mono, WinRT, it is an amazing amount of work -- whole new platforms that CSLA is supporting that didn&#39;t even exist 18 months ago.</p>
<p>If my research into Web API using CSLA produces anything I will be sure to get in touch. Right now I was trying to return an IEnumerable of a read-only root list just to see how this looked when serialized to xml and json. I haven&#39;t tried json yet but the xml didn&#39;t work. Got the following error:</p>
<p style="padding-left:30px;">You must write an attribute &#39;type&#39;=&#39;object&#39; after writing the attribute with local name &#39;__type&#39;</p>
<p>Found a thread here&nbsp;<a href="http://forums.asp.net/t/1773173.aspx/1?You+must+write+an+attribute+type+object+after+writing+the+attribute+with+local+name+__type+">http://forums.asp.net/t/1773173.aspx/1?You+must+write+an+attribute+type+object+after+writing+the+attribute+with+local+name+__type+</a>&nbsp;that describes another person having this problem but one of the proposed solutions was unworkable (decorating base class with&nbsp;<span class="pun">[</span><span class="typ">System</span><span class="pun">.</span><span class="typ">Runtime</span><span class="pun">.</span><span class="typ">Serialization</span><span class="pun">.</span><span class="typ">KnownType</span><span class="pun">(</span><span class="kwd">typeof</span><span class="pun">(</span><span class="typ">DerivedClassGoesHere</span><span class="pun">))] to describe every possible derived class!!! -- impossible to do when I have hundreds of CSLA classes and my base classes are in different assemblies from the real bus obj library). Hopefully the Web API team figures this out soon (they say they are working on it).</span></p>
<p><span class="pun">Edit -- did a little more digging in case anyone else is reading this. It looks like Web API uses normal XmlSerializer so I tried to use it to serialize my root read only list. It failed with some old junky base class property I had around that was IEnumerable&lt;object&gt; which I wasn&#39;t using. But then the next problem was with MobileDictionary. I suppose the whole reason the MobileDictionary exists is to solve serialization problems so I shouldn&#39;t be surprised.</span></p>
<p><span class="pun"><b>Why doesn&#39;t MobileDictionary implement IXmlSerializable?</b></span></p>
<p>I think I will take a try at using Peter Welter&#39;s serializable generic dictionary&nbsp;<a href="http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx">http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 05, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>Arthur Dumas<br></b>
<p><span class="pun">It looks like Web API uses normal XmlSerializer so I tried to use it to serialize my root read only list. It failed with some old junky base class property I had around that was IEnumerable&lt;object&gt; which I wasn&#39;t using. But then the next problem was with MobileDictionary. I suppose the whole reason the MobileDictionary exists is to solve serialization problems so I shouldn&#39;t be surprised.</span></p>
<p><span class="pun"><b>Why doesn&#39;t MobileDictionary implement IXmlSerializable?</b></span></p>
<div style="CLEAR:both;"></div>
</div></p>
<p>That&#39;ll be a problem then. At no point has CSLA ever supported XmlSerializer. In fact, several of the basic assumptions made by XmlSerializer are in direct conflict with basic assumptions made by CSLA.</p>
<p>XmlSerializer is designed specifically to serialize/deserialize data transfer objects. It assumes all objects have the following characteristics:</p>
<ul>
<li>Only public read/write properties (no read-only properties or normal data hiding capabilites allowed)</li>
<li>Public default constructor</li>
<li>Writing to a property never fails (no business or authorization rules allowed)</li>
<li>Writing to a property doesn&#39;t cause side-effects (no business rules allowed)</li>
<li>Objects can be created directly via constructor (no data portal or normal object initialization allowed)</li>
</ul>
<p>CSLA objects should be (or at least CSLA assumes they will be) designed with the following characteristics:</p>
<ul>
<li>Data will be protected via read-only and/or private properties as appropriate</li>
<li>Objects will be created using the data portal to get normal object initialization</li>
<li>Writing to a property can fail due to authorization rules</li>
<li>Writing to a property will cause side-effects - at least validation, if not outright business rules</li>
</ul>
<p><strong>BUT even that 180 degree mismatch isn&#39;t the REAL ISSUE.</strong></p>
<p>The real issue is that you don&#39;t want to expose your internal object model as your external service contract.</p>
<p>Your external service contract can&#39;t change. Once you&#39;ve exposed it, you will have unknown numbers of consumers working against your service contract, and if you change that contract then you break those consumers.</p>
<p>If your business object model IS your contract, then you can never change your business object model. I ask you: how will you maintain your application if you can&#39;t change your object model????</p>
<p>In other words, I have never felt any motivation to directly expose business objects via service interfaces, because that way lies madness. Or beyond that sea there be monsters. Whatever metaphor you&#39;d like to use for certain doom, feel free to insert it here :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>artsd replied on Monday, March 05, 2012</h2><p>I understand what you are saying about:</p>
<p style="padding-left:30px;"><span>The real issue is that you don&#39;t want to expose your internal object model as your external service contract.</span></p>
<p><span>I guess I saw that MVC users had an easy job and didn&#39;t have to create custom DTO -- could just use CSLA directly and use binding helper.</span></p>
<p>Was trying to be <span style="text-decoration:line-through;">lazy</span> efficient and not do the DTO. But you are of course correct that using CSLA as the DTO certainly ties your hands and is not the way to go.</p>
<p>So now I am working on a DTO base class that can return broken rule details in addition to normal properties. Will then make a helper to do to/from mapping. But also get the advantage of being able to more easily expose composite contract that is not just one-to-one with bus obj.</p>
<p>Thanks!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 05, 2012</h2><p>MVC users don&#39;t really have such an easy job though. They have to create a contract too, it is just in the form of a view. And it is a contract with a human, not another machine, but it is still a contract of sorts, and it still rearranges and/or hides the data.</p>
<p>What would be really cool (imo) would be something like an MVC view engine that worked with service contracts.</p>
<p>In fact, I wonder if you couldn&#39;t use Razor to accomplish that goal? Or if someone on the Web API side of things has thought of this sort of thing?</p>
<p>Why wouldn&#39;t the result of a service call be a type of view? A JSON or XML view to be sure, but still it would be a view.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Tuesday, March 13, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>[quote user=&quot;Arthur Dumas&quot;]</p>
<p><span class="pun">It looks like Web API uses normal XmlSerializer (...)</span></p>
<p>
<div style="CLEAR:both;"></div>
</div> </p>
<p>That&#39;ll be a problem then. At no point has CSLA ever supported XmlSerializer.</p>
<p>(...)</p>
<p></div></p>
<p>Good news!</p>
</p>
<p>&quot;We on the web team will be including JSON.NET as the default JSON Serializer in Web API when it releases, so that&#39;ll be nice.&quot;</p>
<p><strong>Scott Hanselman </strong>in <a href="http://www.hanselman.com/blog/OnTheNightmareThatIsJSONDatesPlusJSONNETAndASPNETWebAPI.aspx">http://www.hanselman.com/blog/OnTheNightmareThatIsJSONDatesPlusJSONNETAndASPNETWebAPI.aspx</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, March 13, 2012</h2><p>Probably not as good as it sounds. The JSON serializers have the same limitations as XmlSerializer...</p>
<p>In any case, the core architectural issue remains the same: you don&#39;t want to directly expose your internal implementation as an immutable external contract.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Friday, April 05, 2013</h2><p>This post is a year and two months old, but i believe the web api is becomming more and more the preferred model for communication (over WCF). REST services over SSL are secure enough and alot easier to implement. With 4.5 default being claim based and all those Identity providers lately... Just a bearer token in the header. Hense look at the WAAD (Windows Azure Active Directory) Graph API, microsoft is also just creating new services based on REST. Why would you still use WCF? Only when not using SSL HTTP WCF services or using stuff like MTOM. (or when the serializer aren&#39;t strong enough)</p>
<p>I did not believe in REST vs WCF a couple of years ago, but now i&#39;m turned.</p>
<p>imh CSLA should at least offer a ApiDataPortal for REST (if it will be possible)</p>
<p>PS: I believed in Silverlight a couple of years ago so i might be wrong again ;)</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Saturday, April 06, 2013</h2><p>I agree that Web API is becoming the preferred communication mechanism for non-enterprise scenarios, and for some enterprise scenarios.</p>
<p>The thing to keep in mind is that the data portal is an n-tier technology, so being &quot;open&quot; is not a design consideration.</p>
<p>It would be extremely easy to create a Web API data portal channel, and I may do this at some point. But it won&#39;t be RESTful or open. It will provide the exact same data portal behaviors you have today, by passing a binary byte array via a REST service.</p>
<p>For that matter, the data portal is an open architecture. You can easily implement your own transport channels (proxy/host pairs) to use any synchronous network technology of your choice. In other words you don&#39;t need to wait for me if you have a pressing need :)</p>
<p>I would recommend looking at the old asmx channel to see how I did that, because the Web API channel will work in essentially the same way - run the serializer to create a byte array, and pass or accept the byte array via the GET/PUT operations, then run the serializer on the receiving end to deserialize the byte array back into the object graph.</p>
<p>This hasn&#39;t been a high priority for me, because the REST people will hate what I&#39;ll do (with a passion), and it offers no value to anyone already successfully using WCF.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>andy replied on Thursday, April 24, 2014</h2><p>Very good discussion. &nbsp;Now I want to learn more about your new raw http channel.</p>
<p>Any resources?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 24, 2014</h2><p>Not yet, I did most of the implementation just yesterday and am still trying to optimize it before putting the code into CSLA itself.</p>
<p>My plan is to have it be a full data portal channel though, so it will be supported on (hopefully) all platforms, not just WinRT/WP8.1.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Peran replied on Thursday, April 24, 2014</h2><p>Hi Rocky,</p>
<p>A timely post!</p>
<p>I&#39;m currently starting a prototype using AngularJS in the browser and CSLA/WebApi on the server (JSON interface I assume).</p>
<p>I would be interested in trying your new code, so I can see your thoughts on how CSLA/WebApi play together, and whether I&#39;m heading in the right direction!</p>
<p>&nbsp;</p>
<p>Regards</p>
<p>&nbsp;</p>
<p>Peran</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kirkpabk replied on Monday, June 02, 2014</h2><p>Hey Rocky, be a fan for a while now--geez... has it been a decade already?? &nbsp;</p>
<p>Anyway--my two cents... wrestling one convention or practice in favor of another... relaxing constraints... I don&#39;t think that&#39;s what your community is necessarily trying to convey. &nbsp;Perhaps a comprise in that they are seeking a standardized interface with CSLA and WebAPI (perhaps OWIN/Katana based) which utilizes the CSLA (internal) mechanisms which improve the XMLSerializer issue, but interface such that when the XML or JSON serializers fail, simply issue up the best practice Http Status responses. &nbsp;Perhaps some extensions or helpers which help the controller authors interact with the back end a bit easier. &nbsp;</p>
<p>Long story short, I believe this can be growth and leveraging the best of both worlds while remaining true to the elements that make both widely accepted. &nbsp;Here&#39;s another thought, is it CSLAs responsibility to police (perhaps too strong--and not intended that way) the full pipeline of contracts? &nbsp;I tend to believe that there are conventions (both existing and emerging) which can be tailored to meet the goals of your product and the goals of so-called modern architecture without compromising each other.</p>
<p>Does this make sense? &nbsp;Keep up the good work!</p>
<p>v/r</p>
<p>BK</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF replied on Friday, June 06, 2014</h2><p>Something Rocky said in a more recent reply made me realize that I wasn&#39;t thinking correctly about my situation when I originally asked about the Web API.</p>
<p style="padding-left:30px;">&quot;The thing to keep in mind is that the data portal is an <em>n-tier technology</em>, so being &#39;open&#39; is not a design consideration.&quot;</p>
<p>This statement is extremely helpful. For my part, whether CSLA continues to use WCF or switches at some point to the WebAPI for its primary mechanism, it doesn&#39;t really matter in so far as it is taking care of the implementation for me. One less thing that I have to do...and since it is part of an n-tier application, I&#39;m not particularly concerned with whether it meets the open RESTful standards.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, June 06, 2014</h2><p>The current beta of 4.5 includes a new HttpPortal for the data portal that does use Web API if your data portal server is MVC 5. If your data portal server is MVC 4 the host is just a controller. The client doesn&#39;t care which server technology you are using.</p>
<p>This is not strictly RESTful of course, because this is a data portal channel that uses the exact same semantics as the WCF channel (and the Local/asmx/Remoting/EnterpriseServices channels).</p>
<p>You can switch from the WcfProxy to the HttpProxy and the client won&#39;t care - which is the whole point of the data portal.</p>
<p>I implemented this new HttpProxy/Portal channel because the new Windows Phone 8.1 WinRT environment doesn&#39;t support WCF, so I needed a new data portal channel for that platform.</p>
<p>It turns out though, that by using the new HttpClient API from Microsoft we now finally have a consistent client-side API for calling services, because HttpClient (via NuGet) is available for all platforms.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF replied on Friday, June 13, 2014</h2><p>&quot;the new Windows Phone 8.1 WinRT environment doesn&#39;t support WCF&quot;</p>
<p>Are you referring to WinRT <em>universal</em> apps?&nbsp;Also, is there a sample app showing the HttpProxy in use?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, June 13, 2014</h2><p>Universal apps yes, but the limitation is because WinRT on WP8.1 doesn&#39;t have WCF and universal apps use portable class libraries and those are limited by the lowest common denominator.</p>
<p>If you don&#39;t care about Windows Phone then this is a non-issue, but given my ongoing goal of making CSLA support all platforms it was something I had to take on as an issue.</p>
<p>The sample I&#39;ve been using to test this (and some other stuff) is</p>
<p><a href="https://github.com/MarimerLLC/csla/tree/master/Samples/WinRT/SimpleApp">https://github.com/MarimerLLC/csla/tree/master/Samples/WinRT/SimpleApp</a></p>
<p>At the moment the code is configured to use BrokeredProxy, which is a way for a WinRT app to use the data portal running in full .NET on the client device such that it can be called from a WinRT client.</p>
<p>But if you look at the two web projects you can see how the data portal controller is set up in MVC 4 and MVC 5 (page and web api respectively), and in the WinRT app.xaml.cs you can see the commented lines that configure HttpProxy on the client.</p>
<p>As you&#39;d expect, the rest is transparent - your only concern (as always) is configuring the client and setting up the server.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
