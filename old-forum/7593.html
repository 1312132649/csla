<html><header><title>DataDecoratorBase and PropertyStatus cause memory leaks</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>DataDecoratorBase and PropertyStatus cause memory leaks</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7593.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec posted on Wednesday, September 09, 2009</h2>Hi Rocky<br><br>After spending many hours tracing a performance issue in our WPF app I ran on the fact that the two classes have the following problems in connection with attaching and detaching event handlers:<br><br>1) DataDecoratorBase attaches to the data object's 'PropertyChanged' event 2 times, because the DataContext_Changed is in my case triggered before the Panel_Loaded call. <br><br>2) None of the objects (of mentioned types) unsubscribe from the 'PropertyChanged' event when the host form closes. The implication is grave: After you open a form for editing a business object it won't get collected until the BO gets unused too. This means that opening forms using the same BO (acting as a data source) will cause memory leaks.<br><br><br>I made a quick fix to these two classes and it works:<br>1) Unhook from the old and hook to the new data object event.<br>2) Always hook to the 'current' data object event if not hooked yet.<br>3) Always unhook from the 'current' object event if hooked yet<br><br>The 2) and the 3) are important because loaded and unloaded events can be called many times in a control's life - every time you attach and detach it from the visual tree (also by setting its Visibility to Collapsed). And the 3) is what is currently missing which cause the unsubscription after the form closes.<br><br>We're still using V3.6.2 but I also checked the source code of the Csla 3.7 and found no difference.<br><br><br>-- Jure<br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Thursday, September 10, 2009</h2><P>Would it be possible for you to&nbsp;provide your code changes?</P>
<P>I ran into an issue with the PropertyStatus losing its connection to the business object on a DataProvider 'Refresh' operation.&nbsp; I had to manually&nbsp;re-hook the Source to the PropertyStatus controls, and am wondering if your changes would fix this problem.</P>
<P>Thanks</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Friday, September 11, 2009</h2>I doubt that your issue has anything to do with the mine. From my understanding of how the 'PropertyStatus' control works I can assert that the control only subscribes itself to the 'PropertyChanged' event of the source object and listens to the changes. In my case the problem is that the control doesn't get deteached form the event until the source object dies. In your case I'm not sure what the problem is because I'm not sure what you mean with 'losing its connection' and I have almost no experience with the data provider control.<br><br>Anyway, here are the changes made to the ProertyStatus.cs:<br>1) Add the private field:<br>private bool _isAttachedToSource;<br><br>2) Add or modify methods<br>public PropertyStatus()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultStyleKey = typeof(PropertyStatus);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRules = new ObservableCollection&lt;BrokenRule&gt;();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Loaded += (o, e) =&gt; { UpdateState(); };<br>&nbsp;&nbsp;&nbsp; &nbsp; this.Loaded += new RoutedEventHandler(Control_Loaded);<br>&nbsp;&nbsp;&nbsp; &nbsp; this.Unloaded += new RoutedEventHandler(Control_Unloaded);<br>&nbsp;&nbsp;&nbsp; }<br><br>private void Control_Loaded(object sender, RoutedEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!_isHookedToPropertyChanged) AttachSource(Source);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private void Control_Unloaded(object sender, RoutedEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (_isHookedToPropertyChanged) DetachSource(Source);<br>&nbsp;&nbsp;&nbsp; }<br><br>private void AttachSource(object source)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Ignore the call if already attached.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (_isAttachedToSource) return;<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INotifyBusy busy = source as INotifyBusy;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (busy != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; busy.BusyChanged += new BusyChangedEventHandler(source_BusyChanged);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INotifyPropertyChanged changed = source as INotifyPropertyChanged;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (changed != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; changed.PropertyChanged += new PropertyChangedEventHandler(source_PropertyChanged);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; _isAttachedToSource = true;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; private void DetachSource(object source)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Ignore the call if not attached.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (!_isAttachedToSource) return;<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INotifyBusy busy = source as INotifyBusy;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (busy != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; busy.BusyChanged -= new BusyChangedEventHandler(source_BusyChanged);<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; INotifyPropertyChanged changed = source as INotifyPropertyChanged;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (changed != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; changed.PropertyChanged -= new PropertyChangedEventHandler(source_PropertyChanged);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; _isAttachedToSource = false;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br><br>-- Jure<br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jureleskovec replied on Tuesday, September 22, 2009</h2>No respond?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, September 22, 2009</h2><A href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=561">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=561</A></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
