<html><header><title>AmbiguousMatchFound in SL application</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>AmbiguousMatchFound in SL application</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8701.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman posted on Monday, March 22, 2010</h2><p>As I said in a previous post, I&#39;m trying to write a simple SL4 application that loads a read only list. I&#39;m following the Rolodex SL sample (which runs), VS2010 Beta 2, SL4 beta, CSLA 3.8.2.</p>
<p>I copied the WcfHostWeb project from Rolodex and added it to my solution. I changed the port numbers , assembly name and default namespace&nbsp;so there wouldn&#39;t be any conflict. Is this sufficient or did I skip something important here (I&#39;m not a web developer, so I don&#39;t know what I don&#39;t know.)</p>
<p>I&#39;m using the conditional compilation strategy used in the Rolodex sample.</p>
<p>I have&nbsp;set the proxy type to SynchronizedWcfProxy an App.xaml.cs, again, just like the Rolodex solution.</p>
<p>Stepping through both applications I get to SynchronizedWcfProxy.RunSynchronized and call worker.RunWorkerAsync(). The calls stack look very similar.</p>
<p>&nbsp;&gt;&nbsp;Csla!Csla.DataPortalClient.SynchronizedWcfProxy&lt;BusinessLogic.ReadOnlyIntellifolders&gt;.RunSynchronized(System.Delegate method = {System.Action}, object[] arguments = {object[0]}) Line 255&nbsp;C#<br />&nbsp;&nbsp;Csla!Csla.DataPortalClient.SynchronizedWcfProxy&lt;BusinessLogic.ReadOnlyIntellifolders&gt;.BeginFetch() Line 74&nbsp;C#<br />&nbsp;&nbsp;Csla!Csla.DataPortal&lt;BusinessLogic.ReadOnlyIntellifolders&gt;.BeginFetch() Line 187 + 0x45 bytes&nbsp;C#<br />&nbsp;&nbsp;BusinessLogic!BusinessLogic.ReadOnlyIntellifolders.GetReadOnlyIntellifolders(System.EventHandler&lt;Csla.DataPortalResult&lt;BusinessLogic.ReadOnlyIntellifolders&gt;&gt; handler = {System.EventHandler&lt;Csla.DataPortalResult&lt;BusinessLogic.ReadOnlyIntellifolders&gt;&gt;}) Line 52 + 0xb bytes&nbsp;C#<br />&nbsp;&nbsp;[Native to Managed Transition]&nbsp;<br />&nbsp;&nbsp;[Managed to Native Transition]&nbsp;<br />&nbsp;&nbsp;Csla!Csla.Reflection.MethodCaller.CallFactoryMethod(System.Type objectType = {BusinessLogic.ReadOnlyIntellifolders}, string method = &quot;GetReadOnlyIntellifolders&quot;, object[] parameters = {object[1]}) Line 308 + 0xf bytes&nbsp;C#<br />&nbsp;&nbsp;Csla!Csla.Silverlight.CslaDataProvider.Refresh() Line 408 + 0x2b bytes&nbsp;C#<br />&nbsp;&nbsp;Csla!Csla.Silverlight.CslaDataProvider.Data.get() Line 210&nbsp;C#<br />&nbsp;&nbsp;[Native to Managed Transition]&nbsp;<br />&nbsp;&nbsp;[Managed to Native Transition]&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.CLRPropertyListener.Value.get() + 0x32 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.PropertyAccessPathStep.ConnectToPropertyInSource(bool isSourceCollectionViewCurrentItem) + 0x231 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.PropertyAccessPathStep.ConnectToProperty() + 0x35 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.PropertyAccessPathStepDescriptor.CreateStep(System.Windows.PropertyPathListener listener, object source, bool listenToChanges) + 0x40 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.PropertyPathListener.ConnectToSource(System.Windows.PropertyPath path = {System.Windows.PropertyPath}, object source, bool listenToChanges = true) + 0x3a bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.Data.BindingExpression.ConnectToSource() + 0x4f bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.Data.BindingExpression.OnAttach(System.Windows.DependencyObject d, System.Windows.DependencyProperty dp) + 0x2cf bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.DependencyObject.SetValueInternal(System.Windows.DependencyProperty dp = {System.Windows.CustomDependencyProperty}, object value, bool allowReadOnlySet) + 0x22a bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding) + 0xd1 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.Data.Binding.MS.Internal.IMarkupExtension.SetupExtension(object target, object property) + 0x49 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!MS.Internal.FrameworkCallbacks.SetBindingForObject(System.IntPtr nativeTarget, string propertyName, uint nKnownIndex, System.IntPtr nativeBinding, string attachedDPOwnerNamespace, string attachedDPOwnerAssembly) + 0xfc bytes&nbsp;<br />&nbsp;&nbsp;[Managed to Native Transition]&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!MS.Internal.XcpImports.Application_LoadComponent(MS.Internal.INativeCoreTypeWrapper componentAsDO, string resourceLocator, System.IO.UnmanagedMemoryStream stream, uint numBytesToRead) + 0x6b bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!System.Windows.Application.LoadComponent(object component, System.Uri resourceLocator) + 0x91 bytes&nbsp;<br />&nbsp;&nbsp;MyClxWeb!MyClxWeb.FolderList.InitializeComponent() Line 59 + 0x28 bytes&nbsp;C#<br />&nbsp;&nbsp;MyClxWeb!MyClxWeb.FolderList.FolderList() Line 21 + 0x8 bytes&nbsp;C#<br />&nbsp;&nbsp;MyClxWeb!MyClxWeb.App.Application_Startup(object sender = {MyClxWeb.App}, System.Windows.StartupEventArgs e = {System.Windows.StartupEventArgs}) Line 30 + 0x15 bytes&nbsp;C#<br />&nbsp;&nbsp;System.Windows.dll!MS.Internal.CoreInvokeHandler.InvokeEventHandler(int typeIndex, System.Delegate handlerDelegate, object sender, object args) + 0x991 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.dll!MS.Internal.JoltHelper.FireEvent(System.IntPtr unmanagedObj, System.IntPtr unmanagedObjArgs, int argsTypeIndex, string eventName) + 0x2e4 bytes&nbsp;<br />&nbsp;&nbsp;[Appdomain Transition]&nbsp;</p>
<p>However, when worker.RunWorkAsync is executed, I never get into my BO&#39;s DataPortal_Fetch method and ultimately end up with Ambiguous match found error. What is the ambiguous method? I can see in the call stack references to my Read only list&#39;s factory method (GetReadOnlyIntellifolders). Given that this method appears in both the server BO assembly and the client BO assembly, is this the ambiguous match?</p>
<p>I&#39;ve been stumped on this for days now...</p>
<p>Thanks,</p>
<p>Kevin</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, March 22, 2010</h2><p>This exception typically comes when the data portal can&#39;t get .NET to uniquely identify the right method to invoke. And that means you probably don&#39;t have an exact match between the parameter type you pass to BeginFetch() and the parameter type on your DataPoral_Fetch() method.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman replied on Monday, March 22, 2010</h2><p>Thanks Rocky...that was it.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
