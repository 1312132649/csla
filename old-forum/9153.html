<html><header><title>Queueing Asynchronous Requests</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Queueing Asynchronous Requests</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9153.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>edreyes77 posted on Wednesday, June 30, 2010</h2><p><span style="font-family:&#39;Verdana&#39;,&#39;sans-serif&#39;;font-size:10pt;">Mr Rockford:<br />&nbsp;<br />I have a question about loading different data aynchronously into several different ViewModels/Models on initialization.</span><span style="font-family:&#39;Verdana&#39;,&#39;sans-serif&#39;;font-size:10pt;"><br />I have a Silverlight client using just a WCF Service getting data from various sources. My Silverlight client is using the BxF framework and using CSLA Business Objects.&nbsp; When I switched to BxF I found an initialization issue.&nbsp; <br />&nbsp;<br />I use to load all my data from a csla dataportal and when I received a reply I would then&nbsp;ask for more initialization data and continue until I received all the data I wanted.&nbsp; It was literally requesting more data in Callbacks from the last request.&nbsp; I did not like it at all, but it got the job done and let me focus on other things.&nbsp; <br />&nbsp;<br />now that I am using BXF, in the MainPagePresenter, I use the region to set some content window properties:<br />&nbsp;<br />presenter.OnShowView += (view, region) =&gt; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (0 == region.CompareTo (&quot;EntityPanel&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EntityPanel = view.ViewInstance;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (0 == region.CompareTo (&quot;ReportTypePanel&quot;)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReportTypePanel = view.ViewInstance;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;};<br />&nbsp;<br />This works well, I have a lot more content to show and was wondering if this is the right way to do this?&nbsp; It can get messy I think.&nbsp; <br />&nbsp;<br />But the real issue is that, I want to do this to get all my initialization data:<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;Bxf.Shell.Instance.ShowView (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof (NavigatorEntities).AssemblyQualifiedName,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;entityViewModelViewSource&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new EntityListViewModel (),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;EntityPanel&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;Bxf.Shell.Instance.ShowView (<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typeof (NavigatorReportTypes).AssemblyQualifiedName,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;reportTypeViewModelViewSource&quot;,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ReportTypeListViewModel (),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ReportTypePanel&quot;);<br />But If I don&#39;t comment the second message and allow it to run then the second callback will come back as a timeout error.&nbsp; I use to get around that my daisy chaining requests for more data in my callbacks.&nbsp; But I placed the callbacks in my respective ViewModels and I can&#39;t really daisy chain more requests for more required data.&nbsp; Can you suggest what I might do?&nbsp; I thought about using MSMQ, but that seems like an extreme thing to do.&nbsp; I am sure I will run into situations like this over and over again. my WCF Service ordinarily would send this message to another Application Server, but I need to be able to handle one SL Client with only one Broker and one Application Server.&nbsp; I can&#39;t predict in the future how many requests I will have cueued up from a WCF Service, and i don&#39;t want to have a whole bunch of Application Servers running just to suffice multiple queues from one client.</span></p>
<p><span style="font-family:&#39;Verdana&#39;,&#39;sans-serif&#39;;font-size:10pt;">I think if I was writing the Application Server at this time as well then I would probably sandwich a request/reply to get all initialization data at one time, but it&#39;s legacy code that I am starting a migration path for it to be rewritten and broken apart and distributed and still have everything running.&nbsp; And either way, I still need to handle getting lots of data in a chaining mechanism.&nbsp; Would workflow work here?</span></p>
<p><span style="font-family:&#39;Verdana&#39;,&#39;sans-serif&#39;;font-size:10pt;">Ed</span></p>
<p><span style="font-family:&#39;Verdana&#39;,&#39;sans-serif&#39;;font-size:10pt;"><br /></span></p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Wednesday, June 30, 2010</h2><p>These sound like menu items you are loading? A list of entities and a list of reports?</p>
<p>You aren&#39;t accidentally using the SynchronizedWcfProxy data portal channel or something?</p>
<p>The data portal should allow multiple concurrent server requests to run independently. There are limits (set by Windows) on how many outstanding requests can run at a time, but certainly 2 requests can run concurrently.</p>
<p>Your &quot;new EntityListViewModel()&quot; line of code, for example, almost certainly returns instantly right? It just does a BeginRefresh() to start the async load, and that&#39;s it?</p>
<p>So what should happen with the code you show, is that the entity view and viewmodel should initialize and be displayed, then the report view/viewmodel - and at some point after they&#39;ve been displayed, their data will arrive and appear on the screen.</p>
<p>I don&#39;t think workflow will help - at least WF - since that&#39;s a server-side construct. Or is your problem that the two server requests are blocking each other on the server for some reason?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>edreyes77 replied on Friday, July 09, 2010</h2><p>you are right.&nbsp; The dataportal allows multiple server requests and so does my wcf service.&nbsp; But the application servers do not allow multiple concurrent requests.&nbsp;&nbsp; This is an issue that needs to be fixed by either queueing messages at the client, or in the middle wcf service.&nbsp; I am not allowed to change the application server.&nbsp; I think queueing at the client would be the cleanest.&nbsp; I have a Bridge that is a simple singleton object to all my methods in my business objects that will create asynchronous calls to a wcf service.&nbsp; I think this would be a good place to insert some type of orchestration, what I thought would be a WF function.&nbsp; Maybe not.&nbsp; </p>
<p>Ed</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, July 10, 2010</h2><p>Queuing at the client seems somewhat pointless, at least if you have more than one user? Wouldn&#39;t multiple users conflict as well?</p>
<p>It seems like your only option is to implement a queuing scheme on your app server (on the server-side of the data portal), so you block client requests until they can be handled by your single-process server. You could run into timeout issues doing this though, so some serious testing is indicated...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, July 10, 2010</h2><p>One last thing though. If by some strange miracle multiple users can&#39;t conflict, but requests from one user do (which I can&#39;t understand), you might look at the SynchronizedWcfProxy. Its purpose is for testing, but it does client-side blocking to ensure that only one data portal request is sent to the server at a time. I never envisioned it being used for production purposes, since it obviously has a terrible impact on throughput in a real app - but it might be pretty close to what you need.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
