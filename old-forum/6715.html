<html><header><title>OT: At what point does the number of interfaces implemented by a class become a problem?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OT: At what point does the number of interfaces implemented by a class become a problem?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6715.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Wednesday, April 01, 2009</h2><P>As we have grown our CSLA-based application over the 18 months we have been working on it, we have discovered over time that we want to use different classes in the same context and have been gradually adding interfaces to them. So far, the most I have in one class is in the range of 5-10.</P>
<P>The vast majority of them have only a few members, and in&nbsp; a few cases only 1. </P>
<P>What potential pitfalls lurk as the number of implemented interfaces increase? Or should I not worry about this at all?. Without knowing for sure, I'd expect that casts might become increasingly expensive, but otherwise I can't think of what practical impact it they would have. &nbsp;</P>
<P>I freely admit that I&nbsp; am comparatively new to C# and come from long C++ background where I didn't have interfaces at all.&nbsp;So having the ability to have completely unrelated classes share a common interface that lets them be&nbsp;used in the same place is like being a kid in a candy store... :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, April 01, 2009</h2>It depends.. are your objects still just focusing on fulfilling one use case?&nbsp; Or are you starting to reuse the same objects across different use cases?&nbsp; If it's the latter, you really need to be careful, because your BO will become more complex and less maintainable.&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, April 01, 2009</h2><P><FONT face=Tahoma size=2>Interfaces are used everywhere in .NET.&nbsp; All the value types implement 5 interfaces, plus they have the Serializable attribute (which could have been implemented using ISerializable instead).&nbsp; I built an object for one of our company libraries that we use like a value type, and it implements 6 interfaces, as well as being marked Serializable.&nbsp; No one has complained about performance, and the interfaces are there so that the object plays nice with all the .NET stuff.</FONT></P>
<P><FONT face=Tahoma size=2>Admittedly, you're probably not building BO's that are intended to work as .NET value types, so let's look at an example a little closer to home - BusinessBase.&nbsp; The 3.0 version (the only code I currently have available to me) implements five interfaces, as well as inheriting from&nbsp;base classes that add two more.&nbsp; I'm pretty sure later versions don't change that.</FONT></P>
<P><FONT face=Tahoma size=2>As Andy said, I don't think it's the number of interfaces in use as much as how they're affecting the use of your class.&nbsp; If you were marking your classes with 15 or 20 of them, I might ask why, and whether there's a better way of structuring what you need.&nbsp; Heck, I might even ask&nbsp;on those where you're implementing 10.&nbsp; But I wouldn't look at it from a performance perspective - I'd look at it from a maintainability/use perspective.&nbsp; Since you're talking about "completely unrelated classes... [being] used in the same place", that makes me wonder a little.&nbsp; But since I don't know anything about your project, I can't comment any more beyond some vague personal preferences/feelings.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, April 01, 2009</h2><P>Thanks for both replies. When I said "completely unrelated", I mainly meant that one is neither an ancestor nor descendant of the other from an inheritance perspective. </P>
<P>Usually what I am trying to do by adding an Interface is to reuse behavior from one previously existing&nbsp; BO in a new BO. </P>
<P>What usually happens is that all the necessary methods exist in one class, and I'm trying to extend that behavior to another class. So, I make an interface out of the required methods in the original class (which already implemented them anyway), and then add the interface to the new class and implement the necessary methods.</P>
<P>My situation may differ from the common one in that very few, if any of our concrete BO classes directly derive from a CSLA class, there is always an intervening classes that form our own application framework. &nbsp;The interfaces are usually in these intervening classes.&nbsp; </P>
<P>I also add interfaces for common functions I want to get to because anything derived from CLSA has generic parameters, and so you need something common to cast to get to the common function. </P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
