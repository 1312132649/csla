<html><header><title>Example LinqBindingList Usage</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Example LinqBindingList Usage</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6610.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>justin.fisher posted on Monday, March 16, 2009</h2><P><FONT face="Courier New">I am using the 3.6.0 version of the framework. </FONT><FONT face="Courier New">I have a editable root object that contains an editable child list.&nbsp; </FONT></P>
<P><FONT face="Courier New">I have a winform with two binding sources:</FONT></P>
<OL>
<LI><FONT face="Courier New">bsParent.DataSource = _parent;</FONT></LI>
<LI><FONT face="Courier New">bsChildList.DataSource = LinqBindingList&lt;ChildObjectType&gt; returned from a Linq query against _parent.&nbsp;</FONT></LI></OL>
<P><FONT face="Courier New">Filtering, applying changes, and saving of the list are working fine but when </FONT><FONT face="Courier New">I call CancelEdit on the parent object there is no change to the editable child list?&nbsp; </FONT></P>
<P><FONT face="Courier New">I have reviewed the Project Tracker sample and read over the Linq to CSLA section of the Expert Business Objects 2008 book but I'm still not clear how to use the LinqBindingList?&nbsp; Does someone have some example code illustrating the intended usage of the LinqBindingList beyond the simple sorting in ProjectTracker?</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 16, 2009</h2><P>Did you call BeginEdit() on _parent before doing any binding?</P>
<P>The rules imposed by Windows Forms data binding are very strict, and are explained in some detail in the <EM>Using CSLA .NET 3.0</EM> ebook. The CslaActionExtender control discussed in the <EM>Expert 2008 Business Objects</EM> book helps wrap a lot of the complexity, but the rules are still very strict.</P>
<P>If you expect a CancelEdit() on _parent to undo anything in the child objects, you must unbind all objects before making that call, and you must have called BeginEdit() on _parent before setting up any binding. This is all stuff that CslaActionExtender automates - so it is worth taking a look at it.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>justin.fisher replied on Monday, March 16, 2009</h2><font face="Courier New">I refreshed my memory by reviewing the data binding portion of the CSLA 3.0 eBook.&nbsp; Apparently I was forgetting a key step in the RebindUI code, I did not reset the child's binding source correctly:<br><br><b>:Broken code</b><br>UnbindBindingSource(bsChild, saveObject, false);<br>UnbindBindingSource(bsParent, saveObject, true);<br><br><b>:Working code</b><br></font><font face="Courier New">UnbindBindingSource(bsChild, saveObject, false);<br>
UnbindBindingSource(bsParent, saveObject, true);<br>
bsChild.DataSource = bsParent; //added this line<br><br>The datagrid is working great when bound directly to the child list.&nbsp; I am able to apply changes, cancel changes, and save the list. The problems arise when I use Linq To CSLA to filter down bsChild.<br><br>I have a tree view control which a user can click to execute the the following code:<br><br>var myParent = bsChild.DataSource as Parent;<br>bsChild.DataSource = <br>&nbsp; from items in myParent.ChildList<br>&nbsp; where items.Name.Contains(e.Node.Text)<br>&nbsp; select items;<br><br>This approach seems to work fine for filtering the tree but throws an UndoException when I am trying to run the same cancel code that works fine for the unfiltered list.&nbsp; I realize that after running the query that bsChild.Datasource is now using a Csla.LinqBindingList&lt;childListItem&gt;, but I was under the impression that this would function just as if I were bound directly to the child?<br><br>I realize this is a lengthy post and I appreciated any feedback anyone may have on with this.<br><br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, March 17, 2009</h2><P>I am not sure if this code:</P>
<P><FONT face="Courier New">&nbsp;from items in myParent.ChildList<BR>&nbsp; where items.Name.Contains(e.Node.Text)<BR>&nbsp; select items;</FONT><BR></P>
<P>should be changed to this:</P>
<P><FONT face="Courier New">&nbsp;from items in myParent.ChildList<BR>&nbsp;where items.Name.Contains(e.Node.Text);<BR></FONT></P>
<P><FONT face="Courier New">I thought someone mentioned that there is no need for the select when a LinqBindingList is involved.</FONT></P>
<P><FONT face="Courier New">I have no idea about the cancel problem.</FONT></P>
<P><FONT face="Courier New">I do know that the LBL is a wrapper around the original list. And that the LBL maintains a cross reference of index positions between the original list and the result of your query. If you step into the LBL code you can see that it builds a sorted subset of the list to meet the query criteria and then uses that sorted subset to build the cross reference index and discards the subset itself.</FONT></P>
<P><FONT face="Courier New">When databinding calls the indexer (Default Item Property in VB)&nbsp;it passes in 0,1,2 etc in sequence. The LBL looks up each index and returns the cross referenced value and then uses that to look up the item in the original list and returns that item to be data bound. </FONT></P>
<P><FONT face="Courier New">So you can see that it does do the actual work against the "original list". Just in the ordered&nbsp;defined by your query.&nbsp; </FONT></P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>justin.fisher replied on Tuesday, March 17, 2009</h2><P><FONT face="Courier New">I was unable to remove the 'select criteria' portion of my linq query, the compiler seems to require it.&nbsp; After&nbsp;giving&nbsp;this problem some additional thought,&nbsp;I realized that my question may be more fundamental.&nbsp; </FONT><FONT face="Courier New"><STRONG><EM>Who should store the LBL result of the Linq query?&nbsp; Is there anything special (unbinding, call BeginEdit) I need to do before making the assignment?</EM></STRONG>&nbsp; </FONT></P>
<P><FONT face="Courier New">When I set things up in code the parent's binding souce is attached to the parent object and the child biding source is attached to the parent with a datamember attribute designating the child list as the attribute it should bind to.&nbsp; When I am handling the tree view node click I am resetting the childs binding source and I suspect this may be where my problem lies?&nbsp; </FONT></P>
<P><FONT face="Courier New">Does anyone have an example illustrating filtering of a child list using Linq that keeps the n-level undo functionality in tact?</FONT></P>
<P><FONT face="Courier New"></FONT>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>justin.fisher replied on Wednesday, March 18, 2009</h2><font face="Courier New">Apparently the problem I was having had nothing to do with the fact that I was binding to a LinqBindingList.&nbsp; It was a classic problem with windows forms data binding to a datagridview control.<br><br>I used the DataBinding section of the CSLA 3.0 eBook as a guide and implemented the BindUI and RebindUI as was descirbed in that section.<br><br>That fixed most of the problems.&nbsp; I was able to work with the datagrid normally and get the expected behavior when cancelling, applying, and saving the business object.&nbsp; If I clicked on a specific node (filtered the results which meant bsChild.DataSource was now of type Csla.LinqBindingList&lt;childListItem&gt;) and made changes there then I would get the dreaded UndoException with an edit level mismatch.&nbsp; I read over <a href="/forums/thread/98.aspx?View=Threaded">this forum post</a>&nbsp; as it discussed some of the nuances of the databind process and it was very instructive. &nbsp;<br><br>The problem was the result of my changing the child binding <br>source's data source without removing the bindings first.&nbsp; The<br>result of this was that the child objects would always have an edit level mismatch with the parent.<br><br>To fix this I simply removed the bindings completely from the child binding source prior to resetting it to the result of a Linq To CSLA query.&nbsp; This is such an improvement over my old way of filtering, which consisted of a round trip to the database to filter it on the server.&nbsp; The initial headache of figuring out the process of filtering the data was more than made up for with the performance gains of in memory filtering.<br><br><u>Below is the code in the tree view node click event:<br><br></u><font size="2">// Disable events on the child's binding source<br>bsChild.RaiseListChangedEvents = false;<br><br>// Retrieve the parent business object from the <br>// binding source datasource.<br>var myParent = bsParent.DataSource as Parent;<br><br>// Ensure the datasource had a parent object bound to it<br>if (myParent != null)<br>{<br>&nbsp; // Unbind the child object from the binding source<br>&nbsp; UnbindBindingSource(bsChild, false, false);<br>&nbsp; <br>&nbsp; // Reset the child binding source's data source to the <br>&nbsp; // result of a Linq to CSLA query.&nbsp; Changes will map back<br>&nbsp; // to the parent object's BusinessListBase property<br>&nbsp; bsChild.DataSource = <br>&nbsp;&nbsp;&nbsp; from item in myParent.ChildListProperty<br>&nbsp;&nbsp;&nbsp; where item.Name.Contains(e.Node.Text)<br>&nbsp;&nbsp;&nbsp; select item;<br>}<br><br>bsChild.RaiseListChangedEvents = true;<br>bsChild.ResetBindings(false);</font></font></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
