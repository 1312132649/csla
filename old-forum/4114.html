<html><header><title>Design gone wrong?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Design gone wrong?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4114.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Thursday, January 03, 2008</h2>Hi,<br><br>I have a new requirement which is proving rather difficult.&nbsp; <br><br>I have a quoting system, so of course there are line items.&nbsp; It's not a flat list, because certain line items may contain other line items. Here's what I have, and why.<br><br><b>SimpleLineItem</b> - a line item which has behaviors for a simple product.&nbsp; You can change quantity and some users may change the unit price.&nbsp; <br><b>NoteLineItem</b> - a line item which has every property "empty," except description which any user may change.<br><b>SubTotalLineItem</b>, <b>RunningSubTotalLineItem </b>- sums the unit price, tax, ext. price of items above it.&nbsp; SubTotal stops when it encounters another sub total or the "top" of the document, running only stops at the top.<br><b>DiscountLineItem </b>- computes its unit price, tax, ext. price based on the line immediately above it.<br><b>BankingFeeLineItem </b>- a fixed fee line item<br><b>PackingFeeLineItem </b>- a calculated fee line item, which doesn't include other fees in its calculation.<br><b>CustomLineItem </b>- allows editing of part number, description, taxable and unit price.<br><b>BundleLineItem </b>- we have product bundles; this item is always tied to a product which is a bundle and contains BundleSubLineItems.&nbsp; These sub items are not modifiable at all.&nbsp; The sub items must be present so that internally we can see them but externally customers cannot.<br><b>GroupLineItem </b>- functions as a kind of custom bundle.&nbsp; This is created by selecting one or more Simple or Custom line items and selecting group.&nbsp; The price of the group is calculated by adding the prices of the items in the group.&nbsp; It's possible to set a quantity for the group item or its sub items, all which affect price.&nbsp; GroupLineItem has an Items colleciton of <b>GroupSubItem</b>, which has an Item property which exposes the item contained in the sub item.&nbsp; The sub item functions like a decorator.<br><b>LineItem </b>- an internal abstract class from which all other items inherit to get common behaviors.<br><br>All non-sub items may be moved up or down the document (in addition to cut/copy and pasted).&nbsp; Items in a group can't be reordered.<br><b>IContainerLineItem </b>- interface implemented by both Group and Bundle item, provides a common Items property.<br><br><b>LineItemList </b>- internal list which is how everything is stored in memory.&nbsp; The UI doesn't see this.&nbsp; If there's a bundle item (with seven sub items), discount and two simple, there will be four items here.<br><b>LineItems </b>- the public list which the UI manipulates.&nbsp; It's a view which maps actions back to the LineItemList.&nbsp; There would be 11 items here, because this view flattens the hierarchy.<br><br>Everything works and fits together nicely... until the users want to be able to put bundle items into groups.&nbsp; Opps... everything was geared to at most one level deep, now in one particular case everything falls apart.<br><br>I actually have it working mostly, although there is a warning flag going off.&nbsp; The LineItems class now does two checks; as it flattens the list, it attempts to cast the current item to IContainerLineItem (which is implemented by both Bundle and Group line items).&nbsp; Before, that's all that was needed.&nbsp; Now I'm also attempting to cast to the concrete GroupSubItem.&nbsp; If that works, I cast the GroupSubItem.Item to IContainerLineItem to get it's Items properties.&nbsp; <br><br>So that feels a bit off.&nbsp; The real wall I'm hitting though is getting the internal order form printed.<br><br>Say you have this:<br><br>5 - Group 1<br>&nbsp;&nbsp;&nbsp; 2 - Bundle 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2 - Simple 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 - Simple 2<br>10 - Simple 1<br>15 - Simple 2<br><br>It should show up on the order form like this:<br><br>30 - Simple 1<br>45 - Simple 2<br><br>I have a way to get the bundle sub item to take its parent's quantity into account, but I'm not sure how to get the bundle to also multple by it's containing group line item.<br><br>Any suggestions?&nbsp; Did I mess up the design orginally, or is this a case of the use case changing causing large changes all around?&nbsp; Anyone have a cleaner design? <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, January 04, 2008</h2><P><FONT face=Tahoma size=2>I wouldn't say it's a messed-up design.&nbsp; I think it may be a little overly complex in some areas.</FONT></P>
<P><FONT face=Tahoma size=2>These part-whole hierarchies are always a bit of a tough nut.&nbsp; I've never been a fan of an explosion of leaf classes, which is kinda what you have here.&nbsp; I will readily concede that a use-case-driven design could lead to this, and there's no real good alternative.&nbsp; You're either checking against a ton of different types, or you're checking against some kind of type property.&nbsp; Which is better?&nbsp; OO design will say different types - but OO design will also say that you should include methods in the base class so that you can treat the subtypes the same.</FONT></P>
<P><FONT face=Tahoma size=2>If you look at the GoF Composite pattern - which is what most people would probably say you should be using - the issues with the pattern center around what you're dealing with.&nbsp; If you include a child collection at the base level, then you have to define behaviors for types that, by definition, will never have any children.&nbsp; You also potentially incur an object graph overhead, since said child collection will exist at every level, whether you need it or not.</FONT></P>
<P><FONT face=Tahoma size=2>(OK - enough of this theory crap.&nbsp; Let's get&nbsp;to some real advice, huh?&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />)</FONT></P>
<P><FONT face=Tahoma size=2>I don't see a need for GroupSubItem, since all it seems to do is expose a property to the actual object you care about.&nbsp; Since the items are, by this definition, still editable within this context, GroupSubItem seems to be getting in the way.</FONT></P>
<P><FONT face=Tahoma size=2>One possible simplification I see is to take your collection-based line items and combine them into one class.&nbsp; Realizing that BundleLineItem and GroupLineItem aren't the same thing, when you boil it down, they aren't all that different.&nbsp; BundleLineItems contain non-editable (and, in some cases, non-viewable) children; GroupLineItems don't have that restriction.&nbsp; Presumably, pricing is basically the same - it's the sum of the individual parts.&nbsp; Especially if you get rid of the GroupSubItem, you might be able to combine both of those.</FONT></P>
<P><FONT face=Tahoma size=2>In the end, I think you're going to have to get to some kind of Composite hierarchy in order to protect yourself.&nbsp; You designed for one level of nesting, and now they want two.&nbsp; How long before they want three, four, etc.?&nbsp; Also, I think you may want to step back from the individual line-item use cases to do some consolidation.&nbsp; I see line items that look to have been created to fulfill mostly UI-related functions.&nbsp; I realize that putting that kind of logic in the UI isn't as helpful, but the alternative is what you have here.</FONT></P>
<P><FONT face=Tahoma size=2>The one crucial thing (crucial to my way of thinking, at least) is that order is important to you.&nbsp; Since you have line items that function on the previous one, or previous ones, in the list, the order of items must be preserved.&nbsp; That would include in the database.&nbsp; So my thoughts were centered around this.&nbsp; It's an odd implementation of a Composite pattern, but it might make your life easier - and you've already started at least some of it.</FONT></P>
<P><FONT face=Tahoma size=2>Your LineItems collection flattens your hierarchy.&nbsp; What if that was your one (and only) collection?&nbsp; Since order is important, you'd need to introduce two concepts: depth and sequence.&nbsp; Sequence is contained by depth, and depth is relatively self-explanatory.&nbsp; Then you only have one collection - the collection of LineItems off your quote.&nbsp; You'd want to build routines that allow a lineitem to find their next sibling, previous sibling, parent, etc.&nbsp; But then your grouping/bundling could become easier, and you automatically support any level of nesting you need without generating some sort of complex object graph.&nbsp; Grouping items merely requires a bit of re-ordering and some depth/sequence updates.&nbsp; It removes the "what do I do with child collections in leaf objects" question.&nbsp; You can still store parent-object references - they just point to an object higher up in the list.&nbsp; That way, parent-level properties can easily be retrieved (for something like the bundle children quantity multiplication).</FONT></P>
<P><FONT face=Tahoma size=2>I realize this probably ends up looking a lot like your database layout, and I'm not advocating a data-driven design.&nbsp; You can still have your different line items.&nbsp; But you'd also want to push as much functionality into the base LineItem class as you can.&nbsp; That way, your flattened collection can treat line items the same.</FONT></P>
<P><FONT face=Tahoma size=2>I also realize that, if you push your functionality into the base LineItem, you could still do a standard object graph.&nbsp; Using recursive routines, that's still not too hard to process.&nbsp; But, from your description,&nbsp;it feels like the&nbsp;flattened hierarchy is the more dominant form.&nbsp; Add in the need to "promote" child objects to the parent level for purposes of combining/rolling up items, and I think it's an idea at least worth investigating.</FONT></P>
<P><FONT face=Tahoma size=2>I also realize this is probably a fairly radical departure from your current design.&nbsp; If it were me, I'd blame it on the new use case.&nbsp; <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /></FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, January 07, 2008</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I wouldn't say it's a messed-up design.&nbsp; I think it may be a little overly complex in some areas.</div></BLOCKQUOTE><br><br>Perhaps.&nbsp; My goal was as simple as possible.&nbsp; But I'm nto sure if I've achieved that or not. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><font face="Tahoma" size="2"><br></font>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>These part-whole hierarchies are always a bit of a tough nut.&nbsp; I've never been a fan of an explosion of leaf classes, which is kinda what you have here.&nbsp; I will readily concede that a use-case-driven design could lead to this, and there's no real good alternative.&nbsp; You're either checking against a ton of different types, or you're checking against some kind of type property.&nbsp; Which is better?&nbsp; OO design will say different types - but OO design will also say that you should include methods in the base class so that you can treat the subtypes the same.</div></BLOCKQUOTE></p><p>Well, all those classes exist because they do have different responsiblities.&nbsp; Discounts aren't like note line items, etc.<font face="Tahoma" size="2"><br></font></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>If you look at the GoF Composite pattern - which is what most people would probably say you should be using - the issues with the pattern center around what you're dealing with.&nbsp; If you include a child collection at the base level, then you have to define behaviors for types that, by definition, will never have any children.&nbsp; You also potentially incur an object graph overhead, since said child collection will exist at every level, whether you need it or not.</div></BLOCKQUOTE></p><p>I orginally did think about that pattern, but didn't go there for the reasons you specify.<font face="Tahoma" size="2"><br></font></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I don't see a need for GroupSubItem, since all it seems to do is expose a property to the actual object you care about.&nbsp; Since the items are, by this definition, still editable within this context, GroupSubItem seems to be getting in the way.</div></BLOCKQUOTE></p><p>Hmm, an interesting concept.&nbsp; I'll have to think about this.&nbsp; The GroupSubItem does a bit more than expose the Item property.&nbsp; For example, a SimpleLineItem overrides IsGroupable, IsUngroupable and IsGrouped to return true, false and false.&nbsp; While GroupSubItem delegates some thing, like Description, to the decorated instance, it doesn't delegate those three properties and always returns a fixed value for each of the Isxxx properties above.&nbsp; But this still may be a good option.<font face="Tahoma" size="2"><br></font></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>One possible simplification I see is to take your collection-based line items and combine them into one class.&nbsp; Realizing that BundleLineItem and GroupLineItem aren't the same thing, when you boil it down, they aren't all that different.&nbsp; BundleLineItems contain non-editable (and, in some cases, non-viewable) children; GroupLineItems don't have that restriction.&nbsp; Presumably, pricing is basically the same - it's the sum of the individual parts.&nbsp; Especially if you get rid of the GroupSubItem, you might be able to combine both of those.</div></BLOCKQUOTE></p><p>Yes, they are similar, but the container itself acts a bit differently.&nbsp; For example, only the quantity of the bundle item is changable, and the unit price by certain users.&nbsp; For the group, everything is changable; the part number, description, etc.&nbsp; Taxable is forced blank (also unlike the bundle).&nbsp; The group item will also remove itself once it has no children.&nbsp; But perhaps this is something I can again work towards.</p><p>Also, bundle pricing may be the sum of the parts, or it may be fixed.&nbsp; That option is set by the product administrator when working with the bundle, and of course they can change to either method at any time.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>In the end, I think you're going to have to get to some kind of Composite hierarchy in order to protect yourself.&nbsp; You designed for one level of nesting, and now they want two.&nbsp; How long before they want three, four, etc.?&nbsp; Also, I think you may want to step back from the individual line-item use cases to do some consolidation.&nbsp; I see line items that look to have been created to fulfill mostly UI-related functions.&nbsp; I realize that putting that kind of logic in the UI isn't as helpful, but the alternative is what you have here.</div></BLOCKQUOTE></p><p>Well, I'm pretty certain that they will never ask for more than two levels of grouping.&nbsp; The purpose of the group item is to provide a way to "hide" what the customer is actually getting.&nbsp; Either to get around some IT policy at the customer site or because the customer just wants one line item on the invoice, for whatever reason.&nbsp; The bundle's purpose isn't necessarly to hide the items to make up the bundle, its a standard "we'll sell a complete system instead of you buying all the individual parts."&nbsp; Kind of like a home theater system.&nbsp; You could be each piece individually, but they'll sell you a working system.&nbsp; The result ends up being the same; the customer only sees the zero level items.&nbsp; Internally, we only show our parts department the "deepest" items.<font face="Tahoma" size="2"><br></font></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>The one crucial thing (crucial to my way of thinking, at least) is that order is important to you.&nbsp; Since you have line items that function on the previous one, or previous ones, in the list, the order of items must be preserved.&nbsp; That would include in the database.&nbsp; So my thoughts were centered around this.&nbsp; It's an odd implementation of a Composite pattern, but it might make your life easier - and you've already started at least some of it.</div></BLOCKQUOTE></p><p>Yes, the ordering piece is in place currently.&nbsp; The items in a List stay where you place them, and you can ask a LineItem to move up or down.&nbsp; When saving, a position is deteremined.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>Your LineItems collection flattens your hierarchy.&nbsp; What if that was your one (and only) collection?&nbsp; Since order is important, you'd need to introduce two concepts: depth and sequence.&nbsp; Sequence is contained by depth, and depth is relatively self-explanatory.&nbsp; Then you only have one collection - the collection of LineItems off your quote.&nbsp; You'd want to build routines that allow a lineitem to find their next sibling, previous sibling, parent, etc.&nbsp; But then your grouping/bundling could become easier, and you automatically support any level of nesting you need without generating some sort of complex object graph.&nbsp; Grouping items merely requires a bit of re-ordering and some depth/sequence updates.&nbsp; It removes the "what do I do with child collections in leaf objects" question.&nbsp; You can still store parent-object references - they just point to an object higher up in the list.&nbsp; That way, parent-level properties can easily be retrieved (for something like the bundle children quantity multiplication).</div></BLOCKQUOTE></p><p>Yes, I have thought of this, and Rocky has also suggested it.&nbsp; My problem has been to reliably keep the items in order, or how to determine if an item can be moved.&nbsp; For example, bundle sub items cannot be re-ordered, they must appear in the order the product administrator set.&nbsp; If the bundle item needs to move up, so do all its children.&nbsp; Maybe this is simplier than I'm imagining though.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I realize this probably ends up looking a lot like your database layout, and I'm not advocating a data-driven design.&nbsp; You can still have your different line items.&nbsp; But you'd also want to push as much functionality into the base LineItem class as you can.&nbsp; That way, your flattened collection can treat line items the same.</div></BLOCKQUOTE></p><p>No, not at all.&nbsp; Its confusing, because at the same time items ARE flat, but also exhibit behaviors which also suggest a hierarchy.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I also realize that, if you push your functionality into the base LineItem, you could still do a standard object graph.&nbsp; Using recursive routines, that's still not too hard to process.&nbsp; But, from your description,&nbsp;it feels like the&nbsp;flattened hierarchy is the more dominant form.&nbsp; Add in the need to "promote" child objects to the parent level for purposes of combining/rolling up items, and I think it's an idea at least worth investigating.</div></BLOCKQUOTE></p><p></p>Yes, I agree that flat is more dominant and that I may have a lot of work to do... that's why I posted here.&nbsp; Since it's just me doing everything for this application (database to deployment and support), I need some place to bounce thoughts around.. and this forum has been a great place.&nbsp; Part of my dilemma is that I want to get this done rather soon, but I also don't want a bad design.&nbsp; I'm while I'm almost certain they'll never ask to group anything else (rather, ask to have one group of items under another group), I'm not 100% sure.&nbsp; <br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I also realize this is probably a fairly radical departure from your current design.&nbsp; If it were me, I'd blame it on the new use case.&nbsp; <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /></div></BLOCKQUOTE></p><p>Yes, I knew that might be a possiblity when I ask for help.&nbsp; I certainly have a lot to think about.</p><p>In the interest of "getting it done" and the likelihood that I won't be asked to allow for groups of groups (just groups of products or product bundles), I think I may try for eliminating GroupSubItem and making items which can be grouped a bit smarter about when they are grouped (i.e., if their container is actually a line item or some other container).</p><p>Of course, if there are any other suggestions, I'd still love to hear them!</p>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, January 07, 2008</h2><FONT face=Tahoma><FONT size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div></FONT></FONT><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>These part-whole hierarchies are always a bit of a tough nut.&nbsp; I've never been a fan of an explosion of leaf classes, which is kinda what you have here.&nbsp; I will readily concede that a use-case-driven design could lead to this, and there's no real good alternative.&nbsp; You're either checking against a ton of different types, or you're checking against some kind of type property.&nbsp; Which is better?&nbsp; OO design will say different types - but OO design will also say that you should include methods in the base class so that you can treat the subtypes the same.</div></BLOCKQUOTE></FONT>
<P><FONT face=Tahoma><FONT size=2>Well, all those classes exist because they do have different responsiblities.&nbsp; Discounts aren't like note line items, etc.</FONT></FONT><FONT face=Tahoma><FONT size=2></div></BLOCKQUOTE></FONT></FONT></P>
<P><FONT face=Tahoma><FONT size=2>Sure - I'm not saying all the LineItem classes are the same.&nbsp; But they all do the same basic things, so perhaps your base class could turn into something more like a Template class.&nbsp; I don't know the full extent of your app, but if you could do something like that, you may be able to not care about the specific subtypes more.&nbsp; That makes the code a bit cleaner.</FONT></FONT></P>
<P><FONT face=Tahoma><FONT size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div></FONT></FONT><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>One possible simplification I see is to take your collection-based line items and combine them into one class.&nbsp; Realizing that BundleLineItem and GroupLineItem aren't the same thing, when you boil it down, they aren't all that different.&nbsp; BundleLineItems contain non-editable (and, in some cases, non-viewable) children; GroupLineItems don't have that restriction.&nbsp; Presumably, pricing is basically the same - it's the sum of the individual parts.&nbsp; Especially if you get rid of the GroupSubItem, you might be able to combine both of those.</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>Yes, they are similar, but the container itself acts a bit differently.&nbsp; For example, only the quantity of the bundle item is changable, and the unit price by certain users.&nbsp; For the group, everything is changable; the part number, description, etc.&nbsp; Taxable is forced blank (also unlike the bundle).&nbsp; The group item will also remove itself once it has no children.&nbsp; But perhaps this is something I can again work towards.</FONT></P>
<P><FONT face=Tahoma size=2>Also, bundle pricing may be the sum of the parts, or it may be fixed.&nbsp; That option is set by the product administrator when working with the bundle, and of course they can change to either method at any time.</FONT></P>
<P><FONT face=Tahoma size=2></div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>I know what this is going to sound like, but if you&nbsp;took advantage of the fact that the line items know who their parent is, you could rely on the parent type to manage some of that.&nbsp; I know that sounds like you're pushing some of the responsibility of the LineItem to another class, but since the operations are dependent on the parent anyway, there's some coupling built in.</FONT></P>
<P><FONT face=Tahoma size=2>At least that's what I tell myself to feel better about it.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></P></FONT>
<P><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>Your LineItems collection flattens your hierarchy.&nbsp; What if that was your one (and only) collection?&nbsp; Since order is important, you'd need to introduce two concepts: depth and sequence.&nbsp; Sequence is contained by depth, and depth is relatively self-explanatory.&nbsp; Then you only have one collection - the collection of LineItems off your quote.&nbsp; You'd want to build routines that allow a lineitem to find their next sibling, previous sibling, parent, etc.&nbsp; But then your grouping/bundling could become easier, and you automatically support any level of nesting you need without generating some sort of complex object graph.&nbsp; Grouping items merely requires a bit of re-ordering and some depth/sequence updates.&nbsp; It removes the "what do I do with child collections in leaf objects" question.&nbsp; You can still store parent-object references - they just point to an object higher up in the list.&nbsp; That way, parent-level properties can easily be retrieved (for something like the bundle children quantity multiplication).</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>Yes, I have thought of this, and Rocky has also suggested it.&nbsp; My problem has been to reliably keep the items in order, or how to determine if an item can be moved.&nbsp; For example, bundle sub items cannot be re-ordered, they must appear in the order the product administrator set.&nbsp; If the bundle item needs to move up, so do all its children.&nbsp; Maybe this is simplier than I'm imagining though.</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>If you introduce depth and sequence, it's not so bad.&nbsp; Since the child items point to their parent, and sequence is encapsulated by parent item, moving a parent automatically moves the children -&nbsp;they still point to their parent, and their ordering doesn't change.&nbsp; Moving is pretty simple too - just change the sequence numbers of the moving items.</FONT></P>
<P><FONT face=Tahoma size=2>Maybe an example.&nbsp; Say you have something like this:</FONT></P>
<P><FONT face="Courier New" size=2>Parent ID&nbsp;&nbsp;&nbsp; Child ID&nbsp;&nbsp;&nbsp; Depth&nbsp;&nbsp;&nbsp; Sequence<BR>---------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -----&nbsp;&nbsp;&nbsp; --------<BR>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NULL&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<BR>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3<BR>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NULL&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<BR>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<BR>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</FONT></P>
<P><FONT face=Tahoma size=2>If you need to move 5 above 1, then you just change their Sequence values.&nbsp; Nothing else changes, and the children stay where they&nbsp;should be.</FONT></P>
<P><FONT face=Tahoma size=2>As for determining what can or can't be moved, I'd fall back on "operations based on parent type" again, since the type of parent determines what can be done to its child(ren).<BR></P></FONT><FONT face=Tahoma size=2></FONT>
<P><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I also realize that, if you push your functionality into the base LineItem, you could still do a standard object graph.&nbsp; Using recursive routines, that's still not too hard to process.&nbsp; But, from your description,&nbsp;it feels like the&nbsp;flattened hierarchy is the more dominant form.&nbsp; Add in the need to "promote" child objects to the parent level for purposes of combining/rolling up items, and I think it's an idea at least worth investigating.</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2></FONT></P>
<P><FONT face=Tahoma size=2>Yes, I agree that flat is more dominant and that I may have a lot of work to do... that's why I posted here.&nbsp; Since it's just me doing everything for this application (database to deployment and support), I need some place to bounce thoughts around.. and this forum has been a great place.&nbsp; Part of my dilemma is that I want to get this done rather soon, but I also don't want a bad design.&nbsp; I'm while I'm almost certain they'll never ask to group anything else (rather, ask to have one group of items under another group), I'm not 100% sure.</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>Wherever you&nbsp;can get the help... hopefully I am helping!</FONT></P>
<P><FONT face=Tahoma size=2>I work under a similar type of situation, and here's how I look at it.&nbsp; I would love to have the time to develop The Perfect Design, and I often get my brain in a twist trying to get there.&nbsp; But in the end, if the design handles the needs of the app, then it's a good design.&nbsp; Everyone can see the holes&nbsp;they&nbsp;coded, given enough time.&nbsp; It's hard to plan for all the possible future cases, and in most cases you don't need to.&nbsp; You already know this.&nbsp; If what you have can be modified to accept the new conditions without a ton of work, and you're comfortable with the changes, do it and move on.&nbsp;&nbsp;You seem like a smart-enough developer that you're not going to code yourself into a corner&nbsp;that requires you to&nbsp;blow up the whole thing.&nbsp; Just because I think the design&nbsp;might be&nbsp;overly complicated certainly doesn't mean it is - I know nothing about the app or your customers.&nbsp; The only thing I'll say is that, if it were me, I wouldn't code myself into the "they aren't going to ask for more nesting levels" situation.&nbsp; But I only say that because I've been burned on that more than once.&nbsp; I know that makes the problem harder to fix than what's in front of you, and if they really never do ask for it, then you wasted your time.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, January 08, 2008</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>Sure - I'm not saying all the LineItem classes are the same.&nbsp; But they all do the same basic things, so perhaps your base class could turn into something more like a Template class.&nbsp; I don't know the full extent of your app, but if you could do something like that, you may be able to not care about the specific subtypes more.&nbsp; That makes the code a bit cleaner.</div></BLOCKQUOTE><br><br>Yes, they do.&nbsp; I think I'm not understanding something here, because I do have a base LineItem class which does implement common behaviors (like MoveUp, MoveDown, etc.).&nbsp; Is there something else you're suggesting?<font face="Tahoma"><font size="2"><br></font></font>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I know what this is going to sound like, but if you&nbsp;took advantage of the fact that the line items know who their parent is, you could rely on the parent type to manage some of that.&nbsp; I know that sounds like you're pushing some of the responsibility of the LineItem to another class, but since the operations are dependent on the parent anyway, there's some coupling built in.</div></BLOCKQUOTE></p><p>I think that's kind of the approach I'm taking.&nbsp; I don't want BundleLineItem to depend on GroupLineItem in any way, but I'm putting code in BundleLineItem to be able to recognize if it is a zero depth item or not.&nbsp; I'm also doing the same for SimpleLineItem (which, thinking about it, I should probably rename to ProductLineItem).&nbsp; I'm trying to use the interfaces I have to do this.&nbsp; I have a bunch.. ILineItemContainer (a collection class which holds line items), IContainerLineItem (a line item which containers other line items), IGroupableLineItem, IGroupedSubItem, ILineItemInternal.&nbsp; Then there's ILineItem, which is ALL the UI sees.&nbsp; Maybe it is time to see if I can't simplify a bit.<font face="Tahoma" size="2"><br></font></p>

<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>If you introduce depth and sequence, it's not so bad.&nbsp; Since the child items point to their parent, and sequence is encapsulated by parent item, moving a parent automatically moves the children -&nbsp;they still point to their parent, and their ordering doesn't change.&nbsp; Moving is pretty simple too - just change the sequence numbers of the moving items.</p>
<p>Maybe an example.&nbsp; Say you have something like this:</p>
<p><font face="Tahoma" size="2">Parent ID&nbsp; Child ID&nbsp;&nbsp; Depth&nbsp; Sequence<br>---------&nbsp;&nbsp;&nbsp; --------&nbsp;&nbsp;&nbsp; -----&nbsp;&nbsp;&nbsp; --------<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NULL&gt;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 1<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 2<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 3<br>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;NULL&gt;&nbsp;&nbsp;&nbsp;&nbsp; 1 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 2<br>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 1<br>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 2</font></p>
<p>If you need to move 5 above 1, then you just change their Sequence values.&nbsp; Nothing else changes, and the children stay where they&nbsp;should be.</div></BLOCKQUOTE></p><p>That (except for depth) is what I first tried.&nbsp; It got complex, line items needed to know other line item's sequence numbers, etc.&nbsp; I realized that List kept the order, so I could remove that complexity and just move things around in the list.&nbsp; I could probably keep numbers in sync though.. my problem was exposing a BusinessListBase class that enforced this order.&nbsp; In my case, ordering is not just a UI feature, it's a business feature.&nbsp; But maybe I wasn't going about it the right way.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>As for determining what can or can't be moved, I'd fall back on "operations based on parent type" again, since the type of parent determines what can be done to its child(ren).</div></BLOCKQUOTE></p><p>Well, right now the only items that can't be moved are those contained in a BundleLineItem.&nbsp; Technically, items within a Group <i>could</i> be moved by the user... the current coding doesn't allow this, but it's not actually a business requirement, I think it was just a shortcut I took... or something I didn't think about.&nbsp; Indeed, this may be useful to users, because if they want a certain order within the group they need to ungroup the whole thing, re-order, regroup.&nbsp; <br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>Wherever you&nbsp;can get the help... hopefully I am helping!</div></BLOCKQUOTE></p><p>You have been very helpful.&nbsp; Going back and forth like this has given me some ideas.<font face="Tahoma" size="2"><br></font></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>I work under a similar type of situation, and here's how I look at it.&nbsp; I would love to have the time to develop The Perfect Design, and I often get my brain in a twist trying to get there.&nbsp; But in the end, if the design handles the needs of the app, then it's a good design.&nbsp; Everyone can see the holes&nbsp;they&nbsp;coded, given enough time.&nbsp; It's hard to plan for all the possible future cases, and in most cases you don't need to.&nbsp; You already know this.&nbsp; If what you have can be modified to accept the new conditions without a ton of work, and you're comfortable with the changes, do it and move on.</div></BLOCKQUOTE></p><p>Well, that's where I'm at right now.&nbsp; This one feature is harder to implement in the current design than I would have liked.&nbsp; I guess that's just how things go sometimes.&nbsp; I don't mind doing alot of work again now, I just would like to have a design so that later changes don't require so much.&nbsp; But I guess that's not always possible, since we can't see the future.&nbsp; <br></p><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>You seem like a smart-enough developer that you're not going to code yourself into a corner&nbsp;that requires you to&nbsp;blow up the whole thing.&nbsp; Just because I think the design&nbsp;might be&nbsp;overly complicated certainly doesn't mean it is - I know nothing about the app or your customers.&nbsp; The only thing I'll say is that, if it were me, I wouldn't code myself into the "they aren't going to ask for more nesting levels" situation.&nbsp; But I only say that because I've been burned on that more than once.&nbsp; I know that makes the problem harder to fix than what's in front of you, and if they really never do ask for it, then you wasted your time.</div></BLOCKQUOTE></p><p>Well, I might be at a point now where my current design needs to be blown up.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />&nbsp; I don't want to code myself into a corner either, but at the same time I try to stick to the YAGNI principle, so that I can get things done in a reasonable amount of time.&nbsp; Although my employer has been great about saying "take as much time as you need to do it," I still like to get things out the door sooner rather than later.&nbsp; Especially since much of what I'm replacing is a huge mess, and they've been very happy with what I've been able to deliver thus far.</p><p>I think I'll stay the current route, and follow your suggestion to kill GroupSubItem.&nbsp; It seems to be going much better so far, although there are some kinks to work out still... mostly that I haven't finished coding this concept yet.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />&nbsp; If the time comes that I need more nesting, my current design shouldn't prevent me from moving to a full Composite pattern.. it won't be any harder than it is now, and it really wouldn't be that hard... just more difficult than killing GroupSubItem.</p><p>Thanks very much for your help, it has been useful!</p><p>Andy<br></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, January 08, 2008</h2>Ok, coding things has been.. difficult.&nbsp; So I think I'll go the composite pattern route.&nbsp; I do have some things I'm still not sure of though.&nbsp; Currently, users can't group Discount, Note, and any kind of Fee line items.&nbsp; They must always be 'top level,' contained by the LineItemContainer my new line item class super class.&nbsp; <br><br>Currently, I have a flag, IsGroupable defined on every line item, and the UI checks this value when the context menu is displayed, and if any selected item returns false, it grays out the Group Items menu option.&nbsp; I'd like to continue to do this somehow, but I'm at a loss.<br><br>The design I'm thinking of has LineItemContainer as the superclass.&nbsp; Then I have LineItemLeaf, which is what most things will sub-class.. Notes, Discounts, Fee, Product (formally SimpleLineItem), BundleComponentLineItem (formally BundleSubLineItem).&nbsp; These will not support the adding or removing of children line items.&nbsp; <br><br>I'll also have LineItemNode, which will actually be able to hold other line items.&nbsp; From this, BundleLineItem and GroupLineItem will inherit.&nbsp; Also, LineItems will inherit from this as well.&nbsp; LineItems will always be the root node in the tree.&nbsp; <br><br>Back to the problem.. how do I give the UI clues as to what items can be regrouped?&nbsp; I thought about having a CanAddItem and CanRemoveItem... but the problem is that a Discount CAN be removed from LineItems, but not added to GroupLineItem.&nbsp; Hmm... maybe that's the trick... but the problem is that a group item isn't created until after the user selects the Group Items menu command.&nbsp; <br><br>Thoughts?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, January 09, 2008</h2><P><FONT face=Tahoma size=2>Well - the first thing that comes to mind is a static list of allowable child types for your GroupLineItem class.&nbsp;&nbsp;This isn't something I see you being able to put in the LineItemNode base class, since the check is really type-specific, and you can't have virtual or abstract static members.&nbsp; Plus, the check isn't really useful for the other list types.&nbsp; BundleLineItem objects&nbsp;only accept BundleComponentLineItem children,&nbsp;but that's completely enforced in the UI.&nbsp; And LineItems objects accept all types.</FONT></P>
<P><FONT face=Tahoma size=2>Anyway,&nbsp;you add a static constructor for your GroupLineItem class that populates this list.&nbsp; Finally, you put a "CanContainType" method that returns True or False based on a simple Contains() check.&nbsp; Then, i</FONT><FONT face=Tahoma size=2>n your context-menu code, you call "GroupLineItem.CanContainType(Type)" for each selected item, and enable/disable your menu item appropriately.&nbsp;&nbsp;And maybe you also have an overload that takes a list of items and does the looping for you - depends on how often you have to check multiple types.</FONT></P>
<P><FONT face=Tahoma size=2>It's not polymorphic, but since the grouping functionality is specific to the GroupLineItem type, that's not so bad.&nbsp; At least it isn't to me.&nbsp; It also "feels" better - knowing whether a specific line item can be grouped feels like GroupLineItem functionality to me.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, January 09, 2008</h2>Ya, I come up with something similar, although you raise a good point I missed.&nbsp; I have a IsReparentable, which indicates if you can change the parent of a lineitemcontainer.&nbsp; I also have a Reparent method which asks the line item to update it's parent.&nbsp; It will remove itself from it's current parent after it adds itself to the requested parent.<br><br>I thought this would be good enough, but your post remidned me.. the UI creates any line item via a LineItemFactory.&nbsp; So techinically it could create a NoteLineItem and then call Add on a GroupLineItem.&nbsp; So I'll need to check there anyway.&nbsp; I think though instead of checking the type, I can check the items IsReparentable property and throw an exception if that returns false.<br><br>Argh... I also thought of something else.&nbsp; LineItemContainer is a BusinessBase object.&nbsp; How do I know when to delete line items that are totally out of the graph?&nbsp; Hmm..<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
