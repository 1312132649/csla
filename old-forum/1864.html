<html><header><title>Decoupling my objects/classes?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Decoupling my objects/classes?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1864.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ianinspain posted on Wednesday, November 29, 2006</h2>Hi there,<br><br>after doing some research here, its time to edit my BO and classes to decouple them... but i had some questions that i hope someone can help with..<br><br>From what i understand - i should never pass a class from 1 class to another as this can cause many things to break if i change one of the classes...<br><br>Does this also go for controls i.e. textboxes, checkboxes etc... should never pass in a control to a class ... otherwise it becomes coupled?<br><br>so i presume the only thing that is valid is passing in what?? simple types like string, int, what else??<br><br>So if i required to update a grid control, the right way would be to NOT pass in the grid control to a class but to use events and populate the grid via the UI, the UI would obviously get its information from these events from the class/BO??<br><br>I also read some where that you can use Interfaces to decouple?? this i&nbsp; am a little confused with .. because i presumed an interfaces enforces a class to implement a certain number of methods etc <br><br>I really tried searching google for some best practices but could find any hints or tips and what to do...<br><br>Any help or information really appreciated...<br><br><br><br>Ian</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Wednesday, November 29, 2006</h2><p class="MsoNormal"><span>There is
nothing wrong with passing an object to a class.<span>&nbsp; </span>However, you should keep in mind the OOP principle
that states you should program to an interface not an implementation.<span>&nbsp; </span>This basically states that you should program
to interfaces or abstract classes rather than concrete classes when it is
prudent to do so.<span>&nbsp; </span>Keep in mind this is a
suggestion not a rule.<span>&nbsp; </span>You can pass
control objects to other classes, but you should not pass the control object to
a business object.<span>&nbsp; </span>The business object
should know nothing about the presentation layer.<span>&nbsp; </span><o:p></o:p></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ianinspain replied on Tuesday, December 05, 2006</h2>Thanks very much for the reply... i am a little confused with this<br><br>"<span>However, you should keep in mind the OOP principle
that states you should program to an interface not an implementation."<br><br>How would i use a interface or abstract class to decouple my class?<br><br>Thanks once agian<br><br>Ian<br></span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ianinspain replied on Tuesday, December 05, 2006</h2>If i require access to a class from another class then should i build my own implementation of this class in the assembly that requires it?<br><br>This sounds good, but there is no code re-use so hence each class/assembly that requires access to this special class would need to hold its own copy of class .... hence there is no code-re-use and duplicate code??<br><br>Any ideas?<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 05, 2006</h2>Well, remember that the principal is not a hard and fast rule.&nbsp; If you are trying to decouple some assemblies, probably what you'll have to do is create an interface in a 3rd assembly, which both those assemblies will reference.&nbsp; Then your BO in the first assembly will implement the interface, and the class in the second assembly that needs the object will accept somethign which implements the interface, not the concreate class.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 05, 2006</h2><P>I think we need to keep a pragmatic view of this when considering applying this principle as a general rule just because you should.&nbsp; I'm building a specific UI&nbsp;solely to interact with a specific business layer built on a specific framework.&nbsp;&nbsp; The reason for decoupling with&nbsp;interfaces would be so you could "swap" out the underlying layer.&nbsp; There is precisely zero chance of that IMO, so it's just a waste of effort.</P>
<P>I still use several interfaces, mind you, but it's&nbsp;for when I can't know the specifics in a particular area of functionality.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 05, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div>The reason for decoupling with&nbsp;interfaces would be so you could "swap"
out the underlying layer.&nbsp; There is precisely zero chance of that IMO,
so it's just a waste of effort.</div></BLOCKQUOTE><br><br>I wouldn't go that far; perhaps in your circumstances, but not for everyone.&nbsp; Especially if the OP has chosen to build seperate assemblies which still must work together.&nbsp; I have this situtation right now, and having interfaces allows me to test each assembly regardless of whether or not the other assembly is working properly or not.<br><br>I do have one case where this isn't true in the testing layer; it directly uses another business assembly, and its been causing me nothing but problems.&nbsp; When I get more time, I do plan on breaking that dependancy.&nbsp; Changing one assembly shouldn't cause me to change the testing assembly for another different assembly.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 05, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BR>I wouldn't go that far; perhaps in your circumstances, but not for everyone.&nbsp; Especially if the OP has chosen to build seperate assemblies which still must work together.&nbsp; I have this situtation right now, and having interfaces allows me to test each assembly regardless of whether or not the other assembly is working properly or not.<BR><BR>I do have one case where this isn't true in the testing layer; it directly uses another business assembly, and its been causing me nothing but problems.&nbsp; When I get more time, I do plan on breaking that dependancy.&nbsp; Changing one assembly shouldn't cause me to change the testing assembly for another different assembly.<BR><BR>Andy<BR></div></BLOCKQUOTE></P>
<P>I was referring to the rather dogmatic adherence to this principle that the OP suggested with words like "always" and "never".&nbsp; I just think it's silly in a case where a form is built specifically to edit Customer objects which inherit from BusinessBase to add a bunch of interfaces to the mix.&nbsp; There's zero chance I'll use that form for anything else, so I've gained nothing from the interface.</P>
<P>I'm interested in a little further explanation of your scenario though.&nbsp; We are all using "separate assemblies which still must work together" by definition because we're building n-tiered applications.&nbsp; I'm presuming you're meaning multiple assemblies at the same tier, as in two assemblies of business objects.&nbsp; But what is the test scenario where an interface helps you?&nbsp; Are you saying you put "dummy" classes in one assembly to represent the classes that would really be found in the other in production so you can stay "local" for testing?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 05, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div>
<P>I was referring to the rather dogmatic adherence to this principle that the OP suggested with words like "always" and "never".&nbsp; I just think it's silly in a case where a form is built specifically to edit Customer objects which inherit from BusinessBase to add a bunch of interfaces to the mix.&nbsp; There's zero chance I'll use that form for anything else, so I've gained nothing from the interface.</P>
<P></div></BLOCKQUOTE></P>
<P>I want to clarify that in actual practice I often build forms or controls&nbsp;that have common functionality for dealing with an unknown implementing type.&nbsp; But I didn't feel that was specifically what the OP was addressing.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 05, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div>I was referring to the rather dogmatic adherence to this principle that the OP suggested with words like "always" and "never".&nbsp; I just think it's silly in a case where a form is built specifically to edit Customer objects which inherit from BusinessBase to add a bunch of interfaces to the mix.&nbsp; There's zero chance I'll use that form for anything else, so I've gained nothing from the interface.</div></BLOCKQUOTE><br><br>Right, which is why I said that OO principal wasn't a hard and fast rule.&nbsp; <br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div>I'm interested in a little further explanation of your scenario though.&nbsp; We are all using "separate assemblies which still must work together" by definition because we're building n-tiered applications.&nbsp; I'm presuming you're meaning multiple assemblies at the same tier, as in two assemblies of business objects.&nbsp; But what is the test scenario where an interface helps you?&nbsp; Are you saying you put "dummy" classes in one assembly to represent the classes that would really be found in the other in production so you can stay "local" for testing?</div></BLOCKQUOTE></p>Yes, I have multiple business assemblies.&nbsp; There are some cases where I need to know the properties of say a Contact, but managing contacts is handled by an external assembly.&nbsp; Rather than recode the object, I put an interface in a lower level assembly, so my Contact manager assembly has some objects which implement that interface, and my quoting assembly needs to consume that data.<br><br>The application works nicely because it can use both assemblies and existing screens to select a contact, and then use that to work with the quoting assembly's objects.&nbsp; The problem was that in my test assembly for the quoting module, I directly referenced the contact management assembly (much like the application would).&nbsp; This causes problems in the build, because if a "lower" dependancy and the quoting module builds first, the quoting module will use the old version of the contact module, which is still using the old version of the "lower" assembly.&nbsp; <br><br>In my third (softwaer) assembly, instead of referencing the contacts assembly in the testing assembly I created mock objects which implement the interfaces in the lower assembly.&nbsp; This doesn't cause any problems if the contacts or lower assembly is changed.<br><br>Now, it could be argued that these assemblies should be merged into one and that is something I'm certainly considering.. except that I'll be creating a new totally seperate UI which will need to use the contacts and software assemblies, but shouldn't include the quoting assembly (it will never be used in the UI).<br><br>I also suppose it could be argued that I should have one assembly for each application, but then we are talking about major code duplication, and I'm not sure that cost would be worth it because both applications still use the same database.. <br><br>So, to sum it up, maybe having seperate assemblies may or may not be the right thing to do, but if you DO have seperate assemblies which have some common ground, the interfaces are very very helpful.<br><br>Clear as mud?<br><br>Andy<br><br>PS - Are there any resources out there to help figure out how to physically seperate classes into assemblies, when there are two or more applications share a common database?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ianinspain replied on Thursday, December 07, 2006</h2>Wow ... this thread as turned out to be really good!, I have learned a lot here... I am very interested in the process of using an interface to decouple... see if i get this right.. I am sure i won't and have missed something :-)<br><br>create an interface and have some specific classes inherit from this interface so they have a contract and have to act a certain way..<br><br>have another class i.e. a BO or whatever.. doesn't really matter that accepts a parameter on a method not of type class, arraylist, MyOwnClass but of an interface meaning that you can pass ANYTHING into this method that implements this interface...<br><br>Would you not have to cast it once it arrives?<br><br>And where would be the best place to store the interface as many many different assemblys would possible use it ... so what is the best thing to do.... to create a seperate assembly and put all common interfaces into it..... and then add a reference to this assembly from my other assemblys?&nbsp; but this is coupling each assembly with this common Interface assembly isn't it... I presume it would&nbsp; matter because if you update the common assembly then all assemblies would get the changes ....<br><br>I hope i am not babbling :-)<br><br>Thanks<br><br>Ian<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 07, 2006</h2>No, you wouldn't have to cast it.&nbsp; An interface is a type as well, and you'd interact with it just as you if the method accepted a concrete type.<br><br>Now, suppose you have the following:<br><br>public interface MyInterface {<br>&nbsp;&nbsp;&nbsp;&nbsp; string MyString{ get; }<br>&nbsp;&nbsp;&nbsp;&nbsp; void DoSomething( int count );<br>}<br><br>public class MyClass : MyInterface {<br>&nbsp;&nbsp;&nbsp;&nbsp; public string MyString{ <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; get { return myString; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  set { myString = value; }<br>&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; public void DoSomething( int count ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do something here<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; public void DoSomethingElse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do something here<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>public class Consumer {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Consume( MyInterface myIFace ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myIFace.MyString = "x"; // Will bomb, because the interface only specifies that get is required<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine( myIFace.MyString );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myIFace.DoSomething( 3 );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myIFace.DoSomethingElse(); // Will bomb, because not in the interface definition.<br>}<br><br><br>That's an example (in C#) of implicit interface implementation.&nbsp; That means that the interface is concidered implemented because it has matched all the signatures in the interface.&nbsp; If you explicitly implement (as here);<br>
<br>public class MyClass : MyInterface {<br>
&nbsp;&nbsp;&nbsp;&nbsp; string MyInterface.MyString{ <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; get { return myString; }<br>&nbsp;&nbsp;&nbsp; }<br>

&nbsp;&nbsp;&nbsp; void MyInterface.DoSomething( int count ) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do something here<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; public void DoSomethingElse() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Do something here<br>
&nbsp;&nbsp;&nbsp; }<br>
}<br>
<br>
<br>You can ONLY call DoSomething if you first cast the instance of MyClass to MyInterface.&nbsp; So explicitly implementing can be used to 'hide' methods.&nbsp; This can be very useful ifyou just want an interface for internal use within the assembly; declare the interface as internal instead of public, and explicity implement it where you need it.&nbsp; <br><br>Finally, remember that you can implement an interface both implicity AND explictly in the same class.&nbsp; <br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>I understand the argument that there are many times and applications where adhering to the OOP principals, such as coding to an interface not an implementation, is "overkill" and may seem excessive.&nbsp; However, it is my seasoned opinion that you are either disciplined to program following solid OOP practices or you are not.&nbsp; I don't care if you are programming a simple calculator to do only addition, there is no justifiable reason why you should ever do LESS than a standard job developing an app.</P>
<P>Among the many reasons for this opinion is the fact that everythign changes and while you all can say today that your apps are not going to need code reuse or being extended or grow, s*** happens.&nbsp; Everything changes.&nbsp; In addition, if you don't develop a standard set of practices for yourself, how can you ever expect to have a framework that supports you?&nbsp; Furthermore, going back and looking at an app that you completed 6 months ago using one approach after spending the gap working on a new app with a completely different tact will only lead to increased time reassessing what you did and why.&nbsp; Add in the case where many of us are battling with contractors (both on-shore and off-shore) and these kinds of variations and deviations are killers.</P>
<P>Fact is, the best way to make yourself a good OOP programmer is to simply make it a habit to do things the OOP way.&nbsp; Now, I am not saying that OOP is the be-all-end-all.&nbsp; Just saying that&nbsp;picking and chosing when to follow good, solid, standard practices because "it is easier" is just lazy - IMO.</P>
<P>The original post indicates a real confusion over how this principal is implemented and that still seems to be a concern.&nbsp; By telling the author that he can follow the rule sometimes will certainly not help matters as now you've introduced another variable into the decision making process.&nbsp; These rules, like the decisions made by Rocky with CSLA, are there for a reason - to share with the developer community the lessons learned by more experienced programmers.&nbsp; Fact is, this would not be a rule if those that have walked this path before didn't feel it was important and significant.&nbsp; And rather than add the additional variable, just make it a habit of thinking this way and developing this way and, voila! Before you know it you will be doing it without consciously thinking about it.</P>
<P>The result will be better code.&nbsp; And whether you are making a database app of your CD collection or an e-commerce solution for a Fortune 500 company, IMO it doesn't matter and there is never an excuse for less than your best.&nbsp; But, I have taught myself to be a highly disciplined programmer over my 25 years in the trenches.&nbsp; I understand where these rules, principals and guidelines comes from because I've been bittin the same way those that came up with the tenets have.&nbsp; I'm the guy that comments everything (!) because I've been the guy brought in one an app that was under development for a year when the guy up and died!&nbsp; Try picking up the pieces when that happens!</P>
<P>Again, IMO, there is never an excuse to pick and choose when to apply good standard and practices.&nbsp; Anyone working in manufacturing or quality-controlled industries know that is just not allowed.&nbsp; This "rule" should be applied to programming as well.&nbsp; If you are going to claim to be an OOP programmer, than be one all the time.&nbsp; Not just when you have the time.</P>
<P>As for the original post, the rule is intended to facilitate change, modularization and extensibility and even if you don't think these things are necessary for your application, it is simply good practice to follow them anyway.&nbsp; The key to understanding this one is understanding what an interface is.&nbsp; The fact that an actual Interface and an Abstract Class can be thought of the same way makes it a bit more confusing, but remember, you can't instantiate either directly - that is the key.&nbsp; In both case, some other class has to exist that either inherits from the base class or implements the interface.&nbsp; In either case, your goal is to make your dependant class use the interface rather than the derived class.</P>
<P>Perhaps the most prevalent example of this rule is the IEnumerable interface.&nbsp; This interface indicates that the concrete class that has implemented it allows enumeration via the GetEnumerator() method.&nbsp; Coupled with the IEnumerator interface that is returned from GetEnumerator, this provides for a very meaty and flexible way to interact with an incredibly wide-spectrum of objects.</P>
<P>Let's say you want to create a method to generate a simple listing of objects.&nbsp; Your method would accept an IEnumerable as an argument as simply iterate of the elements, calling ToString() to dump the text for each item.&nbsp; You don't care if this is a List, Array, ControlCollection or some custom collection because it doesn't matter to your functionality what the actual object is.&nbsp; All that matters to you is that the object has the properties and methods that you need to complete the task.&nbsp; That is what an interface does for you.</P>
<P>Yes, it may seem like redundancy because you've defined the properties and methods in your actual class, but the interface allows you to "decouple" - as they say - that concrete class.&nbsp; And even in a simple case, this can be valuable if for no other reason than to simply make it a habit of programming this way.&nbsp; Why?&nbsp; Because is it good practice to do so.</P>
<P>One finaly note.&nbsp; Generics have introduced a new complexity that can only be solved by interfaces.&nbsp; Try determining the type of a generic&nbsp;object in code (for comparitive purposes) and you'll quickly find out how valuable it is that there are interfaces to check for.&nbsp; This is because each type that the generic class handles actually becomes its own type at run-time.&nbsp; So, there is no checking for: type == typeof(List&lt;&gt;), for instance.&nbsp; You either know the specific type that you want, like List&lt;int&gt;, or you need to be able to check against an interface (IList).</P>
<P>Make it a habit to follow good practices and it will simply become a matter of fact rather than another variable you must decide when developing your apps.</P>
<P>Of course, that's just my opinion.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, December 07, 2006</h2>

<p class="MsoNormal">The OOP principles are guidelines not rules.<span>&nbsp; </span>In many cases it is not possible or practical
to follow every principle for every situation.<span>&nbsp;
</span>There are some principles that you should follow every time but the "program
to an interface not an implementation" principle is not one of them. This does not
mean you are doing less than your best if you don’t follow an OOP
principle.<span>&nbsp; </span>It does not mean your
application is any less OOP.<span>&nbsp; </span>It takes experience
to know when to follow the principles.<span>&nbsp; </span>The
only advice I can really give to the OP is to know all of the principles and
use them.<span>&nbsp; </span>Using them will help you
understand when to use them. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 07, 2006</h2>I'm going to have to agree with malloc here.&nbsp; If the 'program to interface' rule was always applied, that would mean for every object in your system you'd have a corresponding interface.&nbsp;&nbsp; Not only does that waste a lot of time just generating interfaces, you may never actually have any other classes implement the interface.<br><br>Your Enumerator and List examples don't really apply here either I think.&nbsp; There is a difference between building a framework class, that will be used by millions, and building business objects, where the number of applications using them is quite small.<br><br>I think in programming everything is a tradeoff, and you have the find the one that works best for your situation.&nbsp; If at some point in the future and interface is needed, it can easily be added at that time.<br><br>Just my opinion, of course.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ianinspain replied on Thursday, December 21, 2006</h2>Thanks for everyones comments on this... It has been real helpful.....<br><br>I am certainly going to try and following the rules if i can... i know sometimes its not practical.... but i am going to try and stick to them as much as possible... as to get an habit of doing things right<br><br>thanks again<br><br>ian<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Thursday, December 07, 2006</h2><P>SonOfPirate, thank you for that lengthy thoughtful response.</P>
<P>However, and this is certainly my OPINION, I have to say what you've&nbsp;described is exactly the level of dogmatic adherence I think is ridiculous.</P>
<P>Having an interface for every single business object results in "better code"?&nbsp; I should say not!&nbsp; </P>
<P>I'd like to humbly suggest you do a little googling on agile development principles and then spend some time pondering them.&nbsp; While I don't consider myself a full-blown agile or test-driven development, I have found keeping them in mind has made me a more disciplined developer.</P>
<P>And the interesting point about that is that one of the core principles is exactly 180 degrees&nbsp;the opposite of what you describe - namely that you never do something "just because", but rather only when there's a specific need to.&nbsp; I stop myself several times a week from going down the path of some complex solution when a simple one will work just fine.&nbsp; Yes, sometimes I have to refactor or redesign things, but the time saved still far outweighs what's spent doing that.</P>
<P>And that's the bottom line, not what some alleged OO guru says in a popular book.&nbsp; At the end of the day it's all about having the most functional and maintainable code.&nbsp; </P>
<P>So, I guess I'll consider myself "lazy", as&nbsp;I have to&nbsp;pass on your advice.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, December 07, 2006</h2>

<p class="MsoNormal">The following links contain the OOP design principles that
you should by heart.<span>&nbsp; </span>If you need more
information, you can google it.</p>


<p class="MsoNormal"><o:p>&nbsp;</o:p></p>


<p class="MsoNormal"><a href="http://sis36.berkeley.edu/projects/streek/agile/oo-design-principles.html">http://sis36.berkeley.edu/projects/streek/agile/oo-design-principles.html</a></p>


<p class="MsoNormal"><a href="http://architechie.blogspot.com/2005/10/oo-design-principles-quick-rundown.html">http://architechie.blogspot.com/2005/10/oo-design-principles-quick-rundown.html</a></p>


<p class="MsoNormal"><a href="http://www.codeproject.com/gen/design/nfOORules.asp">http://www.codeproject.com/gen/design/nfOORules.asp</a></p>


<p class="MsoNormal"><o:p>&nbsp;</o:p></p>


<p class="MsoNormal">The following link contains a very detailed explanation of
the program to an interface, not an implementation principle.<span>&nbsp; </span>This is a very good article and I recommend reading
it.</p>


<p class="MsoNormal"><o:p>&nbsp;</o:p></p>


<p class="MsoNormal"><a href="http://www.artima.com/lejava/articles/designprinciples.html">http://www.artima.com/lejava/articles/designprinciples.html</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Tuesday, December 05, 2006</h2><p class="MsoNormal">If one class is only going to implement the interface or abstract class
and no future classes will, then it is not necessary to create that
interface or abstract class in most cases.<span>&nbsp;
</span>However, if many classes are going to implement the interface or abstract
class, you might want to consider creating the interface or abstract class.<span>&nbsp; </span>Keep in mind this is an oversimplification of
the issue and it does not work for every scenario.<span>&nbsp; </span>For example, the separated interface pattern uses
interfaces to separate a package from its implementation.<span>&nbsp; </span>Many of these interfaces will only be implemented by
one class, depending on the usage.<span>&nbsp;
</span>Despite this, it can be a very useful pattern to <span>decouple assemblies</span>.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
