<html><header><title>Refreshing cached lists?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Refreshing cached lists?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2000.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Monday, December 18, 2006</h2>Hi,<br><br>I'm caching some NVLs, as per Rocky's example in the book.&nbsp; I also invalidate the list properly when changes are made to it.<br><br>The only problem is that I bind the lists to some BindingSource components, and if the list is changed after the binding, the dropdown lists which use the BindingSources don't have the most current one.<br><br>What's the best way to get the list updated in this case?&nbsp; Is it time I finally look at ActiveObjects?&nbsp; Or is there a better way?<br><br>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Monday, December 18, 2006</h2>Looks like its time!! :D<br>Also, I believe some people use cab... but I don't know much about it.<br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 19, 2006</h2><P>Hang on a minute here.&nbsp; Are you saying if I set a BindingSource component's DataSource to a list business object, and the business object updates itself, that the next time the dropdown using that BindingSource is activated it will NOT contain the changes?&nbsp; That would seem to imply that the BindingSource or DropDown itself has some sort of cache which isn't the case.</P>
<P>Is what we're really talking about the fact that in the CSLA / DataPortal paradigm the database lookup results in a new instance?&nbsp; If so, is ActiveObjects (specifically, the observer channel pattern implemented there I presume) really the best solution to that?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Tuesday, December 19, 2006</h2>It doesn't have to do with the binding source... Here's how it goes:<br><br>Your nvl (say, ProductCodes) is cached (in andy's case) in a static variable in your class.<br><br>When you add a new product code, you do ProductCodes.Invalidate(). This only removes that cache and forces the nvl to reload the next time sometimes does ProductCodes.GetProductCodes(), but if you already have instances of that nvl in use, you need either to update them manually with the new list or have some sort of observer watching for an event that indicates that a product code was added / deleted / modified...<br><br>That's the problem scenario. There are several solutions out there. I mentioned the 2 I know are used a lot (CAB and AO / Observer pattern), but there may be others.... Which one suits your needs best is up to you to decide. Personally I'm an AO fan.<br><br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 19, 2006</h2>Ah... I just took the simpler (and cruder)&nbsp;design of only having one "global" instance&nbsp;for the static nvl types in the first place.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Nicholas Trevatt replied on Wednesday, August 15, 2007</h2>I know this post was a while ago but I'm looking at options to solve my synchronization/caching problems and came accross this post.<br><br>Dan, just to be sure I'm following you correctly in your example - do you expose the cached (static) nvl type and bind straight to that in your UI?&nbsp; Indeed this certainly sounds simpler but are there any downfalls?<br><br>Cheers,<br>Nicholas<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
