<html><header><title>Command Object Use Case</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Command Object Use Case</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4982.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Warren posted on Monday, June 16, 2008</h2><P><BR>I am looking for advice on BO design for some batch functionality I will be adding into a new winforms application.&nbsp; I would like to create a solution that is similar to an method used in an existing non-csla, VB6 winforms application. </P>
<P><BR>The non-csla application process is: </P>
<OL>
<LI>A DB stored procedure is triggered which loads bank balance information from a flat file into a temporary database table and then validates each record.</LI>
<LI>If no validation errors occurred, this same stored procedure copies the records from the temporary table into a permanent table which stores bank balance information then deletes all records from the temporary table. </LI></OL>
<P>&nbsp;&nbsp; <BR>In my new application, all database access is done via stored procedures, no in-line SQL statements are allowed.</P>
<P>I have 3 use cases for the bank balance information: </P>
<OL>
<LI>Load Bank Balance Information.</LI>
<LI>Edit Bank Balance Information.&nbsp;</LI>
<LI>Various other uses cases that need read only use of bank balance information.</LI></OL>
<P>For use cases 2 &amp; 3 I am planning to create an Editable Root Object, Readonly Collection Object and ReadOnly Object. </P>
<P>After reading the book on pages 240-243 I think I should use a Command object for the Load Bank Balance use case. Most of the validation used in the current stored procedure is not business rules but is ensuring a date is valid and numbers are in valid numeric format. However, there is <BR>some validation that searches other tables for existence of a related record. </P>
<P>My specific questions are: </P>
<P>1) Is the Load Bank Balance use case a good candidate for a Command Object?<BR>2) Should the validation portion of the current stored procedure that searches for related records be moved out to a separate command object which implements exists functionality?</P>
<P>Any feedback is appreciated, thanks. </P>
<P>&nbsp;</P>
<P><BR>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, June 17, 2008</h2><P>IMO</P>
<P>#1 - No. This is not a good place for a Command Object.</P>
<P>I would actually tyr to re-use the Editable Root Object instead. It will have all of your validation rules for Bank Balance so if you try to load information from a file into a new instance then you will Know whether or not it IsValid right away and then you can also .Save it.</P>
<P>#2 - not sure what code is in the SP but I would just add validation rules to the Editable Root object and then cover all cases.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Warren replied on Tuesday, June 17, 2008</h2><P>Hi Joe, </P>
<P>#1 - I can understand the benefits of using the business rules already in the&nbsp;business object to load the data but I thought that the code that finds the flat file and bulk loads it into the temporary table should be encapsulated in an object also, hence my idea of using a Command object to load this data. &nbsp;</P>
<P>#2 - The code in the SP executes various "does record exists" calls. For example, a&nbsp;bank balance record&nbsp;contains information about the balance for an account at a particular bank. In order for the bank record to pass validation, I must make sure that the bank and account number already exists in the database. I thought this was a good &nbsp;reason to develop two command objects BankExists and AccountExists.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, June 17, 2008</h2><P>#1 - I agree that the code for locating and loading the flat file should be entriely separate. I use a Winforms app for this kind of code. But once the data is loaded in memory (usually in a datatable) then I simply new up an instacne of my root BO and load its properties with the data. Then I test if it IsValid and try to save it. If there are any issues, I log them and then loop back and do it again. So I catch any exceptions to ensure I have the chance to keep looping.</P>
<P>#2 - I agree completely that BankExist and AccountExists could be 2 command objects. But I would simply use them both in rules for my root BO. I also use rule priority of 1 for DB calls so that all other simple rules must first pass before we hit the DB.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Tuesday, June 17, 2008</h2>Hi Warren,<br><br>the CSLA-way of doing what you want would be as follows (IMHO): <br><br>Create an editabe child object ('FileEntry') that represents one single entry in your file.<br>Create an editable child list (Of FileEntry), named 'MyFileData'.<br>Create an editable root parent object ('ProcessFileUseCase'), containing a MyFileData as a child object.<br><br>ProcessFileUseCase would be responsible for accessing the file system and loading the data contained in the file. You would pass the filename to the GetProcessFileUseCase factory method. That factory method would pass the filename to the DataPortal_Fetch method through the criteria object.<br><br>DataPortal_Fetch would make the file system access, and fill its MyFileData child list.<br>Note that if the application should run on an arbitrary client machine, what I suggest here only works with a remote DataPortal configured, because of the file system access from within the DataPortal!<br>Otherwise the DataPortal would have to call a service that would be running on the machine where the files are located...<br><br>Your FileEntry class would have validation rules for each presumable foreign key fields.<br>You will need a lookup-list class (NameValueListBase derived) for each foreign key you want to check. Make sure you use a cached list there! See the RoleList in the ProjectTracker example.<br>Then your validation rules would try to look up the value read from the file in these lists. If not found, the rule would be broken, and your ProcessFileUseCase object would refuse to save. Override IsValid therefore.<br><br>Then you could choose to further process the valid/invalid entries i.e. saving the valid ones to db and writing back the changes to the file...<br><br>Your command objects would trigger at least one database roundtrip per file entry.<br>Following my suggestion would only result in one hit per lookup list!<br><br>Hope that helps!<br><br><br>Stefan<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SomeGuy replied on Tuesday, June 17, 2008</h2><P>Assuming that this is a process that is only run once for the whole company, not different clients loading thier own data; I would stick to a process similar to what you have, and have most of the work done on the server and by the db server. You can use a Command object to kick off the process, by loading the temp db table (DTS?), and then calling the sproc that validates/imports the data. If you can do all the work in a sproc, do it!</P>
<P>I would reserve BO's for interactive user operations, like viewing/editing the invalid records to be fixed and imported manually.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
