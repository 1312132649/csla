<html><header><title>Inheritance and data access methods.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Inheritance and data access methods.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6244.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>dctc42 posted on Friday, January 23, 2009</h2><P>Hi All,<o:p></o:p></P>
<P>The project I'm working on involves a somewhat complex&nbsp;business objects hierarchy with several layers of inheritance. It's more complex than I would like it to be but we're gradually upgrading an existing application and can't change the feature set or program flow so we don't have many options. <o:p></o:p></P>
<P>To give you an idea of what I'm dealing with: <o:p></o:p></P>
<P>POSDocumentBase is a parent class (abstract) of PayOnAccountDocument as well as SaleTicket. Both concrete classes share the same backend data model (one of things I'd like to change but can't because it impacts about a billion reports and data analysis tools). They also share about 20 properties in the base class. <o:p></o:p></P>
<P>Do I write data access methods in the base class and override on concrete classes to deal with newly introduced attributes or should I keep the base class out of this and rely on good old copy/paste?<o:p></o:p></P>
<P>My main concerns are maintainability and performance (I need to handle very large transaction volumes) but loose coupling is also important in case we get chance to refator some of this.<o:p></o:p></P>
<P>Is using polymorphic techniques in data access methods a good approach? What are some of the pros and cons?<o:p></o:p></P>
<P>Thanks</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, January 23, 2009</h2>This is tough.<br><br>Inheritance and loose coupling are in direct conflict. Inheritance is one of the most tightly coupled relationship types in all of OOP...<br><br>To have any hope of loose coupling, you need to make each class in the inheritance hierarchy be as unaware of its base or subclasses as possible. This is especially true with virtual methods.<br><br>When discussing this in terms of data access, what it means is that each class in the hierarchy must be responsible for loading only its data. Which means doing a database query for each class. Which means a given object instance might do 2+ database queries depending on the depth of your hierarchy.<br><br>Obviously that can be a performance problem, so few people do that.<br><br>An alternative, is to accept a higher level of coupling, and have the leaf node subclass do the database query to retrieve its data, and the data for all its base classes. This clearly breaks encapsulation, because the leaf subclass must know all the fields required by all its base classes up the chain. But it provides good performance.<br><br>Yet another alternative, is to define a way by which you generate a dynamic SQL statement (specifically the SELECT clause) by allowing all classes in the inheritance hierarchy to inject their required column names. Then the leaf subclass runs the query. This can obviously become very complex, especially if 2+ tables (or databases) are involved in loading a single object.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, January 23, 2009</h2>As Rocky has pointed out, inheritance is a tightly coupled design.. so that ship has sailed, more or less.<br><br>As for subclasses have extra properties / attributes or whatever, what I've done is provide in the base class an InsertSelf method, and an OnBeforeInsertSelf and OnAfterInsertSelf virutal or abstract methods.&nbsp; These will provide subclasses with a known place in the data update process to do their processing.&nbsp; <br><br>These seems to work pretty well, and I have a similar situtation as you; a base Document class, and in my case I have Quote, Order, Invoice, etc inhertiting behavior from that base class.&nbsp; But the key is to well define what the base class does, and what the subclass will do (and what it should NOT do), and to only keep common behavior in the super class.&nbsp; As soon as behavior is not shared, move it down the chain.&nbsp; For example, I have an OrderBase which is a subclass of Document, and Order, RMA and other documents considered orders inherit OrderBase.&nbsp; Invoice directly inherits Document, and it adds it's own behavior as well.<br><br>So the pros are that, if done right, you have a good design and can add behavior at each subclass level as needed, the con is that by definition using inheritience is creating a tightly coupled design.&nbsp; It can work... but pay close attention to detail.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dctc42 replied on Friday, January 23, 2009</h2><P>Thanks Rocky and Any for your insight.</P>
<P>I've made my piece with coupling the base class and all the node classes. As you say this is inevitable. What I'd like to decouple as much as possible are the concrete document types. One of my design goals is to be able to deploy a SaleDocument component in a "Cash and Carry" POS app and be able to deploy an OrderDocument component on the web for e-commerce apps. </P>
<P>Currently all these classes live in a single, mountrous, monolith object chuck full of branching logic everywhere. I need to support existing UI's (Win32 app + COM) so I'm having to make some tough choices. </P>
<P>Thanks again for your help.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Friday, January 23, 2009</h2>I've seen a pattern for populating collections of objects where a parent object runs a query and passes the
resulting Reader around to child classes so they children can populate
themselves.&nbsp; This is (I believe) what Rocky meant when he said, "few people do that" (referring to a query per object).&nbsp; In this case, you're accepting limited coupling in return for performance.<br><br>But I've also done something similar with inherited classes.&nbsp; Run your query and grab the reader in your base class, populate all the base class properties, then pass the reader to an abstract method that derived classes can use to populate their specific data.&nbsp; If your queries vary from subclass to subclass (which they're likely to do if the data model varies), then you can use another abstract method to get the command to execute, or variations on that theme (for instance, run the query in the derived class and pass the reader to the base).<br><br>Again, you're trading increased coupling for (in some cases) dramatically reduced code size.&nbsp; You'll have to consider whether you like that tradeoff in your application, but it can work pretty well.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, January 23, 2009</h2><P>I use a pattern very similar to what dlambert describes.</P>
<P>Here is a sample for a child BO:</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Overridable</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</FONT></FONT><FONT size=2> Fetch(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> dr </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> SafeDataReader)<BR>SetDefaults()<BR>FetchData(dr)<BR>PostFetchData()<BR>FetchChildren()<BR>MarkOld()<BR>ValidationRules.CheckRules()<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Overridable</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</FONT></FONT><FONT size=2> FetchData(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>ByVal</FONT></FONT><FONT size=2> dr </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> SafeDataReader)<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>With</FONT></FONT><FONT size=2> dr<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If</FONT></FONT><FONT size=2> .Read = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>True</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Then<BR></FONT></FONT><FONT size=2>&nbsp; mKey = .GetInt32(</FONT><FONT color=#ff00ff size=2><FONT color=#ff00ff size=2>"key"</FONT></FONT><FONT size=2>)<BR>&nbsp; </FONT><FONT size=2>&nbsp;'etc.<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>If<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>With<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Overridable</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</FONT></FONT><FONT size=2> PostFetchData()<BR></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>'marker method that can be overridden in child class<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</P></FONT></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Protected</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Overridable</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</FONT></FONT><FONT size=2> FetchChildren()<BR></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>'load child objects here if there are any using a second datareader<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Dim</FONT></FONT><FONT size=2> dr2 </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>As</FONT></FONT><FONT size=2> SafeDataReader = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Nothing<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Try<BR></FONT></FONT><FONT size=2>dr2 = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>New</FONT></FONT><FONT size=2> SafeDataReader(DAL.ExecuteReader(DAO.SelectByKey(mKey)))<BR>mLines = Lines.GetLines(dr2)<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Finally<BR></FONT></FONT><FONT size=2>dr2.Close()<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Try<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>End</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>Sub</P></FONT></FONT>
<P>In a derived class you can choose to Override any of these methods and optionally call back in to the Base class to fill the common data first. You can also decide which level will determine the query to populate the dr and branch/override accordingly.</P>
<P>Joe</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
