<html><header><title>Authorization &amp; Object Retrieval</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Authorization &amp; Object Retrieval</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7190.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Slayer posted on Monday, June 29, 2009</h2>Hi<br /><br />I have a editable USER object. Restricted users may not create or view existing USERS on the system, they may only modify their own profile.<br /><br />I have CanGetObject and CanAddObject and CanEditObject methods on my USER object. For restricted users the CanGetObject must return false in all the cases, except where the user wants to modifies his or her USER profile. I dont want to return true on my CanGetObject method for these users. Any ideas ?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 29, 2009</h2><P>This is a pretty common question.</P>
<P>The thing to remember is that the CanGetObject(), etc. methods are <EM>per-type</EM>, not per-instance. They are static (or in 3.5 and higher they are on Csla.Security.AuthorizationRules).</P>
<P>What you are asking for is per-instance authorization. To even know the rules, you have to have an instance of the object, otherwise you don't know if it is for the user or not.</P>
<P>There is no per-instance authorization concept in CSLA .NET at this time. I'm not sure there ever will be, for two reasons</P>
<OL>
<LI>It isn't clear how such rules could be standardized - they are clearly not just role-based or the per-type system would be sufficient</LI>
<LI>.NET has no formal concept of authorization - so anything I made up would be just as valid as anything you are going to make up - so I don't see where CSLA would provide value beyond what you'll do by implementing an instance method on your class</LI></OL>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Henrik replied on Thursday, July 02, 2009</h2>What you really have is two different use cases:<br /><br />One use case is administrators (not-restricted users) creating/editing/deleting users in the system,<br />and the other is a user maintaining his/her user profile.<br /><br />In my own systems I usually have two different editable root classes:<br /><br />1. User (only accesible by admins).<br />2. UserProfile (can be accessed by any user, but can only load, edit and save data for the current user. This is ensured inside the class in DataPortal_Fetch where the current user's id, which I have in the current Principal.Identity.UserId, is added as a parameter to the stored procedure that fetches the current user's data).<br /><br />Cheers<br />/Henrik</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>whelzer replied on Saturday, July 04, 2009</h2><br>We override the Can methods so we'll have something like:<br><br>shared function CanAddObject() as boolean<br>&nbsp; return isinrole("adders")<br>and <br><br>shared CanAddObject(obj as myBO) as boolean<br><br>select case obj.MyProperty<br>&nbsp;&nbsp; case whatever<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanAddObject()<br>&nbsp;&nbsp; case somthingelse<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false<br>end <br><br>Fairly sure (hope) I got this idea from the Forum...either way it works for us..<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
