<html><header><title>AuthorizationRules Implementation question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>AuthorizationRules Implementation question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5547.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Pawz posted on Monday, October 06, 2008</h2>I've got a bit of a best practices question here in implementing authorization rules, and I'm wondering what you guys think.<br><br>Roles &amp; access for users is something that shifts constantly around here - staff shifts around doing different things fairly often. I need to be able to enable / disable access to individual fields and buttons in my application based on each user.<br><br>The Project Tracker example has the authorization using a simplistic, hardcoded roles system which wasn't going to work for what I needed. Roles aren't known before hand, so they need to linked up to the database and loaded on a per-user basis.<br><br>Anyways, I came up with the following solution:<br><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void AddAuthorizationRules()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Utils.IsAdmin())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (PropertyInfo props in GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance)) //All public <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowRead(props.Name, "AllowRead" + props.DeclaringType.FullName + "." + props.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowWrite(props.Name, "AllowWrite" + props.DeclaringType.FullName + "." + props.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font><br><br>So it looks at itself and for each public property it creates a unique 'role', which matches up with a record in the database - when the user logs in, the user's list of roles is filled with these unique roles - some several thousand of them. It works, but I can't shake the feeling there's a better way to handle it.<br><br>Any thoughts would be welcome.<br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Tuesday, October 07, 2008</h2>Have you thought about writing Custom Principal and Custom Identity classes.&nbsp; Specifically, overriding the IsInRole method.&nbsp; There is nothing to prevent you from defining your own set of roles for the application; that is, different roles from those provided by active directory.&nbsp; These roles could be quite fine-grained: "allowed to access field X".&nbsp; The Custom Identity could retrieve/fabricate the roles from the database.&nbsp; <br><br>Before I went down that path, I would be inclined to step back and ask what the requirements are.&nbsp; If it is the case that the application must be able to constrain each user uniquely, I really do not see a much better way than you described.&nbsp; What you are saying in this case is that there are no patterns of access.&nbsp; A role is just a pattern of access.&nbsp; Every user is unique.&nbsp; This might be true but I would find that quite astonishing.&nbsp; More likely, there are a fixed number of use cases that define the authorized actions.&nbsp; If you have defined your use cases, you could define a "role" per use case: Judy is allowed to execute use case Alpha but not use case Beta.&nbsp; Each use case would define a set of properties that could be accessed.&nbsp; At this point, patterns of usage start to show up.&nbsp; The custom Principal and custom Identity could setup those roles from the contents of the database.&nbsp; My guess is that this would be simpler than what you are doing now.<br><br>Jon Stonecash<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Pawz replied on Friday, October 10, 2008</h2>Yeah, I've pretty much come to the same conclusion here - in this case, Judy is allowed to execute use case Alpha, but only part of Beta.<br><br>In a lot of cases, I can group the behaviours together, so I've allowed for grouping securables together under a 'role', but the role is defined as the collection of items rather than a specifically hardcoded item. <br><br>They just love to shift users and roles around here.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Friday, October 10, 2008</h2>Hi,<br><br>be aware that the example you posted won't work <br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Pawz:</strong></div><div><br><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void AddAuthorizationRules()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Utils.IsAdmin())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (PropertyInfo props in GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance)) //All public <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowRead(props.Name, "AllowRead" + props.DeclaringType.FullName + "." + props.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRules.AllowWrite(props.Name, "AllowWrite" + props.DeclaringType.FullName + "." + props.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font><br></div></BLOCKQUOTE><br><br>AddAuthorizationRules is called only once in the apps' lifetime. <br>So if you follow the PTracker pattern for login/logout, if the user that logged in first was an admin, <br>there would be no authorizationrules for any other user that would log in later...<br>You should just add the rules here, and move the IsAdmin check to your custom IsInRole override!<br><br><br>Stefan<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
