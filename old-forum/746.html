<html><header><title>Performance and memory use with large result sets (collections)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Performance and memory use with large result sets (collections)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/746.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SteveInCO posted on Thursday, July 27, 2006</h2><P>Hello,</P>
<P>I've been working with CSLA.Net 2.0&nbsp;(VB) for several weeks now, and I really like it so far. It is very similar to the approach I took with my last project under VB6, although of course much more sophisiticated and complete. </P>
<P>It also seems to suffer from the same issue I had with my VB6 project...what do you do when you have a large result set (i.e. collection) that needs to be filled? Some of my queries may have <EM>several thousand</EM> records (and therefore objects) returned. When using a "collection" model for this type of result set, the problems are twofold: </P>
<OL>
<LI>It takes a long time to read all that data and build all those objects during which time the caller is in a wait mode. </LI>
<LI>The objects take a lot of memory once the collection is populated.</LI></OL>
<P>Collections are handy and easy to work with, but they don't lend themselves to large chunks of data. </P>
<P>In my previous project, I took the approach of using collections any time I expected a small result set or wanted to cache data, but then I designed another type of retrieval object for large result sets that functioned more like a Recordset or DataReader...you start it up, then continuously call a GetNext method until you reached the end of the result set.</P>
<P>This works much better for large sets of "throwaway" objects where you have to retrieve a lot of them, but don't need them all in memory simultaneously. There is no long pause while they are read from the data source, and you never have more than one of them in memory at a time. </P>
<P>An example might be generating a report. It doesn't make sense to load every detail line in to memory and then generate the report...it is much more efficient to load them one and a time add them to the end of the report. </P>
<P>So all this leads to the question: Is there some predefined way to do something like this in CSLA? Maybe I missed it in the book (I confess I didn't read every chapter), and I didn't see anything in Project Tracker that used this sort of model. Do I need to "roll my own"?</P>
<P>Suggestions appreciated.</P>
<P>Thanks.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, July 27, 2006</h2>If you really need to do that, you could implement a "merge" functionality in your collection (which would probably be really really simple for what you want to do).<br>Then you'd be able to retrieve the objects by chunks of tens or hundreds and simply append them to the existing collection...<br>You could do something like yourCollection.RetrieveMore() which internally will fetch another list passing the id of the last loaded record or something like that and then when the list is loaded append the records to your current collection.<br><br>You'd probably want to do this in a background thread, because otherwise there is no gain but in the end the result is probably goint to be. Also, take note that if you're using databinding to display the items and you use threads, this is not safe.<br> <br><br><br>Andr√©s</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SteveInCO replied on Friday, July 28, 2006</h2><P>That could help with the load performance, but it wouldn't really do much for the memory usage problem unless I also dumped the previously loaded items as I loaded the next block. That would kinda defeat the purpose of a collection wouldn't it?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pvanroos replied on Thursday, July 27, 2006</h2><P>... And, if I may... I would like to add on to this... I am building a web application that utilizes some async calls (AJAX).&nbsp; Like everyone, I anticipate a new model for&nbsp;ASP.NET&nbsp;web applications emerging with the advent of AJAX-enabled controls.&nbsp;&nbsp;For instance, I have&nbsp;some web&nbsp;pages that utilize 3 to 4 business objects at once.&nbsp; In CSLA 2.0, that means&nbsp;I have to set up 3 to 4 data sources&nbsp;controls to manage, at the very least, the&nbsp;retrieval&nbsp;of&nbsp;records.&nbsp; If the individual controls on the page utilize async calls to retrieve this data without refreshing and&nbsp;reconstructing the whole page, this more discrete model is fine.&nbsp;&nbsp; However in the traditional sense, this is not acceptable, given that each SelectObject call using CslaDatasource will open and close a database connection per control--thus incurring a performance hit.&nbsp; </P>
<P>Perhaps I'm wrong.&nbsp; Maybe this aspect of scalability is negligible.&nbsp; Maybe somebody has a better approach to the architecture.&nbsp; </P>
<P>Thanks guys.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rlarno replied on Friday, July 28, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>pvanroos:</strong></div><div> 
<P>&nbsp;However in the traditional sense, this is not acceptable, given that each SelectObject call using CslaDatasource will open and close a database connection per control--thus incurring a performance hit.&nbsp; </P>
<P>Perhaps I'm wrong.&nbsp; Maybe this aspect of scalability is negligible.&nbsp; Maybe somebody has a better approach to the architecture.&nbsp; </P>
<P></div></BLOCKQUOTE></P>
<P>The effect of opening and closing a database connection in .NET would be negligible, as by default connection pooling is used. In fact, opening the connection as late as possible and closing it as soon as possible helps the scalability of the application. As the connection is not actually closed when you call .Close(), but merely returned to the connectionpool, another page request (or background thread in a WinForms app) can pick up that connection and use it. So you are really only using 1 active connection to the database. If you were to keep your connection open, that other page request (or thread) would need to open another connection to your database (most likely to be an already open connection from the connection pool). So at that point you would have 2 active connections being used.</P>
<P>Say that the connectionpool will hold a maximum of 2 active connections and you have 3 concurrent &nbsp;requests comming in, so we are simulating a high load on the server.</P>
<P>If you do not close the connection<BR><PRE>request 1: open connection, fetch object 1, do some processing, fetch object 2, fetch object 3, close connection<BR>request 2:&nbsp;open connection, fetch object 1, do some processing, fetch object 2, fetch object 3, close connection<BR>request 3: ... waiting for a connection ...                                               ... open connection, fetch object 1, etc.</PRE>
<P>The 3rd user will most likely complain, as s/he will need to wait a long time before the request even gets serviced.</P>
<P>If you do close the connection after each db operation, the result might be as follows:</P><PRE>request 1: open, fetch object 1, close, do some processing, open, fetch object 2, close, open, fetch object 3, close <BR>request 2:&nbsp;open, fetch object 1, close, do some processing ...       open, fetch object 2, close, ...                open, fetch object 3, close<BR>request 3:                              open, fetch object 1, close, do some processing ...       open fetch object 2, close, open, fetch object 3, close</PRE>
<P>Although that the individual response times might become longer, each user will get their request fulfilled in due time. And so you will be able to server a lot more users at the same time.</P>
<P>hope this helps.</P>
<P>Rudi</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pvanroos replied on Friday, July 28, 2006</h2><P>Hi Rudi,</P>
<P>Thanks for the response.&nbsp; </P>
<P>Much appreciated,</P>
<P>Paul</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SteveInCO replied on Friday, July 28, 2006</h2><P>It occurred to me that I may not have been clear. I don't advocate opening a new connection and data reader for each of the objects when the GetNext method is called...here's a general idea of how I did it before:</P>
<P><FONT face="Courier New" size=2>MyObject = MyObjectList.Begin&nbsp; ' Opens the connection, runs the query,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp;and returns the first object<BR></FONT><FONT face="Courier New" size=2>While MyObject IsNot Nothing&nbsp;&nbsp;&nbsp;' MyObject will be nothing if there were<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' no results<BR><BR></FONT><FONT face="Courier New" size=2><FONT color=#808080><FONT color=#000080>&nbsp;&nbsp;&nbsp; ' Perform whatever processing on the object here<BR></FONT><BR></FONT>&nbsp;&nbsp;&nbsp;MyObject = MyObjectList.GetNext ' Get the next object from the results,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' or returns Nothing on EOD.</FONT><FONT face="Courier New" size=2><BR></FONT><FONT face="Courier New" size=2>Wend</FONT></P>
<P>The SQL query would get run during the Begin method and the DataReader that receives the results would be left open. The Begin method returns the first object from the results (i.e. calls GetNext the first time for you). Each subsequent call to GetNext takes the next record out of the DataReader, builds an object and returns it. The only disadvantage of course is that the DataReader is left open the entire time, but as long as your processing doesn't goof around too long, that isn't that big a deal. </P>
<P>I gather by the responses that CSLA doesn't really have anything with this sort of mechanism built in to it. </P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
