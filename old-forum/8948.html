<html><header><title>Authorization Rules not thread safe</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Authorization Rules not thread safe</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8948.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>cejones posted on Monday, May 17, 2010</h2><p>We recently encountered an issue with a web service that hung and took up the entire CPU.&nbsp; A memory dump showed that it was calling Dictionary.TryGetValue as a result of Csla.ReadOnlyBase.CanReadProperty. &nbsp; Since CanReadProperty writes to a dictionary without synchronizing first, that can lead to an infinite loop.&nbsp; See more details as Tess explained it in her blog <a href="http://blogs.msdn.com/tess/archive/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary.aspx">here</a>.&nbsp; Basically any multi-threaded application, web application or even WPF application with asynchronous binding, can run into this problem.</p>
<p>We are currently using CSLA 3.6.2, but it seems the problem will still exist in 3.8.3 and even 4.0.</p>
<p>We&#39;re just going to patch the version that we&#39;re running but I&#39;m curious if there are other suggestions on using authorization rules with a multi-threaded application.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, May 17, 2010</h2><p>I just posted a related question on very much this same topic. CSLA has a few places in it that read dictionary objects without locking them while a write might be concurrently altering them...</p>
<p>&nbsp;<a href="http://forums.lhotka.net/forums/t/8947.aspx">http://forums.lhotka.net/forums/t/8947.aspx</a></p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>You can&#39;t actually share an object instance across threads, and I suspect that&#39;s what you are doing?</p>
<p>CSLA objects are not threadsafe. Putting a CSLA object into a global cache on a server is off limits. If you must do such a thing, you&#39;ll need to clone the object into and out of your cache - thus ensuring that each thread has a copy of the object, not a shared instance.</p>
<p>On the other hand, if I&#39;m making a faulty assumption and you are seeing this issue without a shared object instance, please let me know, because that would be a problem I&#39;d want to explore further.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, May 17, 2010</h2><p>Not even &quot;read only&quot; objects like NameValueListBase, etc??? It never even occurred to me to worry about thread safety for an object that is never changed after it has been created. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p>NVL is probably fine.</p>
<p>ReadOnlyBase is the problem, because it has authz rules. Those rule results are cached. When the object detects that the principal has changed, it discards the cache.</p>
<p>If the object is used by two threads/users at the same time this can obviously cause nasty issues.</p>
<p>Now I suppose if your ROB object has not authz rules this is a non-issue. And you could ensure it is a non-issue by overriding CanReadProperty() and just return true - thus avoiding the invocation of the authorization system completely.</p>
<p>But as a general rule, ROB objects shouldn&#39;t be shared across threads.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
