<html><header><title>Real-World DDD: Structuring the Domain Layer</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Real-World DDD: Structuring the Domain Layer</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10243.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Wednesday, April 06, 2011</h2><p>I am trying to make the jump from data-centric design and development into more of a DDD approach (using CSLA for my domain objects, of course!) and have read Evans and Nillson but am still having trouble wrapping my head around how I should structure my Domain Layer.&nbsp; I&#39;m sure the nature of my current project isn&#39;t helping!</p>
<p><strong>A little background</strong></p>
<p>The application is an internal solution to manage personnel assessments. HR personnel will create assessment &quot;templates&quot; that consist of a set of questions that team leads and managers are to complete for each of their direct reports.&nbsp; The answers are persisted for auditing and review. These assessments can be for a wide variety of things such as feedback for company initiatives, performance reviews, etc.</p>
<p><strong>The data-centric side of me</strong></p>
<p>Not to influence the solution but highlighting my data-centric mindset, I already have a vision for the database schema and include it here only for reference (since a picture says a thousand words):</p>
<p><a href="http://forums.lhotka.net/cfs-file.ashx/__key/CommunityServer.Components.UserFiles/00.00.00.24.85/Domain_2D00_Model.png"><img src="http://forums.lhotka.net/resized-image.ashx/__size/550x0/__key/CommunityServer.Components.UserFiles/00.00.00.24.85/Domain_2D00_Model.png" border="0" alt="" /></a></p>
<p>The schema is, as would be expected, normalized and does not match how the data is handled in my application.&nbsp; And, I&#39;ve left out lookup tables and the like to try and keep it to a minimum for the problem at hand.</p>
<p><strong>The use cases</strong></p>
<p>The first use case is to retrieve and display a list of assessments that a user needs to completed.&nbsp; This will be displayed when the user first signs into the application and at first it seems like it would be relatively easy, but there are two wrinkles: 1 - assessments are time-based so they may be required monthly, annually or every &#39;x&#39; number of years based on the employee&#39;s Anniversary Date; and, 2 - users can save an assessment in-progress and complete them later.&nbsp; As a result, the list should contain assessments that are due as well as any that are in-progress.</p>
<p>Next, when the user selects an assessment to perform, I need to retrieve all of the questions for that assessment (the current version) so that I can display them to the user. At any point during the assessment, the user may save the current results. Only after the entire assessment has been completed may it actually be &#39;submitted&#39; - or committed.</p>
<p>Third, HR needs a way to re-generate the assessment with the responses provided by the supervisor.</p>
<p>Finally, HR is able to create and modify assessments - and they are versioned. So whenever someone modifies an assessment, a new version is created and that one becomes the template for any NEW assessments that are performed (any in-progress assessments continue using their original template).</p>
<p><strong>The Domain Model</strong></p>
<p>Working out of order, it makes sense to me that I will have an Assessment entity that is an Aggregate Root (business root)&nbsp;to satisfy the fourth use case. It will have a child collection of Section entities that will, in turn, have a child collection of Question entities.&nbsp; They are all entities because they have identity (yes?) but still implented as child objects/collections.&nbsp; The Assessment is the object that consuming code uses for persistence, validation, etc (although the Section and Question entities validate themselves and roll-up the status to the root Assessment). My goal is to make the versioning abstract from the consumer and implement it in the data persistance layer (good or bad idea?)</p>
<p>This means that I will also have an AssessmentRepository that handles persistence for me and, possibly, an AssessmentFactory that creates a new Assessment when needed.</p>
<p>The bigger issue comes with the other use cases.&nbsp; Do I have an EmployeeAssessment Aggregate root as well? Or is it simply an entity?</p>
<p>Looking at the use cases, I need to use this information a couple of ways. First, when I am generating the list of assessments to display to the user, I have to not only evaluate the list of direct reports against the assessment frequency, but I also need to know if I&#39;ve already started and/or completed an assessment for that employee.&nbsp; And that comes from the EmployeeAssessments table.&nbsp; The other case is when a user actually performs the assessment in which case, I am interacting with the EmployeeAssessments and Responses tables.</p>
<p>From the UI perspective, when a user is performing the assessment, they know nothing of the internal data structure, etc.&nbsp; I need to supply the UI with the list of questions for that assessment to display and accept the list of responses to persist.&nbsp; Does this lead to a second root with accompanying repository, etc?</p>
<p>The third use case is similar in that HR wants to be able to re-generate the assessment with responses at a later date. However, I&#39;m thinking the same process used when performing the assessment can be used here because resuming an existing assessment would require the same data with the only difference being read/write capability versus read-only for HR.</p>
<p><strong>Wrap it up already!</strong></p>
<p>Okay, I&#39;ve rambled on enough and think I&#39;ve cleared my head of the cob webs.&nbsp; I appreciate any direction, suggestions, critiques, etc.&nbsp; As I said, I&#39;m trying to make the jump and think I understand the concepts, now it&#39;s a matter of applying them.&nbsp; Thanks!!!</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, April 07, 2011</h2><p>Some rules of thumb, in my view anyway:</p>
<ol>
<li>Remember that business objects are not entities - entity objects are data containers, business objects are behavior containers</li>
<li>Design each use case independently - don&#39;t worry about reuse during design</li>
<li>Once you have the use cases designed, look for common types across use cases - don&#39;t force the issue by combining objects with similar (but different) properties - reuse is the flip-side of coupling, and coupling is the ultimate evil - you can&#39;t have reuse without evil</li>
<li>Once you have the use cases designed, remember to &quot;normalize behavior&quot; by pulling common behavior from different objects into shared objects or rules - often these aren&#39;t stateful objects, but are &quot;rule bags&quot; that are pure behavior</li>
</ol>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Thursday, April 07, 2011</h2><p>Rocky, &nbsp;I&#39;ve used your framework since 2003 and am currently using it now (still on 3.8 but I bought the 4 e-book and am getting ready to upgrade). </p>
<p>There is a big black hole in my understanding of your writings. &nbsp;The hole exists between:</p>
<p>#1 &nbsp;You say &quot;Entity objects are data containers and business objects are behavior containers&quot; and you always talk of behavior driven thinking</p>
<p>and</p>
<p>#3 &nbsp;Your business objects in Project Tracker look an&nbsp;awful&nbsp;lot like your data tables</p>
<p>What is #2 such that you can make sense out of #3. &nbsp;To us outsiders, your Project Tracker objects look like entity objects...most of the behaviors are the ones that come BUILT INTO THE FRAMEWORK:<br />- editable or read-only<br />- bind-able<br />- &nbsp;authorize/validate etc.<br />- easy CRUD plug-able<br />- easy UI changeable (mono, silverlight, etc)</p>
<p>Are those the behaviors you are talking about? &nbsp;If yes then the &quot;behaviors&quot; are mostly already there and abstracted <i>into the</i>&nbsp;<i>framework.</i>&nbsp;&nbsp;All that is left is to mix in our entity shapes and authorization/validation stuff? &nbsp;That feels awfully data-driven to me...but only because you already took care of most of the behaviors common to most business apps.</p>
<p>I feel like the kid in &quot;Enter the Dragon&quot; who is looking for Master Sum-Dum-Guy!!!</p>
<p>Rocky, another way to approach this question would be to answer this. &nbsp;What behaviors did I build into my code so that I am behavior driven not data driven:<br />1. &nbsp;as Rocky the framework developer<br />2. &nbsp;as Rocky the Project Tracker developer</p>
<p>The answer to #1 is obvious to me...it is why we all love CSLA. &nbsp;The answer to #2 is a mystery to me.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, April 07, 2011</h2><p>Let me clarify because I sense confusion.&nbsp; I used the term &#39;entity&#39; in the DDD sense which is all about encapsulating Domain Logic (Business Logic) in the Domain Layer and, in DDD terms, an Entity is an object that has Identity.&nbsp; I realize that in the world of Entity Framework, etc. that the term can also be applied to more of a table-driven design with objects that possess only state.&nbsp; However, having been a long an avid CSLA user and evangelist (and Tech. Ed. on your 2008 books), I am all about making sure that our business objects are more than just state bags.</p>
<p>In my opinion, the more I get to understand Domain Driven Design the more it looks like CSLA - or that CSLA is the perfect framework for developing DDD applications.&nbsp; Our &quot;Business Objects&quot; are our Domain objects.&nbsp; Those with identity are DDD &quot;entities&quot;, our root objects are their &quot;root&quot; objects, parents are their &quot;aggregates&quot; and so on.&nbsp; Maybe I&#39;m wrong, but I see these as very complimentary topics.</p>
<p>I think the only difference may be how we instantiate and load our objects but I know there are some blog posts about implementing the Repository patten with CSLA that I will look at.</p>
<p>So my goal with my current project (described above), is to apply a DDD approach using CSLA as the framework for my domain layer (business objects).</p>
<p>I will take a stab at walking through each use case as an independent path and see what materializes.&nbsp; Any other suggestions or guidance is appreciated.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Thursday, April 07, 2011</h2><p>&gt;&gt; I<span>n my opinion, the more I get to understand Domain Driven Design the more it looks like CSLA - or that CSLA is the perfect framework for developing DDD applications. &lt;&lt;</span></p>
<p>Jeje, I came to the same conclusion when I read those books and people were (are) all in to DDD. I feel like I&#39;ve been doing some form of DDD for the last 10 years with CSLA and that DDD solves some of the same problems CSLA has solved me for the same time .</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, April 20, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>xAvailx<br></b>
<p>&gt;&gt; I<span>n my opinion, the more I get to understand Domain Driven Design the more it looks like CSLA - or that CSLA is the perfect framework for developing DDD applications. &lt;&lt;</span></p>
<p>Jeje, I came to the same conclusion when I read those books and people were (are) all in to DDD. I feel like I&#39;ve been doing some form of DDD for the last 10 years with CSLA and that DDD solves some of the same problems CSLA has solved me for the same time .</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>I agree with this as well; unfortunately I&#39;m not very good at conviencing my coworkers of the same!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 07, 2011</h2><p>The problem with ProjectTracker is that it needs to be simple enough to work within the context of a book, and that makes it hard to simulate the sorts of things real apps deal with.</p>
<p>Real apps have lots of screens that are data focused. In my experience, a business app is 80% maintenance screens, 15% slightly complex data entry screens, and 5% &quot;interesting&quot; screens.</p>
<p>The maintenance screens are generally data-centric, and so the screens, and their domain objects, and the data entity objects in the DAL all look like the table being edited.</p>
<p>The slightly complex data entry screens usually are also data focused, but use 2-3 tables instead of one. But specific regions on the screen generally correspond to a table. So the domain objects, and the data entity objects in the DAL all look like tables.</p>
<p>What&#39;s confusing then, is that you&#39;d get the same (or very similar) domain objects if you use actual OOD, or if you do data-centric design. The reason is that the user task - the use case - is inherently focused on the data.</p>
<p>Nothing wrong with that at all - and these types of screens/objects/entities/tables can often be created by code generation tools - and that&#39;s awesome!</p>
<p>It is the 5% of the screens that are &quot;interesting&quot; where things are really fun. And this is where CSLA is really valuable (imo).</p>
<p>The order entry screen, purchasing screen, invoicing screen, QA simulation screen, insurance quote generation screen - these are <em>interesting</em>.</p>
<p>The reason they are interesting is that they tend to interact (in whole or part) with <em>many</em> tables. Not just 2-3, but maybe 12-15 or more. And almost nothing on these screens is a 1:1 match with a table. Many regions of the screen interact with domain objects containing data from several tables. And the rules are complex and highly interactive.</p>
<p>Almost every app has some of these screens. Even small apps usually have at least one interesting screen - unless they are truly boring apps (which do exist of course).</p>
<p>In my view, the fact that you can apply code generation and very standard, repetative patterns to build the 80%, and often the other 15%, is excellent. That means you can whip out those screens with little thought, time, or effort - leaving more time to focus on the interesting screens.</p>
<p>And that&#39;s good, because the users almost certainly spend most of <em>their time</em> in the interesting screens too - so that&#39;s where you should be spending time and really thinking deeply about the experience and the underlying domain objects.</p>
<p>The sad fact is that ProjectTracker is one of those boring apps. Nothing in PTracker rises to the level of &quot;interesting&quot;. It demonstrates the 95% case.</p>
<p>I started writing the InventoryDemo (samples\silverlight\cs) to overcome this - to have at least one interesting screen. Around 18 years ago I worked for a bio-medical manufacturing firm where inventory was amazingly complex, so I thought it would be &quot;fun&quot; to revisit that problem domain. The problem with that idea is that I&#39;m so busy keeping up with Microsoft&#39;s changes to the platforms and technologies - and working at Magenic of course - that I&#39;ve been simply unable to put the time into InventoryDemo to get it to the point where it is interesting.</p>
<p>You can find several threads on the forum over the past few months where people are begging for a ProjectTracker update. I&#39;m soooooo done with ProjectTracker - but the demand is very high, so that&#39;s what I&#39;m doing right now actually - updating ProjectTracker to use all the 4.1 techniques described in the <em>Using CSLA 4</em> ebook series.</p>
<p>Because this includes reasonable amounts of unit tests for the business types, and a pluggable DAL, and all the other goodies people want to see - it is pretty time consuming...</p>
<p>(yes, I <em>really do know</em> that having unit tests saves time over the lifetime of an application (I wouldn&#39;t live without them for CSLA) - but building unit tests balloons the up-front dev time - and so does implementing 2+ DALs)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 07, 2011</h2><p>I should also clarify terminology.</p>
<p>I make a distinction between &quot;domain&quot; and &quot;entity&quot; objects that not everyone agrees with.</p>
<p>All objects are (or should be) defined by their behavior or responsibility.</p>
<p>Some objects have one responsibility: to contain data.</p>
<p>Of those data container objects, there are two general (and similar) types:</p>
<ol>
<li>Objects that exist for easy serialization into/out of XML or JSON - these are <em>data transfer objects</em> or DTOs</li>
<li>Objects that exist to map data into/out of a database or data store - these are <em>entity objects</em></li>
</ol>
<p>Domain objects, or business objects, or business domain objects, don&#39;t exist to meet the needs of a service contract (like a DTO) or a data mapping technology or data entity (like an entity object). Domain objects exist to meet the needs of a user story, user scenario, use case, or whatever term you are using in your object-oriented design process.</p>
<p>The fact that a domain object contains data is secondary to the fact that it contains behavior. The responsibility of the object is to be an <em>actor in the user scenario</em>, and to act it requires some data.</p>
<p>I have a 60-90 minute presentation I often give at <a href="http://www.vslive.com">Visual Studio Live</a> where I walk through the design process I use for domain objects - and that&#39;s really not enough time, because what&#39;s <em>really</em> needed is a hands-on lab...</p>
<p>I use a modified CRC (class-responsibility-collaboration) design approach. This is <em>far, far</em> superior to typical class diagram based approaches or UML schemes - because those almost always get people thinking about properties (data) before responsibility or behavior.</p>
<p>You don&#39;t need anything fancy. </p>
<ol>
<li>Just get a whiteboard and flow out the user scenario. Each box or circle you draw is an actor - either a human or an object or some other component/device/machine/whatever. Each actor has a responsibility within the context of the scenario. This gets you to the <em>responsibility</em> part of CRC, and a good start at the <em>class</em> part.</li>
<li>When you are done with that diagram, you should be able to see how each actor in the diagram contributes to completing the scenario. Ideally each actor has one responsibility - though sometimes the non-object actors (humans especially) have multiple responsibilities.</li>
<li>At this point you can go through each actor and list the behaviors that actor must employ to fulfil its responsibiltiy. These behaviors are often rules - including validation, calculations, data retrieval, etc.</li>
<li>Once that&#39;s done, you can normalize behavior within the user scenario - behaviors common to multiple actors should be consolidated into a shared actor, and the original actors requiring those behaviors can collaborate with this new actor. This is the <em>collaboration</em> part of CRC, and often adds more classes to the <em>class</em> part of CRC.</li>
<li>You should now be able to go through each actor and assign a stereotype (human, editable root, read-only list, etc). This might reveal some other classes that are technically required for implementation - such as collection types that contain child objects, etc.</li>
<li>Finally, go through each actor (class) and identify the data it must have to implement its behaviors.</li>
</ol>
<p>Once all this is done you should have a domain model for your one use case or user scenario.</p>
<p>In real life, this is usually the point where you have to identify the DAL entities that will be used to persist the data for these domain objects, and you&#39;ll need to implement them.</p>
<p>Normally you don&#39;t get to go on to design other user scenarios without first implementing the one you already have.</p>
<p>And that&#39;s a double-edged sword. It is far more agile to do what I just described and then to implement the scenario&nbsp;- at least unit tests, domain objects, DAL entities, and data storage.</p>
<p>For a whole lot of user scenarios this whole thing can be done in a sprint. If the user scenario is in that 80% of screens that&#39;s data focused you can probably do several in a sprint.</p>
<p>The one drawback to this, is that you don&#39;t have the opportunity to look for reuse of domain types across user scenarios early on. You need to remember to insert a step 7 where you look at existing domain types to see if you can use them <em>without changing them</em> in your new user scenario - thus avoiding duplicate implementations.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Friday, August 26, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>I have a 60-90 minute presentation I often give at <a href="http://www.vslive.com/">Visual Studio Live</a> where I walk through the design process I use for domain objects - and that&#39;s really not enough time, because what&#39;s <em>really</em> needed is a hands-on lab...</p>
<p>I use a modified CRC (class-responsibility-collaboration) design approach. This is <em>far, far</em> superior to typical class diagram based approaches or UML schemes - because those almost always get people thinking about properties (data) before responsibility or behavior.</p>
<p>You don&#39;t need anything fancy. </p>
<ol>
<li>Just get a whiteboard and flow out the user scenario. Each box or circle you draw is an actor - either a human or an object or some other component/device/machine/whatever. Each actor has a responsibility within the context of the scenario. This gets you to the <em>responsibility</em> part of CRC, and a good start at the <em>class</em> part. </li>
<li>When you are done with that diagram, you should be able to see how each actor in the diagram contributes to completing the scenario. Ideally each actor has one responsibility - though sometimes the non-object actors (humans especially) have multiple responsibilities. </li>
<li>At this point you can go through each actor and list the behaviors that actor must employ to fulfil its responsibiltiy. These behaviors are often rules - including validation, calculations, data retrieval, etc. </li>
<li>Once that&#39;s done, you can normalize behavior within the user scenario - behaviors common to multiple actors should be consolidated into a shared actor, and the original actors requiring those behaviors can collaborate with this new actor. This is the <em>collaboration</em> part of CRC, and often adds more classes to the <em>class</em> part of CRC. </li>
<li>You should now be able to go through each actor and assign a stereotype (human, editable root, read-only list, etc). This might reveal some other classes that are technically required for implementation - such as collection types that contain child objects, etc. </li>
<li>Finally, go through each actor (class) and identify the data it must have to implement its behaviors. </li>
</ol></div></p>
<p>&nbsp;</p>
<p>Rocky, is this presentation available anywhere? You have articulated the exact approach I have always used and even introduced me to an acronym I am ashamed to say I didn&#39;t know of. I am sure there is plenty I can google but, of course, I am specifically interested in how <em>you </em>work it all out.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Thursday, April 07, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b></p>
<p><span></span></p>
<p>Real apps have lots of screens that are data focused. In my experience, a business app is 80% maintenance screens, 15% slightly complex data entry screens, and 5% &quot;interesting&quot; screens.</p>
<p>The maintenance screens are generally data-centric, and so the screens, and their domain objects, and the data entity objects in the DAL all look like the table being edited.</p>
<p>The slightly complex data entry screens usually are also data focused, but use 2-3 tables instead of one. But specific regions on the screen generally correspond to a table. So the domain objects, and the data entity objects in the DAL all look like tables.</p>
<p>What&#39;s confusing then, is that you&#39;d get the same (or very similar) domain objects if you use actual OOD, or if you do data-centric design. The reason is that the user task - the use case - is inherently focused on the data.</p>
<p>&nbsp;</p>
<div style="clear:both;"></div>
<p></div></p>
<p><img src="http://forums.lhotka.net/emoticons/emotion-55.gif" alt="Idea" />&nbsp;AHA MOMENT! &nbsp;I never heard you break it down like that before. &nbsp;In a perpetual state of self doubt and shame, 80+ percent of my coding seemed to be very data-centric matching those unavoidable and boring majority of use-cases. &nbsp;I would end up shrugging my shoulders and thinking to myself...&quot;Oh well, I am just thick headed and don&#39;t get the behavior driven thing.&quot; &nbsp;The last application I was architect on, there were only about two screens/scenarios that were <i>&quot;interesting&quot; </i>and they fit the description you mentioned of being complex with many interacting rules, validations, on demand properties, and at least seven different tables.</p>
<p>Now I feel validated as if you were telling me...&quot;Hey Sean, don&#39;t feel weird if +/- 80% of your code/screens/BO&#39;s <i>seem</i> very data centric because the behavior of simple CRUD matches most of the simple use-cases. &nbsp;But don&#39;t forget Sean to be on the lookout for those few interesting and complex screens/scenarios where you need to be careful. &nbsp;Remember to start from the behavior point of view instead of the database point of view.&quot; &nbsp;Peace and harmony returns like the THX intro sound.</p>
<p>The inventory demo, showing an &quot;interesting&quot; behavior driven/designed object, is a thing I wait for with great anticipation!! :-)</p>
<p>Side note: &nbsp;All that being said, I think we take for granted the behaviors you have abstracted into the framework when we think of our use-cases. &nbsp;The complexity you have hidden behind the veil makes these behaviors look simple...heck they might even be forgotten all together. &nbsp;But throw out CSLA and you realize very quickly the need for those first class behaviors in your use-cases. &nbsp;So what I am saying is, because of CSLA, even the 80+ have a whole host of behaviors built in. &nbsp;This is what cracks me up about these &quot;young whipper snappers&quot; touting lean SOA with DTO&#39;s as the <i>solution for everything</i>. &nbsp;They whip out a data entry screen, some interfaces, a dumb DTO, and some tests in two seconds and are proud of themselves. &nbsp;I ask them...well what about &quot;business rules, n-level undo, grid-friendly data binding, Silverlight ability, validation, etc etc...&quot; &nbsp;and they say in a slightly annoyed tone as if I am getting in the way of progress with all that &#39;heavy&#39; thinking...&quot;Oh that will get done next sprint :-) Just put it on the backlog.&quot;&nbsp;</p>
<p>IMO as an official arm-chair quarterback...this same problem is at the core of Ken&#39;s metaphor of iterative regrowing of a forest after a clear cut (weeds -&gt; plants -&gt; rapid confers -&gt; cedars &amp;&nbsp;tamaracks). &nbsp;He uses this simple slide deck in his presentation on Agile to justify low-no design/architecture up front. &nbsp;He suggests a quick and simple layering of subsequently complex iterations and&nbsp;refactoring. &nbsp;There is some simple truth here and a just critique of overly heavy up front architecture. &nbsp;But the glaring omission is the lack of real accounting for the underlying VAST complexity of systems and frameworks that enable seemingly simple process to work. &nbsp;Started in <span style="text-decoration:underline;">Darwin&#39;s Black Box</span>&nbsp;and further explored in <span style="text-decoration:underline;">Debating Design, From Darwin to DNA</span>, Behe helps us understand this concept by introducing us to some of the mind blowing architecture and complexity that is abstracted underneath the surface of life. &nbsp;This architecture and design needs to be accounted for. &nbsp;Back in the software world the best compromise I ever heard of was a team at Microsoft that was having an architect&nbsp;(from Asia I think)&nbsp;work several iterations ahead of the main team. &nbsp;He was preparing things ahead of time such that they had what they needed when they came to a sprint. &nbsp;They seemed to think that worked nicely. &nbsp;I assume that the architect, if good, works herself out of a job eventually...but maybe they should go onto a retainer :-) &nbsp;I can&#39;t remember the name of the way old sci-fi movie I saw on a reel in my basement as a kid about some space travelers that visit a seemingly abandoned futuristic planet where the missing inhabitants had built machines that did everything for them. &nbsp;Unfortunately over successive generations, because the machines did it all, they forgot how the machines worked and when the machines broke and started making peoples nightmares come true, they couldn&#39;t fix them and everyone died at the horror of the monsters they each dreamed up.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, April 11, 2011</h2><p>Back to the problem at hand, I&#39;m working through the first of my use cases and have had an &#39;aha&#39; moment of sorts.&nbsp; To spare you from scrolling up and re-reading the use case, I&#39;ve repeated it here:</p>
<p><em>The first use case is to retrieve and display a list of assessments that a user needs to complete.&nbsp; This will be displayed when the user first signs into the application and at first it seems like it would be relatively easy, but there are two wrinkles: 1 - assessments are time-based so they may be required monthly, annually or every &#39;x&#39; number of years based on the employee&#39;s Anniversary Date; and, 2 - users can save an assessment in-progress and complete them later.&nbsp; As a result, the list should contain assessments that are due as well as any that are in-progress.</em></p>
<p>To generate this list, I have to apply three criteria:</p>
<p>1. Any AssessmentVersion that has an associated EmployeeAssessment with DateComplete = null (meaning the assessment is in-progress).</p>
<p>2. The AssessmentVersion with the maximum Version for any AssessmentVersion that has no associated EmployeeAssessments (meaning the assessment is new).</p>
<p>3. Any AssessmentVersion&nbsp;with all&nbsp;associated EmployeeAssessments having a DateComplete value (meaning they are done) that are &quot;due again&quot;, meaning that the Frequency field is such that the assessment needs to be performed again (such as every 30 days).</p>
<p>It appears to me that it is actually the AssessmentVersion class&nbsp;that would be my root and not Assessment. However, list items should contain the ID and Title fields from Assessment as well as the Version field from AssessmentVersion.</p>
<p>Where I am blocked is looking at the fourth use-case, creating a new Assessment.&nbsp; In this case I am actually creating two objects: Assessment and AssessmentVersion (with Version = 1).&nbsp; Or would it be better (and more DDD-like) to have a NewAssessment class that encapsulates both objects and is responsible for the logic required to create a new assessment?</p>
<p>If the latter is the better route, would it then also be appropriate to have something like an ActiveAssessment class that encapsulates the first use case? Or perhaps I&#39;m way off and Assessment and AssessmentVersion are one and the same in the Domain Layer?</p>
<p>My problem is that I still see Assessment as the start of my navigation. For instance, list all Assessments, then view all of the versions of a single Assessment.&nbsp; List all &quot;active&quot; Assessments then start a new Assessment for a given employee.&nbsp; And so on.&nbsp; I think this is where I&#39;m hung up.</p>
<p>Anything you can advise to break my analysis paralysis?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>tmg4340 replied on Monday, April 11, 2011</h2><p>I think, for purposes of this use case, you should combine Assessment and AssessmentVersion - after all, the use case considers data from both pieces.&nbsp; Something like an &quot;AssessmentInfo&quot; class that contains properties from both tables.&nbsp; That becomes the start of your navigation process.</p>
<p>Ultimately, based on what you&#39;ve laid out to date, I&#39;m betting that most of your app is going to consider Assessment and AssessmentVersion to be a single... well, entity.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" />&nbsp; Your database structure breaks out the versioning information, but I haven&#39;t seen anything in your use cases that suggests that the version information needs to be handled separately from the assessment within the app.</p>
<p>Also, I wouldn&#39;t create specific classes that represent an object and that object&#39;s state.&nbsp; I know some people advocate that, and in the cases where there&#39;s significant functionality that&#39;s different based on the state, I can see the argument.&nbsp; But I&#39;d much rather encapsulate the state within the object and use some kind of state pattern if I really needed it.&nbsp; An object may do different things if it&#39;s in different states, but they are all things the object still has to do.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, April 20, 2011</h2><p>I suggested Scotts answer because I think he&#39;s right on.&nbsp; Your use cases don&#39;t mention versions anywhere.&nbsp; You may have another use case where you can see the history of Assements, but users aren&#39;t creating them (directly) in your use cases.&nbsp; If you need such a history, create it when a new assement is created.&nbsp; Based on your description, it sounds like the &quot;start of navigation&quot; would be whatever you&#39;re users are assessing. </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
