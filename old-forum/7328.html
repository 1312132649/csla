<html><header><title>Child with a reference to a child witch is also a parent</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Child with a reference to a child witch is also a parent</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7328.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Goran posted on Thursday, July 23, 2009</h2>If we look at the Invoice entity, we see that it contains a child collection InvoiceItems, which is a collection of InvoiceItem. InvoiceItem will need to hold a reference to a Article class (1-1 relationship), since there will be a need to display article info for particular InvoiceItem (name, serial number, meaurement unit, tax rate). Article class is also part of the root collection ArticleList, so it becomes a candidate for switchable object.<br><br>In your book you state that when there is a need for switchable objects, usually its the result of a bad design. How exactly can I redesign it?<br><br>And one more thing that is troubling me, Coming from the procedural world, I find difficult to understand one thing: Article class will have many"shorter forms" of it. Example, Article class contains 15 fields which are all used when doing CRUD operations on ArticleList. In previously mentioned situation (as child of a InvoiceItem), there wil be only a need for 5 Article properties (read only access). In some other scenario, I wil lneed only 3 properties (usually when I need to choose some article to display some info about it, like in Article card) - also read only. Will I have different classes for each "shorter form" of Article class? Or i should also fetch those fields I dont care about (which highly degrades performance)?<br><br>In above situation DataTable is highly effcient - I am not interested in behavior, nor business rules, I just want to display data to user in order to make selection.<br><br>Thanks,<br>Goran<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 23, 2009</h2>Create an ArticleInvoiceItem, which has the additional fields.  These wouldn't display as columns in a grid, but it doesn't seem like you'd expect that anyway (after all, what if you later add Book, Magazine, Software, Video Game... your grid would have tons of columns which may be empty most of the time).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, July 23, 2009</h2><P><FONT face=Tahoma size=2>The short answer is yes, you would have separate objects.</FONT></P>
<P><FONT face=Tahoma size=2>CSLA objects are designed to fulfill a use case.&nbsp; Since you note that, in this scenario, the Article information is only being displayed, you do not need/want your full (and, I presume, editable) Article object.&nbsp; You would create a ReadOnlyBase-derived child object that contains only the properties that your particular scenario requires.&nbsp;&nbsp;You would also build your data access for that object to only pull the properties you need as well.&nbsp; Since you list two display-only situations, you would probably create two objects - one with the five properties you need for the one scenario, and the other with the three properties you need for that scenario.</FONT></P>
<P><FONT face=Tahoma size=2>If the property lists overlap (i.e. the three properties you need in one scenario are also needed in the other), then you could probably just create one object, and ignore the two properties you don't need in the one case.&nbsp; Yes, that technically degrades performance - but unless those two properties are monstrous BLOB's of data, any performance hit taken by pulling two pieces of unneeded data is going to be negligible.</FONT></P>
<P><FONT face=Tahoma size=2>Given this&nbsp;style of object&nbsp;design, it is not uncommon at all to have multiple "versions" of an object.&nbsp; You'll see Rocky talk about that in multiple posts in the forum.&nbsp; When building your object designs,&nbsp;design the objects to fulfill the use case, without any regard to what you may have built for another use case.&nbsp; If, after building your object graph, you see two objects <EM>that perform the same function</EM> in two use cases, then you can combine the objects.&nbsp; Don't combine them just because they have the same data - if they have different business rules or behavior, keep them separate.&nbsp; Only if the data and the behavior match should you&nbsp;merge them.</FONT></P>
<P><FONT face=Tahoma size=2>This isn't to say that refactoring common code isn't done - that's the point of the Assignment class in the ProjectTracker example.&nbsp; But complete object re-use is not the overarching goal here.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Goran replied on Thursday, July 23, 2009</h2>Tahnks for the response.<br><br>@										<a>ajj3085</a><br>Some columns from ArticleItem would be displayed in a grid, maybe I haven't been clear enough. The idea is to map grid to columns that need to be displayed, other columns can be used just for the background operations.<br><br>Invoice (InvoiceId, Number, Date, Customer, InvoiceItems)<br>InvoiceItems (collection of InvoiceItem)<br>InvoiceItem (InvoiceId, ArticleItem, Quantity, Price, TaxRate)<br>ArticleItem(ArticleId, ArticleCode, ArticleName, MeasurementUnit,TaxRate)<br><br>I will name it ArticleItem, because it will be reused in many different cases, like with Invoice, Order, Offer, etc<br><br>@Scott<br><br>Thanks for the very informative response, I have cleared many things now.<br><br>There is one more thing - actual implementation: Invoice fetches data from stored procedure, first resultset is used to get Invoice data, and second resultset is passed to InvoiceItems collection, which loops through data and passes each item data to InvoiceItem GetItem method, to populate itself wtith data. So far so good. Now I need to populate ArticleItem data, and I am not sure if I am using the correct way. This is how I did it: the second resultset has joined data from both InvoiceItem and Article table, and I am passing the same resultset to both classes, to use only the fields they need. Ex<br><br>// in the PurchaseItemsList class<br>private void Fetch(SafeDataReader dr)<br>{<br>&nbsp;&nbsp;&nbsp; RaiseListChangedEvents = false;<br>&nbsp;&nbsp;&nbsp; while (dr.Read())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PurchaseItem item = PurchaseListItem.GetItem(dr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item.Article = ArticleItem.GetItem(dr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(item);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; RaiseListChangedEvents = true;<br>}<br><br>Is this approach good? I can make it work for sure, but since I am now trying to rewrite the whole application (which has like 100 forms), I want to do it properly at least. :)<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, July 24, 2009</h2><P><FONT face=Tahoma size=2>This approach is fine.&nbsp; My only question is, if you only have one ArticleItem related to an InvoiceItem, why the separate class?&nbsp; Especially considering that the data is read-only, you could save yourself some potential binding headaches if you combined InvoiceItem and ArticleItem.&nbsp; Y</FONT><FONT face=Tahoma size=2>our object design can (and, in some cases, should) be independent of database structure.</FONT></P>
<P><FONT face=Tahoma size=2>If you could have multiple articles related to an invoice item, then you would need a separate class - but then I wouldn't use your JOIN-based SQL construct; I'd create a third resultset.&nbsp;&nbsp;And your InvoiceItem would have a list of ArticleItem objects with its own factory method, similar to how InvoiceItem is constructed.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Goran replied on Saturday, July 25, 2009</h2>Data in AricleItem is read only - user cant change name, code, measurement unit, tax rate, etc for the article in the Invoice Form. However, LineItem is editable, since User can change ArticleItem, quantity, price, etc.<br><br>There is a read-only ArticleItems collection, and when user selects one article to place in invoice, this new LineItem.ArticleItem property has reference to current ArticleItem in collection.<br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
