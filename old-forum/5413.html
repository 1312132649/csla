<html><header><title>Security that isn't role based</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Security that isn't role based</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5413.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wbmstrmjb posted on Tuesday, September 16, 2008</h2>Our security model is such that Users are assigned Roles and Roles have Permissions.&nbsp; Each Permission has CRUD.&nbsp; The IsInRole does not work for our model because it will be based on whether they have a particular CRUD piece of a Permission and not whether they are in a particular Role.&nbsp; How can we still use CSLA's security to implement this model?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, September 16, 2008</h2><P>We have almost exactly the same permission model, but unfortunately I don't really see a good way to remap this to the CSLA implementation. </P>
<P>I think Rocky said you could safely retask your "permissions" as roles, but the CSLA security model seems (at least to me) to be primarily centered around property access, and what we really need is task or function access. </P>
<P>So, I've basically rolled my own implementation for the time being -- essentially I have a BitArray property in my user object where each&nbsp;permisssion is&nbsp;mapped to a single bit, which makes for both compact storage and efficient testing. I still have all the CanReadProperty()/CanWriteProperty() calls generated in my BO layer, but they are currently NOPS. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>triplea replied on Wednesday, September 17, 2008</h2><P>The way I have implemented this (I think its similar) is place a method <FONT face="Courier New" color=#0000ff size=2>bool HasPermission(string operation)</FONT> on my custom Identity. When a user gets authenticated, a list of valid permissions for the users role(s) gets loaded internally (I use strings for now but&nbsp;a bit array as mentioned or any other form would do the trick). Then I place the checks all over my BO's so for example:</P>
<P>public static bool&nbsp;CanAddObject()<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ((CustomIdentity)Csla.ApplicationContext.User.Identity).HasPermission("AddCustomer");<BR>}</P>
<P>I used this as a guide: <A HREF="/forums/thread/17224.aspx">http://forums.lhotka.net/forums/thread/17224.aspx</A></P>
<P>HTH</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, September 17, 2008</h2><P><FONT face=Tahoma size=2>CSLA's permission model is actually built around .NET's model - it's intended to integrate with the existing Principal/Identity system.&nbsp; As such, "IsInRole" is defined under that system, not CSLA.&nbsp; If you look at BusinessPrincipalBase, it's just an implementation of .NET's IPrincipal interface.</FONT></P>
<P><FONT face=Tahoma size=2>Having said that, the solutions presented here will work, and there's certainly nothing wrong with them.&nbsp; But you could do something that would integrate with "IsInRole".&nbsp; IIRC, the PT example creates a CSLA business object to use for its IIdentity implementation (which is where the list of roles and the actual "IsInRole" implementation lies).&nbsp; Even if it doesn't, it's certainly a possibility - .NET relies on those two interfaces to do its work, so you&nbsp;could&nbsp;use BusinessPrincipalBase, create a&nbsp;CSLA RO BO that implements IIdentity, plug them in, and have at it.</FONT></P>
<P><FONT face=Tahoma size=2>So... how can you integrate that with your role/permission model?&nbsp; Remember that "IsInRole" takes a string value.&nbsp; That string value can pretty much be anything you want - just because the method name references roles doesn't mean your actual role string has to be limited to that.&nbsp; So you could create your list of roles as a concatenation of role/permission, and make your calls that way.</FONT></P>
<P><FONT face=Tahoma size=2>(And to the poster who talked about needing task/function access - starting with 3.0, the authorization rules system implemented methods for allowing/denying the execution of methods.&nbsp; And I believe that the 3.5 techniques to standardize the "Can" methods have a "CanExecute"...)</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stanc replied on Wednesday, September 17, 2008</h2><P>This is exactly what we have. To make things work with the CSLA model we did as Scott suggested. I thought it might be helpful to provide an example of what we did.</P>
<P>When authenicating the user, we get their individual permissions and add the appropriate CSLA&nbsp;roles. It doesn't matter what roles (from our app) the users belong to, it's their end permissions that determine the CSLA roles.</P>
<P>The CSLA roles are a combination of the BO (name) and the CRUD operation. Say we have an Order object and we wanted to set permissions for CRUD operations. Using CSLA we would have roles called "OrderCreate", "OrderRead"...</P>
<P>So we can have a user (Bob), who belongs to two application roles (User and Checker). User may have CR permissions for Order and Checker may have UD permissions, so Bob would have the full CRUD permissions for Order. When he is authenticated he will have the following CSLA roles "OrderCreate", "OrderRead", "OrderUpdate", and "OrderDelete".</P>
<P>This allows us to have as many different custom application roles we want with different permission settings, and allows our users to be tied to more than one application role as well. In the end, our BO will check against the CSLA roles that are figured out during the authenication process.</P>
<P>Hope this was clear and helpful.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, September 17, 2008</h2><P>One thing that has not been mentioned yet is a new feature that Rocky added to the framework in 3.5&nbsp;to support using something other than IsInRole. He now allows you to add a setting to your config file describing your provider. So I can use HasPermission directly instead of IsInRole.</P>
<P>===================================================================<BR>Rocky wrote:<BR><A href="/forums/thread/20749.aspx">http://forums.lhotka.net/forums/thread/20749.aspx</A></P>
<P class=MsoNormal><SPAN>The object-level auth works like the property-level – which is to say that if you don’t specifically allow/deny any roles then all roles are allowed. The default is permissive.<O:P></O:P></SPAN></P>
<P class=MsoNormal><SPAN><O:P>&nbsp;</O:P></SPAN><SPAN>Regarding the HasPermission() thing – I finally implemented something Joe asked for a long time ago. You can now provide a replacement behavior for IsInRole() deep within CSLA. This is a provider model concept, where you write an IsInRole provider that (if I remember right) looks like this:<O:P></O:P></SPAN></P>
<P class=MsoNormal><SPAN><O:P>&nbsp;</O:P></SPAN><SPAN>void IsInRole(IPrincipal principal, string role)</SPAN><SPAN><O:P>&nbsp;</O:P></SPAN></P>
<P class=MsoNormal><SPAN>The default provider in CSLA simply returns principal.IsInRole(role), but you could write a provider like<O:P></O:P></SPAN></P>
<P class=MsoNormal><SPAN><O:P>&nbsp;</O:P></SPAN><SPAN>public static void IsInRole(IPrincipal principal, string role)<BR></SPAN><SPAN>{<BR></SPAN><SPAN>&nbsp; PTPrincipal.HasPermission(role);<BR></SPAN><SPAN>}</SPAN><SPAN><O:P>&nbsp;</O:P></SPAN></P>
<P class=MsoNormal><SPAN>Or</SPAN><SPAN><O:P>&nbsp;</O:P></SPAN></P>
<P class=MsoNormal><SPAN>public static void IsInRole(IPrincipal principal, string role)<BR></SPAN><SPAN>{<BR></SPAN><SPAN>&nbsp; var p = principal as MyCustomPrincipalType;<BR></SPAN><SPAN>&nbsp; if (p != null)<BR></SPAN><SPAN>&nbsp;&nbsp;&nbsp; return p.HasPermission(role);<BR></SPAN><SPAN>&nbsp; else<BR></SPAN><SPAN>&nbsp;&nbsp;&nbsp; return false;<BR></SPAN><SPAN>}<O:P></O:P></SPAN></P>
<P class=MsoNormal><SPAN><O:P>&nbsp;</O:P></SPAN><SPAN>Or whatever you need. Then you just add an entry in the app.config file to tell CSLA to load this custom provider and away you go.</SPAN><SPAN><O:P>&nbsp;</O:P></SPAN></P>
<P class=MsoNormal><SPAN>Rocky</SPAN></P>
<P class=MsoNormal><SPAN>=================================================================<O:P></O:P></SPAN></P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, September 17, 2008</h2><P>Is there any reason to be concerned about using the CSLA model if you have a large number of different permissions (say 300+), or should I not worry about this?</P>
<P>This was one reason I went with a BitArray implementation -- 300 strings seemed like a lot of baggage to be ferrying back and forth in addition to everything else that is going on. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Wednesday, September 17, 2008</h2>It's been several years since I implemented object level security.&nbsp; I'm still using this implementation on all our web development.&nbsp; <a HREF="/forums/thread/1246.aspx">This </a>is the last link I can find on this forum.<br><br>There has been very little changed but the concept is still the same.&nbsp; I included the CanGet|Add|Edit|DeleteObject in the base class as follow:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static bool CanGetObject()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return SecurityManager.CanGetObject(typeof(T));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
