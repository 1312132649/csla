<html><header><title>CSLA 1.52 issue implementing binding? Or bad design strategy?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 1.52 issue implementing binding? Or bad design strategy?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2469.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson posted on Friday, March 02, 2007</h2><P>CSLA 1.52 - VS2003 - VB.NET - Binding question, I think.</P>
<P>I'm building a private vehicle registration system.&nbsp; </P>
<P><U>What I'm trying to do</U></P>
<P>I want to show the user a list of items in list-type controls (presently using DevExpress LookUpEdit) as an aid in populating a related field on my form bound to a CSLA Editable Root Object (vehicle).&nbsp; The values in the lists are simply the result of a query against the Vehicle table for all values ever entered in the related field (Select Distinct blah, blah).&nbsp; I use ReadOnly Collection objects to hold these lists.&nbsp; This is for things like Make, Model, Year, BodyType, etc.</P>
<P>I expected to be able to let the user either pick a value from the list or enter a new value.&nbsp; I put code in my U.I. to re-Get the ROCs after the ERO is Saved, so that they will include a new value if one was offered.</P>
<P><U>What happens instead</U></P>
<P>But I'm finding that the control won't allow the new value typed in by the user to remain in the textbox of the LookUpEdit control.&nbsp; It changes it to the next closest value in the list.</P>
<P>The control fires an event (ProcessNewValue) when the user does this and, had I used an Editable Root Collection object, I could use code in that event to simply add the item to the list.&nbsp; </P>
<P><U>It looks to me like I have three options to get this to work:</U></P>
<P>1) Fix the binding technique(s) I'm using on the form if they're amiss somehow and causing the problem.&nbsp; (I show them below.)</P>
<P>2) Change my list's collection object from a ROC to an ERC and use the control's event to add a new item to the list.&nbsp; (I.E., add it to the collection, but not make any attempt to persist it since there's no supporting table.&nbsp; I would still re-popluate the list after saving the form's Main ERO.&nbsp; This ERC wouldn't need implementation of DP_Update.)</P>
<P>3) Drop the strategy of populating from that Distinct query altogether and, instead, create tables to hold allowable values.&nbsp; Then I have a couple of options.&nbsp; (a) I can provide a different screen on which they can add items and just prohibit the use of items not in the list on my ERO's screen. (b) Use the control's Validated event to Save new values whenever&nbsp;they are&nbsp;entered.</P>
<P>My preferences for these are in the order I offered them (I really don't care for that last one at all, actually).&nbsp; But I'm also open to other suggestions.</P>
<P><U>Binding in the form presently:<BR></U><BR>At startup, the ROC is instantiated with typical ROC.GetROC() call and then bound to the control with code like this:<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; With cboMakeList<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.DataSource = moMakeList<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.Columns.Clear()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col = New DevExpress.XtraEditors.Controls.LookUpColumnInfo<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; col.FieldName = "Make"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.Columns.Add(col)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.ValueMember = "Make"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.DisplayMember = "Make"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.BestFit()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.PopupWidth = 150<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Properties.AutoSearchColumnIndex = 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End With</P>
<P>And the related field in the Vehicle object is bound with a call in the CSLA 1.x standard technique:</P>
<P>&nbsp;BindField(cboMakeList, "EditValue", moVehicle, "Make")</P>
<P>It seems to be a simple enough piece of functionality.&nbsp; But I must be botching it up some how.</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P>
<P><BR>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Friday, March 09, 2007</h2><P>Wow, 58 views and no replies.&nbsp; Oh well.&nbsp; </P>
<P>I got some help from the DevExpress forum and found out how to handle that ProcessNewValue event better.&nbsp; I simply add the item typed by the user to the list object.&nbsp; I don't have to save it since I'll read the value next time the form opens if the user saved the vehicle record with the new value for that field.&nbsp; Of course, that meant that I had to re-create all these ReadOnlyCollection objects as EditableRootCollections with Children.</P>
<P>So, this experience has shown off the flexibility of CSLA even further to me.&nbsp; I just ran the code generator (I use MyGeneration, but it doesn't have any bearing on the outcome) and made new objects for my five lists (and their children) and substituted their types for my list object declarations in the UI.&nbsp; Everything that worked before worked now and all I needed to do was handle that ProcessNewValue event with code like:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If e.DisplayValue.ToString = "" Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Sub<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moModelList.Add()<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moModelList(moModelList.Count - 1).ModelID = e.DisplayValue.ToString<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Handled = True</P>
<P>To build the ten new classes (five lists and their child classes) and create the handlers for all five ProcessNewValue events took about an hour.&nbsp; </P>
<P>And now, should I choose to do so, I can also switch to the table-based list strategy just by modifying the query called in the DP_Fetch event of each List and easily create an update query for implementing the DP_Update routine (for which code has already been created by the code generator but isn't presently called with the current design).&nbsp; </P>
<P>I hope this was useful for any of you other DevExpress users with similar design goals for a data entry form.</P>
<P>Regards,</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
