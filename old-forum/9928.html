<html><header><title>CSLA 4 - Business Rules: context.Target property</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 4 - Business Rules: context.Target property</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9928.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans posted on Sunday, January 09, 2011</h2><p>What I gather from the original blog posts regarding the new CSLA 4 business rules system:</p>
<ul>
<li><a href="http://www.lhotka.net/weblog/CSLA4BusinessRulesSubsystem.aspx">http://www.lhotka.net/weblog/CSLA4BusinessRulesSubsystem.aspx</a></li>
<li><a href="http://www.lhotka.net/weblog/CSLA4BusinessRuleChaining.aspx">http://www.lhotka.net/weblog/CSLA4BusinessRuleChaining.aspx</a></li>
<li><a href="http://www.lhotka.net/weblog/CSLA4AuthorizationRules.aspx">http://www.lhotka.net/weblog/CSLA4AuthorizationRules.aspx</a></li>
</ul>
<p>It seems that the Target property cannot be guaranteed? I understand that by default, the target property isn&#39;t available for ASYNC rules, and that it would require the setting ProvideTargetWhenAsync = true.</p>
<p>Not sure if this is still the case since there has been plenty of work towards improvements done since.What I&#39;m after is more determinism - under what circumstances will the Target property not be populated and left NULL?</p>
<p>A practical point is that I need access to the IsDirty / IsNew properties of the BO inside the rule&#39;s Execute method. I cannot supply these as InputProperties because they are not PropertyInfo objects and so I can only get them from the BO at the Target property. That&#39;s fine, but I need to make sure that I will have a value for Target for both Sync and Async scenarios.</p>
<p>Are there any gotcha&#39;s I should be aware of. Eg. PerType / PerInstance; Async vs. Sync; ValidationRules vs. BusinessRules; etc.</p>
<p>Thanks in advance!<br />Jaans</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Sunday, January 09, 2011</h2><p>Hi Jaans, </p>
<p>The Context.Target property is by default null if IsAsync == true and ProvideTargetWhenAsync == false (the default value). So you must ProvideTargetWhenAsync to true in order to get the target object in an async rule.</p>
<p>Csla4 Rules system is all PerType rules. PerInstance rules is not supported anymore.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Sunday, January 09, 2011</h2><p>Thanks Jonny</p>
<p>Are you confirming then that provided I set ProvideTargetWhenAsync = true for async implementations, the Target property will be populated?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Monday, January 10, 2011</h2><p>Yes, it&#39;s easy to check in the Csla4 source code (Rules\BusinessRules.cs) : </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Rule = rule;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!rule.IsAsync || rule.ProvideTargetWhenAsync)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Target = _target;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, January 10, 2011</h2><p>The reason you must request that the Target value be populated is that any use of the Target property by a background thread will almost certainly cause problems. Some problems might be easy to find (cross-threading exceptions), but others could be subtle race conditions that are very hard to find/fix.</p>
<p>So I default to not making Target available. My assumption is that if you request access to Target that you will know enough to absolutely never, ever, ever use Target in any actual async code.</p>
<p>In short, when someone does make this mistake (and I&#39;m sure they will), I want to be able to say &quot;I told you so&quot; and leave it at that :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Monday, January 10, 2011</h2><p>Thanks for that Rocky - makes sense.</p>
<p>Given that, do you have any suggestions&nbsp;to accomplish the following scenarios using the &quot;<em>InputProperties + AddOutPutValue</em>&quot; pattern?<br /><br />(Some of it relates to this post: <a href="http://forums.lhotka.net/forums/t/9927.aspx">http://forums.lhotka.net/forums/t/9927.aspx</a>)</p>
<p><strong>Scenario 1: Rule on Parent property should mutate/affect child instances in child collection</strong></p>
<p style="padding-left:30px;">Here I can see adding the ChildCollection (<em>Editable Child Collection</em>) Property to <em>AffectedProperties</em> in the constructor of the rule, but I&#39;m not sure about the execute method. It doesn&#39;t make sense to call <em>context.AddOutValue</em> for the same Child Collection Property because I have&nbsp;<span style="text-decoration:underline;"><em>not</em></span> changed the property, nor the collection itself - but what I have changed was properties on the child business objects in the collection. I guess I could have a scenario where I add/remove items in the collection also.<br /><br />Would this be possible to do without accessing <em>Target</em> and also in an Async scenario?</p>
<p><strong>Scenario 2: Mutating other properties, without causing rules for those properties to trigger.</strong></p>
<p style="padding-left:30px;">As Jonny Bekkum pointed out I could use <em>LoadProperty</em> and specify <em>Target</em> to achieve this, which is great for sync usages. Again, how could I do this in an async fashion, safely. Basically, I&#39;m looking for an <em>context.AddOutValue</em> that has an parameter that allows me to suppress rule checking like I would when using <em>LoadProperty / BypassPropertyChecks</em></p>
<p><strong>Scenario 3: Accessing BO properties that are not IPropertyInfo implementations</strong></p>
<p style="padding-left:30px;">So here, I&#39;m asking using the how I could use the &quot;InputProperties + AddOutputValue&quot; pattern for async. </p>
<p style="padding-left:30px;">I guess I could relatively safely &quot;read (only)&quot; the <em>IsDirty / IsNew / IsValid</em> / etc. properties from <em>Target</em>.&nbsp;Would the &quot;<em>MarkAsXXXX</em>&quot; methods be safe to call on target?</p>
<p>I guess the simplest workaround for the above kind of rules is to stick to synchronous usage and accessing target.</p>
<p>Thanks for helping!<br />Jaans</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, January 11, 2011</h2><p>Hi Jaans,</p>
<p><b>Scenario 1:</b> I would not use context.AddOutValue on this one. You should process the child list and do the updates you need syncronously.</p>
<p><b>Scenario 2: </b>What type of properties are we talking about here?&nbsp;</p>
<p> If this is a certain type of property it could also be handled (to a certain degree) in how you define the property, (ie: property stereotypes) ex:</p>
<ul>
<li>ReadWritePropertyValue&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (GetProperty/SetProperty)</li>
<li>ReadWritePropertyValueWithConversion (GetPropertyConvert/SetPropertyConvert)</li>
<li>ReadWriteProperyValueNoDirty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (GetProperty/LoadProperty with OnProptertyChanged)</li>
</ul>
<p>The main issue here is in what code is executed asyncronously. In the async callback you can safely interact with the Target object - but you should not set any values/properties in the async code. </p>
<p><b>Scenario 3</b>: You must get access to context.Target to get properties that are not IPropertyInfo implementations.</p>
<p>Why would create rules that should alter the state management of the BusinessObject, like MarkXYZ?<br />Are you creating rules that is actually being a sort of DataAccess? </p>
<p>I would not recommend to create rules that call MarkXYZ.....&nbsp;&nbsp; These methods are protected (only accessible in class and descendants) so you would need to create overrides that are public or internal to gain access to them and could potentially create a mess&nbsp; in object state.</p>
<p><b>Using context.AddOutValues:</b><br />The purpose of context.AddOutValues is to make a more generic way of updateing other properties in your BO from a rule. The process is as follows: </p>
<p>1. After rule is executed (sync: rule.Execute() is finished, async: context.Complete() is called)<br />2. Call non-generic LoadProperty to load values into BO<br />3. Check rules for all properties that was changed (AffectedProperties)<br />4. If (ApplicationContext.PropertyChangedMode = PropertyChangedModes.Windows <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise OnPropertyChanged for &quot;PrimaryProperty&quot;)<br />&nbsp;&nbsp;&nbsp; else <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise OnPropertyChanged for all affectedProperties (including PrimaryProperty).</p>
<p>So the intending process is to make sure rules are run for all properties that are changed.</p>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
