<html><header><title>LoadPropertyMarkDirty does not consider BypassPropertyChecks</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>LoadPropertyMarkDirty does not consider BypassPropertyChecks</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12840.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jayoub posted on Thursday, March 05, 2015</h2><p>Hi,</p>
<p>I have a data bound tree with check boxes on a screen that allows the user to set properties on quite a lot of business objects (up to 100, or maybe more). If a parent node is checked, it sets boolean properties on all of the business objects bound to the child nodes to true or false accordingly. </p>
<p>I set up these properties following the CSLA pattern, but when I use SetProperty in the property setters on these business objects, it causes a performance issue. If a parent node is checked, it takes more than 10 seconds for the UI to respond, because SetProperty is being called on so many business objects. </p>
<p>I have tried using LoadProperty instead, as I do not have any business rules associated with these properties, but LoadProperty does not mark the business object dirty or run change notification. </p>
<p>I have also tried LoadPropertyMarkDirty, while also manually calling OnPropertyChanging and OnPropertyChanged so that change notification is run. This cuts down the UI response time to 1/4 of when I use SetProperty.</p>
<p>The issue with calling LoadPropertyMarkDirty is that I have found it does not take BypassPropertyChecks into account. </p>
<p>When I&#39;m calling Fetch on the business objects, and using BypassPropertyChecks, when the property value is changed to a value different from the default value, the business object gets marked dirty when LoadPropertyMarkDirty is called. </p>
<p>When using SetProperty, it takes BypassPropertyChecks into account so that, when properties change during a fetch, the business object is not marked dirty. On the other hand, LoadPropertyMarkDirty will still mark the object dirty while using BypassPropertyChecks. This is not the behavior I expected, as it seems to be different than how SetProperty operates in regards to marking the object dirty. </p>
<p>I have tried to somehow manually override the default CSLA behavior, but the problem is that the _bypassPropertyChecks field in Core.BusinessBase is marked private, so I don&#39;t have the ability to make a kind of custom behavior based around its value. </p>
<p>If anyone has any ideas to make SetProperty perform faster or get around my issue with LoadPropertyMarkDirty, it would be appreciated. </p>
<p>Thanks,</p>
<p>Jonathan</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, March 05, 2015</h2><p>BypassPropertyChecks exists to prevent rules from running (auth and business) while you are loading your BO, as well as prevent the object from being marked dirty.&nbsp; It effectively does what LoadProperty does.&nbsp; LoadPropertyMarkDirty is supposed to mark the object dirty, while not running the business rules.&nbsp; So LoadPropertyMarkDirty is in fact doing what it is designed to do.</p>
<p>First off, I suspect your object design is off; editing 100+ objects at once seems a bit off and more like it should be handled by a command object which hits the DB.&nbsp; If there are complex rules that need to be enforced, maybe you have no other choice.</p>
<p>What I would do is go back to SetProperty, but before you go looping through the objects call SuspendBinding on all your binding sources, loop and change, then call ResumeBinding.&nbsp; You may also need to call ResetBinding to cause the data to refresh.</p>
<p>This will stop the UI from trying to react to each individual property change while letting your rules run normally and setting Dirty correctly as well.&nbsp; So that is my first guess is that all the events being raised are forcing the UI to refresh itself (including repaint), which is really slow.&nbsp; Telling the UI to ignore things for a while generally fixes these issues.</p>
<p>The other two usual culprits in my experience are business rules that hit the DB or complex code that fires in internal BO event handling (for example, doing complex things in the root objects OnChildChanged method).&nbsp; If you have business rules that must hit the UI, I&#39;m not sure you can do much there except ensure the entire thing runs as quickly as possible, but since you probably have at least one network hop you may be limited by what you can do.&nbsp; Usually if OnChildChanged is the issue its along similar lines; causing DB hits when the code runs.&nbsp; If that is the case you can try setting lists RaiseLIstChangedEvents to false while you set your values, then restore it to true and fire a non-specific property changed / list changed.&nbsp; Usually you&#39;d want to do this via a method on your list or BO so that the UI needn&#39;t worry about those details.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jayoub replied on Friday, March 06, 2015</h2><p>Thank you for your responses. I&#39;m using CSLA 4.5, XAML and MVVM.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>Andy<br></b></p>
<p>First off, I suspect your object design is off; editing 100+ objects at once seems a bit off and more like it should be handled by a command object which hits the DB.&nbsp; If there are complex rules that need to be enforced, maybe you have no other choice.</p>
<p></div></p>
<p>I&#39;m not sure that my object design is off. I have a hierarchy of objects four levels deep. Each object in the hierarchy has a list of children objects and a boolean property which I am binding to. In the UI, I am using a data tree control with check boxes. Basically, the &quot;IsChecked&quot; property of the check box is bound to the boolean property on the business object. </p>
<p>I&#39;m not sure that a command object would help me here, because that would be when I need to run a command on the database. What I need in this situation is a business object that the UI can interact with.</p>
<p>The datatree gives the user the ability to make a really large amount of changes by clicking on a parent node. When a parent node is checked, that cascades down to all of the child nodes, and they set the boolean properties on each node along the way, calling SetProperty in the property setters. I&#39;m thinking that calling SetProperty so many times as a result of checking one checkbox is what is leading to the performance issue.</p>
<p>I wasn&#39;t aware of the purpose of LoadPropertyMarkDirty, but was thinking that it may give me the ability to change a property value while marking the object dirty as well as avoid some of the overhead of SetProperty. It won&#39;t work for me because it marks my object dirty when I fetch an object from the database.</p>
<p>One thing I do know is that if I set my property setters from SetProperty to LoadProperty, the UI responds instantly when I check a parent node. SetProperty can make the UI take more than 10 seconds to respond. </p>
<p>None of my boolean properties have any business rules associated with them, so I know that&#39;s not the issue. I also don&#39;t think that the UI responding to property changing events is the only culprit. I&#39;ll try to run a performance profiler and find exactly where the performance hit is occurring. The reality may be that the user is just making a very large amount of changes with one action, and that I need to pop up a window asking them to wait while it is being processed.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>ajj3085 replied on Friday, March 06, 2015</h2><p>Your design may not be off; usually though when a user has 100+ Bos on the screen at once, it means a lot of data, and huge amounts of data are hard for a user to effectively work with.&nbsp; So when I see that happening it helps to at least question if the design is correct.&nbsp; Sounds like its just a tree of BOs which a simple Boolean, so that doesn&#39;t sound unreasonable, but only you will know for sure since you have all the details of the use case.</p>
<p>Johnny is right in that the only way to really see what&#39;s going on is with a profiler, but if you don&#39;t have access to one we can make some reasonable guesses.</p>
<p>Given your post though, its almost certain that this is just a UI problem, and you&#39;re right in that SetProperty is probably causing hundreds (or more) of PropertyChanged events, which XAML responds to and just like WinForms ultimately causes repainting, among other things.&nbsp; All that is very slow, but this is a common problem in UI frameworks, so while I don&#39;t know the specifics for XAML I&#39;m sure there&#39;s a way to suspend the binding, set the IsChecked on the BO and let it do the cascade, and then resume binding.&nbsp; You&#39;d be surprised how slow just the UI eventing can be; this alone may solve your problem</p>
<p>You don&#39;t mention that anything else happens in your BOs when this Boolean is set, so I&#39;m assuming that the only effect of setting it is that it goes and sets the flag on its immediate children.&nbsp; If that&#39;s not the case, you may have other rules firing too, and if any hit the DB that will be a performance issue.</p>
<p>The command object comes into play if the use case really is as simple as you suggest (check a box, and that value cascades to all decedents).&nbsp; What you could do is have a RO list that you use to get the initial tree structure, then create an tree structure of non-Csla View models that have the checkbox and probably the text you display at each node.&nbsp; This would be a simple POCO really that probably implements IPropertyChanged.&nbsp; (SO you&#39;ll probably still need to do the suspend / resume binding).&nbsp; When the user hits save you have a command object which takes the ID of a node in the DB and runs a SQL query to update it and all children, probably using a CTE (common table expression) to do this in one DB query.</p>
<p>The advantage of that approach is that you use a lightweight RO object tree to initially get the tree data, the VMs you bind to your UI aren&#39;t Csla classes and so don&#39;t have the overhead of editable Csla business objects, and then the command object will issue one simply query to hit all the rows instead of multiple queries to update each row.&nbsp; But again this depends on your use case and if there&#39;s any other additional complexity I don&#39;t know about that would make editable BOs the way to go with this.</p>
<p>At any rate, I&#39;d start with investigating how to suspend / resume binding in XAML temporarily and see if that alone is enough to fix the issue.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jayoub replied on Monday, March 09, 2015</h2><p>I was able to profile the CSLA dll and it looks like the property change events are in fact the culprit. When BusinessBase runs CheckPropertyRules, it changes a metastate property (I&#39;m assuming IsValid or something like that), which called OnPropertyChanged. It also runs MarkDirty, which also changes a metastate property (probably IsDirty), which calls OnPropertyChanged. So I&#39;m certain the UI responding to the events is where the bottleneck is. </p>
<p>I think that I can remove the bindings on my controls in the code behind of the View responding to the CheckedChanging event or something like that, and then set the binding again in the CheckedChanged event. I don&#39;t know exactly how that will be achieved, but I know that I need to remove the binding somehow before the property change events are thrown, and then put the binding back after they are done.&nbsp;</p>
<p>No matter how that is implemented, it should solve my performance problem.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, March 09, 2015</h2><p>Your solution sounds like it should work.&nbsp; Perhaps this SO answer has the key: <a href="http://stackoverflow.com/a/3383010/347348">http://stackoverflow.com/a/3383010/347348</a></p>
<p>&nbsp;</p>
<p><span class="pln">using</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Dispatcher</span><span class="pun">.</span><span class="typ">DisableProcessing</span><span class="pun">())</span><span class="pln"><br /></span><span class="pun">{</span><span class="pln"><br />&nbsp;&nbsp;&nbsp; </span><span class="com">/* your work... Use dispacher.begininvoke... */</span><span class="pln"><br /></span><span class="pun">}</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, March 05, 2015</h2><p>Hi, </p>
<p>Maybe you could provide us with more information about your application, CSLA version and UI type. </p>
<p>First of all - I totally agree with what Andy wrote. <br />BypassPropertyChecks is only effective on SetProperty/SetPropertyConvert to make this method work like LoadProperty/LoadPropertyConvert.</p>
<p>LoadPropertyMarkDirty was created for use by the RuleEngine to update fields in the BO and make these dirty if changed. The rule engine will raise OnPropertyChanged as appropriate after all rules have run.</p>
<p>Maybe you could provide us with more information about your application, CSLA version and UI type. </p>
<p>CSLA 4.x has default property changed mode to Xaml. If you are using WinForms make sure to use the BindingList type list classes and set PropertyChangedMode to Windows.</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;CheckPropertyRules(<span style="color:#2b91af;">IPropertyInfo</span>&nbsp;property)
{
&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;propertyNames&nbsp;=&nbsp;BusinessRules.CheckRules(property);
&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:#2b91af;">ApplicationContext</span>.PropertyChangedMode&nbsp;==&nbsp;<span style="color:#2b91af;">ApplicationContext</span>.<span style="color:#2b91af;">PropertyChangedModes</span>.Windows)
&nbsp;&nbsp;&nbsp;&nbsp;OnPropertyChanged(property);
&nbsp;&nbsp;<span style="color:blue;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;name&nbsp;<span style="color:blue;">in</span>&nbsp;propertyNames)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OnPropertyChanged(name);
}</pre>
<p>CSLA 4.x rule engine is quite a bit smarter and you may also specify (to some extend) when rules are allowed to run, see base class PropertyRule.</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">protected</span>&nbsp;PropertyRule()&nbsp; :&nbsp;<span style="color:blue;">base</span>()
{
&nbsp;&nbsp;CanRunAsAffectedProperty&nbsp;=&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;CanRunOnServer&nbsp;=&nbsp;<span style="color:blue;">true</span>;
&nbsp;&nbsp;CanRunInCheckRules&nbsp;=&nbsp;<span style="color:blue;">true</span>;
}</pre>
<p>Also be aware that the rule engine will process rules in 2 rounds</p>
<ol>
<li>Rules where the property is &quot;PrimaryProperty&quot;</li>
<li>Rules for all &quot;AffectedProperties&quot; in step 1 + rules for Properties where &quot;ChangedProperty&quot; in InputProperty. </li>
</ol>
<p>This may or may not make the rule engine run some expensive rules.</p>
<p>I do recommend to first revert back to use SetProperty and then use a performance profiler to determine where the time is being spent.</p>
<p>Is it running rules, list changed event handlers, UI code or other parts of the code. Identify the root cause and then find the proper solution.</p>
<p>Do you have a sample project that demonstrates the issue?</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
