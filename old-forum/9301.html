<html><header><title>Prevent Property Changes (business rule)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Prevent Property Changes (business rule)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9301.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH posted on Friday, July 30, 2010</h2><p>In the old days of CSLA, if you wanted to prevent a change to a property, you would simply check a few conditions on the setter.&nbsp; If those conditions failed, you would simply thrown an exception, preventing the property value from being changed.</p>
<p>With the introduction of the static IPropertyInfo members, this method doesn&#39;t seem to work, as loading an object invokes the property setters.&nbsp; I don&#39;t want existing data to go through these business rules when the data is being loaded into the objects (on Fetch)</p>
<p>I tried adding a new Rule, but the problem is that the rule is executed AFTER the property has already been set.</p>
<p>I really need the rule to be run first, and based on success, the property is set.</p>
<p>Am I going about this the right way.&nbsp; Any thoughts?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, July 30, 2010</h2><p>The only way to prevent changes to a property (and this has been true for a few years/versions now) is to use an authorization rule.</p>
<p>Throwing an exception was never a good solution, as it confused data binding and could often leave the user seeing something on the screen that didn&#39;t match what was in the object (or just crash the app).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH replied on Friday, July 30, 2010</h2><p>Not sure how authorization rules tie into this.&nbsp; This is really a business rule.&nbsp; If the rule fails, I need it to prevent setting the underlying property value.</p>
<p>See, the issue is that if I bind a grid to a list of objects and the user makes a change, the object becomes invalid and the property now contains the invalid value.</p>
<p>Now, all I can do is present them with a &quot;cancel changes&quot; which rolls back the object state to its previous values, but what if they made a few changes to the object that were good also?&nbsp; Then they have lost all of those changes.</p>
<p>I suppose I could also prevent entry for that certain property too based on pass/fail of the logic, but now i&#39;m putting business logic into the UI as well...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joemorin73 replied on Friday, July 30, 2010</h2><p>If you edit data directly in a SQL editor and one of the values is invalid, all data is rolled back when you press escape.&nbsp; This is a common user experience.</p>
<p>Are there many fields in your data?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, July 30, 2010</h2><p>True - but that is not the only undo paragidm with which Aaron&#39;s users may be familiar.</p>
<p>Consider Excel.&nbsp; If you type a value in a cell, don&#39;t like it, and press Ctrl-Z (or use whatever means of invoking the undo functionality that floats your boat), only that cell&#39;s value is undone - every other change you have made is kept.</p>
<p>This is a common issue - the &quot;batch&quot;-level undo versus the &quot;individual&quot;-level undo.&nbsp; Unfortunately, CSLA isn&#39;t really built to handle the individual-level undo.&nbsp; And without changing the CSLA codebase, I don&#39;t think you can shoehorn individual-level undo in there, particularly on a property-by-property basis.&nbsp; It might be possible by switching to private-variable backing fields, but you&#39;d still probably have to ignore/work around a lot of the CSLA infrastructure, and you still may not get there without a lot of work.</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, July 30, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>AaronH<br></b></p>
<p>See, the issue is that if I bind a grid to a list of objects and the user makes a change, the object becomes invalid and the property now contains the invalid value.</p>
<p></div></p>
<p>The challenge here, is that the datagrid controls expect things to work a certain way - and not the way you are describing. So you are embarking on a road where you&#39;ll have to fight the datagrid controls, data binding and CSLA (or any other object framework that supports data bindng).</p>
<p>Data binding assumes it can always set the value. This is a blanket assumption. If you prevent the value from changing in the setter, you&#39;ll almost certainly confuse data binding - the user will see one thing in the UI and the object will have a different value.</p>
<p>Additionally, datagrid controls and data binding interact with the IEditableObject interface on a per-row (per-object) basis, and expect undo operations to occur at the row level. That&#39;s the way the whole infrastructure is designed. Outside of select datagrid controls, there&#39;s no concept of per-cell undo - and if a datagrid does such a thing it is purely at the control level - because data binding itself has no such concept, nor are there interfaces by which a data source can interact with the UI for such a concept.</p>
<p>CSLA supports data binding. What data binding defines, CSLA does. What data binding doesn&#39;t do (generally speaking) CSLA doesn&#39;t do. How could it? Without formalized interfaces and data binding interactions, CSLA can&#39;t arbitrarily invent some concept - nothing else in the world would support it.</p>
<p>Given all that - the question is how to solve your problem.</p>
<p>The answer is to &quot;allow the change to occur&quot; and to then undo the change.</p>
<p>In other words, data binding <i>assumes the property will accept any new value</i> whether valid or not. And it assumes the object will go into an invalid state if the value is bad.</p>
<p>You are saying you dislike the model defined by data binding. OK, then you need to work around data binding.</p>
<p>You can do that by accepting the bad value, and then resetting the value to the previous value <i>and allowing CSLA to interact with data binding as though the value changed</i>. That way CSLA will tell data binding that the value changed, so data binding will refresh the value, so the user will see the value that&#39;s in the object - which is the previous value.</p>
<p>If you don&#39;t follow that sequence, the user will see what they typed in, but the object will have the previous value - which is a horribly confusing user experience.</p>
<p>So how do you do this? Well, it will take some work.</p>
<p>First, you need to use custom FieldData types that track the previous value - Jason Bock has a blog post on how to do this, and it is something CSLA does support (with some work on your part).</p>
<p>Second, you need a rule to run (probably at priority -1 or something) that reverts the new value to the previous value and triggers explicit short-circuiting so no subsequent rules run (why bother when you&#39;ve undone the change to the new value).</p>
<p>What&#39;ll happen then, is that the user will enter the new value. It will be &quot;accepted&quot; into the object. Your priority -1 rule will run and revert the property to its previous value. But CSLA will still think that the property has been changed, so it will raise PropertyChanged. That&#39;ll cause data binding to refresh the value, updating the UI to replace the invalid value the user typed in, with the value from the object - which is the previous value.</p>
<p>The user experience will still be sort of iffy (imo), because the user will enter a value, hit Tab and their entry will silently be replaced by the previous value. They won&#39;t know why, and perhaps won&#39;t even notice that their entry was ignored/undone. For my part, I&#39;d find such an experience to be really frustrating - but perhaps your users are used to this sort of thing.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>AaronH replied on Saturday, July 31, 2010</h2><p>Thanks for the thoughtful replies, everyone.&nbsp; The actual problem isn&#39;t so much reverting the value, that was just an example.&nbsp; But it is a solid business rule that absolutely must prevent the state of the object from changing based on some other state values.</p>
<p>Here goes the scenario:&nbsp; I have a class called Record.&nbsp; For sake of clarity, Record has an InputType (enum) property that represents an AUTOMATIC entry or a MANUAL entry.&nbsp; If the Record instance was created AUTOMATICALLY, then certain fields CANNOT be changed.&nbsp; This is where I would throw the exception.&nbsp; </p>
<p>It&#39;s business logic that physically prevents state from being changed.&nbsp; So I guess it&#39;s a bit more than just telling the object whether it&#39;s valid or invalid.&nbsp; It&#39;s more of a requirement of business logic preventing the object instance from even reaching an invalid state due to a property of the Record object changing while being AUTOMATICALLY entered.</p>
<p>What I have done for this type of scenario in the past is to throw an exception in the property setter.&nbsp; This logic guarantees that the object cannot be changed in certain scenarios.&nbsp; Then, when a developer consuming the object bound it to some UI,&nbsp; it would be up to them to disable input based on the state of the object.&nbsp; This would prevent the exception from ever being raised in the first place, but still having the business logic built into the business class.&nbsp; </p>
<p>I&nbsp;guess this is the approach I was thinking of following, but running into issues of course, due to the IPropertyInfo paradigm.&nbsp; Perhaps this isn&#39;t a great practice to follow anymore?&nbsp; </p>
<p>Or perhaps, I should be explicitly calling LoadProperty to avoid the property setters being called, which invoke the business logic?&nbsp; See, right now, I am calling Property = DataSource.Value within a BypassPropertyChecks block, which causes each property setter to be called when loading the state (data) of the record object.</p>
<p>Any further thoughts or comments would be greatly appreciated!</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>ajj3085 replied on Saturday, July 31, 2010</h2><p>I believe the previous suggetion of authorization rule still applies.&nbsp; In Csla 4, you can write an auth rule which checks the state of the object and allows or denies write access to the property.&nbsp; Just make sure it runs first.&nbsp; Prior to 4, you should be able to do the exact same thing by overriding CanWriteProperty.&nbsp; You&#39;ll just need to ensure that the cell control checks if the property can be written to and enable / disabling when the other values change.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, July 31, 2010</h2><p>I do agree with Andy - to a point.</p>
<p>If you can determine, before the user enters any new value, whether the user <i>should be able to enter a new value</i>, then that&#39;s an authorization rule. That can be done easily in CSLA 4, and can be done by overriding CanWriteProperty() in earlier versions of CSLA.</p>
<p>However, if the user is allowed to enter a new value, and you want to validate that new value after they&#39;ve entered it, then you really should follow the model defined by data binding for how this should work - and that&#39;s the model supported by CSLA of course. If you really want to fight data binding and CSLA, see my previous post for some ideas on how you might be able to overcome the standard .NET data binding behaviors.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jav replied on Saturday, July 31, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>AaronH<br></b></p>
<p>&nbsp;If the Record instance was created AUTOMATICALLY, then certain fields CANNOT be changed.&nbsp;</p>
<p>
<div style="CLEAR:both;"></div>
</div></p>
<p>I am a newbie in this realm also, but can those fields not be made ReadOnly under those circumstances.&nbsp; </p>
<p>Jav</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Saturday, July 31, 2010</h2><p>I think the thing to remember here, and this is the key:</p>
<p><b>Authorization is NOT security. Authorization is a form of business logic.</b></p>
<p>What I hear being described in this thread is this:</p>
<p>&quot;I have an object, and when the object is in a certain state, users are not authorized to change a specific property.&quot;</p>
<p>That&#39;s an authorization rule. Is it security? No, but it most certainly is authorization.</p>
<p>This is why CSLA 4 has much more powerful authorization capabilities than previous versions. While my answer in 3.x would be to override CanWriteProperty(), that was awkward. But in CSLA 4 you can very easily create a rule to handle this scenario and attach that rule to the write operation of the property.</p>
<p>The result, btw, will be an exception if the user does attempt to change the property. But that really shouldn&#39;t happen if the UI developer is competent, because the UI developer will have picked up on the CanWriteProperty() result (via IAuthorizeReadWrite) and will have prevented the user from even trying to update the value. CSLA includes controls for Windows Forms, Silverlight, WPF and ASP.NET MVC that make this happen almost automatically.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH replied on Sunday, August 01, 2010</h2><p>Do you see a clear advantage of taking the CanWriteProperty approach over the approach of placing the business logic directly in the property setter, and invoking LoadProperty to avoid invoking that business logic on load?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, August 01, 2010</h2>well sure, if you use the authz subsystem then the ui can find out the user can&#39;t enter values BEFORE the user tries. this enables the ui developer to give the user a substantially superior experience. if you embed the rule in the setter there is no way for the ui developer to reuse the logic to improve the user experience.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Sunday, August 01, 2010</h2><p>Hi, </p>
<p>I&#39;ve tried to update the BusinessRuleSample but I am not happy about the way BusinessBase caches the result of the authorization rules. </p>
<p>Say if the State of the object is actually dependent on a value the user has entered/selected. Ex address form in an application with Country list and US State list. The State list is only allowedd to write/select if Country is &quot;US&quot;. This will not work properly today in an editform in WinForms/WPF/SL as the rule result is cached, ie: returns the result of the first tun of the authorization rule in this instance - thus allowing for awkward situations.</p>
<p>Should the result of authorization rules be cached at all? </p>
<p>Is it obvious for delopers that AuthorizationRules and ValidationRules are treated differently in the new rule system? </p>
<p>It&#39;s very easy to override but I think we&#39;ll see some questions about it in the forum.</p>
<p><b>To make this work properly the developer must override 
CanWriteProperty so that rules are not cached.</b></p>
<p>

</p>
<pre style="font-family:consolas;"><br />&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#cc7832;">public</span>&nbsp;<span style="color:#cc7832;">override</span>&nbsp;<span style="color:#cc7832;">bool</span>&nbsp;CanWriteProperty(Csla.Core.<span style="color:#2b91af;">IPropertyInfo</span>&nbsp;property)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#004000;">//&nbsp;must&nbsp;override&nbsp;so&nbsp;that&nbsp;authorization&nbsp;rules&nbsp;are&nbsp;not&nbsp;cached</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#cc7832;">return</span>&nbsp;<span style="color:#ffc66d;">BusinessRules</span>.HasPermission(<span style="color:#ffc66d;">AuthorizationActions</span>.WriteProperty,&nbsp;property);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /></pre>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, August 01, 2010</h2><p>That is true - and that&#39;s an issue I&#39;m aware of.</p>
<p>I&#39;ve been thinking that the best overall answer is probably for IAuthorizationRule to have a bool property that indicates whether the results of the rule can be cached (with the cache invalidating based on a change to the current principal). I&#39;d hoped to work that into the 4.0.0 release, but ran out of time.</p>
<p>Some rules, like IsInRole, etc, can be cached based on the principal.</p>
<p>Other rules, like what we&#39;re discussing here, can&#39;t.</p>
<p>So I <em>think</em> the answer is for the rule to indicate whether it is OK with having its results cached.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, August 02, 2010</h2><p>Yes, that would be a much better solution for Authorization. </p>
<p>How important is caching for the authorization rules?<br />Does the authorization providers themselves provide caching mechanisms internally?&nbsp; &nbsp; </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, August 02, 2010</h2><p>Hi,</p>
<p>For more advanced Authorization (BusinessRules) it&nbsp; would also be nice to have ReadProperty available in these rules. </p>
<p>Maybe even have InputProperties to create better generic rules. </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 02, 2010</h2><p>The caching is important, at least in Windows Forms where data binding can re-read properties fequently.</p>
<p>There is no Microsoft infrastructure for any of this btw. This is a CSLA thing, and has been for years. I <em>wish</em> Microsoft would formalize authorization as a concept within data binding - but so far no luck...</p>
<p>I agree, allowing for InputProperties is probably a good idea for a future enhancement.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Tuesday, August 03, 2010</h2><p>I would vote for the rule being able to exclude itself from caching.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
