<html><header><title>OT: Event Handlers for multicast delegate not firing</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OT: Event Handlers for multicast delegate not firing</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1923.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Thursday, December 07, 2006</h2><P>I have an event that I have "attached" multiple event handlers using the following standard syntax:</P>
<P><CODE>myObject.PropertyChanged += new PropertyChangedEventHandler(Handle_PropertyChanged);</CODE></P>
<P>This occurs in four different&nbsp;classes - all listening for this event.&nbsp; When I run the application and the event occurs, only the most recently added handler executes.</P>
<P>Any ideas what is going on?</P>
<P>Is there any way to check what handlers are attached to an event in debug mode (VS 2k5)?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 07, 2006</h2>As far as I know that should work.&nbsp; And unfortunately I don't know how you can check what event handlers are attached.. did you trace into Bindable base to see what code is being executed?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, December 07, 2006</h2>Make sure you reattach handlers for non serializable listeners...<br>You normally do that in OnDeserialized().<br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 07, 2006</h2>What determines if an event is serializable?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, December 07, 2006</h2>It's not the Event itself that is or isn't serializable.<br><br>In c# when you declare an event you can add a param like: [field: NonSerialized()]. (this makes the event "reset" when the object is serialized). That means that the actual delegate that run within the event are not serialized. <br><br>In vb there is no "field:" modifier for attributes, so you are forced to code a custom event (next paragraph).<br><br>If you create the events "the hard way" you can create 2 delegates, one for serializable listeners (which does get serialized) and one for non serializable listeners. When you do AddHandler (in vb), the custom event can check whether the listener is serializable or not and add it to the correct delegate.You can do a similar thing in c# I believe.<br> (you can find a good example of this in the csla codebase or in rocky's blog). <br><br>Sorry for the quick explanation, it's actually a long subject... :)<br><br><br>Andrés<br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>To answer both questions:</P>
<P>I did step through the code and that's how I know what's happening.&nbsp; Until then I just knew the behavior wasn't right.&nbsp; When stepping through I am able to see that all four handlers are added to the event but when the event is triggered, only the handler that was attached last executes.&nbsp; (I even manually attached a different handler after the other four using the Command Window and that was the one executed when the event was triggered.)</P>
<P>There is no serialization/deserialization taking place.&nbsp; I had considered that and remembered that event handlers are not restored on deserialization.&nbsp; (I have reviewed the code in BindableBase for an example how this is dealt with.)&nbsp; But, since there is no serialization taking place, AND, one of the four event handlers IS being triggered, I have no reason to believe this is the culprit.</P>
<P>The one thing I did fail to mention is that this is a web app.&nbsp; The event handlers are attached when the page is first requested.&nbsp; The object model which contains both the sources of the event and the objects handling them is persisted in Session between postbacks.&nbsp; So, when a button is clicked on the page, a property is changed on postback that triggers the event which should be handled by all four handlers but is only being executed by the last to be added method.</P>
<P>It is the fact that one of the four, and that it is the last of the four, that makes this confusing.&nbsp; I would assume an all or nothing result if serialization or posting back had anything to do with it.&nbsp; So, beyond that, I am stumped and dead-in-the-water until I get this figured out.</P>
<P>Thanks for the help.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 08, 2006</h2>Hmmm, very weird.&nbsp; Did you try the same code, but in a forms applcation?&nbsp; If it works there, then asp.net is somehow throwing things off.&nbsp; That might help narrow in on what may be causing a problem.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>No I haven't, but I will do just that as soon as I can steal a few minutes to set it up.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Friday, December 08, 2006</h2>Can we see the code for the event? How is the event declared?<br><br>As I said before, event's use delegates internally. If you wrote a "custom" event, you need to keep in mind that you need to Combine the delegates. Here's a sample:<br><br>Public Delegate Sub EmptyDelegate()<br><br>&nbsp;&nbsp;&nbsp; &lt;NonSerialized(), NotUndoable()&gt; _<br>&nbsp;&nbsp;&nbsp; Private d_create As EmptyDelegate<br><br>&nbsp;&nbsp;&nbsp; Protected Custom Event Create As EmptyDelegate<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler(ByVal value As EmptyDelegate)<br><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_create = CType([Delegate].Combine(d_create, value), EmptyDelegate)</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End AddHandler<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveHandler(ByVal value As EmptyDelegate)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d_create = CType([Delegate].Remove(d_create, value), EmptyDelegate)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End RemoveHandler<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If d_create IsNot Nothing Then d_create()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End RaiseEvent<br>&nbsp;&nbsp;&nbsp; End Event<br><br><br><br>If your code always runs the last defined handler, it might be that it's not combining the delegates and the delegate always holds the reference to the last handler... I don't recall if this works the same way in c#.<br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 08, 2006</h2>Andres, good point.&nbsp; I have been assuming that he's actually having problems with the PropertyChanged event.&nbsp; The C# version would be:<br>[NonSerialized, NotUndoable]<br>private event EmptyDelegate d_create;<br><br>protected event EmptyDelegate Create {<br>&nbsp;&nbsp;&nbsp; add { d_create = (EmptyDelegate)Delegate.Combine( d_create, value ); }<br>&nbsp;&nbsp;&nbsp; remove { d_create = (EmptyDelegate)Delegate.Remove( d_create, value ); }<br>}<br><br>private void RaiseEvent() {<br>&nbsp;&nbsp;&nbsp; if ( d_create != null ) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  d_create();<br>&nbsp;&nbsp;&nbsp; }<br>}<br>
&nbsp;</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>Yea, this is in C# and that is ALL completely new to me.&nbsp; We are having this problem with a "custom" event.&nbsp; Here's how the class that defines and triggers the event is declared:</P>
<P><CODE>public class myClass<BR>{<BR>&nbsp; &nbsp; protected virtual void OnSelectionChanged(SelectionChangedEventArgs e)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (SelectionChanged != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectionChanged(this, e);<BR>&nbsp; &nbsp; }<BR>&nbsp;<BR>&nbsp; &nbsp; public event SelectionChangedEventHandler SelectionChanged;<BR>} </CODE></P>
<P>And the event is declared as:</P>
<P><CODE>public delegate void SelectionChangedEventHandler(System.Object sender, SelectionChangedEventArgs e);</CODE></P>
<P>The SelectionChangedEventArgs simply inherits System.EventArgs and adds a SelectedItem property.</P>
<P>The only additional comments I've ever heard with respect to declaring and using events is when it comes to serialization and the need to restore handlers after deserialization as Rocky demonstrates in BindableBase.&nbsp; This stuff about combining, etc. is new to me.</P>
<P>(BTW - I was told this is also happening with PropertyChanged but I have not verified that one.&nbsp; The custom SelectionChanged event I have seen myself.)</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 08, 2006</h2>Pirate,<br><br>Try doing something similar to the code I posted, where you keep the actual event property private and explicity declare the public event with the add and remove handlers.&nbsp; See if that solves the problem.<br><br>At this point that's the only thing I can think of, because otherwise the code you posted looks fine.. it just might be the default add remove methods for the event as you declared it only keep the last event handler which was hooked up.&nbsp; The explicit add remove I posted (and Andres) will combine the delegates into one.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Friday, December 08, 2006</h2>You could also try declaring the event like:<br><br><br><code>public event EventHandler&lt;</code><code>SelectionChangedEventArgs&gt;</code><code> SelectionChanged;</code><br><br><br>Andrés</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 08, 2006</h2>Andres,<br><br>That's the recommended way now actually... but would that change the behavior of the default add remove event methods?<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Friday, December 08, 2006</h2>I don't think so, not at all.<br>But he is definitely having a rare issue:<br>He's not using custom events, so there's no way he could be screwing up the combines. The only thing I can think of is:<br><br>-The handlers are not being added correctly.<br>-The compiler did something unusual for some reason.<br><br>So, even though I don't really think it makes a difference, I'm just tossing another ball in the air... :)<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>So after all that, including making all of the changes suggested and creating a simple Windows app to verify, turns out that there was a logic error deep in the code blocking the event as a result of the conditions being tested on the page post-back!&nbsp; Test using different circumstances and it works just fine.&nbsp; I had the logic corrected and now the original tests work as well. (Let's hear it for team development!)</P>
<P>To finish the train of thought that the thread has gone on, can you tell me what the advantage/disadvantages are of specifying events in the manner you've described aside from addressing the deserialization issues Rocky mentioned in the book?&nbsp; Also, can you refer me to where it is written up that using EventHandler&lt;T&gt; is now the recommended practice versus declaring your own handler delegate?&nbsp; Is this just to simplify things or is there a reason why this is now recommended?</P>
<P>Thanks for the follow-up.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 08, 2006</h2>Glad you got it fixed.&nbsp; The only advantage of havng your own add remove is that you can control it more... but thinking it would help was a long shot, I must admit.&nbsp; Personally I prefer it because its more in keeping with the 'private fields, public properties' design I like to keep.&nbsp; <br><br>Does Rocky recommend having explicit add / remove for your events for some deserialization issue?&nbsp; I might have missed that in the book.<br><br>The recommendation to use EventHandler&lt;T&gt; actually comes from FxCop.&nbsp; Its under <a href="http://msdn2.microsoft.com/en-us/library/ms182178%28VS.80%29.aspx">Microsoft.Design, CA1003</a>.&nbsp; The reason they suggest to use it is a good one; you no longer have to define your own delegates if you have custom event arguments.<br><br>So instead of :<br><br><font color="#0000ff">public delegate void</font> MyEventHandler( <font color="#0000ff">object </font>sender, <font color="#008000">MyEventArgs </font>e );<br><br><font color="#0000ff">public event</font> <font color="#008000">MyEventHandler </font>MyEvent;<br><br>You just do:<br><br><font color="#0000ff">public event</font> <font color="#008000">EventHandler</font>&lt;<font color="#008000">MyEventArgs</font>&gt; MyEvent;<br><br>and off you go.&nbsp; Basically you no longer have to create your own delegates anymore, which is kind nice.&nbsp; A little less code you have to enter and maintain.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
