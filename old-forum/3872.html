<html><header><title>Exception in SharedAuthorizationRules.GetManager()</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Exception in SharedAuthorizationRules.GetManager()</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3872.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JBergdahl posted on Friday, November 09, 2007</h2><P><FONT face=Arial size=2>I have run into a problem in an application that runs numerous (25+)&nbsp;threads concurrently (the code runs&nbsp;in a&nbsp;BizTalk transmit adapter), using CSLA BO's. At startup, the following exception occurs for the first creation of a specific BO.</FONT></P>
<P><FONT face="Courier New" size=2>Exception DataPortal.Fetch failed (System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.ArgumentException: An item with the same key has already been added.<BR>&nbsp;&nbsp; at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)<BR>&nbsp;&nbsp; at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)<BR>&nbsp;&nbsp; at Csla.Security.SharedAuthorizationRules.GetManager(Type objectType, Boolean create) in C:\c\Common\csla2.1.4\csla20cs\Csla\Security\SharedAuthorizationRules.cs:line 36<BR>&nbsp;&nbsp; at Csla.Security.AuthorizationRules.HasReadAllowedRoles(String propertyName) in C:\c\Common\csla2.1.4\csla20cs\Csla\Security\AuthorizationRules.cs:line 226<BR>&nbsp;&nbsp; at Csla.Core.BusinessBase.CanReadProperty(String propertyName) in C:\c\Common\csla2.1.4\csla20cs\Csla\Core\BusinessBase.cs:line 460<BR>&nbsp;&nbsp; at Csla.Core.BusinessBase.CanReadProperty(String propertyName, Boolean throwOnFalse) in C:\c\Common\csla2.1.4\csla20cs\Csla\Core\BusinessBase.cs:line 406</FONT></P>
<P><FONT face="Courier New" size=2><FONT face=Arial>The CSLA code looks like this:</FONT></FONT></P>
<P><FONT face="Courier New" size=2>&nbsp;&nbsp;&nbsp; internal static AuthorizationRulesManager GetManager(Type objectType, bool create)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AuthorizationRulesManager result = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_managers.TryGetValue(objectType, out result) &amp;&amp; create)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <STRONG><FONT color=#0000ff>lock (_managers)</FONT><BR></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = new AuthorizationRulesManager();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _managers.Add(objectType, result);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;<BR>&nbsp;&nbsp;&nbsp; }</FONT></P>
<P><FONT face="Courier New" size=2><FONT face=Arial>What is happening seems to be that two threads passes the if (TryGetValue()) at the same time (it is a dual core processor, so we do have two threads running at exactly the same time), one of them reaches the lock first, and adds&nbsp;the new result object. Meanwhile the other thread is waiting for the lock, and when the lock is released, tries to add the very same thing, resulting in the above exception.</FONT></FONT></P>
<P><FONT face=Arial size=2>I see two possible solutions:</FONT></P>
<P><FONT face=Arial size=2>1. Move the lock so that in encapsulates the TryGetValue() call. This would induce the overhead of always aquiring a lock.<BR>2. Encapsulate the _managers.Add() call in a try-catch clause that catches and ignores any exceptions thrown. This would not induce any overhead, but&nbsp;looks like the ugly kludge it is.&nbsp;</FONT></P>
<P><FONT face=Arial size=2>Comments? </FONT></P>
<P><FONT face="Courier New" size=2><FONT face=Arial>Regards;<BR>/jb</FONT></P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JBergdahl replied on Friday, November 09, 2007</h2><P><FONT face=Arial size=2>A quick search in the CSLA project reveals three different ways locking implemented in the framework:</FONT></P>
<P><FONT face=Arial size=2>1. With the risk for a potential exception</FONT></P>
<P><FONT face="Courier New" size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!_managers.TryGetValue(objectType, out result) &amp;&amp; create)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_managers)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = new ValidationRulesManager();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _managers.Add(objectType, result);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</FONT></P><FONT face="Courier New" size=2>
<P><FONT face=Arial size=2>2. With locking overhead</FONT></P></FONT>
<P><FONT face="Courier New" size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_syncClientContext)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HybridDictionary ctx = GetClientContext();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ctx == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx = new HybridDictionary();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetClientContext(ctx);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ctx;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR></P>
<P><FONT face=Arial size=2>3. With an extra safeguard</FONT></P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (applySort &amp;&amp; !_sorted)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (_list)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (applySort &amp;&amp; !_sorted)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _list.Sort();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _sorted = true;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</P>
<P><FONT face=Arial>Seems to me that the last one is the optimal solution, as it only uses a lock when necessary, but still avoids duplicate work by rechecking the criteria.</FONT></P>
<P><FONT face=Arial>Regards;<BR>/jb</FONT></P>
<P>&nbsp;</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Friday, December 14, 2007</h2><P>We're having similar issues with this method as well.&nbsp; We get intermitent exceptions since it's running in a multi-threaded environment with a high volume of requests.</P>
<P>Personally, I'm thinking that moving the lock statement before the </P>
<P><FONT face="Courier New" size=2>if (!_managers.TryGetValue(objectType, out result) &amp;&amp; create)</FONT></P>
<P>line would suffice.&nbsp; Locking has less of an&nbsp;overhead than one might think and it makes things much simpler.&nbsp; </P>
<P>Rocky, have you had a chance to look at this issue yet?&nbsp; I know you've made changes to this class in the past to better support multi-threading but perhaps overlooked this edge case?</P>
<P>~pete</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, December 14, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JBergdahl:</strong></div><div><FONT face="Courier New" size=2>
<P><FONT face=Arial>Seems to me that the last one is the optimal solution, as it only uses a lock when necessary, but still avoids duplicate work by rechecking the criteria.</FONT></P>
<P></FONT></div></BLOCKQUOTE></P>
<P>There are good reasons for using 2 and 3 in different locations. Number 1 is clearly a bug, and where that occurs it should be changed (probably) to use technique 3.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, December 14, 2007</h2><P>The two cases where the race condition existed have been changed now in version 3.0.4 and 3.5. Both sets of code are in svn at the moment, so if you could let me know if this addresses the issue that'd be really helpful.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JTWebMan replied on Wednesday, April 02, 2008</h2>This could be fixed with a double lock check. Add the if statement to the other side of the lock so once the thread is in the lock it checks again and doesn't add it twice.<br><br>JT<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
