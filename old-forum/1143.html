<html><header><title>Create new objects through DataPortal_Fetch?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Create new objects through DataPortal_Fetch?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1143.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane posted on Wednesday, September 06, 2006</h2>I don't want the client of an object to have to know whether it is creating a record or fetching an existing record. If the record exists, we want to use it. If it does not exist, we want to always create a new record. In both cases, the DataPortal has to go to the database. Currently, we have code like this inside the shared Factory method of the business object:<br><br>Dim return as myObject<br>return = myObject.GetMyObject(id)<br>If return Is Nothing Then<br>&nbsp;&nbsp;&nbsp; return = myObject.NewMyObject(id)<br>End If<br>Return myObject<br><br>The client also has some other logic that depends on whether IsNew is true. Mainly, some fields are read-only if the object is not new.<br><br>Since I always have to hit the database, I want to combine the two DataPortal calls into a single call. Within the DataPortal_Fetch, it was trivial to combine the code, including calls to MarkOld and MarkNew, as appropriate. However, I discovered that my object was still coming back as an "old" object because the DataPortal calls MarkOld for us automatically after the call to the DataPortal_Fetch method.<br><br>I think I can resolve this issue with the following changes to my object:<br><ul><li>Override MarkOld to do nothing.</li><li>Add a private MarkSelfOld method</li><li>Call MarkSelfOld during the DataPortal_Fetch</li></ul>However, I'm not sure that this is the right path to go. I'm wondering if I should create a ReadOnly factory object that returns my real business object through it's own DataPortal_Fetch call. Then, my logic stays the same within my object, but the logic will always be running on the application server because it is being instantiated through the separate factory object.<br><br>If you had this problem, which solution would you choose?<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Wednesday, September 06, 2006</h2>If&nbsp; I understand you, you want a single method of retrieving an object so that it creates or fetches as appropriate, but when you tried to combine them in the DataPortal, you ran into problems.&nbsp; You are now looking at making non-standard changes to CSLA methods.<br><br>Personally, I would take the simple option of having the factory method choose the correct DataPortal method to call.<br><br>public Object GetObject(Guid id)<br>{<br>&nbsp;&nbsp;&nbsp; if (Object.Exists(id))<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  return DataPortal.Fetch&lt;Object&gt;(new Criteria(id));<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  return DataPortal.Create&lt;Object&gt;(new Criteria);<br>}<br><br>If the Exists() call to the database is really going to be too much of a hit, then call DataPortal.Create() and then add a call to MarkOld() when appropriate.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Wednesday, September 06, 2006</h2><P>I don't&nbsp;like DataPortal calling MarkOld() precisely for this reason -&nbsp;I think it makes too big an&nbsp;assumption for code at that low a level, but anyway...</P>
<P>I'd vote for something like Brian's solution mainly because it keeps things very clean and simple even if not quite as efficient in database traffic (it's still the same amount of work at the database though).</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Thursday, September 07, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Brian Criswell:</strong></div><div><br>Personally, I would take the simple option of having the factory method choose the correct DataPortal method to call.<br><br>public Object GetObject(Guid id)<br>{<br>&nbsp;&nbsp;&nbsp; if (Object.Exists(id))<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  return DataPortal.Fetch&lt;Object&gt;(new Criteria(id));<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  return DataPortal.Create&lt;Object&gt;(new Criteria);<br>}<br><br>If the Exists() call to the database is really going to be too much of a hit, then call DataPortal.Create() and then add a call to MarkOld() when appropriate.<br></div></BLOCKQUOTE><br><br>This is essentially what I am doing now, which creates two calls to the database. Some of our clients are operating in a WAN environment, and we are finding that the round-trip time is a significant portion of the response time. Having two round trips is what I am trying to eliminate.<br><br>After having had a night of sleep, I think I am going to wrap the creation inside of a separate ReadOnlyBase-derived factory object. I'll change the GetObject factory method to call the separate factory object. This will give me one round trip and I won't have to change the client usage. <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, September 07, 2006</h2>I would recommend creating a ROB-derived factory object that goes to the server, gets the object you want and returns with it (new or old). This ROB object doesn't need to be public, so it doesn't clutter your namespace, and is an elegant solution to the problem. So your factory looks like this:<br><br>public static Object GetObject(Guid id)<br>{<br>&nbsp; return ObjectFactory.GetObject(id)<br>}<br><br>[Serializable]<br>private class ObjectFactory : ReadOnlyBase&lt;ObjectFactory&gt;<br>{<br>&nbsp; private Object _result;<br>&nbsp; public Object Result<br>&nbsp; { get { return _result; } }<br><br>&nbsp; public static Object GetObject(Guid id)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; ObjectFactory factory = DataPortal.Fetch&lt;ObjectFactory&gt;(new Criteria(id));<br>&nbsp;&nbsp;&nbsp; return factory.Result;<br>&nbsp; }<br>&nbsp; // implement criteria and DataPortal_Fetch()<br>}<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
