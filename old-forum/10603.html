<html><header><title>Permission based authorization and performance in CLSA.NET v4</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Permission based authorization and performance in CLSA.NET v4</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10603.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>nhwilly posted on Tuesday, August 09, 2011</h2><p>I thought I had a good initial design for doing a permission based authorization model based on Rocky&#39;s comments and my understanding of things - until I read in Using CSLA 4 how the principal and hence the identity have to be passed through the dataportal on each call.&nbsp; That, or they have to be reconstructed on the other end.&nbsp; </p>
<p>In the latest version of Using CSLA 4, Rocky makes a point of possible performance issues if too much data ends up in the identity.&nbsp; Uh oh.</p>
<p>Well, the design I have makes it possible to have quite a few permissions - hundreds possibly - in a given application - all stored in a SQL database.&nbsp; I don&#39;t want to reread all that on each dataportal call at the server and if the list is large, I don&#39;t want to passed it along the wire on each dataportal call.&nbsp; I know if there was some easy workaround, Rocky would have suggested it in his writings.&nbsp; So I guess it&#39;s a choice of the lesser of the evils, unless someone has a better idea.</p>
<p>I haven&#39;t finalized any of it yet and I thought I&#39;d ask if anyone has used a permission set that&#39;s large and which approach they took.&nbsp; Maybe I&#39;m worried too much about nothing, but I was hoping this security module would work for both&nbsp;my ASP.NET applications and my WPF app.</p>
<p>Thanks in advance.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, August 09, 2011</h2><p>This can be a very real concern. I was working with a client last year who wanted extremely granular permissions at a property level. The result was tens of thousands of permissions.</p>
<p>Even if each permission is stored as a bit, the raw data structure was quite huge - too big to pass on each data portal call.</p>
<p>I honestly don&#39;t know their resolution, because they continued working after I&#39;d moved on to other things. My suggestions:</p>
<ol>
<li>Use compression on the bit-wise data structure (most permissions would be 1 for most users, so simple RLE compression would shrink the structure to be very small for almost all users)</li>
<li>Don&#39;t pass the principal on each call - instead have the server retrieved a cached copy from the AppFabric cache to handle each call (so the cached identity objects would be available across the app server cluster)</li>
</ol>
<p>You should be able to predict the likely size of the identity object. And you should be able to predict the load to recreate it from the database for each request. Those two pieces of information should help you decide whether you can afford to pass it on each call, recreate it on each call, or if you need a server-side cache to minimize the security database load.</p>
<p>None of these things are at all unique to CSLA btw. Every web app that has granular permissions has had to deal with this issue for the past 14 years or so. Sadly, there are no really good answers - it depends on your particular situation.</p>
<p>I should also say that most web apps don&#39;t have the richness of smart client apps - and this type of challenge is a big reason for that. In my observation, a lot of web apps would <em>like</em> to have this sort of richness, but the developers don&#39;t have the time/budget/expertise to make it work - so they back off and go with a far simpler page-based authorization scheme.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>nhwilly replied on Tuesday, August 09, 2011</h2><p>Well, dang.</p>
<p>So a big&nbsp;dictionary of strings is out, huh?</p>
<p>Does this mean I have one enormous structure like this:</p>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;"><span style="color:blue;">Public</span>&nbsp;<span style="color:blue;">Enum</span>&nbsp;<span style="color:#2b91af;">Permission</span>&nbsp;<span style="color:blue;">As</span>&nbsp;<span style="color:blue;">Byte</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ManageUsers&nbsp;=&nbsp;1&nbsp;&lt;&lt;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateOrders&nbsp;=&nbsp;1&nbsp;&lt;&lt;&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PurchaseEquipment&nbsp;=&nbsp;1&nbsp;&lt;&lt;&nbsp;2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CancelOrders&nbsp;=&nbsp;1&nbsp;&lt;&lt;&nbsp;3</pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">        ...<br />        ...<br />        ...<br />        CanEditCustomerBirthdateIfIQGreaterThanRoomTemperature = 1 &lt;&lt; 49863
<span style="color:blue;">End</span>&nbsp;<span style="color:blue;">Enum</span></pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">And then compress it using RLE?</pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">Don&#39;t I get into versioning problems like I would with storing serialized data?</pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">Maybe I&#39;ll look into AppFabric.  </pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">I didn&#39;t know it was free and if it&#39;ll get me out of writing low level code, I&#39;m all ears. <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:13px;">As always, thanks, Rocky.</pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, August 09, 2011</h2><p>Somewhat like this, yes. There&#39;s a new collection type in .NET 4 - something like vector or bitvector or something. If it is serializable it might work. </p>
<p>I had envisioned an array of byte, wrapped in a data structure with methods that made it easy to index into bits in the array - so basically creating&nbsp;a bit[] data type of a sort.</p>
<p>I don&#39;t want the code in the individual rules to be complex - so I&#39;d rather create (and thoroughly test) a data structure that exposes a simple and intuitive API for rule authors.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, August 10, 2011</h2><p>We use a bit array.</p>
<p>110 permissions is trivial in terms of size.</p>
<p>10,000 permissions maybe getting a little big for my taste for a principal/identity pair.</p>
<p>But most applications - it&#39;s hard for me to see a bit array creating an object too heavy to be passed around.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>nhwilly replied on Thursday, August 11, 2011</h2><p>Looks like a BitVector32 collection and I believe it serializes just fine.</p>
<p><a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.bitvector32(v=VS.100).aspx">http://msdn.microsoft.com/en-us/library/system.collections.specialized.bitvector32(v=VS.100).aspx</a></p>
<p>Thanks, guys.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>nhwilly replied on Thursday, August 11, 2011</h2><p>Also, it seems like the use of the BitVector32 collection is best when there are 32 boolean values only.&nbsp; So the identity would have a collection of BitVector32 collections.</p>
<p>I&#39;ll bet the entire collection of my permissions (in my wildest imagination) could fit in about 400 bytes.&nbsp; That doesn&#39;t seem like too much...</p>
<p>So long as I&#39;m not passing it in for every item in an enormous collection of items, it shouldn&#39;t be too bad.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
