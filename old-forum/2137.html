<html><header><title>Design Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Design Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2137.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>cultofluna posted on Saturday, January 13, 2007</h2>Hello,<br><br>I have a design question regarding the correct way to handle a two layer editable object structure. I have an app that uses two bo's: customer and customerContact. One customer can have multiple customerContacts. <br>During the use of the application the user most of the time makes selections of customerContacts so a readonly list does the trick there. <br>The problem lies with editing the customerContact's. In the book Rocky mentions that an invoiceline is nothing without an invoice. In a way that's also the case with customerContact's, they are nothing without a customer. This means however, for maintenance on customerContact's I always have to load an editable customer BO and an editable collection with customerContact BO's, even when only a small modification has to be made to a customerContact.<br><br>My questions:<br><br>Is it wrong to simply make the customerContact an editable rootobject? <br><br>Is it handy to use ReadOnly BO's as criteria parameters, like for a new customerContact a customer ReadOnly BO is used as criteria and for editing a customerContact ReadOnly BO?<br><br>Or even making new customerContact's only available using a NewContact method from the customer ReadOnly BO and editing customerContact's only using an Edit method from the customerContact ReadOnly BO?<br><br>Any thoughts?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Saturday, January 13, 2007</h2><P>So, if I am understanding you correctly, you have a one-to-many relationship between a customer and a contact (so that a customer can have many contacts but a contact can only belong to one customer)?</P>
<P>Not sure what you meant by having "to load an editable customer BO and an editable collection with customerContact BO's, event when only a small modification has to be made to a customerContact", but let me describe how I've addressed this.&nbsp; I am interested in other's comments as well as this was an under-explained scenario in the book, IMO.</P>
<P>I would have a Customer object with a read-only child collection, CustomerContactList, containing read-only CustomerContactInfo child objects.&nbsp; In the form used to edit the Customer object, you would display the list of CustomerContactInfo objects in a list or grid view.&nbsp; To edit a contact's information, you would open another form that is bound to the editable root CustomerContact object.</P>
<P>The trick is in how the CustomerContact object is instantiated.&nbsp; If you are editing an existing item, then it is simply a matter of telling the second form the unique identifier for the item to edit - everything else, including the relationship with the Customer is already established.&nbsp; For a new item, you have a&nbsp;few options.</P>
<P>First, expose a CreateContact() method from your Customer class.&nbsp; This will allow you to instantiate the object and pre-set the Customer object as the parent.&nbsp; The new object would then be passed to and bound to the second form.</P>
<P>Another option is to pass the unique identifier of the parent Customer to the second form which then instantiates the new object passing the identifier to the constructor, i.e. Contact newContact = Contact.NewContact(customerID).</P>
<P>A third option, which works when you have many-to-many relationships, is to have a Contact&nbsp;editable root object that can be instantiated and edited on it's own then add the new object to the Customer's ContactList which will establish the relationship.&nbsp; Again, this is more suited for many-to-many scenerios which it doesn't sound like you are doing.</P>
<P>As I said, I am interested in other's feedback on this as well because I certainly don't know that my approach(es) are the only or best options out there.</P>
<P>HTH</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, January 13, 2007</h2><P>Why wouldn't you have read-only CustomerContactList and CustomerContactInfo objects and then have an editable root CustomerContactEdit object? It sounds like that combination would accomplish your goal. The user can see and select from that read-only list, and an edit dialog (or whatever) can pop up to allow the user to edit a specific contact.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cultofluna replied on Tuesday, January 16, 2007</h2>Hello,<br><br>The most important rule is that a Customer has to have at least one Contact. The problem is that I have two goals for the BO's:<br><br>1. Background processing where my online information is imported to my local system. The import is not allowed to succeed when one of the BO's are invalid.<br><br>2. Application, where the users create a new Customer and add Contacts. There is only one moment where information is saved to the database.<br><br>For this a solution is needed where both the Customer and Contact are BusinessBases?! What I meant with"to load an editable customer BO and an editable collection with
customerContact BO's, event when only a small modification has to be
made to a customerContact" is that when I only want to change for example the firstname of a Contact I would need to load the Customer AND the Contact. However with Rocky's solution this would be a less expensive operation, but than again if I want to support both goals the Contact BO must be switchable, which in my opinion isn't a pretty solution.<br><br>There are to many options here :)<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 16, 2007</h2><P>The key to success is to design your objects for each use case independantly. You are describing at least three use cases (background-import, user-creates-customer and user-adds-contact), at least as I understand what you are saying.</P>
<P>You should only try to reuse objects across use cases if their responsibilities match exactly - <EM>after you've designed them for each use case</EM>.</P>
<P>In other words, design your set of objects for background-import. That means defining their responsiblity, listing their behaviors and collaborators. Do the same for user-creates-customer and user-adds-contact - each one as a totally separate set of objects from the others.</P>
<P><EM>Then</EM> you can look across all three (or n) use cases to see if you have objects with the same responsiblity/behavior description in different use cases. If so, you can choose to reuse that object. If not, then you can't.</P>
<P>Regardless, you should always look for <EM>behaviors</EM> that appear in multiple objects, within or across use cases. These duplicate behaviors should be normalized into a centralized class, and the objects where they originally appeared should then collaborate with this new object/class to gain access to those behaviors. This, in my view, is the <EM>primary</EM> way you get reuse out of OOD. Not at the object level, but at the behavior level.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
