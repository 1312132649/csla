<html><header><title>Invalidating a custom enumerator</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Invalidating a custom enumerator</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1108.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Saturday, September 02, 2006</h2><P>I have the need to implement my own enumerator for a custom collection class and immediately went to the SortedBindingList for a reference source and was pleased to find that Rocky's implementation was as simple as my approach was - especially considering the half-dozen sources I found online seemed to be building a suspension bridge where a 2x4 would do the trick!</P>
<P>Anyway, I did notice that there is no code addressing invalidation of the enumerator should the source collection be changed after the enumerator was created (e.g. an item added or removed).&nbsp; I know this is a standard feature of an enumerator but am not quite sure how to implement.</P>
<P>Any good suggestions where I can find examples that cover this aspect of a custom enumerator?</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Sunday, September 03, 2006</h2>I do not know if it is a <i>good </i>example, but you can look at the ObjectListView for an example.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Sunday, September 03, 2006</h2><P>Thanks, Brian.&nbsp; That does confirm the approach I had considered for collections implementing the ListChanged event (via IBindingList interface), but I am looking for a solution for more 'primitive' collections - those that implement only IEnumerable&lt;T&gt; or ICollection&lt;T&gt; and have no ListChanged event to handle.</P>
<P>Any ideas how this is done in these cases?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Sunday, September 03, 2006</h2>Well, the Enumerator is invalidated whenever any change is made.&nbsp; So any call to Move...() or Reset() would need to check every item in the collection.&nbsp; I don't know how you would practically check that.&nbsp; Do you have a use case for this?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Sunday, September 03, 2006</h2><P>We are implementing several custom collections as part of our efforts but are not implementing IBindingList as they are much simpler objects that this interface provides/requires.&nbsp; And, I am trying to be as thorough and consistent with the FCL as possible in our own efforts to make it easier for developers to use.</P>
<P>Every 'collection' (everything derived from IEnumerable) provides the ability to retrieve an enumerator for that collection and only System.ComponentModel.BindingList&lt;T&gt; implements IBindingList.&nbsp; BUT...&nbsp; All of them fail should the collection be changed while enumerating.&nbsp; For instance, iterate a System.Collections.Generic.List&lt;T&gt; with a foreach and attempt to remove the item.&nbsp; You'll get the expected exception.</P>
<P>I'd like to understand how this is done without having some kind of event to catch as is done in ObjectListView.&nbsp; Obviously, since SortedBindingList does derive from BindingList&lt;T&gt;, it would be easy to add this logic in the same way it is done in ObjectListView to close that gap in the book and source code, but my concern is how the other myriad of collections manage to do the same thing so that we can have consistent behavior with those objects.</P>
<P>Any ideas?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Sunday, September 03, 2006</h2>Well, enumerators generally have a reference to the list.&nbsp; You could use a Guid in the list and change the Guid whenever the list changed.&nbsp; The enumerator could then check if the Guid changed since the last time you called one of the Move...() methods.&nbsp; You could also use the assembly browser in SharpDevelop (an open source IDE) to look at List&lt;T&gt;'s implementation, as it gives the internal and private members as well.&nbsp; That might give some extra information than the Visual Studio object browser.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Sunday, September 03, 2006</h2><P>How do you accomplish this with SharpDeveloper?&nbsp; I am familiar with it but was not aware this capability was included?!?&nbsp; Does this show more than VS's Object Browser or is it more inline with IL DASM?</P>
<P>I did look at the mscorlib.dll using IL DASM and found a _version variable in both the parent collection and nested enumerator.&nbsp; I am thinking that the collection (List&lt;T&gt; in this case) may increment this value each time a change is made.&nbsp; Then, when an enumerator is created, the nested Enumerator sets its variable to the parent's value and then uses that to validate itself each time Current, MoveNext or Reset is called.</P>
<P>What do you think?&nbsp; Sound reasonable?&nbsp; There really isn't anything else evident in the disassembly to indicate how the objects would be communicating, so I'm thinking this must be it.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Sunday, September 03, 2006</h2>I think it would be closer to IL DASM.&nbsp; The _version variable is probably what you are looking for.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
