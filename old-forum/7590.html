<html><header><title>ASync Dataportal issue</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ASync Dataportal issue</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7590.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong posted on Wednesday, September 09, 2009</h2><P>I need some help on this, i've a WPF application and while saving the application shouldn't be able to close so i though the ManualResetEvent would block the main thread in this case until the save operation is done. Ok, not very nice because this will lock the UI, but effective since it must block the close operation.</P>
<P>_model as an csla business object.<BR><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ManualResetEvent</FONT></FONT><FONT size=2> waitHandle = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ManualResetEvent</FONT></FONT><FONT size=2>(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>false</FONT></FONT><FONT size=2>);<BR><BR></FONT><FONT size=2>_model.BeginSave((s1, e1) =&gt;<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e1.Error != null)&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT size=2>throw e1.error;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT size=2><FONT size=2>waitHandle.Set();</FONT><BR>});<BR><BR><FONT size=2>waitHandle.WaitOne();</FONT></FONT></P>
<P><FONT size=2><FONT size=2><FONT size=3>The problem is that the backgroundworker within the DataPortal does his DoWork method but never does his RunWorkerCompleted.<BR><BR>I know a solution for this problem, but that isn't realisable.<BR><BR>Setting the waitHandle in the backgroundworker at the end of DoWork.<BR><BR><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> Update_DoWork(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>object</FONT></FONT><FONT size=2> sender, System.ComponentModel.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DoWorkEventArgs</FONT></FONT><FONT size=2> e)<BR>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;var</FONT></FONT><FONT size=2> request = e.Argument </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>as</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortalAsyncRequest</FONT></FONT><FONT size=2>;<BR>&nbsp;&nbsp;&nbsp;SetThreadContext(request);<BR>&nbsp;&nbsp;&nbsp;T result = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>default</FONT></FONT><FONT size=2>(T);<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;try<BR></FONT></FONT><FONT size=2>&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>object</FONT></FONT><FONT size=2> state = request.Argument;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = (T)Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortal</FONT></FONT><FONT size=2>.Update&lt;T&gt;((T)state);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Result = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortalAsyncResult</FONT></FONT><FONT size=2>(result, Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ApplicationContext</FONT></FONT><FONT size=2>.GlobalContext, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>,&nbsp;&nbsp;&nbsp;&nbsp;request.UserState);<BR><BR><STRONG>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitHandle.Set();</STRONG><BR>&nbsp;&nbsp;&nbsp;}<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;catch</FONT></FONT><FONT size=2> (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Exception</FONT></FONT><FONT size=2> ex)<BR>&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.Result = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortalAsyncResult</FONT></FONT><FONT size=2>(result, Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ApplicationContext</FONT></FONT><FONT size=2>.GlobalContext, ex, request.UserState);<BR>&nbsp;&nbsp;&nbsp;}<BR></FONT><FONT size=2>}</P></FONT></FONT></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, September 09, 2009</h2><P>The problem is that RunWorkerCompleted delegates back to the UI thread - which you have blocked.</P>
<P>You really can't block the UI thread like that, as doing so is outside the design parameters for the async data portal.</P>
<P>I haven't looked in WPF, but in Windows Forms there's an event you can handle when the primary form is closing, and you can cancel the close operation. I suspect there's a similar concept in WPF as well.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Wednesday, September 09, 2009</h2>it's more difficult, but not impossible thru.<br />anyway canceling is something i tried, there are 2 ways of closing an application or actually 3.<br /><br />1) When the user request the application to close, something like mainwindow.closing<br /><br />2) When the user log's off windows<br />application session_ending with the reason<br /><br />3) When the user shuts down windows<br />application session_ending with the reason<br /><br />All 3 can be cancelled, but that isn't the problem. The real problem is that the application should wait until the save operation is completed. BeginSave() as Event-Based Async method and whenever it comes back then continue.<br /><br />The only real solution i currenly see is passing the handle along so that the background worker can signal it at the end of the DoWork method.<br /><br />Another solution is having a while busy do eat processor loop<br /><br />I tryed to cancel the close operation and setting a private boolean to closing and in the callback method i closed the application again, but then it just throws an exception that it's already closing.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, September 09, 2009</h2>If you cancel the user logoff or shutdown, wouldn't that make users upset?<br /><br />Which brings me to another question... if you have an async BeginSave, can you cancel the async operation.. and will that rollback changes?<br /><br />Oh, I wouldn't do that while busy eat processor... that will cause problems for users on laptops as your program wastes cycles (and thus battery power, not to mention cpu time).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Thursday, September 10, 2009</h2>Canceling is correct when showing a dialog that there is a ongoing mutation and u want to ask the user what to do, if he is sure to close without saving. In my situation there is a problem when there are more then one controllers open and they are one by one closing with user interaction.<br /><br />It's kinda frustrating that something so simple isn't as simple as it should be, i could modify csla code but that isn't what i want.<br /><br />I'm almost going to introduce something like a (while busy do) Dispatcher.KeepMyMainThreadAlive(); or something.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, September 11, 2009</h2>Even if you manage to get the dialog to display, I think at some point Windows will say "this program is preventing your logoff, wait or end it" so the user can still force it to exit.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Friday, September 11, 2009</h2>Well forget the windows logoff and windows shut down, just when the user closes the application manually and choose to save his changes. That save will be async and some code  will run on the server, at this point the client running the wpf application shouldn't close yet because something could go wrong saving.<br /><br />Any suggestion on how to join the threads?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, September 11, 2009</h2>What you need is a thread sync mechanism that doesn't block the UI thread.<br />That's the core issue here - blocking the UI thread is never a good idea.<br /><br />You can implement a basic polling scheme that uses a busy loop with a sleep<br />timer so you don't consume all the processor.<br /><br />using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br />using System.Threading;<br /><br />namespace ConsoleApplication1<br />{<br />  class Program<br />  {<br />    static void Main(string[] args)<br />    {<br />      var busy = new BusyWait();<br /><br />      var bw = new System.ComponentModel.BackgroundWorker();<br />      bw.RunWorkerCompleted += (o, e) =><br />        {<br />          busy.End();<br />        };<br />      bw.DoWork += (o, e) =><br />        {<br />          // sleep for 5 seconds<br />          Thread.Sleep(5000);<br />        };<br /><br />      Console.WriteLine("starting");<br />      busy.Start();<br />      bw.RunWorkerAsync();<br /><br />      Console.WriteLine("waiting");<br />      busy.Wait();<br />      Console.WriteLine("done");<br />      Console.ReadLine();<br />    }<br /><br />  }<br /><br />  public class BusyWait<br />  {<br />    private long _count;<br /><br />    public void Start()<br />    {<br />      Interlocked.Increment(ref _count);<br />    }<br /><br />    public void End()<br />    {<br />      Interlocked.Decrement(ref _count);<br />    }<br /><br />    public void Wait()<br />    {<br />      while (Interlocked.Read(ref _count) > 0)<br />        Thread.Sleep(5);<br />    }<br />  }<br />}</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Saturday, September 12, 2009</h2>I'm going to it with a Sleep(500) around the factory method, when it returns in the event-based async lambda part i end the wait. Maybe even a "busy" popup with a busy animation on it.<br /><br />I was hoping there was a standard solution, since it can't be that i'm the first with this problem.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
