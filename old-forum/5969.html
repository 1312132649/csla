<html><header><title>Multiple modules with each there own businessobjects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Multiple modules with each there own businessobjects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5969.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong posted on Wednesday, December 10, 2008</h2><P>We are going to have (like the subject already says) multiple modules with each there own businessobjects. But what if they are going to be reused? Ofcourse this is just something to show my problem, in the real world there are many many more of those relations.</P>
<P>Module:&nbsp;RelationshipManagement<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Businessobject Customer and CustomerInfo<BR><BR>Module: ProductManagement<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Businessobjects Product and ProductInfo</P>
<P>The Customer object has a managed property with ProductInfoList<BR>The Product object wants a property with CustomerInfo.</P>
<P>And an circulair reference is ofcourse not allowed :)</P>
<P>For so far i see 2 solutions, of which one isn't going to keep consistency.</P>
<P>1) Create an interface module foreach module and reference interfaces instead of businessobjects<BR>Will this work with CSLA?</P>
<P>2) Don't reuse businessobjects, but just copy-paste them.<BR>No consistency.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 10, 2008</h2>You can do the interface route, I've done it and it works.&nbsp; You can also build a service layer, if you need to update data.&nbsp; This layer would use the other's as a client to do it's work.&nbsp; This works as well, although it's kind of like calling a web service.&nbsp; You lose the interactivity you would otherwise have.<br><br>Before you do either though, I'd evaluate whether or not you'd really also use one library without the other.&nbsp; If you are, then it makes sense, but if not, you might as well have one larger library.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Wednesday, December 10, 2008</h2><P>We already did evaluation about it. It's not that one library might not work without the other. But it's more productivity of multiple people c.q. teams together while developing and maintainance later on. What we don't want is a very large assemblies with everything in it. We already have an common.dll with all generated dataentities in it, which is already very large. Our application has in total 1200 tabels.</P>
<P>Btw, common.dll with dataentities acting as businessentities :) which is why im are investigating if CSLA will be usefull.</P>
<P>I still have doubts since our business can be very very complex. As making software for almost every assurance company in our country, they need to prolongate monthly. Keeping track of history on assurances versions etc. oh my god i don't even want to think about rebuilding that part :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, December 10, 2008</h2><P>I manage several large team projects and understand where you are coming from.&nbsp; However, I have a different perspective on breaking apart assemblies.&nbsp; I agree that it is way too cumbersome to put everything into a single assembly but I prefer the smallest number possible to accomplish the requirements.</P>
<P>The first questions&nbsp;I ask are whether the functionality need to be reused/shared and, if so,&nbsp;at what level?&nbsp; In your case, at least some of the business objects need to be shared by different modules.&nbsp; So, it may be prudent to put&nbsp;the business objects that are common to multiple modules into a single assembly that can be shared across modules.&nbsp; Then, the individual modules can be in separate assemblies (projects) that reference the common library (much like you do with CSLA).</P>
<P>It is possible that some of your 1200 tables (with CSLA, the number of entities would be different because it is behavior-based not data-based) are relevant only to specific modules and these should not be in the shared assembly.&nbsp; Only code that actually needs to be shared can go here.&nbsp; And there can be multiple layers.</P>
<P>Next, I ask if there is a logic separation.&nbsp; For instance, anything UI related goes into a different assembly then my business objects and likewise with data access and so on.</P>
<P>A lot of this can be determined by your overall architecture.&nbsp; For instance, I work with several product families and many of the individual products support multiple UI technologies (web, windows, mobile, ...).&nbsp; We have many objects that are shared across product families, this forms the lowest layer in our model, then more that are shared only within the product families, the next layer, followed by the types specific to a product, the middle layer, then our presentation components and, finally, the application (UI) layer itself.&nbsp; For example, we have:</P>
<UL>
<LI>Acme.Core - assembly containing all types common to all products across all families.</LI>
<LI>Acme.Web - assembly containing all components supporting a web interface that are common to all products across all families.</LI>
<LI>Acme.MySuite.Shared - assembly containing all types common to all products within the MySuite family.</LI>
<LI>Acme.MySuite.Web - assembly containing all components supporting a web interface common to all products within the MySuite family.</LI>
<LI>Acme.MySuite.MyApp.Library - assembly containing all types common to the MyApp product.</LI>
<LI>Acme.MySuite.MyApp.UI - assembly containing all presentation components for the MyApp products (technology-agnostic).&nbsp; Btw, we use the MVP pattern for our applications.</LI>
<LI>Acme.MySuite.MyApp.Web - web application</LI>
<LI>Acme.MySuite.MyApp.Windows - windows forms application</LI>
<LI>Acme.AnotherSuite.Shared</LI>
<LI>and so on...</LI></UL>
<P>We have a platform team responsible for the company-wide assemblies and an architecture team within each product family responsible for the assemblies shared across that family's products.&nbsp; Then, we have product teams that work on the individual products with some developers focused on business logic, some on UI, others on the back-end DB and so on.</P>
<P>The final consideration for modularity is extensibility.&nbsp; Is there a reason why you would need different Relationship Management functionality in one deployment then in another?&nbsp; If not, then why split them apart?&nbsp; This may actually make the code more tedious to work with.&nbsp; On the other hand, if you have two different Relationship Management modules that can be swapped to provide two different "versions" of the application, then they should absolutely be in separate assemblies.&nbsp; Following the example above, we would have:</P>
<UL>
<LI>Acme.MySuite.MyApp.Module1</LI>
<LI>Acme.MySuite.MyApp.Module2</LI></UL>
<P>and our UI applications would make use of these modules. For extensibility, the dependant code would use interfaces so that the implementation types could be swapped out.&nbsp; The interfaces would be defined in Acme.MySuite.MyApp.Library which is used by both modules.</P>
<P>&nbsp;</P>
<P>Note, I don't use deployment, maintenance of upgrades as a basis for modularity.&nbsp; It makes no difference to me if I have to deploy one large or several smaller assemblies, I still have to deploy.</P>
<P>With a good source control, having many users working on the same code base is not much of an issue.&nbsp; Like I said, I have a large team working at all levels on our products without issue.</P>
<P>If you want another perspective, take a look at how many (actually, how few) dll's there are for the Microsoft Office products and consider how many developers over a vast geographic area they have working on those products.</P>
<P>Hope that helps.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Thursday, December 11, 2008</h2><P>Thats a long reply ;)</P>
<P>Anyway we are a business to business company and one of our main products is nearly everywhere the same except differend based on licences. Only big clients pay extra money to see custom work into the product. A differend module. We'll just have 15 differend modules with differend functionality of which 2 or 3 might be differend at a later time. Lets say Customermanagement.dll and CustomermanagementLight.dll for example.</P>
<P>We are running on a Team Foundation Server, but not with much experience yet. Im in the farm admin group and there isn't any project really being developed in it yet. Just all new hehe.</P>
<P>I was thinking about splitting up the modules based on licences with functionality blocks. It might yust be that one assembly an businessobject CustomerInfo be in a shared library. Enumerations, constants, etc&nbsp;as well then. Until now i was thinking about interface libraries in which the interface Info businessobjects would be exposed to other libraries.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
