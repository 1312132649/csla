<html><header><title>Csla.ApplicationContext and threads</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Csla.ApplicationContext and threads</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/116.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Tuesday, May 16, 2006</h2>Hi all,<br><br>It seems that ApplicationContext is only visible within the thread that created it.&nbsp; <br>Any ideas on how to share context data across threads?<br><br>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Wednesday, May 24, 2006</h2><P>I just ran across the need for this as well.&nbsp; I've stored some configuration data in GlobalContext via the main application thread, but I'm also running a data access query on a background thread - which needs access to the configuration data as well.&nbsp; </P>
<P>One solution that I think will work - modify ApplicationContext to use the AppDomain GetData / SetData methods (just on the client-side obviously).&nbsp; Remote data portal will still need to use thread-local storage.</P>
<P>I'm working on a prototype now to see if it will work.&nbsp; However, it'd be very nice if this (or something similar) were incorporated into the common CSLA code base (hint, hint).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, May 24, 2006</h2>Mark,<br><br>Let me know how this works for you.&nbsp; I was able to work around it (by taking the data i need and pushing it into an object to use as a 'parameter' for the thread.<br><br>I'd much rather have support for this built into the framework though.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Wednesday, May 24, 2006</h2><P>Didn't take long at all to get working.&nbsp; I'm attaching a modified copy of ApplicationContext (C# version) that uses AppDomain storage on the client and thread-local storage on the "server".&nbsp; Just had to modify a couple of lines of code.&nbsp; In my *very limited* testing, everything is working as expected.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Wednesday, May 24, 2006</h2><P>Forgot to mention this - my quick workup is not thread-safe.&nbsp; You'd need to code that in as well.&nbsp; I didn't bother, since I mainly wanted to see if it worked first.&nbsp; :-)</P>
<P>Here's hoping Rocky can incorporate a multi-threaded ApplicationContext object in CSLA.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, May 25, 2006</h2>Great,<br><br>I'll see how this works for me.<br><br>Maybe this could sneak into the 2.0.1 release?&nbsp; <br><br>I've found that using threads is pretty much a must for WinForms application; well if yo don't want the application to stop responding when its fetching large amounts of data.&nbsp; Using threads judiciously has made my application much more responsive and friendly to the users, and they appreciate that.&nbsp; It doesn't look good when only half the window has repainted before your CPU spends its time fetching data.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, May 25, 2006</h2><P>This is a good thought. I don't know about making the whole object threadsafe though. Making it threadsafe would have a negative performance impact, even if you aren't using threads. Most people don't, and so they'd pay this cost for nothing.</P>
<P>I'd rather opt for the solution Microsoft uses pretty globally, which is to <EM>not</EM> be threadsafe, but rather provide a syncroot object you can use to implement your own locking.</P>
<P>Though that may not be realistic either, given that you might be making data portal calls on multiple threads. Of course (as I think about this), that is highly problematic, because the data portal just replaces the client data with the server data - so if you actually use/alter global context data on the server you'd lose some of that data in the case that multiple data portal calls occur at once.</P>
<P>Given that issue, it is clear that this requires quite a lot of thought - because the data portal might have to try and do some intelligent merge of data in globalcontext - and sitting here right now it isn't clear to me how such a thing would work - because that data is free-form, and so there's no guaranteed way for the data portal to match items to other items when doing a merge...</P>
<P>So it might be the case that globalcontext must be per-thread, while the User and ClientContext values can actually be client-wide.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Thursday, May 25, 2006</h2><P>I see the dilemna with the GlobalContext object - if you were running locally, there wouldn't be an issue, but if you were using remoting, there is the chance for data to be overwritten.&nbsp; </P>
<P>I don't see any difficulty with the ClientContext object, though, since it's not restored after a DataPortal call.&nbsp; Store ClientContext in the&nbsp;app domain&nbsp;and all we need is a thread-safe way of getting/setting ClientContext and we should be good (I think).&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, May 25, 2006</h2>I think this approach would help me.<br>
<br>
The data I'm sending back now through ApplicationContext could be
returned by the Command object I have (now that I understand them
better), and I could store the results in the ClientContext (since I don't really need to have the DataPortal code update this data once its set).<br><br>Andy<br>
<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, May 25, 2006</h2><P>Right, I agree. I think that storing the ClientContext in the AppDomain should be fine, and leaving GlobalContext on the thread should avoid the merge issue. </P>
<P>The ClientContext is already a collection, and so has a SyncRoot property you can use for threadsafe access to its contents. I don't think I need to do anything there.</P>
<P>The ClientContext property itself is a different matter, and it needs to become threadsafe - meaning ClientContext, GetClientContext() and SetClientContext() all need to include locking code. I have put this into the code in <A href="http://www.lhotka.net/cslacvs">cvs</A>, and it passes the (updated) nunit tests. Whether I created any possible race conditions remains to be seen, but I don't think I did cause any such problems.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, May 25, 2006</h2>Wow, <br><br>This is great.&nbsp; Thanks for adding it in so quickly!<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, May 26, 2006</h2>Just wanted to update;<br><br>I'm not using the 2.0.1 beta, and I put the data i need (a userid) in the ClientContext.<br><br>It works great, I no longer have to use my bad hack to keep things working across threads.<br><br>Thanks!<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
