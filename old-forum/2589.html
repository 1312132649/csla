<html><header><title>Model help - Switchables / Parent-Child &amp; Inheritance</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Model help - Switchables / Parent-Child &amp; Inheritance</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2589.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>juddaman posted on Monday, March 26, 2007</h2>Heya<br><br>I'm having difficulties with a particular section of my model. The problem resolves around these classes:<br><br>Question<br>ResponseMechansim (abstract)<br>ChoiceResponseMechansim (inherits ResponseMechansim)<br>ScaleResponseMechansim (inherits ResponseMechansim)<br><br>Basically Question (currently, early stages) consists of the text of the question (string) and response means as ResponseMechansim. I was going to create the Question like this:<br><br>Question q&nbsp; = Question.NewQuestion();<br>q.ResponseMechansim = ChoiceResponseMechanism.NewChoiceResponseMechanism();<br><br>However this would mean making ResponseMechanism and its derivatives switchable objects as they would need to be a root so they can be created then appended as a child an object of type Question.<br><br>I came up with the idea of allowing questions to create the new type of response using an enum, something along these lines:<br><br>public void SetResponseMechanismType(ResponseMechanismType type)<br>{<br>&nbsp; switch (type)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; case ResponseMechanismType.Choice:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _ResponseMechanism - ChoiceResponseMechanism.NewChoiceResponseMechanism();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp; case ResponseMechanismType.Scale:<br>&nbsp;&nbsp; }<br>}<br><br>Though this seams a bit messy and unnecessary. I think I'm missing something somewhere. Any thoughts and suggestions welcomed.<br><br>Thanks guys<br><br>George<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 26, 2007</h2><P>Nothing stops you from making the create factory public on a child object. Really, being a child object only blocks the Save() from working - technically you can have public create and fetch methods on a child with no problem (though I think having a public fetch could have other bad side-effects on design).</P>
<P>There are good reasons why you might want to use the create-and-add model for child objects, rather than the created-by-collection model I show in the book, and there's no real issue in doing that - nor do you need to go to all the complexity of making your object a switchable object.</P>
<P>In your child class, just implement a public factory for creation. Then implement DataPortal_Create() to initialize/load defaults. Call MarkAsChild() in the ctor as normal. This allows the UI (or any other code) to create these objects at will.</P>
<P>Then you can just use the pre-existing Add() method on the collection to add this new item. BusinessListBase will automatically set the edit level and parent reference on the new object.</P>
<P>Then the insert operation will be automatically handled when you save the collection, because the object is just like any other new child at that point.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>juddaman replied on Monday, March 26, 2007</h2>Thanks Rocky!!! Very much appreciated. I kind of got it in my head that making the factory public was  a big no no. :-)

George</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
