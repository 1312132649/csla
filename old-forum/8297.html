<html><header><title>What is the right way to (de)serializer complex types with MobileFormatter?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>What is the right way to (de)serializer complex types with MobileFormatter?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8297.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell posted on Thursday, January 07, 2010</h2>Dear ladies and sirs.<br><br>I have a question on the correct use of the MobileFormatter when the (de)serialized types are complex.<br>I want to demonstrate it by an example.<br><b>[Serializable]<br>public class O : IMobileObject<br>{<br>&nbsp; private static string GetShortAssemblyQualifiedTypeName(Type type)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return string.Format(CultureInfo.InvariantCulture, "{0}, {1}",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type.FullName, new AssemblyName(type.Assembly.FullName).Name);<br>&nbsp; }<br>&nbsp; public O() { }<br>&nbsp; public IList&lt;Type&gt; Types { get; set; }<br>&nbsp; public void GetState(SerializationInfo info) { }<br>&nbsp; public void SetState(SerializationInfo info) { }<br>&nbsp; public void GetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Func&lt;Type, string&gt; mapper = GetShortAssemblyQualifiedTypeName;<br>&nbsp;&nbsp;&nbsp; var names = new MobileList&lt;string&gt;(Types.Select(mapper));<br>&nbsp;&nbsp;&nbsp; info.AddChild("Types", formatter.SerializeObject(names).ReferenceId);<br>&nbsp; }<br>&nbsp; public void SetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; var names = (IList&lt;string&gt;)formatter.GetObject(info.Children["Types"].ReferenceId);<br>&nbsp;&nbsp;&nbsp; Types = ((IList&lt;string&gt;)names).Select(name =&gt; Type.GetType(name, true)).ToList();<br>&nbsp; }<br>}<br></b><br>It contains a list of Type objects. Since it is not recommended to serialize Type objects, I first convert them to a list of Type names.<br>Of course, this implementation does not work, because <b>O.SetChildren </b>is called<b> </b>before the Types list is deserialized. This comes as a surprise to someone used to ordinary .NET serialization. It appears that one must override the ISerializationNotification interface in order to get it work right, so here is my final working version (changes are in red):<br><b>[Serializable]<br>public class O : IMobileObject, ISerializationNotification<br>{<br>&nbsp; private static string GetShortAssemblyQualifiedTypeName(Type type)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; return string.Format(CultureInfo.InvariantCulture, "{0}, {1}",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type.FullName, new AssemblyName(type.Assembly.FullName).Name);<br>&nbsp; }<br>&nbsp; public O() { }<br><font color="#ff0000">&nbsp; private object m_types;<br>&nbsp; public IList&lt;Type&gt; Types<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; get { return (IList&lt;Type&gt;)m_types; }<br>&nbsp;&nbsp;&nbsp; set { m_types = value; }<br>&nbsp; }<br></font>&nbsp; public void GetState(SerializationInfo info) { }<br>&nbsp; public void SetState(SerializationInfo info) { }<br>&nbsp; public void GetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Func&lt;Type, string&gt; mapper = GetShortAssemblyQualifiedTypeName;<br>&nbsp;&nbsp;&nbsp; var names = new MobileList&lt;string&gt;(Types.Select(mapper));<br>&nbsp;&nbsp;&nbsp; info.AddChild("Types", formatter.SerializeObject(names).ReferenceId);<br>&nbsp; }<br><font color="#ff0000">&nbsp; public void SetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; m_types = (IList&lt;string&gt;)formatter.GetObject(info.Children["Types"].ReferenceId);<br>&nbsp; }<br>&nbsp; public void Deserialized()<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Types = ((IList&lt;string&gt;)m_types).Select(name =&gt; Type.GetType(name, true)).ToList();<br>&nbsp; }<br></font>}<br><br></b>It has an ugly hack of reusing the same field for holding IList&lt;Type&gt; and IList&lt;string&gt;, the latter is held between the call to O.SetChildren and O.Deserialized.<br><br>My question is this how it is supposed to be? Or there is another, the right way?<br>Thanks.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Wednesday, January 13, 2010</h2>Bump bump bump ....<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, January 13, 2010</h2><P>The MobileFormatter is not necessarily a general-purpose serializer. It is designed specifically to enable the CSLA object scenarios.</P>
<P>You may be able to get it to work outside those scenarios, and if so, good for you!&nbsp;:)</P>
<P>MobileFormatter understands how to serialize primitive types, some special types (like Guid, Decimal, etc) that we consider "primitive" and types that implement IMobileObject. That's it. If you have a type that doesn't fit into one of those categories, then you are outside the design parameters of MobileFormatter.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
