<html><header><title>A common object, architecture ramblings required!</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>A common object, architecture ramblings required!</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5298.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pfeds posted on Tuesday, August 26, 2008</h2><P>I've created a library for an online store and I'm having a bit of a design issue with a couple of objects that are widely used within the library, namely Product, but also others such as Customer.</P>
<P>For Product I have "Product", "ProductList", and "ProductInfo".&nbsp; This works fine.</P>
<P>A number of other objects also require product information. For example&nbsp;BasketLine and OrderLine&nbsp;need to know the product name, image, whether it's in stock, etc.&nbsp;&nbsp;Other objects for product reviews, product bundles,&nbsp;etc also need to load product information.&nbsp; </P>
<P>Until now I have always used joins in the sql statements to link to product information in read only lists.&nbsp; For editable objects I&nbsp;have added a non-serialized property to load the Project object and access the properties, such as:</P>
<P><FONT color=#0000ff>[NonSerialized]</FONT></P>
<P><FONT color=#0000ff>Product product;</FONT></P>
<P><FONT color=#0000ff>public ProductName</FONT></P>
<P><FONT color=#0000ff>{</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;get</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;{</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.product == null)</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.product = Product.GetProduct(this.productId);</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</FONT></P>
<P><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.product.Name;</FONT></P>
<P><FONT color=#0000ff>}</FONT></P>
<P>To me this seems really inefficient as loading the product object additionally loads a number of child collections.</P>
<P>What I think I want to do is create a parent readonlybase ProductSummary class that reads in the property information as well as loading a child read-only collection of product variants (such as different sizes/colours etc).</P>
<P>Then, with the other objects I can create a similar nonserialized member and lazy load it with ProductSummary.GetProductSummary(productId);</P>
<P>I'm not completely confident that this is the best way to go about it, so I'm wondering if anyone else has come across this and has any good ideas.&nbsp; It's vital that the library is efficient and doesn't carry out unnecessary processing.</P>
<P>Thanks.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, August 26, 2008</h2><P>You can still use your joins -- this might be a good idea if you will *always* need the ProductName. I have similar situations in an implementation I am doing.&nbsp;&nbsp;When the main object is fetched, the linked properties are fetched via a left join (inner would be fine also), but these are of course read-only and cannot be updated. </P>
<P>We also support lazy-loading of both objects and individual properties if the property is frequently used. In your post above, for example, why fetch the entire product when you just need the name. (e.g. SELECT PRODUCTNAME FROM PRODUCTS WHERE PRODUCTID=...)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pfeds replied on Tuesday, August 26, 2008</h2><P>The problem I encountered that caused me to think about this was to do with stock control.&nbsp; This can be configured in a variety of ways - on/off, in/out of stock flag, product or product variant level, or driven by a live stock count.&nbsp; I want to display in stock/out of stock information intelligently, such as in the basket view and order view.&nbsp;I also would like to use it to show/hide&nbsp;special offer&nbsp;bundles&nbsp;depending on&nbsp;an item&nbsp;being in&nbsp;stock. I don't want to copy this code, although I could put it on Product as a static method such as <FONT face="Courier New" size=2>public static StockStatus GetStockStatus(IProduct product);</FONT></P>
<P>As well as this comes the issue of a product possibly having a number of variants.&nbsp; If this wasn't the case then a simple left join would do the trick, but now I would like to display a list of variants in certain places such as the basket (to make it easier for the user to change) and when selecting product variants within an offer bundle etc.&nbsp; What I don't want to do is expand all these objects (basket, bundles, etc) to read in child collections of product variants and such.</P>
<P>With the current objects I have&nbsp;this would mean loading&nbsp;each Product (say on&nbsp;the basket view) which in turn would load a fair wack&nbsp;of unnecessary information and slow the site down, especially if there are a lot of items in the basket.&nbsp; Additionally, when proceeding to submit the order I map the basket lines to order lines which will load all the products and copy&nbsp;information (in case of price changes etc) -&nbsp;this seems to be a fairly slow process (well, slow in my opinion!).</P>
<P>This is what led me to the idea of a read-only "summary" object that would only read in the basic product info and variants.&nbsp; Then I can expose this as a lazy property in all the required classes so that they can retrieve the product information if desired.&nbsp; I think it would probably work well as (a) it will reduce the need for sql joins, (b) reduce the amount of properties in each object, and (c) make maintenance a lot easier, and so on.</P>
<P>I think it's the right way, but I'm just wary of any hidden nasties that may crop up with this idea!!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>richardb replied on Tuesday, August 26, 2008</h2><P>Designed a simliar system too.&nbsp; While I had a full blown Product object with some child objects, I also created some Read-Only lightweight&nbsp;objects that would give ProductID, name, description and stockqty available, the latter being calculated in the SQL stored procedure.&nbsp; This helped performance when adding items to an order.</P>
<P>Mind you, when reading back the order items (the order item record would just have the ProductID and Price)&nbsp;the SQL would do a JOIN to get the product description from the products table - getting the sundry information like this would be quicker than having each order item business object loading up it's own product object.</P>
<P>But we also&nbsp;extended&nbsp;this to include a lazy loaded lightweight product property so that if the user did change the productID, we would load the new product and set the order item product code, description, price, etc.</P>
<P>The Stock Qty Available&nbsp;was only used as a snapshot and not relied upon for allocating stock to an order.&nbsp; I did most of the stock allocation work in a Stored Procedure as that seemed to be the best place to do that for my solution.</P>
<P>Also had a RelatedProducts collection so I could automatically add these items to an order as the "main" item was chosen.</P>
<P>Sounds like you are on the right track to me.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
