<html><header><title>Object Model Design Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Object Model Design Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/390.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bnair posted on Thursday, June 15, 2006</h2><P><FONT face=Verdana size=2>Hi All,</FONT></P>
<P><FONT face=Verdana size=2>I am working on CSLA 2.0 and I am running into object model design issues.</FONT></P>
<P><FONT face=Verdana size=2>I am building an address book module..</FONT></P>
<P><FONT face=Verdana size=2>I have the following classes</FONT></P>
<P><FONT face=Verdana size=2>AddressBookContact&nbsp;- Editable Root<BR>AddressBookContactList&nbsp;- Editable Root Collection</FONT></P>
<P><FONT face=Verdana size=2>AddressBookGroup - Editable Root<BR>AddressBookGroupList - Editable Root Collection</FONT></P>
<P><FONT face=Verdana size=2>When I&nbsp;fetch the AddressBookContact object I need all the groups that the contact belongs.Do I need to make AddressBookGroup and AddressBookGroupList as switchable objects</FONT></P>
<P><FONT face=Verdana size=2>ALso ,when I&nbsp;fetch the AddressBookGroup object I need all the contacts that are in the group.In that case I need the ContactList collection..</FONT></P>
<P><FONT face=Verdana size=2>How would I model this efficiently without ending up creating a lot of redundant root and child classes?</FONT></P>
<P><FONT face=Verdana size=2>--bnair<BR></FONT><BR></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, June 15, 2006</h2><P>I'm not pretending to be an object modeling guru, I'm still learning (and my&nbsp;professional experience has been in the dreaded data-centric world).</P>
<P>An AddressBook is composed of AddressBookContactList and AddressBookGroupList.</P>
<P>An AddressBookGroup is composed of AddressBookContactList and AddressBookGroupList.</P>
<P>Not sure whether it would be a good idea to create an AddressBookMember and sub-class it to AddressBookContact and AddressBookGroup.&nbsp;&nbsp; Just don't have the experience in building object-based systems to know yet...</P>
<P>Hope that gives you some ideas to&nbsp;chew over!&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Ronnie replied on Friday, June 16, 2006</h2><P>bnair, this is the problem I bump into a lot&nbsp;when trying to align model with implementation. It is often said that use of switchable is a sign of bad design, and the most common suggestion is to fix it&nbsp;with a readonly collection with simple readonly childs, and when you need to edit you instantiate a new editable version of the "same" domain object, eg:</P>
<P>AddressBookContactList&lt;ReadOnlyListBase&gt;<BR>-- contains AddressBookContactInfo&lt;ReadOnlyBase&gt; objects</P>
<P>AddressBookContact&lt;BusinessBase&gt;(root)</P>
<P>However, as you mention there is often a lot of duplicated effort in this, mostly fields, property-getters and get/fetch-methods. I too am wondering and looking for a better solution, as it just feels wrong having to create different objects for readonly/editable/child/root scenarios. It seems to me there is a lot of cases where you need to have a root object, but still need to have the possibility of having a&nbsp;collection of that type.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, June 16, 2006</h2><P>Not sure if this truly follows the concept of behavior-oriented design, but the approach that we've taken to this VERY common scenario is consistent with what is shown in the sample app in the book.&nbsp; The explanation there is to design a class that represents the relationship between objects as the relationship IS a behavior separate from the objects and, in many cases, is represented with a many-to-many table in a database.&nbsp; Because adding/modifying/removing a record&nbsp;in this N-to-N table is adding/modifying/removing a relationship, this object is able to handle that function.</P>
<P>In your case, what we would do is have the following classes:</P>
<P>AddressBookContactList<BR>AddressBookContact<BR>AddressBookGroupList<BR>AddressBookGroup</P>
<P>AddressBookContactGroupList<BR>AddressBookContactGroup<BR>AddressBookGroupContactList<BR>AddressBookGroupContact</P>
<P>Let's look at one direction through the OM:</P>
<P>AddressBookContact&nbsp;contains a Groups property&nbsp;of the AddressBookContactGroups type.</P>
<P>AddressBookContactGroups is a read/write collection of AddressBookContactGroup objects.&nbsp; It accepts a reference to the parent AddressBookContact object in its constructor and uses that object's ID value as a parameter when selecting the child records to populate the collection.&nbsp; The objects that are actually instantiated are of the AddressBookContactGroup&nbsp;type which actually represent the relationship and NOT the group itself.&nbsp; So, in essance, you have a read-only list of groups (if you choose) but maintain a read/write list of relationships.</P>
<P>This is no different than what Rocky has done with the ProjectTracker application.&nbsp; See the Project-&gt;ProjectResources-&gt;ProjectResource classes for examples.</P>
<P>The question that has perplexed us; however, is how to simplify this model for the developer so that the complexity is abstracted?&nbsp; For instance, to access the properties of a particular group that a contact belongs to,&nbsp;the following would be the most intuitive for a developer:</P>
<P><CODE>myAddressBookContact.Groups[0]</CODE></P>
<P>However, this returns the relationship object and NOT the actual group object.&nbsp; So, the following code would actually fail:</P>
<P><CODE>= myAddressBookContact.Group[0].Name;</CODE></P>
<P>Instead, the developer would have to use the following statement:</P>
<P><CODE>= myAddressBookContact.Group[0].GetGroup().Name;</CODE></P>
<P>Not very intuitive is it? And not very consistent with how the same operation is performed in other areas.</P>
<P>So, what we've done to accomodate the needs of our developers, is to incorporate an interface (IAddressBookGroup)&nbsp;as the return type for the collection's indexer, implement&nbsp;it on both group classes (AddressBookGroup and AddressBookContactGroup) so that the first statement will work.</P>
<P>Accomplishing this, however, does complicate things a bit in the AddressBookContactGroup class.&nbsp; Instead of maintaining just the ID of the AddressBookGroup object, we actually maintain a reference to that object, instantiated within the data access code.&nbsp; Then, all of the properties specified by the interface, such as Name as shown above, are implemented by simply delegating to the inner AddressBookGroup object.</P>
<P>The end result has several benefits that thus far, for us at least, have outweighed the extra complexity with these classes.&nbsp; First, you accurately encapsulate the behavior of the relationship between the objects, but you also gain the ability to manage that relationship through the AddressBookContactGroup object.&nbsp; For instance, when changes are applied to this object, it is the relationship that gets updated - so when a new group is added to the collection, a new record is added to the appropriate N-to-N table in the database.&nbsp; In addition, because we delegate to an instance of the AddressBookGroup class within our AddressBookContactGroup class, any changes made to the group's properties are managed by the AddressBookGroup class - providing consistent encapsulation within the model.</P>
<P>I think the only real difference between our approach and Rocky's is referencing the object rather than exposing a GetResource() method as is done in the ProjectResource class as well as using interfaces to define our return types.&nbsp; It's up to you which approach makes more sense to you.</P>
<P>Hope this helps.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kbcb replied on Saturday, February 17, 2007</h2><P>I just recently (today) posted a thread on the forum relating to a very similar issue. For the most part, I came up with the same solution... However, I am wondering, how do you databind these RO object properties to a form. How do you databind a list of groups to a combobox, where you want to also databind&nbsp;the combobox's selection to a property that is a RO replica of the group object (which was created to represent the relationship of the group object)?</P>
<P>&nbsp;</P>
<P>Thanks!</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
