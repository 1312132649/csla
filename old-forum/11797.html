<html><header><title>Mobile Wcf Portal and MobileRequestProcessor</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Mobile Wcf Portal and MobileRequestProcessor</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11797.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm posted on Saturday, January 19, 2013</h2><p>What&#39;s the reasoning behind MobileRequestProcessor&#39;s delegation of request call to Csla.DataPortal (client DataPortal) rather than Csla.Server.DataPortal (server one) as Csla.Server.Hosts.WcfPortal (regular Wcf Portal) does?</p>
<p>If I&#39;ve got it correctly, this delegation will bring up Local Proxy on the server and will ultimately end on Csla.Server.DataPortal as well, but why is it needed?</p>
<p>Thanks,</p>
<p>--- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, January 21, 2013</h2><p>This approach allows your web server code to leverage the full data portal behavior for routing requests.</p>
<p>Most importantly, you might choose to use something other than the WCF channel to communicate with your app server, so delegating to WcfProxy or WcfPortal would be bad as it would eliminate all your flexibility.</p>
<p>But also, this approach allows you to have a smart custom proxy running on the web server to route different calls to different app servers, etc.</p>
<p>In short, it enables a lot of advanced scenarios that people might want in some cases.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Monday, January 21, 2013</h2><p>Rocky,</p>
<p>Thank you for a prompt reply.</p>
<p>I&#39;m not quite sure I see those benefits. It might be that the explanation is too abstract or it might be me.</p>
<p>Basically, the request already selected the proper proxy (in this case Wcf Proxy) which in turn selected proper host (in this case Mobile Wcf Portal), now the only question is how is&nbsp;the request routed to Server.DataPortal after transport technology is out of equation.</p>
<p>I absolutely don&#39;t see the value of going through additional layer of indirection i.e. Client Data Portal which is pretty much LocalProxy unless that server is configured to point to some other application server.</p>
<p>Whatsoever, despite possible performance degradation, it looks to me that this indirection can mask the real request&#39;s context&nbsp;in that it can look like the business code will&nbsp;infer&nbsp;it&#39;s being executed as part of the local execution and not the remote one. Let&#39;s consider ApplicationContext.ExecutionLocation, it&#39;s being set in SetContext method of Server.DataPortal which in this case is called from LocalProxy. That masks context of the original request (yes the value of ApplicationContext.ExecuteLocation is Client in case of WcfProxy / Mobile WcfPortal).</p>
<p>However, if &quot;jumping from Data Portal to another Data Portal&quot; scenario is to be achieved, that should be left to business developer to implement in data access i.e. she can invoke any type of Data Portal proxy (including local one) from there and thus keep chaining them as long as she wants.</p>
<p>On the other hand the check for Object Factory block of MobileRequestProcessor seems to go in totally opposite direction. It skips Server.DataPortal completely. What it means is that it will in turn&nbsp;skip the transactional support alogether.</p>
<p>Am I missing something seriously here?&nbsp;If so, what&#39;s the&nbsp;reason for this disparity?</p>
<p>Thanks,</p>
<p>- ngm</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, January 21, 2013</h2><p>Just to level set: we are talking about a 4-tier physical deployment, where a smart client makes a call to a web server, and the web server delegates that call to an app server via the data portal.</p>
<p>The design scenario I&#39;m focused on here is one where you don&#39;t fully trust the client. So an <em>honest</em> client does a lot of processing and work, thus giving the user a rich and happy experience. It then sends a request to the web server. A <em>hacked</em> client might do invalid calculations, or generate incorrect data which is sent to the web server.</p>
<p>On the web server you have the option to re-run the business logic on the web server (the same logic as on the client) because you trust the web server more than the client. Or the web server can act as a simple passthrough. Or the web server can apply specialized authorization or verification logic to decide if it wants to accept the client request.</p>
<p>The great thing is that all this has occurred outside the <em>real firewall</em> that protects the app&nbsp;server and database server. So now a would-be hacker must compromise the client, and the web server, and probably discover the alternate ports/protocol used to get through that second firewall.</p>
<p>Just because you used WCF to get from the client to the web server doesn&#39;t mean you can&#39;t switch protocols to get from the web server to the app server.</p>
<p>What&#39;s even more fun is that the web server can do some caching (because it is generally trusted). So some data portal calls might be handled local to the web server, while others are actually routed to the app server behind the second firewall.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Monday, January 21, 2013</h2><p>Got it.</p>
<p>But you&#39;re envisioning (politely for dreaming <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" />) and I&#39;m with my plumbing questions in the mine 2000 ft. under the earth <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>However, I had the solution that implemented similar scenario in CSLA. It was certain app BOs that interact on few occasions with my company&#39;s BOs. Scenarios range from error logging, licensing to telemetry. The similarity was that two Data Portals were involved, one app specific - deployed on- premise and another one within my company&#39;s infrastructure. The difference is that this was part of business logic i.e. app BO when&nbsp;on-premises&nbsp;Data Portal&nbsp;interacts with our infrastructure BO which ultimately talks with our Data Portal, but here you&#39;re talking more about system wide setup where this is enforced for every request.</p>
<p>Back to the plumbing, Object Factory version of invocation doesn&#39;t follow this path and it&#39;s much more &quot;bare bone&quot; then DataPortal_XYZ version. Similarly, non-mobile Wcf Poral doesn&#39;t advocate this approach but rather goes to Server.DataPortal directly. Shouldn&#39;t they all be equal with supported functionalities such as transactions?</p>
<p>- ngm</p>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
