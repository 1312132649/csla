<html><header><title>IAuthorizeDataPortal - How to distinguish incoming remote calls from server-side calls over local data portal?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>IAuthorizeDataPortal - How to distinguish incoming remote calls from server-side calls over local data portal?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8885.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Wednesday, May 05, 2010</h2><p>So, I&#39;m having an odd problem as I start to implement IAuthorizeDataPortal. </p>
<p>When using a Web Service (or WCF service),&nbsp; the service implementation&nbsp;itself uses the *local* data portal to access the BOL/Data layers&nbsp;layer for any &quot;internal&quot; DataPortal_xxx calls that it might make to satisfy an external request.&nbsp; </p>
<p>I don&#39;t want to apply&nbsp;any (well, at least not the same) authorization to internal calls, only to the incoming calls from remote clients.</p>
<p>I don&#39;t see an obvious way in the data portal authorization implementation to distinguish one from the other. Since the IAuthorizeDataPortal provider type name is in the server side .config file, the same provider will be used to authorize both the incoming calls from remote clients, as well as the internal calls made by the service itself. The AuthorizeRequest class doesn&#39;t seem to have enough information to tell the difference between the types of calls, and the ApplicationContext ExecutionLocation and LogicalExecutionLocation are no help either (Both are alway &quot;Server&quot; on the server).</p>
<p>I see a simple change that could be made that would solve my dilemma -- I could extend&nbsp;the AuthorizeRequest class to also include a reference to the DataPortalContext so it is also available. However, I&#39;d rather not do this if there is a way to tell the two types of access apart without making custom changes to CSLA. </p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, May 06, 2010</h2><p>An even simpler solution is for your IAuthorizeDataPortal implementation to put a value in Csla.ApplicationContext.LocalContext, and then look for that value on subsequent calls.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, May 06, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>An even simpler solution is for your IAuthorizeDataPortal implementation to put a value in Csla.ApplicationContext.LocalContext, and then look for that value on subsequent calls.</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>If I follow you, you&#39;re suggesting that since any &quot;originating&quot; call for a remote data portal&nbsp;must (by definition) be remote, that if I authorize it, then I bypass any subsequent authorization for the duration of that call chain (e.g. any local portal calls made servicing the remote request) by putting a value in the LocalContext? </p>
<p>Very clever... :)</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, May 06, 2010</h2><p>That&#39;s what I&#39;m thinking - it should work quite well since LocalContext doesn&#39;t survive between server calls, but is consistent during the life of a given server call.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
