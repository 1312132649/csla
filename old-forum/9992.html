<html><header><title>Specification Pattern from DDD - improves criteria building</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Specification Pattern from DDD - improves criteria building</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9992.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>enzed posted on Thursday, January 27, 2011</h2><p>Hi,</p>
<p>I think the power of linq expression as encapsulated by the Specification pattern (just google to find .NET implementation) would greatly improve the building of criteria in CSLA.</p>
<p>It would allow more dynamic criteria formulation and less custom criteria classes.</p>
<p>Many orms like Entity Framework (POCO - code first) will take the expression and apply it directly.</p>
<p>Here&#39;s an exmaple of how I&#39;d like to use it:</p>
<p>Client Side:</p>
<pre style="font-family:consolas;">	<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">partial</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">WorkWeek</span><br />	{<br />		<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Get(<span style="color:#2b91af;">ISpecificationCriteria</span>&lt;<span style="color:#2b91af;">WorkWeek</span>&gt;&nbsp;criteria,&nbsp;<span style="color:#2b91af;">EventHandler</span>&lt;<span style="color:#2b91af;">DataPortalResult</span>&lt;<span style="color:#2b91af;">WorkWeek</span>&gt;&gt;&nbsp;callback)<br />		{<br />			&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;dp&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">DataPortal</span>&lt;<span style="color:#2b91af;">WorkWeek</span>&gt;();<br />			&nbsp;&nbsp;dp.FetchCompleted&nbsp;+=&nbsp;callback;<br />			&nbsp;&nbsp;dp.BeginFetch(criteria);<br />		}<br />        }<br /><br />Server side using object factory:<br /><br />&nbsp; <span style="color:blue;">public</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">WorkWeekDal</span>&nbsp;:&nbsp;<span style="color:#2b91af;">ObjectFactory</span><br />&nbsp;&nbsp;{<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:green;">//Fetch&nbsp;on&nbsp;a&nbsp;specification&nbsp;based&nbsp;on&nbsp;the&nbsp;business&nbsp;object&nbsp;interface</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;TimeAGF.Business.<span style="color:#2b91af;">WorkWeek</span>&nbsp;Fetch(<span style="color:#2b91af;">ISpecification</span>&lt;<span style="color:#2b91af;">WorkWeek</span>&gt;&nbsp;criteria)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">using</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;db&nbsp;=&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">TimeAGFContext</span>()) //Context is Entity Framework<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />              //apply the linq experssion directly - EF does the heavy lifting<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;db.WorkWeeks.Single(criteria.Predicate);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />  }</pre>
<p>Looking at the CSLA implementation, I think it would take some internal refactoring of CSLA to take these Specification types.&nbsp; It would also require specific handling in the mobile formatters so this type can be serialised.</p>
<p>Other than that that is all that is required I think.</p>
<p>What do you think.&nbsp; If you like it I can have a go at doing it in CSLA and posting the update - or maybe I&#39;ve missed something or maybe you can implement quicker than me.</p>
<p>Anyway - for me it would reduce coding significantly.&nbsp; I&#39;d like to have it.</p>
<p>Kind Regards,</p>
<p>Nick</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, January 27, 2011</h2><p>CSLA .NET is not an ORM, and has very different design goals from a typical ORM.</p>
<p>Most notably, business domain objects shouldn&#39;t normally be queried like data entity objects, because they should have already been designed specifically to meet the needs of each use case.</p>
<p>Data entity objects (like those generated by ORM tools) tend to be data-centric, and therefore somewhat reusable across use cases. After all, they are primarily just data entities in object form - more like tables than behavioral objects.</p>
<p>Domain objects (like you should create using CSLA) tend to be behavior-centric, and therefore focused on individual use cases. The fact that they have data at all is completely secondary to the behavior implemented by the object.</p>
<p>In short, the idea of being able to do a LINQ query across the object model on the client, and having that query serialized to the server so it can be translated into a data query is way outside the scope and philosophy of CSLA.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>enzed replied on Thursday, January 27, 2011</h2><p>Hi Rocky,</p>
<p>I understand your concerns and understand the idea of CSLA.&nbsp; I agree with it.</p>
<p>Take a look at this http://blogs.msdn.com/b/adonet/archive/2010/12/06/ef-feature-ctp5-code-first-walkthrough.aspx</p>
<p>It would fit in nicely with CSLA. In my experience having a linq query based on the domain and then translated to the persistence has worked beautifully for me in the past.&nbsp; EF CTP5 makes it hell of lot more easier.</p>
<p>For instance I&#39;ve been able to shape the query to allow data security concerns to be encapsulated and handled in one discrete place.</p>
<p>I&#39;d also add that CSLA provides the ability to construct critieria (which is a little limiting).&nbsp; A linq query is therefore a more sophisticated criteria.&nbsp; CSLA would just need to serialised this specific type.&nbsp; The orm does the job translating - not a job for CSLA.&nbsp; The only issue is that CSLA is very tighhly bound to what it can serialise (that is a flaw in my mind - but others would beg to differ I&#39;d expect).</p>
<p>Regards,</p>
<p>&nbsp;</p>
<p>Nick</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 27, 2011</h2><p>I agree, the new EF features are very compelling.</p>
<p>But I stand by my 15 year assertion that only the Data Access layer should be aware of the structure of any data entities. The Interface, Interface Control and Business layers should be unaware of the shape of any lower-level data constructs.</p>
<p>And I hold to the philosophy that if you have to do queries over your domain objects to get them into the right shape for your use case, then you did a horrible job designing your domain model. Supporting that sort of query is just enabling bad design imo.</p>
<p>I implemented the entire object factory concept specifically to enable the use of what (I hope) EF is now being able to do, which is to query data entities and map the data into domain objects. All mapping and knowledge of data entities still encapsulated within the Data Access layer, but hopefully simplifying that layer for cases where EF can be exclusively used to do the work.</p>
<p>Whether the new EF features will actually go far enough I don&#39;t yet know. It all depends on whether they have appropriate hooks so we can use LoadProperty and ReadProperty to set/get every property value - thereby bypassing common issues like read-only properties, authz and business rules, etc.</p>
<p>Ideally CSLA would include an EfObjectFactory base class that abstracts the CRUD operations for an object when mapping against EF. Or something that provides higher abstraction anyway. But I haven&#39;t had time to dig into this at all yet - writing the ebook series is very time-consuming.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>enzed replied on Thursday, January 27, 2011</h2><p>I tend to think this is making too much of it.</p>
<p>I can&#39;t see what laws of software engineering are being brokne.&nbsp; In fact it fits in with the DDD idea.</p>
<p>The expression is just another type of Criteria that&#39;s all.&nbsp; It&#39;s not an EF thing.&nbsp; I&#39;d be using the expression if it where a directroy of files I was querying.&nbsp; I repeat it&#39;s just criteria, just not bound by some imperative programming idea which is being unfairly imposed by CSLA.</p>
<p>Not to get too harsh about it, the philosophy you espouse imposes rigidity which is what we should be avoiding.&nbsp; Limiting what you can serialise is an example of this. If this was not the case then this post would have never eventuated and I&#39;d be happily doing my design - not screwing it as you are saying.&nbsp; </p>
<p>So we can disagree - we are coming from a diffrent viewpoint.&nbsp; But rest assured I know what I&#39;m talking about - I know what I want to achieve - I want to do in less code.</p>
<p>I&#39;d finally say that overall CSLA is quite good.&nbsp; But some aspects of it are frustrating.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 27, 2011</h2><p>I have no problem with healthy disagreement, that happens all the time :)</p>
<p>I&#39;m just saying that CSLA is an expression of my philosophy, and the features that get implemented support that philosophy. I&#39;m not overly motivated to implement concepts that don&#39;t fit the way I view the framework. I do this for free after all - it&#39;d be different if this were a commercial product - then I&#39;d be motivated by the requirements of my highest paying customers ;)</p>
<p>The thing to consider though, is that there&#39;s absolutely nothing stopping you from creating an ExpressionCriteriaBase class that serializes LINQ expressions into a form that can be transported over the network. That&#39;s not easy (at all), but it has been done by some more ORM oriented products out there. I think LLBLgen does this, and I think they blogged about how they managed to build a serialization engine for expressions - you may find that useful if you go down this road.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
