<html><header><title>Derived classes and fetching data.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Derived classes and fetching data.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4534.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>preludecrazy posted on Friday, March 21, 2008</h2><P><FONT face=Arial>Hi.&nbsp; </FONT><FONT face=Arial>I am going to write some classes using CSLA 3.03, but before I do, I have a question with regards to the best solution...&nbsp; I've tried to&nbsp;keep my question a simple as possible by omiting most of my data members.</FONT></P>
<P><FONT face=Arial>I will&nbsp;write a derived...:</FONT></P>
<P><FONT face=Arial>Class (class&nbsp;Order : BusinessBase&lt;Order&gt;) containing 'OrderID' and 'CompanyID' data members.</FONT></P>
<P><FONT face=Arial>Collection (class OrderCollection : BusinessListBase&lt;OrderCollection, Order&gt;).&nbsp; The DataPortal_Fetch(Criteria criteria) method will populate&nbsp;the collection will&nbsp;order&nbsp;IDs and&nbsp;company&nbsp;IDs from my orders database.</FONT></P>
<P><FONT face=Arial>Class&nbsp;(class LiteCompany : BusinessBase&lt;LiteCompany&gt;) containing 'CompanyID' and 'CompanyName' data members.</FONT></P>
<P><FONT face=Arial>Collection (class LiteCompanyCollection : BusinessListBase&lt;LiteCompanyCollection, LiteCompany&gt;).&nbsp; The DataPortal_Fetch(Criteria criteria) method will populate&nbsp;the collection will company&nbsp;IDs and&nbsp;names from my companies database.</FONT></P>
<P><FONT face=Arial>Class&nbsp;(<STRONG>class Company : LiteCompany</STRONG>) containing a 'OrderIDCollection' data member.</FONT></P>
<P><FONT face=Arial>Collection&nbsp;(<STRONG>class CompanyCollection : LiteCompanyCollection</STRONG>).</FONT></P>
<P><FONT face=Arial>So by creating an instance on CompanyCollection,&nbsp;I'll have&nbsp;a collection of companyIDs and names, also containing a collection of order IDs against that company ID.</FONT></P>
<P><FONT face=Arial>I have done it like this because sometimes I'll want a collection of companies without a collection of order IDs.</FONT></P>
<P><FONT face=Arial>In&nbsp;the DataPortal_Fetch method in my CompanyCollection, I&nbsp;presume I should be (indirectly) getting the DataPortal_Fetch method in LiteCompanyCollection to populate its data members, then just populate the OrderIDCollection afterwards - presumably the same way, by (indirectly) getting the DataPortal_Fetch method in the OrderCollection to populate its data members?</FONT></P>
<P><FONT face=Arial>Is this the best/correct approach?&nbsp; Rather duplicating most of the code in the DataPortal_Fetch methods?&nbsp; If yes, I was wondering what the best approach is to casting my LiteCompanyCollection to my CompanyCollection?</FONT></P>
<P><FONT face=Arial>Thanks., Jason.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, March 21, 2008</h2><P><FONT face=Tahoma size=2>Maybe I'm missing something here, but I wouldn't do it this way.</FONT></P>
<P><FONT face=Tahoma size=2>I don't think that inheriting CompanyCollection from LiteCompanyCollection is going to help you much.&nbsp; For starters, </FONT><FONT face=Tahoma size=2>you're always going to have to cast the objects coming out of your CompanyCollection, since its definition is to return a LiteCompany object.&nbsp; I don't think the indexer methods are overridable, so it isn't something you can encapsulate within your CompanyCollection.</FONT></P>
<P><FONT face=Tahoma size=2>Beyond that, remember that the standard collection-class pattern takes the DataReader and passes it into the child object that it creates through a factory method, letting&nbsp;said child object&nbsp;populate itself.&nbsp; You can build that pattern into a virtual method that subclasses of LiteCompanyCollection&nbsp;could&nbsp;override,&nbsp;and&nbsp;every subclass would have to override that method and return the type of subclass that you want to put into the collection.&nbsp; But you don't get much protection in using the class, as your overridable method has to be virtual, even though you want to require subclasses to override it.&nbsp; Plus, you'll end up building up a lot of static methods on your subclasses, since it's the static methods that create and populate the class instance.&nbsp; You can't&nbsp;mark static methods as overridable, so you can't keep subclasses from calling the wrong static method.</FONT></P>
<P><FONT face=Tahoma size=2>While it's perfectly fine to have Company inherit from LiteCompany, I think your collection classes are going to have to look like this:</FONT></P>
<P><FONT face=Tahoma size=2>class LiteCompanyCollection : BusinessListBase&lt;LiteCompanyCollection, LiteCompany&gt;</FONT></P>
<P><FONT face=Tahoma size=2>class CompanyCollection : BusinessListBase&lt;CompanyCollection, Company&gt;</FONT></P>
<P><FONT face=Tahoma size=2>While they would share some DP_ code, you can probably factor that out into a&nbsp;separate class if you want.</FONT></P>
<P><FONT face=Tahoma size=2>If I've totally missed the mark here, let me know what I'm not following.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>preludecrazy replied on Sunday, March 23, 2008</h2><FONT face=Arial><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div><FONT size=2>While it's perfectly fine to have Company inherit from LiteCompany, I think your collection classes are going to have to look like this:</FONT></FONT> 
<P><FONT face=Arial size=2>class LiteCompanyCollection : BusinessListBase&lt;LiteCompanyCollection, LiteCompany&gt;</FONT></P>
<P><FONT face=Arial size=2>class CompanyCollection : BusinessListBase&lt;CompanyCollection, Company&gt;</FONT></P>
<P><FONT face=Arial><FONT size=2>While they would share some DP_ code, you can probably factor that out into a&nbsp;separate class if you want.</FONT></div></BLOCKQUOTE></FONT></P>
<P><FONT face=Arial>Thanks Scott.&nbsp; I started to write the classes last night before I saw your reply, and&nbsp;hit the problem inheriting from LiteCompanyCollection! :), and realised I had to change it to exactly what you said.</FONT></P>
<P><FONT face=Arial>Thanks.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>preludecrazy replied on Monday, March 24, 2008</h2><P><FONT face=Arial>Hi (Scott).</FONT></P>
<P><FONT face=Arial>I managed to get my inherited properties to populate via reflection.&nbsp; I hadn't used reflection before, so I might be doing something stupid, or this approach might be overkill or just plain wrong!, but its currently working, so I'll use it for now and see how it holds out while I write the rest of my app.</FONT></P>
<P><FONT face=Arial>Basically, I'm calling Company.GetCompany(LiteCompany objLiteCompany) etc, in CompanyCollection.DataPortal_Fetch, and my Company.Fetch method looks like this:</FONT></P>
<P><FONT face="Courier New" size=2>private void Fetch(LiteCompany myObject)<BR>{<BR>&nbsp;&nbsp;&nbsp;MemberInfo[] myMembers = myObject.GetType().GetMembers();<BR>&nbsp;&nbsp;&nbsp;foreach (MemberInfo myMember in myMembers)<BR>&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object[] myAttributes = myMember.GetCustomAttributes(true);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (object myAttribute in myAttributes)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (myAttribute is MyDataMemberAttribute)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (((MyDataMemberAttribute)myAttribute).IsMyProperty)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropertyInfo[] thisProperties = this.GetType().GetProperties();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach (PropertyInfo thisProperty in thisProperties)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (thisProperty.Name == myMember.Name)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropertyInfo myObjectProperty = myObject.GetType().GetProperty(myMember.Name);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thisProperty.SetValue(this, myObjectProperty.GetValue(myObject, null), null);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT face="Courier New" size=2>MarkOld();<BR>}</FONT></P>
<P><FONT face=Arial>I've created a MyDataMemberAttribute with a 'IsMyProperty' property/constructor parameter, so I've just put [MyDataMemberAttribute(true)] above every property in LiteCompany that I want inherited classes to populate via reflection.</FONT></P>
<P><FONT face=Arial>Thanks.</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
