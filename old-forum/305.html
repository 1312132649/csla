<html><header><title>Bug in new SetItem method</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Bug in new SetItem method</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/305.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>miker55 posted on Wednesday, June 07, 2006</h2><P>I am getting an error when I try to assign&nbsp;to a&nbsp;business object.&nbsp; To verify that it wasn't my code, I modified the ProjectTracker code like so:</P>
<P>In RolesEdit.cs</P>
<P>&nbsp;&nbsp;&nbsp; private void SaveButton_Click(object sender, EventArgs e)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int lastRow = _roles.Count-1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _roles[lastRow] = _roles[lastRow];&nbsp;&nbsp; // crashes!</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....</P>
<P>&nbsp;&nbsp;&nbsp;}</P>
<P>The problem is the SetItem method override.&nbsp; Assuming a 5 item list, you get:</P>
<P>&nbsp;&nbsp;&nbsp; protected override void SetItem(int index, C item)<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveItem(index);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// removes item 5 in 5 count list<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.SetItem(index, item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// tries to assign to item 5 in a now 4 count list, error<BR>&nbsp;&nbsp;&nbsp; }<BR></P>
<P>It calls RemoveItem at position [index], then immediately tries to assign to the same index that now no longer exists.</P>
<P>As I missing something here?&nbsp; In the MS help for overriding SetItem, all it does is call base.SetItem().&nbsp; What is the purpose of the RemoveItem call?</P>
<P>TIA,</P>
<P>Mike Rodriguez</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 07, 2006</h2><P>Hmm, interesting. That's a good catch.</P>
<P>The RemoveItem() call is there to support undo. If you "set" an item it replaces the previous item in that location right? But if you later call CancelEdit(), then you'd expect that the new item would go away and the old item would come back. This means that the old item needs to have been moved to deletedList, not just discarded.</P>
<P>But what you have found is certainly an ugly timing issue. It appears that I can't just call RemoveItem() in this case, but will have to do some extra work...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Wednesday, June 07, 2006</h2><P>How about something like this...</P>
<P>protected override void SetItem(int index, C item)<BR>{<BR>&nbsp;&nbsp; //Only care about deleting if the objects (IDs) are different!<BR>&nbsp;&nbsp; C obj = this[index];<BR>&nbsp;&nbsp; if (!obj.Equals(item))<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteChild(obj);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INotifyPropertyChanged c = c as INotifyPropertyChanged;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (c != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.PropertyChanged -= new PropertyChangedEventHandler(Child_PropertyChanged);<BR>&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>&nbsp;&nbsp; base.SetItem(index, item);<BR>}</P>
<P>This is basically executing the same code that's in RemoveItem - without the actual remove.&nbsp; I'm assuming the base.SetItem() will overwrite whatever object is already there.&nbsp; </P>
<P>I also think we need the check to see if the objects (or their IDs) are the same.&nbsp; If I edit some object and try to push it back into the collection via a Set method (even though it's not necessary), without the check, the object would get marked for deletion as well as exist in the regular collection.&nbsp; Who knows what kind of craziness would follow... :-)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 07, 2006</h2>




<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>Interesting thought about not replacing the existing 
object. I think though, that checking the reference would be sufficient. Even if 
the objects are "logically" the same, I think you'd need to replace it if the 
actual reference is different. So</FONT></SPAN></DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>if (ReferenceEquals(obj, item))</FONT></SPAN></DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>is probably the better check?</FONT></SPAN></DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>Even if there's a good argument for doing a logical 
compare, the event handler for PropertyChanged needs to be removed, so some work 
must happen in any case that the reference is different.</FONT></SPAN></DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>Can you think of a valid scenario where you'd actually WANT 
to replace an object with a whole other object that happened to have the same 
Id?</FONT></SPAN></DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2></FONT></SPAN>&nbsp;</DIV>
<DIV align=left><SPAN class=234010122-07062006><FONT face=Arial color=#0000ff size=2>Rocky</FONT></SPAN></DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Wednesday, June 07, 2006</h2><P>You're correct (as usual) - ReferenceEquals seems to be the proper check.&nbsp; I can't think of a reason why we'd need to allow the SetItem to continue if the references are equal - not that it would be doing much, given the references are equal to begin with.&nbsp; Just move the base.SetItem call into the conditional block and that'd take care of it.&nbsp; :-)&nbsp; Final code looks something like this?</P>
<P>protected override void SetItem(int index, C item)<BR>{<BR>&nbsp;&nbsp; C obj = this[index];<BR>&nbsp;&nbsp; if (!ReferenceEquals(item, obj))<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteChild(obj);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INotifyPropertyChanged c = c as INotifyPropertyChanged;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (c != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.PropertyChanged -= new PropertyChangedEventHandler(Child_PropertyChanged);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.SetItem(index, item);<BR>&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>}</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Thursday, February 21, 2008</h2><P>Hi Mark, wondering about this question you asked some time back - i.e. why would there be a need to carry on with a replace/set if the object references are the same? Thinking that the a second event could be hooked up if the replace code goes ahead - 'child' is never unhooked but maybe item is hooked again in the base.SetItem??</P>
<P><FONT color=#0000ff size=1>protected</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>override</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>void</FONT><FONT size=1> SetItem(</FONT><FONT color=#0000ff size=1>int</FONT><FONT size=1> index, C item)<BR>{<BR>C child = </FONT><FONT color=#0000ff size=1>default</FONT><FONT size=1>(C);<BR></FONT><FONT color=#0000ff size=1>if</FONT><FONT size=1> (!(ReferenceEquals((C)(</FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>[index]), item)))<BR>child = </FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>[index];<BR></FONT><FONT color=#008000 size=1>// replace the original object with this new</FONT><FONT color=#008000 size=1> object<BR></FONT><FONT color=#0000ff size=1>bool</FONT><FONT size=1> oldRaiseListChangedEvents = </FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>.RaiseListChangedEvents;<BR></FONT><FONT color=#0000ff size=1>try<BR></FONT><FONT size=1>{<BR></FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>.RaiseListChangedEvents = </FONT><FONT color=#0000ff size=1>false</FONT><FONT size=1>;<BR></FONT><FONT color=#008000 size=1>// set parent reference<BR></FONT><FONT size=1>item.SetParent(</FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>);<BR></FONT><FONT color=#008000 size=1>// set child edit level<BR></FONT><FONT size=1>ResetChildEditLevel(item, </FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>.EditLevel);<BR></FONT><FONT color=#008000 size=1>// reset EditLevelAdded <BR></FONT><FONT size=1>item.EditLevelAdded = </FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>.EditLevel;<BR></FONT><FONT color=#008000 size=1>// add to list<BR></FONT><FONT color=#0000ff size=1>base</FONT><FONT size=1>.SetItem(index, item);<BR>}<BR></FONT><FONT color=#0000ff size=1>finally<BR></FONT><FONT size=1>{<BR></FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>.RaiseListChangedEvents = oldRaiseListChangedEvents;<BR>}<BR></FONT><FONT color=#0000ff size=1>if</FONT><FONT size=1> (child != </FONT><FONT color=#0000ff size=1>null</FONT><FONT size=1>)<BR>CopyToDeletedList(child);<BR></FONT><FONT color=#0000ff size=1><BR>if</FONT><FONT size=1> (RaiseListChangedEvents)<BR>OnListChanged(</FONT><FONT color=#0000ff size=1>new</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>ListChangedEventArgs</FONT><FONT size=1>(</FONT><FONT color=#008080 size=1>ListChangedType</FONT><FONT size=1>.ItemChanged, index));<BR>}</P></FONT></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
