<html><header><title>Validation and the DataGridView</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Validation and the DataGridView</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2309.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert posted on Friday, February 09, 2007</h2>I'm unclear about how to use Validation Rules to run interference in the UI. I have an Editable Root List that contains Editable Children. I have rules on the child class that successfully return errors to rows in my DataGridView. What I want is to disallow creation of new rows when errors exist on any existing rows. 

Should I do this in the UI or somehow in the collection class? Can I use the AllowNew property to turn this on and off? What's the best practice for doing this?<br><br>I should also add that I think this question is related to <a>this thread</a>. I'm still not sure how to check rules for an object that has not had any property set calls. If I do a ValidationRules.CheckRules() in the constructor, it will fail every property that hasn't yet been written to. The side effect of this is that the error provider displays an "error" even though the user has not typed/selected anything yet. Is there some kind of event I can use at the collection class level to indicate that the user has navigated to another member so that I can fire the CheckValues? Does this make sense?<br><br>Thanks for any help,
Barry</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, February 09, 2007</h2><P>To do it right, you need to have both the collection and UI involved.</P>
<P>The collection needs to prevent addition of a new child when existing children are invalid. If your base class is BusinessListBase you can just use its IsValid property. If you base class is ERLB you'll have to loop through the child items yourself to check each one's IsValid property.</P>
<P>I'd build this decision logic into a read-only property on the collection called IsAddAllowed or something like that.</P>
<P>Either way, your AddNewCore() override can throw an exception to prevent the addition of a new item by checking this IsAddAllowed property.</P>
<P>While "correct", only doing that would lead to a poor user experience. So the UI also needs to be involved. It can handle the ListChanged event, which is raised any time the list or its children change. At that point the UI can check IsAddAllowed and enable/disable the UI from <EM>allowing</EM> the user to try and add a new row.</P>
<P>This is good separation of concerns: the actual decision logic and final check is in the business layer, but the UI is able to also give the user cues as to what is and isn't going to work.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Monday, February 12, 2007</h2>Thanks. I had already figured out the same&nbsp;solution. </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>yuhnkee replied on Tuesday, February 27, 2007</h2>Is their a reason we can't override the save method and check those rules that are required?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, February 27, 2007</h2><P>That is a good point - you could certainly override Save sort of like this:</P>
<P>public override object Save()<BR>{<BR>&nbsp; ValidationRules.CheckRules();<BR>&nbsp; return base.Save()<BR>}</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Thursday, March 01, 2007</h2>Would this work? I didn't think you could CheckRules from a BusinessList-derived class.<br><br>I think I got this to work correctly by doing ValidationRules.CheckRules at the beginning of the Insert and Update routines. Since, in this case, I only care about validity when persisting the data, I think this will work.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jimbo replied on Friday, March 02, 2007</h2>You could expose a .CheckRules or custom validation helper method in
the List BO that the UI may call at the appropriate point in the cycle.
Or you could make good use of an ApplyAuthorizationRules method to
control the enabling of&nbsp; the Save/apply button without necessarily
having to invoke the ErrorProvider based on property changes..&nbsp;
You can also set IsValid to false by default in the ctor - so that the
user must at least begin to enter something that activates checkrules()
to get access to the save button.<br>
<br>
<br>
<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TooMuch replied on Tuesday, April 08, 2008</h2><P>I like the solution proposed by Rocky here for this situation, but I'm struggling with&nbsp;the implementation details.</P>
<P>If you throw an exception in AddNewCore(), where do you catch it in the UI?&nbsp; If I set a break in AddNewCore,&nbsp;I don't see any events that I can use in the UI to put a try-catch.&nbsp; Has anybody out there handled this scenario?&nbsp; Where would you catch the exception from AddNewCore()?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Tuesday, April 08, 2008</h2>I would suggest the DataError event from either the BindingSource or the dgv.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TooMuch replied on Tuesday, April 08, 2008</h2><P>Thanks for the suggestion, I just tried putting both the DataGridView DataError and BindingSource DataError events in my UI and they don't catch the exception.&nbsp;&nbsp;When I look at the call stack in my breakpoint in AddNewCore all I get is the infamous [External Code] so&nbsp;I'm still not sure where I can catch&nbsp;the exception in the UI...&nbsp; </P>
<P>I am now wondering if I should remove the AddNewCore() from my BusinessListBase and instead use the BindingSource AddingNew event to call a method in my BusinessListBase that would do the same thing as AddNewCore.&nbsp; This would allow me to catch the exception in the UI.&nbsp;Will this work?&nbsp; </P>
<P>&nbsp;</P>
<P>Another question in regards to the UI side.&nbsp; When I do the following:</P>
<P>public override object Save()<BR>{<BR>&nbsp; ValidationRules.CheckRules();<BR>&nbsp; return base.Save()<BR>}</P>
<P>My object is correctly setting&nbsp;IsValid = False, but the ErrorProvider exclamations are not appearing next to the controls.&nbsp; The ErrorProvider's DataSource is set to the BindingSource.&nbsp; How do I make the exclamations appear in this scenario?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>FatPigeon replied on Wednesday, April 09, 2008</h2><FONT size=3>
<P>I also have found that an error in the AddNewCore is not caught by the data error event on the data source or the data grid view. So far, the only thing I know that seems to work is to register a handler with the Application.ThreadException event.</P>
<P>&nbsp;</P>
<P>Patrick</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, February 09, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>bgilbert:</strong></div><div>I should also add that I think this question is related to <A>this thread</A>. I'm still not sure how to check rules for an object that has not had any property set calls. If I do a ValidationRules.CheckRules() in the constructor, it will fail every property that hasn't yet been written to. The side effect of this is that the error provider displays an "error" even though the user has not typed/selected anything yet. Is there some kind of event I can use at the collection class level to indicate that the user has navigated to another member so that I can fire the CheckValues? Does this make sense?</div></BLOCKQUOTE></P>
<P>Unforutnately this is the intended behavior. I'm not sure how you'd suppress this behavior in any meaningful way.</P>
<P>To be safe, your object <EM>does</EM> have to check all its rules on creation, otherwise IsValid could be true when it really should be false, and the user could save a bad object.</P>
<P>At the same time, what you are asking for is that the object be invalid and <EM>not say why</EM>. In short, you want the IDataErrorInfo.Item property (or indexer in C#) to return "" for properties the user hasn't touched yet, even if those properties are actually invalid.</P>
<P>At the moment, IDataErrorInfo.Item isn't virtual, so you can't override it. However, <EM>maybe</EM> if it was virtual you could override it in your code to somehow keep a list of properties the user has visited so you could turn on error reporting for each property in turn.</P>
<P>The user experience could still be bad though, because if the user never visits a property that's in error the object would remain invalid (unsavable) and the user wouldn't have a visual indication why they couldn't save their data.</P>
<P>My suggestion is to experiment: change Csla\Core\BusinessBase so the IDataErrorInfo.Item (or indexer in C#) method is virtual/Overridable, then see if you can come up with a meaningful way to decide on a property-by-property basis whether to return "" or allow the normal behavior to occur.</P>
<P>This keeps the changes to CSLA .NET limited: just one line changes. And allows you to see if this is a workable solution at all.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
