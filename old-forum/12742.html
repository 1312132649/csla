<html><header><title>Slow response when i restore other field in set property</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Slow response when i restore other field in set property</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12742.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marian posted on Tuesday, September 09, 2014</h2><p>Hello, I&#39;m using CSLA 3.6 and I have some business rules in my business base object that claim to clean some fields when I change a property. These fields have business rules related with them so, when I&#39;m restoring their value in my set propery, I&#39;m using PropertyHasChanged(field_name). </p>
<p>If I have a lot of fields for restore&nbsp;to initial values,&nbsp;time to successfully&nbsp;run my entire Set property code is growing. How can I&nbsp;obtain this without time issues?</p>
<p>&nbsp;</p>
<p>Thanks in advance, Marian&nbsp;&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marian replied on Wednesday, September 10, 2014</h2><p>I read VB Expert 2005 BO and I found that It&#39;s not good to raise PropertyHasChanged for each derived property changed in my set principal property. I Invoked Validation.CheckRules for each property modified and PropertyHasChanged(&quot;propertyname&quot;) only for my principal property modified in set body.</p>
<p>I didn&#39;t find directly specified in book that data binding is invoked automatically for each property changed, even I call PropertyHasChanged only for principal property modified.</p>
<p>Set&#39; answer time is dramatically improved. </p>
<p>I hope that is the right solution!</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Wednesday, September 10, 2014</h2><p style="color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;orphans:auto;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:auto;word-spacing:0px;-webkit-text-stroke-width:0px;">Hmm, well that depends though on what is actually causing the response to be slow.&nbsp;</p>
<p style="color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;orphans:auto;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:auto;word-spacing:0px;-webkit-text-stroke-width:0px;">The PropertyHasChanged will also send OnPropertyChanged events to make the UI is in sync. This may invole a lot of refreshing in the UI (and lists).</p>
<p style="color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;orphans:auto;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:auto;word-spacing:0px;-webkit-text-stroke-width:0px;">So you may need to aggregate the notifications from BusinessRules.CheckRules(&quot;propertyName&quot;).</p>
<p style="color:#000000;font-family:Arial, Helvetica, sans-serif;font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;orphans:auto;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:auto;word-spacing:0px;-webkit-text-stroke-width:0px;">This is the actual code from PropertyHasChanged:</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;PropertyHasChanged(<span style="color:blue;">string</span>&nbsp;propertyName)
{
&nbsp;&nbsp;MarkDirty(<span style="color:blue;">true</span>);
&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;propertyNames&nbsp;=&nbsp;ValidationRules.CheckRules(propertyName);
&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(<span style="color:#2b91af;">ApplicationContext</span>.PropertyChangedMode&nbsp;==&nbsp;<span style="color:#2b91af;">ApplicationContext</span>.<span style="color:#2b91af;">PropertyChangedModes</span>.Windows)
&nbsp;&nbsp;&nbsp;&nbsp;OnPropertyChanged(propertyName);
&nbsp;&nbsp;<span style="color:blue;">else</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;name&nbsp;<span style="color:blue;">in</span>&nbsp;propertyNames)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OnPropertyChanged(name);
}</pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marian replied on Wednesday, September 10, 2014</h2><p>Thank you Jonny, for your attention and response. From Rocky&#39;s book, I understood that PropertyHasChanged is also involved in databinding. That was the reason for including it after each fields changing in my set property like this:</p>
<p><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;">&nbsp;&nbsp;&nbsp; Set(ByVal Value As Integer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanWriteProperty(True)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If mBaseField &lt;&gt; Value Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mBaseField = Value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mField1 = &quot;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropertyHasChanged(&quot;Field1&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mField2 = &quot;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PropertyHasChanged(&quot;Field2&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyHasChanged()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp; End Set</span></span></span><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"></span></span></span></p>
<p>Now, I replaced this piece of code like this:</p>
<p><span style="font-size:x-small;font-family:Consolas;color:#0000ff;">&nbsp;&nbsp;&nbsp; Set(ByVal Value As Integer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanWriteProperty(True)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If mBaseField &lt;&gt; Value Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mBaseField = Value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mField1 = &quot;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules(&quot;Field1&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mField2 = &quot;&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValidationRules(&quot;Field2&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyHasChanged(&quot;BaseField&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp; End Set</span></p>
<p><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-family:Arial;color:#000000;">Winform DataBinding is working properly, even for Field1 and Field2 properties. And the performance is obvious!</span></span></span></span></p>
<p><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-family:Arial;color:#000000;">Now,&nbsp;I&#39;m trying to understand why... because from Rocky&#39;s book, a call for&nbsp;PropertyHasChanged - that invoke OnPropertyChanged event&nbsp;is required for all properties, in order to be in sync with user interface - windows form.</span></span></span></span></p>
<p><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-family:Arial;color:#000000;">I will be back if I find the answer.</span></span></span></span><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;"><span style="font-size:x-small;font-family:Consolas;color:#0000ff;">&nbsp;</span></span></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, September 10, 2014</h2><p>Marian, if you raise a property changed event with a property name, WinForms will refresh that one field I believe.&nbsp; If you call PropertyHasChanged without giving a property name, it will redo the databinding for ALL bound controls.&nbsp; I think what you&#39;re seeing is a result of removing the last PropertyHasChanged call that didn&#39;t specify a property name.&nbsp; I&#39;m not sure what BaseField is, but I would expect you&#39;d need to call PropertyHasChanged for Field1 and Field2, but it depends on what is going on in the code you&#39;re not showing.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marian replied on Wednesday, September 10, 2014</h2><p>Thanks Andy, I will check the initial implementation, adding name of property as argument to PropertyHasChanged. Like this:</p>
<p>PropertyHasChanged(&quot;BaseField&quot;).</p>
<p>BaseField means the name of property that uses mFaseField field (implementing Get and set). Later I will check and post here the part of Rocky&#39;s book that defines PropertyHasChanged, with and without parameters.</p>
<p>I&#39;m not able to understand why my solution&nbsp;(based on validation.checkrules and without PropertyHasChanged for Field1, Field 2 Is working).</p>
<p>Databinding is implemented based on Rocky advice so.....</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marian replied on Wednesday, September 10, 2014</h2><p>Hi Andy,</p>
<p>Based on information from Rocky&#39;s book, PropertyHasChanged(), without parameters, uses System.Diagnostics to determine the name of the current property, with a possible performance hit. In order to remove this issue it&#39;s necessary to use PropertyHasChanged(&quot;PropertyName&quot;).</p>
<p>So, PropertyHasChanged() and PropertyHasChanged(&quot;PropertyName&quot;) has the same effect, only for current property. </p>
<p>Using my solution, it seems that my problem regarding slow response is solved....but I don&#39;t understand the issue related with databinding. Only&nbsp;one call of PropertyHasChanged, with current property name as parameter is enough for sync UI with all fields changed?</p>
<p>Best regards.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Wednesday, September 10, 2014</h2><p>Hi,</p>
<p>
In Windows Forms the databinding behavior is like this:
</p>
<p>
<ul>
<li>OnPropertyChanged()                          - update all properties&nbsp;</li>
<li>OnPropertyChanged(propertyName)   - update all properties except for propertyName&nbsp;
</li>
</ul>
</p>
<p>The last one is the reason CSLA provides the BindingRefresh component to make sure the the property that was changed is also refreshed (ex the prroperty value is modified in the settter - like uppercase or lowercase)
</p>
<p>
In Xaml the
</p>
<p>
<ul>
<li>OnPropertyChanged(propertyName) - will only refresh the actual property - NOT the other properties.</li>
</ul>
</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
