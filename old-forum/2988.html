<html><header><title>Whose responsibility is it?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Whose responsibility is it?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2988.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, June 05, 2007</h2><P>I have an application where I have to keep track of an object's child items in two collections.&nbsp; One collection is the primary collection and is used to persist the objects, etc.&nbsp; The other is essentially used to "bucket" or categorize the objects for other purposes (statistical, logical, etc.).&nbsp; I am wondering what the most recommended approach is and, ultimately, what suggestions you have about which object should be in charge of maintaining the second collection.</P>
<P>The key is that when I add or remove an item from the primary collection, it needs to also be added or removed from the "bucket" collection - which is a multimap (collection of lists) simply holding references to the objects contained in the other collection grouped by a key field.</P>
<P>I won't lead the witness too much because I am very interested in hearing your opinions and approaches, so I will leave it at that for now.</P>
<P>Thx in advance.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Tuesday, June 05, 2007</h2>Why not use the FilteredBindingList or ObjectListView to provide your logical views?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, June 05, 2007</h2><P>Yea, I guess that deserved&nbsp;a better explanation.</P>
<P>The "bucket" collection actually contains "bucket" objects which contain the collection of items that are also contained by the primary collection.&nbsp; This is because the "bucket" object contains some additional properties that summarize or aggregate the "grouped" items.&nbsp; Oh, and all of this is in memory at once and dynamic, so we can't have a filtered list that represents bucket1 and a separate one that represents bucket2 and so on.</P>
<P>Let me try to represent what we have going on:</P>
<P><CODE>RootObject<BR>&nbsp; &nbsp; Items As PrimaryCollection (of ChildItem objects)<BR>&nbsp; &nbsp; Buckets As BucketCollection (of Bucket objects)<BR>Bucket<BR>&nbsp; &nbsp; SomeProperty<BR>&nbsp; &nbsp; Items As PrimaryCollection (of ChildItem objects)<BR></CODE></P>
<P>When we add a ChildItem to the RootObject, it is added to the PrimaryCollection AND somehow needs to be added to the appropriate Bucket in the BucketCollection (with a new one created if it doesn't already exist).&nbsp; So, who should be responsible for managing this?</P>
<P>The typical ways of adding a child item would be:</P>
<P><CODE>RootObject.AddItem(childItem);<BR>RootObject.Items.Add(childItem);</CODE></P>
<P>Obviously the first gives us the ability to call the second plus call Buckets.Add(childItem) if that was the route we wanted to go.&nbsp; The latter would require us to hook up to ListChanged or some other way to handled when an item is added or removed because we shouldn't, imo, couple the PrimaryCollection to the BucketCollection (or should we)?</P>
<P>The former would require us to hide the Add, Remove, etc. methods from the two collections to avoid inadvertant use.&nbsp; So, all management functions would have to be handled by the containing object.&nbsp; But, they would still have to be exposed in order for the containing object (RootObject) to access them - declare them as internal???</P>
<P>Thoughts?</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Tuesday, June 05, 2007</h2>Sure, but there is no reason why the bucket should not be able to delegate the filtering to another class.<br><br>class Bucket<br>{<br>&nbsp;&nbsp;&nbsp; private ObjectListView _filteredItems; // Items that fit in this bucket will go here<br><br>&nbsp;&nbsp;&nbsp; //Constructor that accepts the primary collection of items.&nbsp; The ObjectListView will be aware of all<br>&nbsp;&nbsp;&nbsp; // additions, removals and changes to items in the list and only show the items that pass the filter<br>&nbsp;&nbsp;&nbsp; // criteria for that bucket.<br>&nbsp;&nbsp;&nbsp; internal Bucket(PrimaryCollection items, string filterString)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  _filteredItems = new ObjectListView(items, "PropertyToSortBy", filterString);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Exposes the list of filtered items<br>&nbsp;&nbsp;&nbsp; public ObjectListView FilteredItems<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  get { return _filteredItems; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; // Gets the sum of a property on all of items that passed the filter.<br>&nbsp;&nbsp;&nbsp; public int Sum<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  get<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  int sum;<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  for (int i = 0; i &lt; filteredItems.Count; i++)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  sum += (int)filteredItems[ i ]["PropertyToSum"];<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  return sum;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>class RootObject<br>{<br>&nbsp;&nbsp;&nbsp; private BucketCollection _buckets = new BucketCollection();<br>&nbsp;&nbsp;&nbsp; private PrimaryCollection _items;<br><br>&nbsp;&nbsp;&nbsp; DataPortal_Fetch()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  //Get PrimaryCollection from data source.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  // Create buckets<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; _buckets.Add(new Bucket(_items, "PropertyToFilterBy like 'A%'"));<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; _buckets.Add(new Bucket(_items, "PropertyToFilterBy like 'B%'"));<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; // Properties to expose buckets and items<br>}<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, June 05, 2007</h2><P><FONT face=Arial size=2>I am not familiar with the ObjectListView class.&nbsp; Can you explain it and where it is located?</FONT></P>
<P><FONT face=Arial size=2>It sounds like you are recommending having BucketCollection implemented so that it is responsible for listening for changes in the associated collection.&nbsp; Then, based on the filter "rules" applied, it will perform an action, such as adding and removing items, as well?</FONT></P>
<P><FONT face=Arial size=2>Also, how do we handle a case when a new item is added to the RootObject's PrimaryCollection that doesn't have a corresponding bucket yet?&nbsp; Ultimately, this is how the bucket objects will come into being:</FONT></P>
<UL>
<LI><FONT face=Arial size=2>A new ChildItem is added to the RootObject's PrimaryCollection (by whatever means)</FONT> 
<LI><FONT face=Arial size=2>If a Bucket exists for the ChildItem in the BucketCollection, the ChildItem is added to that Bucket.</FONT> 
<LI><FONT face=Arial size=2>Else, a new Bucket is created and that ChildItem added.</FONT></LI></UL>
<P><FONT face=Arial size=2>Likewise when an item is removed.&nbsp; If that is the last item in the bucket, the bucket should also be removed.</FONT></P>
<P><FONT face=Arial size=2>To go with your example, let's say our objects are Person classes with a LastName property.&nbsp; If we are creating buckets for the last name, our filtering would be on that property and, as you've shown, something along the lines of "LIKE A%".&nbsp; HOWEVER, we don't know the criteria up-front. It is only as items are added that the criteria is established.&nbsp; In other words, we wouldn't create 26 buckets with 25 empty if our only item was Bob Smith.&nbsp; In that case we would only have one bucket defined for the S% items.&nbsp; Should John Doe be added to the collection, we would then create a bucket for the D% cases.</FONT></P>
<P><FONT face=Arial size=2>I guess using a name is a bad example because our filtering would never be as finite as A-Z.&nbsp; It could be numeric based and of any range.</FONT></P>
<P><FONT face=Arial size=2>See my dilemma?</FONT></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Tuesday, June 05, 2007</h2>The ObjectListView class is a set of four classes that are available in CSLAcontrib.&nbsp; It behaves like the DataView except it works on lists of objects instead of a DataTable.&nbsp; So your root object listens to PrimaryCollection's ListChanged event and whenever an item is added (or the corresponding property is changed?) it checks to see if a bucket exists for the corresponding filter criteria.&nbsp; The RootObject also listens to the ObjectListView's ListChanged property in each bucket and if the .Count property goes to 0, it removes the bucket.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, June 07, 2007</h2><P>This is a great tool.&nbsp; I like what I've seen so far except that I have a problem when loading my objects from the database.&nbsp; The reason is that the child collection uses lazy-load to retrieve the data for its child objects.&nbsp; Because of this, we don't attach the ListChanged handler in our RootObject until AFTER the factory method has completed the DataPortal_Fetch call and already populated the collection.&nbsp; As a result, our buckets are empty.</P>
<P>Obviously, I can get rid of the lazy-load and have the data loaded with the RootObject, but I'd like a solution that keeps the door open for both options if possible.&nbsp; This is not the only child collection that we may use this approach for and there's a lot of data, so lazy-loading has been our best solution to improving the responsiveness of each individual operation.</P>
<P>Can you think of a way to accomplish the same thing given a lazy-load approach?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, June 07, 2007</h2>Try this in your lazy loader:<br><ol><li>Load data</li><li>Attach ListChanged handler</li><li>Add buckets</li></ol>You will need to manually scan the list when it is first loaded to determine which buckets to create.&nbsp; You could make the /RootObject's ListChanged handler handle ListChanged.Reset, which would clear your bucket collection, rescan the list, and add the appropriate buckets.&nbsp; When you first load the list, call your handler manually with the list and a ListChanged event arg that has a change type of reset.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, June 08, 2007</h2><P>Two&nbsp;questions about the ObjectListView:</P>
<UL>
<LI>why return an ObjectView from the indexer (this[int]) and not the underlying object? (Seems like a better name would be ObjectViewList in that case.)</LI>
<LI>am I correct that creating a new instance of an OLV, passing in my source collection and filter to the constructor, will essentially generate the view on-the-fly?&nbsp; So really what I need to do for a typical&nbsp;lazy-load scenario is to create a new instance of my OLV(s) after the source collection has been instantiated and populated.&nbsp; The OLV takes care of the rest, yes?</LI></UL>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, June 08, 2007</h2><ul><li>OLV follows the System.Data.DataView model.&nbsp; It exposes ObjectView items just as DataView exposes DataRowView items.&nbsp; This allows DataGridView and others to uses the ICancelEdit (or whatever its name is) interface to reverse changes and wait on applying changes until the value has been committed.&nbsp; This means that in a DataGridView you will edit the item, move off of the row, and <i>then</i> the row will be sorted and filtered.&nbsp; It is named ObjectListView because it is a view on a list of Objects.</li><li>Yes, the view is generated and sorts and filters on the fly.<br></li></ul></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, June 08, 2007</h2><P>sorry, one more...&nbsp; Why not a generic implementation?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, June 08, 2007</h2>Because at the moment you can set the list property to a list of a different type.&nbsp; The only thing a generic implementation would give you that I can think of off the top of my head is that you would not have to cast ObjectView.Object.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, June 08, 2007</h2><P>Brian, thanks for indulging my questions.&nbsp; This is a great addition to the Csla framework.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
