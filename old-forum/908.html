<html><header><title>Customizing CSLA</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Customizing CSLA</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/908.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>colinjack posted on Tuesday, August 15, 2006</h2><P>Hi Guys,</P>
<P>I'm going to have a few cases where I want to add members to existing CSLA types (BrokenRulesCollection being one example). As I see it I have two&nbsp;decent&nbsp;ways of doings this:</P>
<P>&nbsp;&nbsp;&nbsp;1) Create my own MyCompany.CSLA assembly, put the new types in there and derive from the CSLA ones (using InternalsVisibleTo from the CSLA assembly to my assembly).</P>
<P>&nbsp;&nbsp;&nbsp;2) Modify CSLA directly.</P>
<P>The first solution seems like it'll give me the easiest upgrade path...BUT I still need to modify CSLA to hook in my custom classes at the appropriate points so its not perfect.</P>
<P>I imagine you've all tackled this sort of thing so I'm wondering how you've done it?</P>
<P>Thanks,</P>
<P>Colin Jack</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 15, 2006</h2>I would opts for #1, since with #2 everytime there's a new version put out, you'll spend more time merging the changes with your changes...<br><br>If you need access to internal members of Csla and you're on .Net 2, add a file into Csla whcih includes the InternalsVisibleTo assembly attribute.&nbsp; This will allow you to keep everything seperate and still have access to internal Csla stuff, should you need it.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Tuesday, August 15, 2006</h2>I have had good success with keeping my copy of CSLA in Subversion.&nbsp; Whenever Rocky releases a new version of CSLA, I just unzip it over the top of my copy.&nbsp; TortoiseSVN tells me which files have been modified and I diff them to see what the changes are.&nbsp; The changes generally fall into one of two categories:<br><ol><li>Bugs fixes/new features from Rocky - I leave these.</li><li>Reverting customisations I have made back to vanilla CSLA - I choose my old version.</li></ol>The whole process takes about 15 minutes.<br><br>This allows me to make modifications directly to the CSLA files.&nbsp; For instance, I change SafeDataReader to implement ISafeDataReader instead of IDataReader.&nbsp; This allows me to have child classes that can be loaded by either SafeDataReader or my SafeDataRowReader.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 15, 2006</h2>Brian, I too keep Csla source in source control (Vault, in my case).&nbsp; I just dislike having to be very careful about merging... not to mention testing to make sure my changes to Csla don't really break anything.&nbsp; You can still have unit tests pass because they aren't thorough enough to test the exact situation that will cause a failure.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Wednesday, August 16, 2006</h2><P>I went the #2 route with the VS6 version.&nbsp; Boy oh boy did I go down the #2 route.</P>
<P>While handling new CSLA releases&nbsp;may seem like a 15 minute job with with the source control and merging functionality, if you're really planning on extensive modifications I don't think that is so easy once your modified version doesn't look so much like the original.&nbsp; Granted, there's so much more functionality in this version of CSLA and that risk is greately mitigated, but I for one am never going down that road again.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Wednesday, August 16, 2006</h2>One thing that you could do if you are going to make extensive modifications to CSLA is to keep the vanilla CSLA in a separate branch of your CSLA repository.&nbsp; You can then unzip the new versions on to the branch and this will highlight what the changes are.&nbsp; Then, if you want, you can merge the difference between the two versions on the branch back into your main version that has your customisations.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, August 16, 2006</h2><P>Having had a framework in place before "finding" CSLA, our approach was to use CSLA as a guide and toolset to improve our own framework - which we refer to as a hybrid-CSLA (on steroids) framework.&nbsp; With .NET 2.0, we went back to the drawing board and redesigned our framework from the ground-up but due to all of the customizations, extensions, etc. that we have in our framework we again chose a custom implementation.</P>
<P>With that in mind, the way we handle maintenance issues such as upgrades to the source code in CSLA (and other components we have access to the source code), is to maintain each version separately in our source control library.&nbsp; We do not merge versions.&nbsp; Then we can use a comparison tool such as BeyondCompare to diagnose what changes were made from version to version.&nbsp; Once identified, we can go through them and determine what may or may not need to be done to our own framework to leverage those changes.</P>
<P>We have found that this is rather painless once the framework is established on both sides.&nbsp; As mentioned in a previous post, most changes from one version to the next are going to be bug fixes (which may have already been caught) and/or enhancements to existing features that can be rolled into the framework in a similar manner if desired.&nbsp; Only when there is a major change, like going from 1.0 to 2.0 does this present a problem.&nbsp; But, since our framework needed retooling, it fit right in with our own plans (this time).</P>
<P>Because we aren't dependant upon the actual CSLA builds, we can chose when and if to implement the changes.&nbsp; This allows us to coincide this with scheduled upgrades and releases to our framework and better manage version creep that can occur with multiple projects using multiple versions of our framework refering multiple versions of CSLA and so on.</P>
<P>It has worked well for us thus far.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
