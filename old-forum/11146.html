<html><header><title>TO BE (Async), OR NOT TO BE...that is my question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>TO BE (Async), OR NOT TO BE...that is my question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11146.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele posted on Friday, February 10, 2012</h2><p>Wether to suffer the slings and arrows of (multi-threading)...and background workers...</p>
<p>OK sorry, enough butchering of Shakespeare.</p>
<p><b>Background:</b></p>
<p>Spent years sitting on CSLA 3.8 watching the trains go by (silverlight, windows phone etc.).&nbsp; I thought for sure I would have upgraded by now, but everytime I feel tempted I sit back and ask myself, what is this going to give me?</p>
<p>After much ado, my business layer has the 2 project scheme where it can compile for silverlight or normal by using linked files and compiler directives.&nbsp; I would say about 10-20% of my business objects are coded for both sync and async.&nbsp; I am forced to behave properly so that full async later won&#39;t be a nightmare!&nbsp; Doing this DEFINITELY forced me to see how my coding was based on sync assumptions.&nbsp; I was going to say &quot;bad habits&quot; but I don&#39;t know if there is intrinsic badness if sync works fine for our business needs.&nbsp; But maybe it is good just for ones ability to keep up in an increasingly muti-core, parralel, async world of skills out there.&nbsp; So I haven&#39;t used my silverlight code yet except for a small demo project that I compile alongside my ASP.NET.&nbsp; Nice to know I am ready to spring into action if need be.</p>
<p>I cannot stress enough the value of doing a small silverlight demo UI that I include in my web solution.&nbsp; I have to ensure it compiles and runs as I develop our web app.&nbsp; This showed me many flaws in my thinking, many assumptions and comfortabilities with the old ways.&nbsp; A curious effect was I gave up some of my unique solutions, and started using the more standard CSLA methods (auto-managed properties etc.) because they solved the problems I WOULD run into if I had to go down the multi-UI road.</p>
<p>My current and only application is an ASP.NET website with no glaring reason to change as it meets most of our needs.&nbsp; Its not super sexy, but we are slowly addressing that by ajaxifying/refactoring ui...and Telerik controls like the new RadAsyncUpload are helping us there.</p>
<p><b>Async or not</b></p>
<p>I have had two basic assumptions on the back burner of my mind for the last couple years:</p>
<p>1.&nbsp; It would be good if I would go back and make all my business layer fully Async-able (lack of better worrd)<br />2.&nbsp; It would be good if I would just make all my code async...and get used to just doing it that way.&nbsp; Mostly factory methods and business rules.</p>
<p>#2 is the key to my question!</p>
<p>I spent the last two days digging into the guts of understanding multi-threading/Async/BackgroundWorker from ASP.NET.&nbsp; What a nightmare of knowledge I didn&#39;t know I needed and not sure I want now that I have it!&nbsp; Yick.&nbsp; But I must say<b> I was completely surprised</b> by a truism from Rocky...&quot;Stay away from spinning up Background workers in ASP.NET&quot;</p>
<p>See the 2 following comments from Rocky...please trust me and him if you haven&#39;t done the research yourself...it is not recommended for a reason.&nbsp; Not that you can&#39;t do it...just not recommended.</p>
<p>http://forums.lhotka.net/forums/p/8512/40486.aspx#40486</p>
<p>http://forums.lhotka.net/forums/p/9231/43848.aspx#43848</p>
<p>I was blown away by this!&nbsp; I just hadn&#39;t gotten around to doing any BackgroundWorkers yet...but I was blown away to find out that I shouldn&#39;t!&nbsp; I assumed I could always speed things up in the future by refactoring long running tasks by splitting up using parallel BackgroundWorker tasks spawned from inside the main calling method.</p>
<p>OK so finally to my question.&nbsp; Assuming I am 100% ASP.NET client for the foresee-able years...</p>
<p><b>What good (other than preparedness and education) does Async in my business layer do me?&nbsp; I can&#39;t or shouldn&#39;t use it right?!</b></p>
<p>I feel like I have a mill-stone around my neck called legacy Sync code just so ASP.NET can run right!&nbsp; Yuck!</p>
<p>But maybe I am missing something.&nbsp; Johnny was good enough to alter the CSLA.BackgroundWorker to properly handle the switch back and forth from HttpContext.Current and TLS.&nbsp; But you are still officially saying don&#39;t use it because it wasn&#39;t designed for that.</p>
<p>Sean</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, February 10, 2012</h2><p>As I mentioned in the other thread, the new async/await keywords in .NET 4.5 will have an impact on whether to use async tasks in ASP.NET.</p>
<p>This is specifically because async/await does&#39;t necessarily (or automatically) create or use background threads, it just enables async operations.</p>
<p>Async operations can include the use of background threads, but it can also include the use of async calls to otherwise blocking IO operations. That latter scenario doesn&#39;t chew up another thread, but with async/await your primary thread doesn&#39;t have to block while the operation runs.</p>
<p>async/await is primarily designed for smart client scenarios, but I rather suspect it will have applicability in some ASP.NET scenarios too.</p>
<p>In the meantime though, your summary is pretty much spot-on - if you are building ASP.NET apps, and not building smart client apps, the cost of using async is almost always higher than any benefit you might get from using it.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Friday, February 10, 2012</h2><p>Whew!&nbsp; Thanks, it feels good to understand the landscape...so much to know these days.</p>
<p>OK so one final question.&nbsp; Do you consider these two scenarios the same in ASP.NET.</p>
<p>#1 - Async call to a factory method on a business object from ASP.NET (not recommended)</p>
<p>#2 - Sync call to a factory method on a business object - BUT - within this business object some parallel-ism is employed so that it spins off 2 or 3 Background worker threads...the business object factory method waits for each to complete and then returns to the ASP.NET page which made the original sync call.&nbsp; This insulates / hides any async from the ASP.NET.&nbsp;&nbsp; The point would be to cut down the time needed since presumably child operations could be carried out in parallel instead of serially.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele replied on Tuesday, February 14, 2012</h2><p>Anyone care to chime in with an opinion on this final question?</p>
<p>&nbsp;</p>
<p>Restated question:<br />Once inside a call to one syncronous factory method (say execute on a command object) from my asp.net page...is it bad (inside the business layer) to employ parallel background tasks and waiting for all the background workers to finish before returning execution back to the web page </p>
<p>Example:</p>
<ol>
<li>DoProcess.aspx calls BusinessLayer.DoProcess.Execute (syncronously)</li>
<li>Inside BusinessLayer.DoProcess I call 3 different tasks and do Task.WaitAll</li>
<li>When finish or error I return to aspx page</li>
</ol>
<p>This hides the async inside the business layer and the ASP.NET page thinks it is all syncronous.&nbsp; </p>
<p>Is that ok or bad too in ASP.NET?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, February 14, 2012</h2><p>If your DAL is running on the web server you have the same issues with using the thread pool as any other threading scenario.</p>
<p>If your DAL is running on an app server, so the root data portal call transfers to the app server, and the async DAL code is running on the app server, then you&#39;ve shifted the threading off the web server.</p>
<p>None of this is to say that you&#39;ll saturate your web server&#39;s thread pool by using async on the web server. That depends on your load, the duration of the data access operations, etc.</p>
<p>In other words, none of this is <em>inherently</em> bad - you just need to know the consequences of your choices so <em>if</em> bad thing happen you know why, and how to address them.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
