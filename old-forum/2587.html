<html><header><title>GUI-Problem with BindingSourceControl - No chance to call CancelEdit()</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>GUI-Problem with BindingSourceControl - No chance to call CancelEdit()</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2587.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan posted on Monday, March 26, 2007</h2>Hi @ all!<br><br>My situation:<br>The objects:<br>I have an object that represents a userdefined query (UserQuery).<br>The UserQuery has a child-collection of 'Criteria'-children (CriteriaCol).<br>In my EditUserQuery form I have a couple BindingSource controls:<br>- UserqueryBindingSource, bound to the root object<br>- CriteriaBindingSource, bound to the Criteria-collection inside the root object<br>- CurrentCriteriaBindingSource, bound to the currently seleted criteria (read on...)<br><br>The GUI:<br>The entire list of criteria is displayed in a DataGridViewControl, which is bound to <br>CriteriaBindingSource. There I display the descriptions of each criteria item (= read only).<br>The user selects a specific criteria item for editing  by clicking on the DataGridView.<br>Then the CurrentCriteriaBindingSource is bound to the selected item. On the same form, <br>there is a region for editing a single criteria item. The controls in this region are bound <br>to the currently selected criteria item through the CurrentCriteriaBindingSource.<br>There are two buttins in this area: <br>- btnUpdateCriteria, which calls CurrentCriteriaBindingSource.EndEdit()<br>- btnCancelEdit, which calls CurrentCriteriaBindingSource.CancelEdit()<br><br>The problem:<br>Clicking on the DataGridViev loads the selected criteria into the edit-area - fine.<br>After editing the current criteria object, I have no chance to Cancel the edit process, <br>because as soon as the focus gets to another control that's not bound to CurrentCriteriaBindingSource,<br>the DataGridView updates and shows the modified values. Calling CancelEdit on the CurrentCriteriaBindingSource has no effect.<br><br>I think there is a flaw in how I deal with the different BindingSource controls, but I have no idea.<br><br>Hope that someone can help me find a solution!<br><br>Stefan<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Monday, March 26, 2007</h2>Hey,<br><br>You should break it down further into all elementary use cases. The key realization is that your single form supports multiple use cases simultaneously:<br>1 - show the details of a single UserQuery<br>2 - show the list of all criteria for this UserQuery<br>3 - edit a single Criteria <br><br>It is not clear to me how you would like your form to work:<br>a) editable criteria list with editable criterias:<br>&nbsp;&nbsp;&nbsp; - users can add/remove/edit criteria's to the list<br>&nbsp;&nbsp;&nbsp; - each criteria is editable by itself on which changes can be canceled AND users can cancel the WHOLE set of changes done to the list as a whole (i.e. undo all additions/removals and edits)<br><br>b) only changes to a single criteria can be undone<br><br>c) also the UpdateQuery has editable properties, and Cancel should cancel all changes to the list of criteria as mentioned under a) AND any changes to UpdateQuery itself<br><br><br>The key difference is the following:<br>- in a) the use cases 2 and 3 are actually the same use case<br>- in b) 2 and 3 are really distinct use cases<br>- in c) there is only one use case that involves all of 1, 2 and 3<br><br>Now comes the mantra: you should model after use cases, i.e. you need a top-level (root) object for each single use case.<br><br>For 1)<br>- if the UpdateQuery has editable properties it should be an editable root<br>- otherwise it can be a readonly object<br><br>For 2)<br>- if changes to the list (add/remove) should be cancellable, use an editable list, depending on whether the canceling should involve the UpdateQuery (as in c)) or not (as in a)) this is an EditableChildList or an EditableRootList<br>&nbsp;&nbsp;&nbsp; - in case of EditableChildList, UpdateQuery would have a property for this purpose<br>&nbsp;&nbsp;&nbsp; - in case of EditableRootList the UpdateQuery object could provide a GetCriterias() function that returns all relevant Criterias in a editable root list for this purpose<br>- otherwise it will be a ReadOnlyList (root) which can be fetched/refreshed independently (perhaps through a UpdateQuery.GetCriteriaList() function)<br><br>For 3) <br>- depending on your sitiation for 2) you would have an EditableRoot or an EditableChild object here<br>- in case of b) (editableroot) you can fetch the object based on the ID that corresponds to the selected row in your grid<br>- in case of a) or c) you already have an editable copy of your object, so you don't need to fetch anything anymore<br><br><br>Now about your Cancel and Update buttons:<br>- in case of a) <br>&nbsp;&nbsp;&nbsp; - you would need to begin a new edit (invoke BeginEdit() on the Criteria object) when binding the Criteria, and later on you can then cancel or commit the change <br>&nbsp;&nbsp;&nbsp; - independently you will also invoke BeginEdit on the list object which will be paired with en EndEdit upon Save<br>&nbsp;&nbsp;&nbsp; - optionally you can provide a CancelAll button that routes to the list's CancelEdit<br><br>- in case of b)<br>&nbsp;&nbsp;&nbsp; - the list is readonly, changes to Criteria objects are beyond the scope of the list, so there is only BeginEdit and EndEdit/CancelEdit to be invoked on the Criteria object<br>&nbsp;&nbsp;&nbsp; - note that the readonly list will not synchronize automatically with changes to criteria objects, so this is why you need this list to be root-level so you can refetch it independently (and refresh your bindingsource)<br><br>- in case of c)<br>&nbsp;&nbsp;&nbsp; - similar to a), but now you can begin, cancel and end edits on 3 levels (UpateQuery/EditableChildList and Criteria)<br><br>Note that in typicaly UI designs you only provide Cancel buttons for the top-level object(s), users typically do not have a clue what you mean by CancelAll vs Cancel.<br><br>Perhaps I helped you out a bit, or perhaps I just added to the fog. ;-)<br><br>I hope the former though. ;-p<br><br>Regards,<br>Bayu<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
