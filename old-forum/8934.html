<html><header><title>CSLA4 Async Ruel not set BusinessRules.RunningAsyncRules on time</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA4 Async Ruel not set BusinessRules.RunningAsyncRules on time</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8934.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>HK.Lee posted on Friday, May 14, 2010</h2><p>Hi Rocky,</p>
<p>My business objects&nbsp;often do BusinessRules.CheckRules() on DataPotal Fetch after retrieving data. The problem is if async rule is included, it looks not set&nbsp;&nbsp;BusinessRules.RunningAsyncRules on time&nbsp;when async rule&#39;s context.Complete() is called.</p>
<p>&nbsp;What I&#39;m saying on time is&nbsp;if it runs through debug mode line by line,RunningAsyncRules is set &#39;false&#39; correctly,but if runs fast, it says &#39;true&#39; in BusinessRules.CheckRule.&nbsp;&nbsp;&nbsp;I only guess it needs time to complete RuleContext.Complete method&#39;s handler, but don&#39;t know in detail. Because of this, BB&#39;s IsBusy always set true so ViewModel&#39;s Can_ properties goes wrong so&nbsp;enable/disable state of view&#39;s buttons are not set as desired. </p>
<p>Thank you in advance.</p>
<p>HK.Lee</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, May 14, 2010</h2><p>If you have async rules that are going to run on the server (like in DataPortal_Fetch()) then you must ensure that the server call doesn&#39;t complete before the rules are done running.</p>
<p>The way to do this is to use a thread synchronization primitive to block the main thread, and to handle ValidationComplete to unblock that main thread. (that technique won&#39;t work in SL because threading is handled differently, but it works fine in ASP.NET).</p>
<p>So in DP_Fetch (typed from memory, excuse minor typos):</p>
<p>var waiter = new System.Threading.AutoResetEvent(false);<br />this.ValidationComplete += (o, e) =&gt; waiter.Set();<br /><br />// load object and do your normal stuff<br />// ...<br /><br />waiter.WaitOne();</p>
<p>This blocks the main server thread until all validation is complete, at which point the server thread continues and the call is returned to the client.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 14, 2010</h2><p>I wonder though, if maybe there should be a way to tell BusinessRules to treat all async rules like sync rules...</p>
<p>That way when you check the rules on a server (like within the data portal) you wouldn&#39;t have to worry about this issue - you&#39;d just have the rules run synchronously and be done with it.</p>
<p>In fact, that could be the default when the logical execution location is &#39;server&#39;. If you really want the async behavior on the server then you&#39;d have to override the default - and add the code to handle the threading issues.</p>
<p>I think I&#39;ll have to try this - I like the idea. Thanks! <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HK.Lee replied on Friday, May 14, 2010</h2><p>Hi Rocky,</p>
<p>I appreciate your kind reply and will try to your idea to treat async rules like sync rules.</p>
<p>Thanks.</p>
<p>HK.Lee</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 17, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>
<p>I wonder though, if maybe there should be a way to tell BusinessRules to treat all async rules like sync rules...</p>
<p>That way when you check the rules on a server (like within the data portal) you wouldn&#39;t have to worry about this issue - you&#39;d just have the rules run synchronously and be done with it.</p>
<p>In fact, that could be the default when the logical execution location is &#39;server&#39;. If you really want the async behavior on the server then you&#39;d have to override the default - and add the code to handle the threading issues.</p>
</div></p>
<p>I thought about this further, and it really isn&#39;t that easy. The reason it isn&#39;t easy is that the rules themselves are async. It isn&#39;t like CSLA invokes them on a background thread, it doesn&#39;t. It is the rule itself that runs things on a background thread.</p>
<p>So the only real solution, I think, is to make the rule itself smart enough to run synchronously on the server, and async on the client - probably using the logical execution location property from Csla.ApplicationContext.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HK.Lee replied on Tuesday, May 18, 2010</h2><p>Hi Rocky,</p>
<p>I tried LogicalExecutionLocation as follows and it seems to work. My business rule is a kind of &#39;Exist&#39; rule of PTtracker, which calls SP to see same name exists in a field of table.</p>
<p>&nbsp; public class DupeNameExistRule : Csla.Rules.BusinessRule<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public DupeNameExistRule(Csla.Core.IPropertyInfo primariProp, Csla.Core.IPropertyInfo chkProperty, DupeNameCriteria criteria)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(primariProp)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // IsAsync = true;<br /><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsAsync = (Csla.ApplicationContext.LogicalExecutionLocation == ApplicationContext.LogicalExecutionLocations.Client);<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _chkProperty = chkProperty;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _criteria = criteria;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputProperties = new System.Collections.Generic.List&lt;Csla.Core.IPropertyInfo&gt; { primariProp, _chkProperty };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DupeNameCriteria _criteria;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Csla.Core.IPropertyInfo _chkProperty;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void Execute(RuleContext context)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get current field value<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string curr = context.InputPropertyValues[PrimaryProperty].ToString();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int chkId = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (context.InputPropertyValues[_chkProperty] != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chkId = (int)context.InputPropertyValues[_chkProperty];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _criteria.SetValue(curr, chkId);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp; if (IsAsync)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DupeNameExists.DupeNameCheck(_criteria, (o, e) =&gt;<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Error != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.AddErrorResult(e.Error.Message);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (e.Object != null &amp;&amp; e.Object.Exist)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddErrorResult(context);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Complete();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />#if !SILVERLIGHT<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var result = DataPortal.Fetch&lt;DupeNameExists&gt;(_criteria);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (result.Exist) AddErrorResult(context);<br />#endif<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void AddErrorResult(RuleContext context)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.AddErrorResult(String.Format(Properties.Resources.AlreadyExtstFieldName,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _criteria.FieldValue, PrimaryProperty.FriendlyName));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p>When run this code,&nbsp;proper method is called along with current execution location and all seems working fine. Before more refactoring be taken, I&#39;d like to&nbsp;listen any advice or something I missed.</p>
<p>HK.Lee</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 18, 2010</h2><p>That is what I was hoping. I do think there&#39;s one issue, and that is with how you set IsAsync. I wonder if I don&#39;t need to make IsAsync a virtual property so you can override its getter.</p>
<p>The reason I think this, is that in a 2-tier physical deployment (like with a WPF app or something), everything runs in one AppDomain. So the rule would be sync or async based on where it was initialized, and that would be true for the entire app. When really you&#39;d want it to switch between sync and async depending on whether it was run from the logical &quot;client&quot; or logical &quot;server&quot;.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HK.Lee replied on Tuesday, May 18, 2010</h2><p>Hi Rocky,</p>
<p>I didn&#39;t assume 2 Tier deployment and your advice is correct. </p>
<p>Hope to see more fine grained way in the RTM.</p>
<p>Thank you in advance.</p>
<p>HK.Lee</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>OscarLauroba replied on Wednesday, February 23, 2011</h2><p>Hello HK.Lee</p>
<p>I&#39;m not clear about the issue that Rocky says.</p>
<p>Is your code correct or needs any modification in reference to what Rocky says about 2 tier deployment. I see your code is using <span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;font-size:10pt;mso-no-proof:yes;">Csla.ApplicationContext.LogicalExecutionLocation in the constructor. Is this the right place or it should be in the Execute method?</span></p>
<p>&nbsp;Oscar.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Wednesday, February 23, 2011</h2><p>HI Oscar,</p>
<p>The code should test for ApplicationContext.ExecutionLocation rather than ApplicationContext.LogicalEexecutionLocation. </p>
<p>ApplicationContext.ExexutionLocation == ExecutionLocations<span style="color:#006400;">.</span>Server only when code is executed on a server, </p>
<p>The rule.IsAsync property must be set in the rule constructor&nbsp; and is used by the rule engine to determine how to call the Execute method. Remember that <b>all </b>properties of a rule should be immutable and only be set in the constructor.&nbsp; You should NEVER change the IsAsync property in the Execute method.</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>OscarLauroba replied on Thursday, February 24, 2011</h2><p>Hello Jonny, </p>
<p>I&#39;m testing my silverlight application and to determine if my ProjectExists rule is Asychronous or not I&#39;m doing this in the constructor as you recommend using ExecutionLocation: (sorry, it&#39;s VB.Net)</p>
<p>IsAsync = (Csla.ApplicationContext.ExecutionLocation &lt;&gt; ApplicationContext.ExecutionLocations.Server)</p>
<p><br />IsAsync will be true whenever ExecutionLocation is not Server. But when the application runs it executes twice the rule constructor: first time ExecutionLocation is Client, second time ExecutionLocation is Silverlight, so&nbsp;the rule is always asynchronous. In which case HK Lee&#39;s code doesn&#39;t work?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, February 24, 2011</h2><p>If you are running 3 tier app (ie not using LocalProxy ) the rule will be created on both Client and Server as separate instances. </p>
<p>Look at the callstack to determine when the rule constructor is called. </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
