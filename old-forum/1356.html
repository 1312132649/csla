<html><header><title>Parametrize query VS SCOPE_IDENTITY() - WTF?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Parametrize query VS SCOPE_IDENTITY() - WTF?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1356.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch posted on Thursday, September 28, 2006</h2><P>I'm having some problem getting the value of SCOPE_IDENTITY() immediatly following a paremetrize query, but works fine after a straight hard coded command.</P>
<P><BR>SAMPLE #1</P>
<P>// Insert command hard coded parameter<BR>IDbCommand dbCommand = this.DataFactory.CreateCommand();<BR>dbCommand.CommandType = CommandType.Text;<BR>dbCommand.CommandText = string.Format(<BR>&nbsp;&nbsp;&nbsp;&nbsp;"INSERT INTO [Severity] ([Descriptor]) VALUES ('{0}')",<BR>&nbsp;&nbsp;&nbsp;&nbsp;ColumnNames.Descriptor);</P>
<P>// Execute the parametrize query<BR>dbCommand.ExecuteNonQuery();</P>
<P>// Get the SCOPE_IDENTITY()<BR>IDbCommand dbScopeCommand = this.DataFactory.CreateCommand();<BR>dbScopeCommand.CommandType = CommandType.Text;<BR>dbScopeCommand.CommandText = "SELECT SCOPE_IDENTITY()";</P>
<P>this.SeverityId = int.Parse(dbScopeCommand.ExecuteScalar().ToString());</P>
<P><BR>----------------------------------------------------------------------</P>
<P>SAMPLE #2</P>
<P>// Insert command using a parametrized query<BR>IDbCommand dbCommand = this.DataFactory.CreateCommand();<BR>dbCommand.CommandType = CommandType.Text;<BR>dbCommand.CommandText = "INSERT INTO [Severity] ([Descriptor]) VALUES (@p1)";</P>
<P>// Add the parameter<BR>IDbDataParameter p = dbCommand.CreateParameter();<BR>p.ParameterName = "@p1";<BR>p.DbType = DbType.String;<BR>p.Value = this.Descriptor;<BR>p.Direction = ParameterDirection.Input;<BR>dbCommand.Parameters.Add(p);</P>
<P>// Execute the parametrize query<BR>dbCommand.ExecuteNonQuery();</P>
<P>// Get the SCOPE_IDENTITY()<BR>IDbCommand dbScopeCommand = this.DataFactory.CreateCommand();<BR>dbScopeCommand.CommandType = CommandType.Text;<BR>dbScopeCommand.CommandText = "SELECT SCOPE_IDENTITY()";</P>
<P>this.SeverityId = int.Parse(dbScopeCommand.ExecuteScalar().ToString());</P>
<P><BR>----------------------------------------------------------------------</P>
<P><BR>In both cases the insert command runs with no problem BUT the SCOPE_IDENTITY() command will fail and will throw an "Input string was not in a correct format" with I run&nbsp;SAMPLE #2 using the parametrize query.&nbsp; WTF ???&nbsp; The value returned in sample #2 is always 'null'.</P>
<P><BR>Csla.DataPortalException: DataPortal.Update failed ---&gt; Csla.Server.CallMethodException: DataPortal_Insert method call failed ---&gt; System.FormatException: Input string was not in a correct format.<BR>&nbsp;&nbsp; at System.Number.StringToNumber(String str, NumberStyles options, NumberBuffer&amp; number, NumberFormatInfo info, Boolean parseDecimal)<BR>&nbsp;&nbsp; at System.Number.ParseInt32(String s, NumberStyles style, NumberFormatInfo info)<BR>&nbsp;&nbsp; at System.Int32.Parse(String s)<BR>&nbsp;&nbsp; <BR>&nbsp;&nbsp; <BR>Any ideas?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Thursday, September 28, 2006</h2><P>BTW, if I use @@IDENTITY instead of SCOPE_IDENTITY() it works.&nbsp; But If I use @@IDENTITY I will run into other issues down the road with insert triggers an al - so SCOPE_IDENTITY() is by far the right solution.</P>
<P>Thanks</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Thursday, September 28, 2006</h2><P>Okay, this one works but not very elegant in my opinion.</P>
<P>// Insert command using a parametrized query<BR>IDbCommand dbCommand = this.DataFactory.CreateCommand();<BR>dbCommand.CommandType = CommandType.Text;<BR>dbCommand.CommandText = "<FONT color=#000080>INSERT INTO [Severity] ([Descriptor]) VALUES (@p1); SELECT SCOPE_IDENTITY()</FONT>";</P>
<P>// Add the parameter<BR>IDbDataParameter p = dbCommand.CreateParameter();<BR>p.ParameterName = "@p1";<BR>p.DbType = DbType.String;<BR>p.Value = this.Descriptor;<BR>p.Direction = ParameterDirection.Input;<BR>dbCommand.Parameters.Add(p);</P>
<P>// Execute the parametrize query<BR>dbCommand.ExecuteNonQuery();</P>
<P><FONT color=#000080>this.SeverityId = int.Parse(dbCommand.ExecuteScalar().ToString());</FONT></P>
<P>-----------------------</P>
<P>What I did is very simple, i've combined both command into so that both are ran within the same scope context.</P>
<P>Is there a better way retain the scope context between 2 individual IDbCommand?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, September 29, 2006</h2>Is there a reason you're not using a stored procedure?&nbsp; I'm not sure why the commands in #2 aren't running in the same scope; perhaps parametizing things creates another context?&nbsp; If you can though I'd recommend putting the insert into an sp which has an output parameter through which you can pass the value from scope_identity().<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Friday, September 29, 2006</h2><P>Thanks guys for your input here - it is appreciated.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Is there a reason you're not using a stored procedure?&nbsp; I'm not sure why the commands in #2 aren't running in the same scope; perhaps parametizing things creates another context?&nbsp; If you can though I'd recommend putting the insert into an sp which has an output parameter through which you can pass the value from scope_identity().<BR></div></BLOCKQUOTE></P>
<P>The reason I'm not using store proc is that I'm currently writting a DAL that will enable our CSLA based application to connect to more than one database like SQL Server, Oracle, and Firebird just to name a few.&nbsp; I'm a big fan of code generation and the DAL layer is generated in .Net code only - so no store procs here.&nbsp; While this approach will bring forward some issues like the one I've just experienced, having the entire DAL generated in .Net code will allow for strongly typed data entity that maps back top the database tables and columns.&nbsp; Thus, having a compile error instead of a runtime error when the data schema is altered due to new features or other reasons.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, October 02, 2006</h2>GuyRoch,<br><br>Understand your reasoning, I have my own DAL as well.&nbsp; However I designed my DAL to always use stored procedures when connecting via Sql Server.&nbsp; Basically my Sql server provider assumes certain things.<br><br>For example, for the Employee table, the DAL assumes a view exists called vEmployee, which is just a select * from employee.&nbsp; It also assumes procedures exists, apEmployeeInsert, apEmployeeUpdate, apEmployeeDelete.&nbsp; The procs do just what you expect.<br><br>The nice part is that once I forced these rules I was able to create an entity generator; it looks at a table, and creates the view, procs and .cs files for me, all ready to go.&nbsp; <br><br>There's no reason you can't have different rules for each provider.&nbsp; I successfully created a DAL that worked with SPs when connecting to Sql Server, but used direct ad-hoc queries for a Filemaker database (which supports only the most basic sql).<br><br>I know you may not be able to change direction for whatever reason, but it may be worth thinking about because of the code gen advantages.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Monday, October 02, 2006</h2><P>Andy,</P>
<P>Sounds good, but what do you do when you encounter a data type not supported in both databases.&nbsp; For example a&nbsp;timestamp data type exists in SQL Server but does not&nbsp;not exists is Oracle.&nbsp; What did you do to get around this issue - or was it not an issue for you guys.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, October 03, 2006</h2>Guy,<br><br>Aren't timestamps read only and come back as a byte[] in .net?&nbsp; What particular problem are you having?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, November 01, 2006</h2><P>I got an answer to this question from Erland Sommarskog - a long time SQL Server MVP.</P>
<P>&lt;quote&gt;</P>
<P>Apparently, you send an unparameterised command<BR>with ExecuteNonQuery, and in that case it will work. But if you would<BR>starting using parameters, it would break.</P>
<P>scope_idenity() returns the most recently generated IDENTITY value in<BR>the current scope. "scope" is a "stored procedure", "block of dynamic<BR>SQL" etc. And the top level of a connection is also a scope.</P>
<P>As long as you don't use parameters, ADO .Net will send bare SQL commands<BR>to SQL Server and they will thus execute in the top-level scope. But<BR>if you use parameterised commands, ADO .Net implements this by calling<BR>sp_executesql, and thus the INSERT commands excutes in a lower-level<BR>scope, and thuse the call to scope_idenity will not return any value.</P>
<P>From this it may sound that using parameters with ADO .Net is a bad<BR>idea, but in fact it is a very good idea. Parameterised commands<BR>increases the chances for cache reuse, and decreases the risk for<BR>the cache being cluttered. Parameterised commands is also the basic<BR>protection against SQL injection.</P>
<P>&lt;/quote&gt;</P>
<P>So you can send sequential commands across the same connection and it will work correctly - and a transaction uses the same connection so it works too.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>guyroch replied on Wednesday, November 01, 2006</h2>Thanks for posting this Joe.&nbsp; This is valuable information.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Friday, September 29, 2006</h2>I don't think you'll ever get SCOPE_IDENTITY to work across two different executed commands. A scope is a stored procedure, trigger, function or batch and you're not within one of any of them.<br><br>Your second example (INSERT INTO [Severity] ([Descriptor]) VALUES (@p1); SELECT SCOPE_IDENTITY()) works because they are indeed in the same batch.<br><br>If you don't like the batched pattern, you're only recourse is to create a procedure.<br><br>There is one other thing you can do but I wouldn't recommend it. You could use: SELECT IDENT_CURRENT('Severity') which will return the last IDENTITY set for the specified table, but you can't be sure that the last one was yours.<br><br>- John<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
