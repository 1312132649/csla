<html><header><title>Design Suggestions Request</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Design Suggestions Request</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2799.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lefty posted on Monday, April 30, 2007</h2><br>I'm about to start working on a project to port a fairly large legacy application over to newer technology (Mainly C#, SQL Server 2005, and most likely CSLA).&nbsp; We love the way CSLA handles the validation rules and the business objects, and OOing the application is going to make mantaining it about a million times easier.&nbsp; I'm hoping someone will be willing to give us some suggestions and let us know what parts of our ideas are doable or not with CSLA, and if there are better ways of doing it then what we're planning.<br><br>To start the legacy application is basically a fat client loan origination system written in Progress that was originally ported over from old mainframe code.&nbsp; It keeps track of our loan applications as well as the current status of the applications.&nbsp; All the business logic exists within the client and it's rather chatty, so it only works on the local network.&nbsp; It's also pretty old and over the years all the new features that have been hacked in have made it slightly unstable.&nbsp; It's very similar to a mainframe application were they make changes on various screens and save the changes each time before changing screens.<br><br>There are some features we currently have that we would want to try an mimic as closely as possible in the new version.&nbsp; Currently we have an audit system that only audits selected database fields in a generic audit table.&nbsp; This makes it very easy to audit and display only the 10-15 fields that we care about in the order that they were changed showing the old value, new value, when it was changed and by who.&nbsp; This audit log gets used regularly by the supervisors and ease of use is important.<br>We also have record locking in the database so that only one person can edit/view an application at a time.&nbsp; The locking does get in the way sometimes, but because of the way the business works it's somewhat common for 2 people to attempt to access the same application at the same time, so we would need someway to deal with that.<br>We also currently have "on-the-fly" validation for each field.&nbsp; This is something that that we absolutely want to keep.&nbsp; Each time an agent edits a field there is a list of field rules that run that verify the data, lookup data in the database to fill into other fields, etc.&nbsp; An example would be the interest rate getting filled in to a read-only field automatically after the loan amount and term are entered.<br>The current system is also very easy to update.&nbsp; The client resides on our file server and I can update individual screens on the fly without having to install anything extra to the users computers.<br><br>What we're looking at is setting it up as an ASP.NET application using CSLA.&nbsp; AJAX would be used to provide the rich UI and do validation call-outs to the server so that we don't need to rewrite the validation rules in the UI.&nbsp; It could also be easily updated at a central location (the web server) without requireing installs at every workstation, and would work for remote users as long as the AJAX wasn't too crazy.&nbsp; From everything I've read in these forums I think we're going to go with a trigger based audit system with history tables, however I'm not sure how to display the history data to the users yet in a easy to understand format..<br><br>Concurrency is about the only thing we're running into with this method, because I don't really want two people editing the same data at the same time.&nbsp; The method of checking a timestamp field before update would work, but I don't want the agent entering a bunch of data and then when they go to save they find out that everything they did was rejected.<br><br>At this point we currently don't have any directives about how we have to implement it, so we aren't locked in to the ASP solution.&nbsp; Please let me know if there are any suggestions or pointers on how to implement these ideas or any better ways to do it.<br><br>Thanks<br>Jeff<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, April 30, 2007</h2><P>Jeff,</P>
<P>All of this sounds like a good approach.</P>
<P>The concurrency issue can be solved in many ways. The one you describe above is the "frustrating" version for a user.</P>
<P>Since it is a common experience for more than 1 users to try to edit the same document, you can try implementing an application level locking mechanism. This can be a separate database table that stores information about the document being locked. You insert a row to lock a docuemnt and you delete the row to unlock the document. When your user requests a document you first attempt to acquire the lock. You look in this table and check to see if the doctype and doc PK are in the table. If not, you can acquire the lock and then insert those values (plus others you may want to track).</P>
<P>When another user attempts to acquire the same document, they won;t be able to get the lock and you can tell them that User X is editing the document beginning at time Y.</P>
<P>When the user is done editing the document and they save it successfully, you can remove the lock.</P>
<P>Things to watch out for:</P>
<P>1. Users abandoning their edit in "unapproved ways". e.g. let session expire, close browser, etc.</P>
<P>We trapped for many of these occurences and attempted to release the lock. This works in 90% of all cases, but there are still odd ways that a lock can be abandoned. </P>
<P>2. You need to provide an Admin UI to release a given lock. This allows your users to call this Admin and tell them they need to be able to edit a locked document. The Admin can check with the current user to see if they are really still editng the document or not and then they can remove the lock.</P>
<P>Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lefty replied on Tuesday, May 01, 2007</h2>Thanks everyone for the suggestions, I think they are going to help with our design.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Patrick.Roeper replied on Saturday, November 03, 2007</h2><P><FONT face=Verdana size=2>I had to resurface this thread because I expect I will need to deal with this concurrency issue myself in the near future. </FONT></P>
<P><FONT face=Verdana size=2>I like the design that Joe mentioned, mainly because I can extend this to not only locking BO's but also for locking certain UI's that only 1 person should be in at a time. However, my concern stems from the following case:</FONT></P>
<P><FONT face=Verdana size=2>Object A is not in a locked state.<BR>User 1 needs to access Object A for read-only purposes.<BR>User 1 obtains lock for Object A.<BR>User 2 needs to access Object A for edit purposes.<BR>Object A is currently locked by User 1.</FONT></P>
<P><FONT face=Verdana size=2>The solution is to not lock Object A for users who only need read-only access, but I am at a loss as to how I could come up with an elegant solution to this. From the perspective of an end user, I would not want to be "overly burdened" by having to open a form in a different way just to achieve read-only access.</FONT></P>
<P><FONT face=Verdana size=2>I would love to hear some suggestions on possible UI designs for this. We are using WinForms for presentation. The only thing that is popping into my head right now is examining the modifier keys when a user is opening an interface..</FONT></P>
<P><FONT face=Verdana size=2>Thanks.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Sunday, November 04, 2007</h2><P>We started with a similar application migration and have avoided locking entirely.</P>
<P>There are several ways to implement concurrency, but we have chosen to implement what we call "changed values concurrency" and not do any locking. First change to a field from a loaded object "wins", any others result in a concurrency exception when the "stale"&nbsp;but changed object is saved. However, two users can independently update separate fields in the same object and both updates can succeed. </P>
<P>We chose this approach mainly&nbsp;because it requires no database-specific features (e.g. timestamp columns), nor does it require any alteration of the database schema. Also, the odds of two users really wanting to edit the same object are low because of the way the data is partitioned, so we mainly wanted to ensure integrity of the data. This approach works well except for contrived situations (e.g. one user updates city, another updates zip code). </P>
<P>With code generation, it's easy to capture original values of properties in the property setter when they are changed to they are available to the concurrency implementation. Also, we have situations in which the logic itself really needs to know if a specific field was changed at the time the object is saved -- e.g. IsDirtyProperty("PropertyName"), and the concurrency mechanism doubles for this purpose. Not only that, but we also have a field-level auditing mechanism for any field in the database, and this becomes almost trivial to implement with this concurrency mechanism in place.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, November 05, 2007</h2><P>Patrick,</P>
<P>I just ran into that issue and I resolved it by adding an optional parameter to my factory method.</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> NewBO(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> key </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Integer</FONT><FONT size=2>, </FONT><FONT color=#0000ff size=2>Optional</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> useEditScreen </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean</FONT><FONT size=2> = </FONT><FONT color=#0000ff size=2>True</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> BO</P></FONT>
<P><FONT size=2>useEditScreen&nbsp;</FONT> is passed to the DataPortal by my Criteria class and then I only acquire the lock when it is True.</P>
<P>(On my Read Only screen I obviously set it to False.)</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>If</FONT><FONT size=2> useEditScreen </FONT><FONT color=#0000ff size=2>Then<BR>&nbsp; </FONT><FONT size=2>Lock = Applock.GetLock(key)</P>
<P></FONT><FONT color=#0000ff size=2>&nbsp; If</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Not</FONT><FONT size=2> Lock.LockAcquired </FONT><FONT color=#0000ff size=2>Then<BR></FONT><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; Throw</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>New</FONT><FONT size=2> ApplicationException(</FONT><FONT color=#ff00ff size=2>"Record is locked by "</FONT><FONT size=2> &amp; Lock.Username &amp; </FONT><FONT color=#ff00ff size=2>" via the use of "</FONT><FONT size=2> &amp; Lock.LockDescription &amp; </FONT><FONT color=#ff00ff size=2>"."</FONT><FONT size=2>)<BR>&nbsp; </FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>If</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>If</P></FONT>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Monday, April 30, 2007</h2><P>Overall, I think your approach makes good sense.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>lefty:</strong></div><div><BR><BR>Concurrency is about the only thing we're running into with this method, because I don't really want two people editing the same data at the same time.&nbsp; The method of checking a timestamp field before update would work, but I don't want the agent entering a bunch of data and then when they go to save they find out that everything they did was rejected.<BR><BR></div></BLOCKQUOTE></P>
<P>I think you will have that problem with any application that uses a pooled database connection that is only kept open just as long as necessary for any one task.&nbsp; Each trip to the database is unconnected to the prior trips.&nbsp;</P>
<P>The best way to test whether that feature is a requirement or a wish is to assign price tag and a timeline just for that feature.&nbsp; Here's an example, with fictional numbers, of course:</P>
<P>"This feature will add&nbsp;2 months to the project timeline and cost an additional $50,000 in labor&nbsp;for an application of our size.&nbsp; The two months delay will&nbsp;mean that the $10,000 a month projected savings will also be delayed, for&nbsp;a total cost of $70,000.&nbsp;&nbsp;To put that in perspective, that equates to 7,000 lost data collisions, at an estimated $10 labor cost apiece.&nbsp; Our staff tells us that we can expect 50 collisions a month, for a&nbsp;break-even point&nbsp;in 11 and 1/3 years."</P>
<P>If the numbers work out like that, it may not be a requirement any longer....</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, April 30, 2007</h2><P>If you want that rich UI (especially if you have the BO keep the rules for the calcuations, which you should) I suggest a WinForms application.&nbsp; Nothing beats a desktop app for a rich experience.&nbsp; Deploy using ClickOnce, and you're all set.&nbsp; You can even ensure that the framework itself is installed prior to installing your application (and if need be, any additional components that would require installation).</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
