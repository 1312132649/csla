<html><header><title>Design Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Design Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2781.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>hatem_info posted on Thursday, April 26, 2007</h2><P class=MsoNormal><SPAN><FONT face=Calibri>I have the situation where my child collection must be persisted &shy;(DB) and keep the exact order of lines items (after an insert or an update). I can insert a line item between 2 other items.<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal><SPAN><FONT face=Calibri><SPAN>&nbsp;</SPAN>My question is how I can do this with CSLA?<o:p></o:p></FONT></SPAN></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, April 26, 2007</h2>You need to keep track of the ordering of items.&nbsp; I do this with line items in my application.<br><br>The underling collection is a list, which always keeps items in the same order.&nbsp; When saving, you need to save the index in the list to the db.&nbsp; Then when you load, you need to order the items by that position.<br><br>HTH<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 26, 2007</h2><P>You may need to add an "OrderPosition" property to your child class, and use that to maintain the order. Even if that value isn't saved to the db, you can use it to keep the order consistent in your list.</P>
<P>The primary reasons are these:</P>
<OL>
<LI>If you allow the user to insert items in the middle, you need a way to manage that</LI>
<LI>If you allow the user to move items in the list, you need a way to track positions</LI>
<LI>If you allow the user to delete items in the list, and you support a "cancel" operation, BusinessListBase will <EM>not</EM> maintain the original ordering of the items, and you need a way to reconcile the ordering</LI></OL>
<P>This OrderPosition (numeric, ascending value) property gives you a tool to manage the positions of the items.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Thursday, April 26, 2007</h2><P>I did this for one of my own applications and the key for me was deciding that the index maintenance for the children was the responsibility of the collection class of which they are all members.</P>
<P>There are really three considerations it seems: index value maintenance while the collection is in use, persistance of the collection, and UI stuff.</P>
<P><U>Index Maintenance</U>: Once I decided to make it the collection's responsibility, the implementation&nbsp;seemed pretty straightforward.&nbsp; I didn't support insertion as you describe it here, but that isn't a big leap, really.&nbsp; I think a Public method for the collection can&nbsp;still handle it all - something like InsertAt() which would take an argument to trigger the correct index management behavior.&nbsp; InsertAt() calls the .Add() method, and then branches based&nbsp;on whether&nbsp;the argument was less than .Count (or .Count -1, depending on whether your index is going to be one-based or zero-based).&nbsp; If&nbsp;the new one is the last item (not inserted; just added) the index is simply set to the next value (new .Count or .Count -1).&nbsp; If it is being inserted, the code&nbsp;will assign the new/last item a value larger than the highest value (or -1 or some other convenient and impossible value), re-order all the existing items whose index is equal to or greater than the desired value for the new guy, and then assign the desired value to the new one.</P>
<P><U>Persistence</U>: In my own case, I chose to simply delete all the children from the DB and re-save them as new ones every time.&nbsp; My collections were rarely more than a dozen items, so such a choice was easy for me.&nbsp; If you think yours might involve a few thousand, you may have to question this.</P>
<P><U>UI</U>:&nbsp;I can't offer any guidance here because&nbsp;it varies so much depending on how the user interacts with your collection members.&nbsp;&nbsp;But as long as the UI can generate the call to InsertAt() appropriately per the above design, it shouldn't be too great a challenge.&nbsp; If it can't, you&nbsp;can take that into consideration in designing a more appropriate InsertAt() argument list that the UI <STRONG><U>can</U> </STRONG>populate.</P>
<P>I hope this is enough to get you started down the right road.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hatem_info replied on Thursday, April 26, 2007</h2><P class=MsoNormal><SPAN><FONT face=Calibri>I think that the <U>index Maintenance</U> is the most suited for me:<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal><SPAN><FONT face=Calibri><SPAN>&nbsp; </SPAN>1/ Let the responsibility to the BO to maintain the order of line items<o:p></o:p></FONT></SPAN></P>
<P class=MsoNormal><SPAN><FONT face=Calibri><SPAN>&nbsp; </SPAN>2/ delete all the children from the DB and re-save the new ones is not always&nbsp;<BR></FONT></SPAN><SPAN><FONT face=Calibri>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possible&nbsp;(take&nbsp;the case&nbsp;where itâ€™s not possible to delete one line item according to&nbsp; <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; business logic constraint (DB Trigger))<o:p></o:p></FONT></SPAN></P><SPAN><SPAN>&nbsp; </SPAN>3/ UI is not the best place for such responsibility. </SPAN></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Thursday, April 26, 2007</h2><P>I'm sorry if I wasn't clear in the first posting.&nbsp; <STRONG>All three</STRONG> of these issues need to be addressed by your solution.&nbsp; I wasn't trying to offer them as a list of choices from which you select only one.</P>
<P>Clearly you do need to maintain the indexes.&nbsp; Although I didn't specify it, I was assuming the Child Objects&nbsp;have the index number property&nbsp;that Rocky mentions in his post.&nbsp; I can't imagine a solution without that property available.&nbsp; You certainly don't have to show it in the UI, though.</P>
<P>You must have <STRONG>some </STRONG>method of persistence of the children.&nbsp; I&nbsp;simply offered my own solution. If you don't like my "mass delete/re-save" technique, you can still get the update process to work properly as long as each of your Child objects has a unique ID (obviously NOT the sorting index value that is our focus here).&nbsp; Many developers use unique IDs for <STRONG>all</STRONG> their tables and, so, one would be available for child objects, too.&nbsp; I don't always do this, which made this&nbsp;more challenging&nbsp;for me.&nbsp; But, again, you certainly can solve this issue without my technique as long as you can identify the Child Object by their unique ID at Save time.</P>
<P>I also agree that the UI isn't the place for the responsibility of maintaining the indexes.&nbsp; But it MUST provide the object that&nbsp;does the index maintenance with enough information to determine what needs to be done.&nbsp; So, for example, if the user is performing an insert at position 2 in the list, the UI must be able to pass that information along somehow.&nbsp; If they are making a simple addition at the end of the list, that information must also be passed along (but there are fine default methods in CSLA for this already, of course).&nbsp; If you offer a Move capability or (Cut/Paste) to change location of the child, the UI must be capable of identifying the child object being moved and its target location.&nbsp; These <STRONG>ARE</STRONG> responsibilities of the UI.&nbsp; But assigning the proper sort index values to each child is <STRONG>NOT</STRONG>.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
