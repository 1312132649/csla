<html><header><title>Cannot XMLSerialize Business Object</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Cannot XMLSerialize Business Object</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1506.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele posted on Monday, October 16, 2006</h2><P>USing CSLA 1.5 - I Get this error trying very simple XMLSerialize.</P>
<P>System.InvalidOperationException: To be XML serializable, types which inherit from ICollection must have an implementation of Add(CSLA.BrokenRules+Rule) at all levels of their inheritance hierarchy. CSLA.BrokenRules+RulesCollection does not implement Add(CSLA.BrokenRules+Rule)</P>
<P>Any ideas?</P>
<P>Sean</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, October 16, 2006</h2><P>Rocky has mentioned that the XMLSerializer is woeful compared to the Binary Serializer and will not work on CSLA BOs.</P>
<P>You can search for more info - bottom line is you have to write some non-trivial&nbsp;code if you want to serialize to XML.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, October 16, 2006</h2>The XmlSerializer has some serious limitations on what types it can serialize. Any serious OO model will likely use some of these "off-limits" types, and that includes CSLA itself as well.<br><br>Remember, the XmlSerializer is designed to support the SOAP standard for interoperability. To do this, they sacrificed functionality: it is the lowest-common-denominator effect.<br><br>The end result, is that the XmlSerializer is only really useful for serializing data transfer object (DTO) graphs, and even then you must be very careful about what types you use for collections or lists. It is a bit better in .NET 2.0 than 1.1, but I still sometimes find it challenging to express my data the way I'd like.<br><br>If you look in Chapter 10 in the 1.x book (or 11 in the 2005 book) you'll see that I formally define DTOs to expose through web services; copying the data into and out of the business objects in the asmx code. The reason for this addresses your problem as well: web services use the XmlSerializer...<br><br>For those who are interested, the problem doesn't go away with WCF. The new WCF serialization only supports one data contract per object/class, forcing you to choose whether to support external XML serialization, or support for mobile objects. For typical business objects in CSLA, you'll need to go with the mobile object support, or lose the data portal, cloning and n-level undo. The end result is that you'll <i>still </i>need to formally define DTOs for external data exchange. In my view, this is good anyway, because architecturally it is the right approach - regardless of the technology.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, October 17, 2006</h2><P>If you delve into some of the more popular development suites or toolkits out there, you will find that many have implemented their own custom XmlSerializers to address the litany of shortcomings in the framework-supplied class.&nbsp; Here's a brief list, reproduced from the documentation, of the System.Xml.Serialization.XmlSerializer's short-comings:</P>
<UL>
<LI>Only works with Public types (protected – not. Internal? - never tried) 
<LI>Must have a default parameter-less constructor (does not have to be public) 
<LI>No security checks can be performed during deserialization 
<LI>Properties must be read/write (and public!) 
<LI>Properties cannot return interfaces (won’t know the type to create when deserializing). Abstract base classes are okay. 
<LI>No multi-dimensional arrays 
<LI>Object graphs cannot contains circular references 
<LI>Object references will be serialized each time they are encountered (resulting in multiple instances on deserialization instead of the expected behavior). 
<LI>Collections must NOT implement IDictionary 
<LI>Base classes should use the XmlIncludeAttribute to list derived classes (when known). This allows the derived class to be serialized for properties with base class return types. Can also apply XmlElement to the property itself (this will accommodate overridden classes outside of the original assembly). 
<LI>A collection’s properties are ignored. 
<LI>Collections must implement ISerializable to be serializable. Requires foreach to write (serialize) and Add(T) to read (deserialize).</LI></UL>
<P>Of these, the requirement to have public read/write properties and public Add methods in collections (versus explicit interface implementations) seem to cause the most headaches and are two of the factors that led me to develop my own XmlSerializer as well.</P>
<P>Keep in mind that this can be a daunting task and should not be taken lightly.&nbsp; There are quite a few attributes and interfaces, etc. that all have to be accounted for.&nbsp; But, if these limitations stand in your way, and you really have to be able to serialize to Xml, then creating your own serializer may be the only way to accomplish your goal.</P>
<P>In our case, our custom serializer allows protected and private set accessors on properties, serializes/deserializes a collection's properties and serializes Dictionaries, Stacks and Queues.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
