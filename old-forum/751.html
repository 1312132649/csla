<html><header><title>Inheritance/Factory/Fetch Methods?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Inheritance/Factory/Fetch Methods?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/751.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul posted on Friday, July 28, 2006</h2><P><FONT face=Arial size=2>Just trying to ascertain whether something is possible using an Abstract base class inherting from BusinessBase.</FONT></P>
<P><FONT face=Arial size=2>I have a structure like this</FONT></P>
<UL>
<LI><FONT face=Arial size=2>ObjectBase (abstract and inherting business base)</FONT></LI>
<UL>
<LI><FONT face=Arial size=2>DerivedObjectA (inherits ObjectBase)</FONT></LI>
<UL>
<LI><FONT face=Arial size=2>DerivedObjectB (inherts DerivedObject A)</FONT></LI></UL></UL></UL>
<P><FONT face=Arial size=2>The main functionality exists in ObjectBase but the derived object override some of the main methods. Most of the objects though&nbsp;can be handled within the application&nbsp;as ObjectBase instances.</FONT></P>
<P><FONT face=Arial size=2>I would like to have a static method on ObjectBase such like</FONT></P>
<P><FONT face="Courier New" size=2>public static ObjectBase GetObject(int ID) {}</FONT></P>
<P><FONT face=Arial size=2>This should get the object of the correct type but returning this as type ObjectBase. So for example the ID specified could be a DerivedObjectA or DerivedObjectB. The trouble is the Type is not know untill the DB is queried. If know that if I wanted to call specific opertation then I would have to cast the object to the correct type.</FONT></P>
<P><FONT face=Arial size=2>Is this possible using a DataPortal_Fetch method in an Abstract base class?</FONT></P>
<P><FONT face=Arial size=2></FONT>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Friday, July 28, 2006</h2><P>One difficulty is that your ObjectBase is generic (inherit from BusinessBase&lt;T&gt;), and it'll need to be a conduit for your concrete classes to pass along their type so that the BusinessBase&lt;T&gt; methods are appropriately typed. </P>
<P>An option would be to inherit directly from Core.BusinessBase and stay away from Generics. (You'd have to implement the small amount of implementation done in BusinessBase&lt;T&gt; yourself). </P>
<P>Considering both options...</P>
<P>With the former approach (inheriting through BusinessBase&lt;T&gt;), you're kind of in trouble because you can't just call the static method on ObjectBase - see, ObjectBase isn't a class, it's a generic, so you can't just invoke your factory method on that class.</P>
<P>An option along these lines might be to have an ObjectBaseFactory, a separate class which has your static method which would have a command object to be invoked by your static GetObject(). It would return IObjectBase, which would be an interface declared on your ObjectBase class for the purposes of polymorphism. This command object would determine the appropriate class in a lightweight manner. The static GetObject on ObjectBaseFactory, using this command to determine the type, would then invoke the appropriate factory method on one of the concrete classes you implement to return an IObjectBase, which is then returned by ObjectBaseFactory's GetObject factory method. </P>
<P>What you are going to run into problems with, IMO, is the idea of the DerivedObjectA and DerivedObjectB (if you intend for these to both be concrete classes). Reason being that the type parameter being passed up to BusinessBase&lt;T&gt; will properly type <EM>one</EM> of your two classes. Maybe some of the experts in here can clear me up on that if I'm speaking incorrectly. </P>
<P>Along the lines of the other path - inheriting from Core.BusinessBase - you avoid the generic problem and I imagine you could have&nbsp;a static GetObject right on your ObjectBase class, which would return an ObjectBase (not necessarily an interface since ObjectBase is no longer generic). The approach would be the same, where one would have a lightweight command object to determine the type, and then you would invoke the factory method on the appropriate concrete class to return the concrete ObjectBase instance for the ObjectBase's GetObject factory method.</P>
<P>This latter approach, where you inherit from Core.BusinessBase, probably allows you to have "DerivedObjectA" and "DerivedObjectB", whereas I think it would be not feasible with the former approach of inheriting from BusinessBase&lt;T&gt;. </P>
<P>I hope this helps!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul replied on Monday, July 31, 2006</h2><P><FONT face=Arial size=2>Thank for your input.</FONT></P>
<P><FONT face=Arial size=2>The idea of an object factory is something that I will probably implement. What I really wanted to avoid was having to hit the database twice, once the determine the type of object and one to get the data.</FONT></P>
<P><FONT face=Arial size=2>What I would have like to do is to obtain a datareader to determine the type of object in the derived object (or object factory for that matter) and then pass the datareader to the appropriate object. Trouble is this would be done server side by the CSLA and the object would already be created preventing me converting it to anything else. Will need to investigate the object factory a little more to see what I can do.</FONT></P>
<P><FONT face=Arial size=2>Just thought this would have been a problem that someone else might have had.</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
