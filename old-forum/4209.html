<html><header><title>Abstract Base Class with Custom Fields and Implementation in Derived Class</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Abstract Base Class with Custom Fields and Implementation in Derived Class</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4209.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jspringer posted on Tuesday, January 22, 2008</h2>I have a question about Best Practices with CSLA and how to implement a derived class. Here is some background.<br><br>I have a base class (Person) that has a small set of data (FirstName, LastName, DateOfBirth, PersonType -- which is an enumeration) and some basic functionality ( public string GetFormattedName(); public void ChangeDateOfBirth(DateTime NewDOB); public abstract void SendCampaignEmails()). The PersonType enumeration tells me what kind of person the object actually is such as President, Vice President, Senator, etc. Now depending on the PersonType the logic in SendCampaignEmails() will obviously change due to the text that is involved, as well as WHO actually gets the email (which is out of the scope of this discussion) and the custom details which are properties of the derived objects depending on their type. Now, in a normal object model I would have a corresponding object for each PersonType and then inherit from the base Person class. To throw a monkey wrench into this, I also have no idea what the PersonType is until I actually read the database. I also really don't want to round trip to figure out the actual type of object before I GET the object and then turn around and re-read the DB since that will duplicate DB calls. What is the best way to implement this type of object model. I did find this example <a title="http://forums.lhotka.net/forums/thread/1286.aspx" HREF="/forums/thread/1286.aspx">http://forums.lhotka.net/forums/thread/1286.aspx</a> that talks about a similar situation, but I didn't quite understand how the final result was configured. Am I stuck with doing multiple reads?? And how does one go about the UPDATE() or DELETE() methods, I'm guessing the derived objects would simply append their custom information to the DataReader. Any help would be greatly appreciated.<br><br>Code Example:<br><span>public abstract class Person</span><br><span>{</span><br><span>&nbsp;&nbsp; string FirstName { get; set; }</span><br><span>&nbsp;&nbsp; string LastName { get; set; }</span><br><span>&nbsp;&nbsp; DateTime DateOfBirth { get; set; }</span><br><span>&nbsp;&nbsp; PersonType PersonType { get; set; }</span><br><br><span>&nbsp;&nbsp; public string GetFormattedName()</span><br><span>&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return string.Format("{1}, {0}", FirstName, LastName);</span><br><span>&nbsp; }</span><br><span>&nbsp; public void ChangeDateOfBirth(DateTime NewDOB)</span><br><span>&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp; //add a history record</span><br><span>&nbsp;&nbsp;&nbsp; this.DateOfBirth = NewDOB;</span><br><span>&nbsp; }</span><br><span>&nbsp; public abstract void SendCampaignEmails();</span><br><span>}</span><br><br><span>public class President : Person</span><br><span>{</span><br><span>&nbsp; public President() : base()</span><br><span>&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.PersonType = PersonType.President;</span><br><span>&nbsp; }</span><br><span>&nbsp; public abstract void SendCampaignEmails()</span><br><span>&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string emailBody = "President.....";</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Do some custom logic</span><br><span>&nbsp; }</span><br><span>}</span><br><br><span>public class VicePresident : Person</span><br><span>
{</span><br><span>&nbsp; decimal TotalCampaignDollars = 0;</span><br><br><span>&nbsp; public VicePresident() : base()</span><br><span>
&nbsp; {</span><br><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.PersonType = PersonType.VicePresident;</span><br><span>
&nbsp; }</span><br><span>

&nbsp; public abstract void SendCampaignEmails()</span><br><span>
&nbsp; {</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string emailBody = "Vice President.....";</span><br><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Do some other custom logic</span><br><span>
&nbsp; }</span><br><span>
}</span><br>
<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, January 22, 2008</h2><P>Hello,</P>
<P>While I don't have an exact match with your situation, we have a situation where Individuals and Organizations are both "Profiles" and both inherit Profile, a base abstract class. </P>
<P>I like, very much, having a ProfileFactory class which takes an ID and first does a check on what type it is before delegating to the appropriate class's factory method. </P>
<P>You obviously wanted to get around this extra "read", but I'm not sure there's a nice way of&nbsp;doing so&nbsp;while keeping things especially clean.&nbsp;I think this offers a very loose coupling -- the only thing your factory class (like ProfileFactory) needs to do is take and ID and determine what type it is, so that it can hand over the actual population behavior to the class that needs to get an instance of itself from the database. </P>
<P>I think this topic has come up before and others have offered a different approach, but this is the one we're using. </P>
<P>Chris</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Tuesday, January 22, 2008</h2>I think that what you need is an instance of the "Strategy" pattern.&nbsp; I would abstract the behavior of the different types into a separate interface (call it IHandleIndicator), with methods to return the email body, campaign total dollars, etc&nbsp; I would then implement this interface for each of the different types.&nbsp; In the data read logic for each instance of the class, I would look at the indicator and "plug in" the appropriate instance of this interface.&nbsp; Within the Person class, I would then invoke the methods on the IHandleIndicator interface as needed.<br><br>This approach will eliminate any need for a second read and give you differentiated behavior based upon the indicator value.&nbsp; There are some that think that this is a better approach than inheritance.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jspringer replied on Tuesday, January 22, 2008</h2><P>So if I get what you are saying Cash, would I have a child object of type IHandleIndicator?? One of my colleagues actually mentioned something like this (if I am interpretting you correctly)....I think I still might run into issues with the custom properties because not all the properties of the derived types will be in all the derived types (ie: in my example I mention CampaignDollars for VP -- only a VP has this value, no one else).</P>
<P>public class Person<BR>{<BR>&nbsp;&nbsp;&nbsp; IHandleIndicator _helperToActualObject;</P>
<P>&nbsp;&nbsp; public void SendCampaignEmails()<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this._helperToActualObject.SendCampaignEmails();<BR>&nbsp; }<BR>}</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jthorndy replied on Tuesday, January 22, 2008</h2><P>The problem you mention (only a VP has CampaignDollars) is a problem regardless of whether you use inheritance or a child object which encapsulates the behavior. If you use inheritance for the root object if you want to access the specialized properties you have to cast the root object as the specialized type. If you use a child object which is an interface or an abstract type then you have to cast the child object into the specialized type.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Tuesday, January 22, 2008</h2>Yes, that is exactly what I meant.&nbsp; <br><br>The issue with differing data values can be handled in three different ways: One, you can hide these values in the general case and only expose them for specialized editing environments.&nbsp; Two, you can expose them in all cases but force them to zero (or the appropriate default value) for anyone other than a VP.&nbsp; Three, you could implement ITypedList (look it up on MSDN); that would allow you to have a dynamic set of properties (but this is a whole lot of work and would be a *** to maintain and only someone who is nuts would attempt it unless he or she was trying to show off how clever he or she was when he or she was not really all that smart -- ouch!).<br><br>Jon<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
