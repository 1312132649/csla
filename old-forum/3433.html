<html><header><title>Authorization Rules Anomalies!</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Authorization Rules Anomalies!</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3433.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken posted on Monday, August 27, 2007</h2><P>I confess!&nbsp; With so much to learn, I've been going along filling in the Authorization rules by rote, without really taking the time to think about how it works under the hood.</P>
<P>Now I want to load up the authorization rules from a database instead of hard-coding them in each business class.&nbsp; So I really started looking into it and found a few conceptual surprises.</P>
<P>Property level authorization rules are the province of an individual business object class.&nbsp;&nbsp; They are stored in classes designed for that purpose.</P>
<P>Object level authorization rules are the province of a collection business object class, not the individual business object class.&nbsp; For example (and forgive the gooberish nature of the example):</P>
<UL>
<LI>Party&nbsp;&nbsp;&nbsp;(A person or organization of interest to the business.)</LI>
<LI>PartyList (A collection of Parties.)</LI></UL>
<P>Party contains the authorization rules for PartyId, PartyName, PartyPhone, PartyEmail, etc.</P>
<P>PartyList contains the authorization rules for adding, editing, deleting or getting Party objects, not Party.</P>
<P>So, if I were to create two different collection business objects for Party, I could have different authorization rules&nbsp;for each list.&nbsp; For Example:</P>
<UL>
<LI>CustomerList&nbsp; (A collection of Parties&nbsp;that are Customers.)</LI>
<LI>VendorList&nbsp;&nbsp;&nbsp;&nbsp; (A collection of Parties that are Vendors.)</LI></UL>
<P>In this scenario, I might be able to add customers but not vendors.&nbsp; (Presumably the collection class is doing some extra work to mark a party added via the CustomerList collection as a Customer.)</P>
<P>Is this sort of situation the reason why the collection class, and not the business object it contains, maintains this type of authorization rule?&nbsp; (It seems to me that this type of situation could get one in a lot of hot water very quickly!).</P>
<HR>

<P>I can clearly see why CanAddObject is a static method.&nbsp; </P>
<P>Given that individual properties can be turned off on a per-instance level, it also makes sense to me that CanEditObject could be a static method.&nbsp; After all, the per-instance situation could be handled by negating the ability to edit any of the properties.&nbsp; They UI experience in that situation would be a bit clunky, but it would not produce incorrect results.</P>
<P>Ditto for CanGetObject.</P>
<P>CanDeleteObject is more problematic.&nbsp; I might have the authority to delete objects in general, but not this object in particular.&nbsp; How are others doing that in the CSLA framework?</P>
<HR>

<P>Or is the reason for this because of some quirk of .Net databinding?</P>
<P>Or is it just a matter of "Hey, this is a big framework to build, document and test, and Rocky didn't have time to do more on this subject?"</P>
<P>Anyone know of a good reason why we shouldn't move these decisions to the business objects contained in the collection?</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>The authorization roles for individual properties in a business object&nbsp;appear to be stored in in a Dictionary collection.</P>
<P>But the authorization roles for the business object itself (add, delete, edit and get) are not stored in any memory structure.&nbsp; Instead, they are hard-coded as static methods on the business object's collection object.&nbsp;&nbsp; For example, ProjectList would have:</P>
<P>public static bool CanEditObject()<BR>{<BR>&nbsp;&nbsp;&nbsp; return someHardWiredAnswer;<BR>}</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Tuesday, August 28, 2007</h2>Hi David,<br><br>I am currently implementing db-based authorization in my CSLA-App, so I will answer on this topic:<br><br>Location of object-level-authorization-rules:<br>I think object-level-authorization-rules belong to root objects, wheter they be collections or not.<br>Your example indicates that party is a child object, and the objects that manage the retrieval/persistance of parties are your Collections (CustomerList, VendorList, ...). <br><br>You could implement CustomerList.CanAddObject. But that would lead to the impression of CustomerList containing editable objects. I would avoid that confusion. <br>If you do, I would delegate the authorization query to a Customer/Vendor object, which would be root objects.<br><br>Per-instance-authorization-rules: <br>I still cannot see any situation where instance-authorization-rules, as they are implemented in the framework at the moment, would make any sense. The instance-rules are set during creation of the object instance. At that moment no business-property-values have been set, so there is no chance of authorizing based on any instance-specific data.<br><br>CanDeleteObject vs. CanDeleteInstance:<br>The former answers the question whether the current user can delete certain types in general, so we can arrange the UI-navigation accordingly. I think it makes sense caching this information. <br>The latter provides us with the current user's authorization with respect to a specific instance of a type.<br><br>I am retrieving the type-level-authorization-rules during login, and store them in a static/shared dictionary. I looked at how Rock implemented the AuthorizationRulesManager/SharedAuthorizationRules and got my 'SharedClassPermissions'<br><br>Here's some code to think/argue about:<br><br>In MyBusinessBase.vb:<br>&nbsp;&nbsp;&nbsp; Public Shared Function CanDelete(Of TObject)() As Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return MyBaseLib.Security.GetAccessInfo(GetType(TObject), MyBaseLib.Security.ClassAccessLevel.CanDelete)<br>&nbsp;&nbsp;&nbsp; End Function<br><br>In MyBaseLib.Security:<br>&nbsp;&nbsp;&nbsp; Puplic Shared Function GetAccessInfo(ByVal objectType As Type, ByVal accesslevel As ClassAccessLevel) As Boolean<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim result As Boolean = False<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim manager As ClassPermissionsManager = SharedClassPermissions.GetManager(objectType, False)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not manager Is Nothing Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim theconfig As ClassAuthorizationConfig = manager.ClassPermission<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return ClassAuthorizationConfig.checkIfAny(theconfig.Config, accesslevel)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return result<br><br>&nbsp;&nbsp;&nbsp; End Function<br><br><br>Hope this is of some help.<br><br>Stefan<br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
