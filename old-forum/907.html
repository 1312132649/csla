<html><header><title>OT: Design question for db</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OT: Design question for db</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/907.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Tuesday, August 15, 2006</h2>Hi,<br><br>I have a table which will store different kinds of documents (which share much the same data).&nbsp; Invoices, quotes, RMAs, and orders.&nbsp; Its likely this list won't change.<br><br>So, should I have a simple char column, Q for quote, etc.&nbsp; An int (which the BO knows)?&nbsp; In the business layer, there doesn't seem a need to expose publicly the document type identifier... but at the same time if feels odd to hard code some values (although on the other hand they really shouldn't change ever).<br><br>Any comments?<br>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, August 15, 2006</h2><P>Well, you're going to have to hard-wire something somewhere... :)</P>
<P>For something this simple, you might as well make it simple!</P>
<P>You might want to consider using an enumeration to define/store/document the codes.</P>
<P>(At least for non-database code.)</P>
<P>That gives you one stop shopping on defining what code means what.&nbsp; The enum label.ToString() can be used to pass to the database, and doing it this way gives you a compile-time error instead of a run--time error if you mis-remember the code somewhere.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 16, 2006</h2>Yes, I'd likely have an internal enum or something like that.<br><br>Thanks for the opinion.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Wednesday, August 16, 2006</h2>My vote would be for an int column that specifies the ID of the document type with a foreign key to a document types table.<br><br>I think you should keep it in the database this way instead of using an enum in the BO.<br><br>The precedent for this has already been set by using a Roles table. We don't have any trouble hard coding things like IsInRole("Administrator") so I think that hard coding logic that identifies the type of document is okay.<br><br>- John<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 16, 2006</h2>John,<br><br>Normally I'd agree with you.&nbsp; The role list can change over time, and thus its better to store said list in the db.&nbsp; <br><br>In this particular case though, I'd be hard pressed to say that I think the list will ever change.&nbsp; Document will be quote, order, invoice, rma, and credit memo.&nbsp; That's it.&nbsp;&nbsp; So my question, why have a DocumentType table in the db at all?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Wednesday, August 16, 2006</h2>I can think of a couple reasons.<br><br>First off, while the document types will most likely never change, the things that you might want to do with those types might change. You may decide later to offer reporting or advanced modeling or forecasting. If you use a DocumentType table, you can better leverage this because you have a link between the documents and their type. <br><br>If you go down the enum route, you instead have a column or columns that identify the type. Those column(s) are really properties of a document. <br><br>This ties into the second reason in that it is possible that those enum type columns could be changed to an invalid type. While I agree it's not likely, let's say that a type is changed from "quote" to "abc". It's no longer really a quote. It's not anything. While your BOs should protect from this kind of change, they cannot protect against direct changes in the database.<br><br>If instead, you had a type column, the DocumentType parent table will not let you change a type to one that doesn't exist. It's just another level of control and security.<br><br>- John</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Wednesday, August 16, 2006</h2><P>I agree with John.&nbsp; Having the foreign key constraint adds another level of protection to ensure data integrity.</P>
<P>Something else to consider.&nbsp; Even though you feel that the list will change infrequently, if ever, think about what would be required to make such a change if you used the enumeration approach.&nbsp; Re-compile and re-deploy!&nbsp; Whereas, having the types in a lookup table means all you have to change is the database with no collateral changes to the application itself.</P>
<P>One other point that tends to come up in discussions like this - if you create a DocumentTypes table and go that route, do NOT create an enum to handle the coding requirements as this undermines the whole point.&nbsp; That may seem obvious to most of us but I can't tell you how many times I've seen that done.</P>
<P>Hope that helps...</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 16, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I agree with John.&nbsp; Having the foreign key constraint adds another level of protection to ensure data integrity.</div></BLOCKQUOTE><br><br>I could use Rules / UDTs in Sql server to the same effect.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>Something else to consider.&nbsp; Even though you feel that the list will change infrequently, if ever, think about what would be required to make such a change if you used the enumeration approach.&nbsp; Re-compile and re-deploy!&nbsp; Whereas, having the types in a lookup table means all you have to change is the database with no collateral changes to the application itself.</div></BLOCKQUOTE></p><p>If the list changes, I'll have to recompile anyway.&nbsp; Invoice, Quote, etc. are all concrete classes in my business layer as well.&nbsp; For roles I find this reasoning acceptable; add a new row, the existing system can handle it since you're just checking one piece of data against another.&nbsp; But a new document type would almost certainly have new behavior, which cannot be acomplished just by dropping a row in the database.<br> </p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>One other point that tends to come up in discussions like this - if you create a DocumentTypes table and go that route, do NOT create an enum to handle the coding requirements as this undermines the whole point.&nbsp; That may seem obvious to most of us but I can't tell you how many times I've seen that done.</div></BLOCKQUOTE></p>Agreed.&nbsp; If I have a table, there's no need for the enum.&nbsp; If i don't have the table, I have a need for an enum.. (although maybe not..)<br><br>Just to be clear, I'm not decided yet, just playing devils advocate to get some good reasons one way or another.<br><br>Thanks!<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, August 16, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JHurrell:</strong></div><div>First off, while the document types will most likely never change, the things that you might want to do with those types might change. You may decide later to offer reporting or advanced modeling or forecasting. If you use a DocumentType table, you can better leverage this because you have a link between the documents and their type. </div></BLOCKQUOTE><br><br>Not sure I follow; you'd be able to tell looking at the column what the type of document is.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JHurrell:</strong></div><div>If you go down the enum route, you instead have a column or columns that identify the type. Those column(s) are really properties of a document. </div></BLOCKQUOTE><br><br>How is this fundamentally different than having a DocumentTypeId column that identifies the document type?<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JHurrell:</strong></div><div>This ties into the second reason in that it is possible that those enum type columns could be changed to an invalid type. While I agree it's not likely, let's say that a type is changed from "quote" to "abc". It's no longer really a quote. It's not anything. While your BOs should protect from this kind of change, they cannot protect against direct changes in the database.</div></BLOCKQUOTE><br><br>This is a valid point; I could counter by creating a UDT that only accepts the predefined values.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>JHurrell:</strong></div><div>If instead, you had a type column, the DocumentType parent table will not let you change a type to one that doesn't exist. It's just another level of control and security.</div></BLOCKQUOTE><br><br>Hmmm. yes and no.&nbsp; If you can change the type id, you can probably just insert a new row in DocumentType.&nbsp; Also, the UDT could prevent invalid values as well.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Thursday, August 17, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Not sure I follow; you'd be able to tell looking at the column what the type of document is.</div></BLOCKQUOTE><br><br>What I meant by that is there is nothing that would prevent a person from directly editing the database column and entering "abc" or any other text. Since there's no foreign key consrtaint, the column is essentially just another value. There's nothing about it that MAKES it a document type beyond whatever logic is contained in your BO.<br><br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>How is this fundamentally different than having a DocumentTypeId column that identifies the document type?</div></BLOCKQUOTE><br><br>In one case, you have a database column that can contain a value which has no relation to any other objects in the database. In order to make sense of it, you'd need to have knowledge of the BOs.<br><br>In the case of a foreign key, you can JOIN the tables and you now have potentially valuable business knowledge that can be shared by other systems.<br><br>Granted, you could provide documentation that says, when DocumentType is 1 then it's a quote, when 2 then it's an order... but that's not elegant.<br><br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>This is a valid point; I could counter by creating a UDT that only accepts the predefined values.</div></BLOCKQUOTE><br><br>So now you're encoding business logic/validations in two places. We all know that's not ideal.<br><br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Hmmm. yes and no.&nbsp; If you can change the type id, you can probably just insert a new row in DocumentType.&nbsp; Also, the UDT could prevent invalid values as well.</div></BLOCKQUOTE><br><br>A person COULD just enter a row in the DocumentType table. However, SQL Server does provide object-level security to restrict access to procedures and CRUD operations on tables. I think that these mechanisms are a better means of limiting input than constraints via BO and UDT.<br><br>- John<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 17, 2006</h2>John,<br><br>Thanks for your continued participation in this thread.&nbsp; Continuing my role as devil's advocate...<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong><strong>JHurrell</strong>:</strong></div><div>In the case of a foreign key, you can JOIN the tables and you now have potentially valuable business knowledge that can be shared by other systems.<br><br>Granted, you could provide documentation that says, when DocumentType is 1 then it's a quote, when 2 then it's an order... but that's not elegant.</div></BLOCKQUOTE><br><br>I would go with O for Order, Q for quote, etc.&nbsp; I can certainly appricate where you're coming from, but I'm not sure I see how this is different than the external app looking for 'Quote' in the DocumentType&nbsp; table (and remembering the DocTypeId) instead of Q in the Document table.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong><strong>JHurrell</strong>:</strong></div><div><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>This is a valid point; I could counter by creating a UDT that only accepts the predefined values.</div></BLOCKQUOTE><br><br>So now you're encoding business logic/validations in two places. We all know that's not ideal.</div></BLOCKQUOTE><br><br>Again, for the sake of being a devil's advocate.. For yes / no fields, do we not usually choose the bit datatype?&nbsp; For straight integer types, do we not pick int / smallint / bigint?&nbsp; Would you choose a smallint if the application would NEVER exceed the storage capacity?&nbsp; Is it a business rule that you only have one character out of a set of allowed characters or can you think of that as a data rule?&nbsp; Is the fact that we pick an int (which disallows character data) a business rule, or just part of the data model?<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong><strong>JHurrell</strong>:</strong></div><div><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Hmmm. yes and no.&nbsp; If you can change the type id, you can probably just insert a new row in DocumentType.&nbsp; Also, the UDT could prevent invalid values as well.</div></BLOCKQUOTE><br><br>A person COULD just enter a row in the DocumentType table. However, SQL Server does provide object-level security to restrict access to procedures and CRUD operations on tables. I think that these mechanisms are a better means of limiting input than constraints via BO and UDT.</div></BLOCKQUOTE><br><br>A UDT would be protected as well, just as the document table is.&nbsp; Its still a data type, just a more specialized one, like the money datatype or varchar vs. nvarchar or bit.<br><br>Thanks again for the discussion.<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, August 17, 2006</h2><P>Maybe this will help with the thought process:</P>
<P>Where and how do documents get added to the database?&nbsp; Presumably, these records are added by your business objects in your application via AddQuote or NewQuote and some sort of Apply or Save method.&nbsp; How does the business object that is writing the object to the database know what letter to use for the DocType?</P>
<P>If you go the route of a UDT in the database, then you've defined the list of valid values in the database and presumably hard-coded them somewhere into your application.&nbsp; Not good practice.</P>
<P>However, using a lookup table with a foreign key reference makes it so the list of DocTypes is in one place.</P>
<P>I am assuming that your object model is designed so that each of your "document"&nbsp;BOs inherits from a common base class.&nbsp; In other words, you have declarations similar to:</P>
<P><CODE>public class Invoice&nbsp;: Document<BR><BR>public class Quote : Document</CODE></P>
<P>etc. Since they are all coming from the same table, this would allow you to simplify the data access code and common methods and properties to them all (presumably matching the table columns).</P>
<P>One of the properties in the base Document class would be an abstract&nbsp;(MustOverride in VB) read-only property name something like&nbsp;"DocumentType".&nbsp; In each of your derived classes, you would provide the actual type.&nbsp; This property would then be called by your data access code to establish the correct doc type when the item is added to the database.&nbsp; For example:</P>
<P><CODE>public class Invoice : Document<BR>{<BR>&nbsp; &nbsp; public override DocumentType DocumentType<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return DocumentTypes["Invoice"];<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>The DocumentType class would expose an ID or Code property (or whatever) which is used as the primary key field in the database and establishes the foreign key relationship.</P>
<P>Again, the point I was trying to make had (mostly) to do with where the DocType calues would be defined and only defining them in one location rather than in both your application code and database.&nbsp; You could certainly make the argument that it would be easier to implement&nbsp;DocumentTypes as an enumeration in code and return DocumentTypes.Invoice in the above example, but then we are back to the earlier posts or looking at implementing a UDT that still has to have knowledge of these values in order to function.</P>
<P>Hope that make sense.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, August 17, 2006</h2>Another approach to the PhoneType question is to add a Public bit column that is true (1) if the record is to be shown to users and false (0) if not.&nbsp; Then, your views and sproc can filter the returned resultset based on the particular function being performed.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 17, 2006</h2>I thought about this approach too; I was trying to plan for the future, but I suppose other 'non public' types needn't be seperated into their own category.&nbsp; I think I'll go this route because 'YAGNI'.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, August 17, 2006</h2><P>Yea, I'd thought about having "Invoice" as the key for the collection when I typed it.&nbsp; But, at some point you are going to have some way of identifying the doc type in code.&nbsp; To me, the more flexible and robust solution which I have used many times (because most of our apps are extensible) would be to use the type name rather than a hard-coded string.&nbsp; In other words, in code, your DocType is the type of the object you are dealing with.&nbsp; In your DB's DocTypes table, you'd have a column for ObjectType and another for the primary key (ID) field referenced from your Documents table.&nbsp; In your data access code, use <CODE>this.GetType().FullName</CODE> (<CODE>Me.GetType().FullName</CODE> in VB) to set the value of the parameter.</P>
<P>Then, if you add another doc type to your application, as you said, you are going to create a new class in code then add a new record with the new class' type name in the DocTypes table and you're good to go.</P>
<P>What I find unique about this approach is that we would typically have a separate table for each document type you've described as each contains unique data.&nbsp; So, this is a bit of a different scenario although the logic behind lookup table vs. enumeration vs. UDT is more generic and common outside of this application.&nbsp; I think ultimately it is going to come down to your overall data access strategy.&nbsp; I've had arguments, I mean discussions, with many other developers about what should and shouldn't be in a stored procedure.&nbsp; You can debate what logic goes where until the cows come home because everyone has their own way of doing things and opinions on what is right.&nbsp; What it boils down to is what you are doing elsewhere and what works best for you.&nbsp; I think if you considered using a lookup table for PhoneTypes then there is a possiblity that you already have other lookup tables and going that route would maintain the consistency of the approach throughout the application.&nbsp; If you are more inclined to use a UDT or stuff all kinds of logic in your stored procedures, then go that route.&nbsp; I think consistency is sometimes more important than the approach we chose for an individual task.</P>
<P>But, I deal with a lot of contract developers and external customers so the training curve for new developers, maintainance and upgrade time and effort, etc. are all considerations to our designs.&nbsp; Consistency and standardization are big factors in those areas.&nbsp; Plus, recognizing the abilities of (or lack there of) our developers also plays a role.&nbsp; Not everyone knows what a UDT is let alone how to program and/or make use of one.</P>
<P>Just some things to think about.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 17, 2006</h2>Pirate,<br><br>Some great points.&nbsp; You've hit across the reason I decided to post this question here.&nbsp; Creating PhoneTypes for me is a no-brainer.&nbsp; <br><br>What goes in that list has really no bearing on business rules anywhere (except that a phone must have a type), and its common for the user's to want more types of phone numbers.&nbsp; For example, I had started with Fax, Cell, Home and Office.&nbsp; The users said 'oh, add a Lab phone number as well.'&nbsp; Lists like that, which have little impact on business rules, and / or are likely to be updated frequently or by the users, I have no problem with using a lookup table.<br><br>For something which users will never change, is only needed by code, and which are likely to never, ever charge, well I started to question the idea of making a seperate table for those kinds of things.&nbsp; I honestly don't think we'll ever have more than five different document types. <br><br>To talk about why I have a Document table vs. one table for each type.. the users currently use QuoteWerks, and really the only difference between a Quote, Order, or Invoice is a label saying what the document is, and how the document numbers are generated.&nbsp; This part of the behavior works just fine for them, which means that mostly that the documents in the new system will behave almost identically.&nbsp; For the 'extra' data that isn't common, I'll likely have the seperate table, Invoice, but it would only have an FK to the Document table, plus the 'extra' data.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 17, 2006</h2>Pirate,<BR><BR>First, yes, you're right about my object model.&nbsp; Invoice inherits from Document.&nbsp; New invoices are created by factory methods, etc.<BR><BR><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>If you go the route of a UDT in the database, then you've defined the list of valid values in the database and presumably hard-coded them somewhere into your application.&nbsp; Not good practice. 
<P>However, using a lookup table with a foreign key reference makes it so the list of DocTypes is in one place.</div></BLOCKQUOTE></P>
<P>followed by<BR></P>
<P><CODE><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong></CODE>SonOfPirate<CODE>:</strong></div><div>public class Invoice : Document<BR>{<BR>&nbsp; &nbsp; public override DocumentType DocumentType<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return DocumentTypes["Invoice"];<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>}</CODE></P>
<P><CODE></div></BLOCKQUOTE></CODE></P>
<P>See, this is what i'm getting at; "Invoice" is harded coded in the property getter anyway... so what is the purpose of getting an int ID value instead of just returning "Invoice"?</P>One said of me says that the UDT approach is similar to choosing the appropiate data type.&nbsp; Its just like smallint, which has a limit on the set of integers which the datatype can contain, the DocumentTypeUDT is a char, which limits the set of alphabetic characters which it can contain.<BR></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 17, 2006</h2>Just wanted to add another question to this..<br><br>I have a table, PhoneType, which contains the data about the type of phone number (cell, lab, office, etc.).&nbsp; I'm going to add more types, ShipTo, SoldTo, BillTo.&nbsp; <br><br>The catch is that the new ones are used ONLY internally, while the existing ones are exposed to the user.&nbsp; The user, when entering phone numbers, selects the type from a drop down.&nbsp; <br><br>I don't want the new types to be in that list.&nbsp; The new ones are used internally only, and are fixed (there's a SoldTo tab, for example, and the number there is automatically marked as a SoldTo phone number).<br><br>My thought is to create a PhoneTypeGroup table, and adding a PhoneTypeGroupId FK to the PhoneType table.&nbsp; The PhoneTypeList business object would always filter the list to those acceptable for the user to select; my other BOs would get a list specific and sort out exactly which type is the bill type.&nbsp; My gut doesn't really like that idea (looking for a certain string from a list of items, to find the id) but my brain says to trust the database (because I control who can change what <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" />).<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
