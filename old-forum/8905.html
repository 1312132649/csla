<html><header><title>CSLA 3.7, Polymorphism and DataPortal.Fetch</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 3.7, Polymorphism and DataPortal.Fetch</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8905.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>danderson00 posted on Monday, May 10, 2010</h2><p>Hi,</p>
<p>I was hoping someone may be able to assist with a particular problem I am experiencing with CSLA version 3.7 and inheritance.</p>
<p>As a contrived example, let&#39;s say we have an abstract&nbsp;&quot;Contact&quot; class that has two derived classes - TelephoneContact and EmailContact. I want to be able to load a Contact object by its primary key without knowing what the derived type is. It is possible to determine the correct type from data loaded from the database, but I&#39;m not sure how to achieve this with CSLA.</p>
<p>The problem is that the DataPortal_Fetch method that one would usually override to implement the data access is an instance method - ie, an instance of the class must already be created to execute this, and we don&#39;t know exactly what type of object to create until we&#39;ve loaded data from the database. Chicken or egg?</p>
<p>It&#39;s possible to do this with collections&nbsp;- override the DataPortal_Fetch method on a custom collection class, load the data, determine the correct type for each instance, instantiate it and populate the data. I&#39;m just not sure how to do this with individual instances. Is there some static method I can implement on a class that CSLA will &quot;magically&quot; figure out how to call and return the appropriate type from? A different solution altogether? Is this sort of thing even possible with CSLA?</p>
<p>It&#39;s worth noting that this is also a well known problem with many ORM frameworks, but there are invariably solutions.</p>
<p>&nbsp;</p>
<p>Thanks in advance!</p>
<p>Dale Anderson&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, May 10, 2010</h2><p>Hi Dale, </p>
<p>This could easily be accomplished by using the ObjectFactory pattern and move data access into separate ObjectFactories. </p>
<p>The OF is responsible for both creating instance and Data access / move data into BO. </p>
<p>It would be hard to accomplish with the DataPortal_XYZ as these are Instance methods. </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Monday, May 10, 2010</h2><p>I don&#39;t know how the BusinessList could handle this.&nbsp; I don&#39;t think it has the capability currently to hold more than one object type.&nbsp; If you could sub-class BusinessList so that it could, I think you would handle loading the different object types in the BusinessList DataPortal Fetch.&nbsp; It would read in each object from the database then determine from the loaded data which type of object to instantiate.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Monday, May 10, 2010</h2><p>You could create a factory class that handles this for you.</p>
<p>e.g.</p>
<p>IContact aContact = ContactFactory.Create(id);<br /><br />ContactFactory.Create delegates creation to the appropriate class. Inside the factory, it can query the database to know what type to create.&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 10, 2010</h2><p>CSLA isn&#39;t an ORM, so it isn&#39;t likely it will have ORM-style solutions to the question.</p>
<p>Jonny is right - if you want to have the data layer decide which type of object to return, the object factory model is the right choice.</p>
<p>But if you want a polymorphic result, you need to remember that generics aren&#39;t polymorphic, and CSLA is designed so the base types will be generic with exactly one non-generic type as the &quot;leaf node&quot; of the inheritance chain. If you don&#39;t follow that pattern many things will start to fall apart.</p>
<p>BusinessListBase is constrained such that its child objects must implement IEditableObject. This means you can define your own interface for your child objects that derives from IEditableObject - thus allowing you to create a polymorphic collection. Normally this is used to create a heterogeneous collection - one that contains different types of child object at the same time. But you could use it to create different homogeneous collections - where each collection is homogenous, but different collections might have different children (though all the children will implement your common interface of course.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>danderson00 replied on Monday, May 10, 2010</h2><p>It would seem that using the ObjectFactory attribute on the classes in question would solve the problem. Thanks for your prompt responses!</p>
<p>Not sure what you mean by &quot;generics aren&#39;t polymorphic&quot;. I think what you mean is that generics are invariant. There is nothing to stop you from storing anything that derives from a class A in a List&lt;A&gt; and treat them polymorphically, but I can&#39;t upcast that to List&lt;DerivedFromA&gt; or even downcast that to List&lt;object&gt;&nbsp;(unless you&#39;re using .NET 4.0 of course). All of our business objects eventually derive from BusinessBase&lt;T&gt; and we&#39;re using a single generic class that derives from BusinessListBase&lt;T,&nbsp;C&gt;&nbsp;rather than a custom collection class for each different business object.</p>
<p>It worries me somewhat that there is no interface to wrap these ObjectFactory&nbsp;classes, or the DataPortal Fetch pattern in general. The signature of these methods are somewhat arbitrary and it requires that a developer consuming these factories knows precisely the parameters required to retrieve an object. There is no compile time validation that they are passing the correct parameters, and no refactoring support. There is a lot of nasty reflection going on under the covers. Use of criteria objects mitigates this slightly, but I still find the lack of compile-time checking uncomfortable.</p>
<p>Thanks again.</p>
<p>Dale</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 10, 2010</h2><p>I&#39;d be interested to hear any suggestions (other than IL-munging with a post-compiler, because that&#39;s nastier than reflection) on how to have a client call a method, and to have the method invocation be on the app server, potentially two network hops away.</p>
<p>A lot has changed since I started down this road in 1996 with COM, and even since 2000 when I wrote the initial .NET data portal. While reflection is used for discovery, it hasn&#39;t been used for invocation since 2005, and now in CSLA 4 the invocation is handled using lambda expression trees.</p>
<p>But ultimately the &quot;method call&quot; needs to be intercepted by CSLA so the call context can be serialized across the network to the physical location where it becomes an actual method call.</p>
<p>It is an interesting problem space, and one that can be solved by writing your own compiler, or altering the IL post-compilation, or by making all method calls cross a context boundary or explicitly use Remoting. All those solutions are at least as bad, if not worse, than using reflection and expression trees though, so I&#39;ve kept on the same basic track, slowly improving and enhancing the basic concept over time (preserving backward compatibility as much as possible).</p>
<p>CSLA 4 actually removes the &quot;criteria object&quot; restriction, allowing you to pass any single serializable value as criteria - which includes int, string, or more complex serializable types.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>danderson00 replied on Tuesday, May 11, 2010</h2><p>I really need to look at what CSLA 4 provides before stating too many opinions and making a fool of myself, but it sounds like it may solve some of the issues I mentioned. </p>
<p>Many of the solutions that come to mind (like wrapping classes and factories in interfaces to cover various data access requirements) are somewhat &quot;opinionated&quot; and would remove some of the flexibility that CSLA provides, so would be better to be a layer built on top of CSLA for specific cases. I&#39;m also a fan of the repository pattern (either with methods written on each repository to cover specific data access needs, or query objects (similar to criteria objects) that are passed to a generic repository), but I&#39;m not sure how well this will fit with CSLA.</p>
<p>I&#39;ll have a look at CSLA 4 before I go any further.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 11, 2010</h2><p>CSLA 4 does not substantially change the way the data portal works.</p>
<p>CSLA is not an ORM, nor does it pretend to be one. The &quot;data portal&quot; is actually poorly named, but after 14 years I&#39;m not planning to change the name any time soon...</p>
<p>The &quot;data portal&quot; is actually an object portal. Its job is not unlike&nbsp;a REST service - you give it specific input (business object type and criteria) and it gives you back an object of that type. Of course the data portal predates REST by quite a few years too, so it isn&#39;t truly RESTful...</p>
<p>The repository pattern is a great pattern for providing indirection for things like accessing a DAL. Create numerous DALs and select the one you want.</p>
<p>The repository pattern is less useful for indirecting the selection of your domain model, because there&#39;s less need to do this. If your object model is actually behavioral and single-responsibility, then it is somewhat difficult to see where you&#39;d be swapping out different models within your use case.</p>
<p>The biggest hang-up people face when coming to CSLA is that they view objects as data containers, not as autonomous behavioral constructs. I don&#39;t know if that&#39;s what&#39;s driving your train of thought, but it is pretty common.</p>
<p>Certainly DAL-level objects (entity objects, DTOs and the like) are usually data-centric. And most of the common &quot;OO&quot; design patterns apply directly to that type of object. But hopefully your actual domain objects (the ones you create with CSLA) directly match the behavioral and responsibility requirements of your use case or user story or usage scenario (whatever term you&#39;d like to use). The fact that these objects have data is secondary to the reality that they fulfil a specific and active role in the usage scenario.</p>
<p>This means that some concepts, like mocking the business objects, is almost entirely meaningless. That&#39;d be like creating a &quot;unit test&quot; for a job interview and coming up with a mock applicant. The test might pass, but it would be meaningless, because a real applicant would never be as simplistic as your mock applicant.</p>
<p>The same is true with these business objects. By the time you&#39;ve mocked the object to the level where it is meaningful, you&#39;ll have recreated the actual object.</p>
<p>Please note that I&#39;m not saying you shouldn&#39;t test the objects. Nor am I saying mocking is bad, or even out of the question at some levels - but to really mock a business object your mock will almost certainly need to <em>be a CSLA business object</em>, otherwise you won&#39;t get the appropriate rule/eventing/notification/persistence behaviors required to do any meaningful test.</p>
<p>So you are better off always using the actual objects, and mocking the DAL. Mocking the DAL is easily done in several ways, and I talk about how to do this in the <a href="http://store.lhotka.net">Core 3.8 video series</a>. With mock data, your business objects become entirely predictable and testable, without the need to incur the huge expense of mocking the business objects themselves.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
