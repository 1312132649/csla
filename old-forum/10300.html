<html><header><title>CSLA 4.1 and Silverlight - WcfErrorInfo vs. Native Exception</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 4.1 and Silverlight - WcfErrorInfo vs. Native Exception</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10300.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans posted on Tuesday, April 26, 2011</h2><p>Hi Rocky / all</p>
<p>This is in the context of a Silverlight application that uses CSLA 4.1.</p>
<p>As you know, if an exception is thrown on the Data Portal it gets wrapped&nbsp;- no actually repackaged/converted (for a more technically correct description) into a WcfErrorInfo class (with as much information about the original native exception as possible).</p>
<p>At the Silverlight client end, the original exception is presented as a chain of WcfErrorInfo class(es). I understand that this is is done because original exception is not neccesarily known to the Silverlight world (and sometimes not approrpriate for it).&nbsp;Part serialisation, part domain cohesion, part security, also at play here.</p>
<p>For many (if not most) scenario&#39;s the WcfErrorInfo wrapping of the native error that occurs on the DataPortal side is sufficient and the ExceptionTypeName is often usefull when I need to know which kind of exception took place.</p>
<p>I am however repeatedly running into some difficulty in not being able to have the original strongly typed exception available to me at the Silverlight end. Mostly this applies to custom exceptions that contain structured information that I need to get to, and I&#39;m not looking forward to an elaborate XML Schema and string parsing alternative for each exception type I need&nbsp;:-( </p>
<p><strong>What I&#39;m proposing is a feature request for CSLA 4 where the DataPortal supports serializing known native exceptions natively and defaulting to WcfErrorInfo for the others.</strong> </p>
<p>It is my understanding that native WCF and Silverlight is able to do so (i.e. serialise an exception), provided it&#39;s a &quot;KnownType&quot;. However, I&#39;m not sure what the impact of such a request would have for the CSLA codebase.</p>
<p>I foresee that tagging an exception with the [KnownType] attribute (or a custom one if more suitable) should therefore indicate which exceptions should be serialised natively and which should be converted to WcfErrorInfo objects by the CSLA WCF DataPortal code.</p>
<p>Obviously it&#39;s up to the developer to make sure that the exception is present in both the .NET code base and the Silverlight end, and should likely be adorned with the [DataContract] and [KnownType]&nbsp;attributes. In theory at least.</p>
<p>I do hope this is at all feasable as it would simplifie so much for our CSLA based solutions.</p>
<p>Jaans</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, April 26, 2011</h2><p>I&#39;d love to do this. What I don&#39;t know is how to make .NET aware of the set of &quot;known exception types&quot; on the Silverlight side.</p>
<p>Some are potentially easy - we could manually catalog the list of exception types in the Silverlight BCL, and maintain a hardcoded list of common exceptions in CSLA I suppose.</p>
<p>Beyond that everything gets difficult though. What about non-BCL exceptions in libraries like System.ServiceModel. Those libraries aren&#39;t part of &quot;core .NET&quot; or &quot;core Silverlight&quot; and you may or may not use them. Cataloging (and referencing) every possible Microsoft assembly from CSLA to get those types seems daunting.</p>
<p>And then we get to third-party libraries. Or your custom libraries. The problem is the same with both of these, because it is entirely unrealistic to catalog all the exceptions in every library.</p>
<p>So cataloging exceptions is an unworkable solution.</p>
<p>The next solution we could consider is for you to &quot;register&quot; exceptions you care about. Basically, you&#39;d write code that runs as the SL app starts up. This code would call some special server-side object through the data portal to register the common types you plan to use. This could be tedious, and would complicate app startup (because you&#39;d have to make sure no other work occurs until this async registration process completes).</p>
<p>However, even given that information I&#39;m not entirely sure what we&#39;d do with it. An exception graph could have known and unknown types intermixed. So what would we do with that? Maybe still return the WcfErrorInfo graph, but each WcfErrorInfo object would have a NativeException property that is normally null, but would be non-null for known exceptions?</p>
<p>Finally we arrive at the crux of the problem though. Because even if all of the above worked out, the MobileFormatter can only serialize types that implement IMobileObject. Exactly zero existing exception types implement this interface. And <em>only your custom exception types can do so</em>. We&#39;ll never convince Microsoft to implement this interface on their types, or DevExpress, or Infragistics, or anyone else.</p>
<p>This would require that you implement IMobileObject on your custom exception types - probably manually, unless we also created some MobileException base class, along with a field manager and so forth, so you could implement your custom exceptions somewhat like a ReadOnlyBase object I suppose.</p>
<p>So what we&#39;re really talking about, is a pretty complex operation that allows your custom exceptions to be serialized - sans any InnerException or other object references.</p>
<p>Surely there must be some simpler solution to this problem. Maybe some way by which you can hook into the process of converting the exception graph into the WcfErrorInfo graph such that you can add extra data to the graph during the process?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Tuesday, April 26, 2011</h2><p>Woa... thanks for your time and input on this Rocky! (I know you are pressed for time, especially with your sabbatical coming up).</p>
<p>Ok, so clearly you have thought this through and able to consider it in more depth -&nbsp;it surely give me some food for thought about the challenge it poses.</p>
<p>I do like your idea of expanding the WcfErrorInfo object to include a NativeException : MobileException property (default to null). But, as you pointed out, a key issue is the MobileFormatter, and InnerException graphs. And so from there your idea about something like including serialisation data (Byte Array&nbsp;/ XML) that can be used to help re-create the exception on the Silverlight end (if I understood your thinking correctly).</p>
<p>I&#39;m speaking out of ignorance, so please bear with me here. The next bit is a bit of a thought-dump and I&#39;m hopefully not missing something that invalidates it.</p>
<p>Would it make sense that we turn around the concept of &quot;registering interest in certain Exceptions from the Silverlight end&quot; and instead drive it from both ends? Specifically I could imagine something like this:</p>
<p><strong><span style="text-decoration:underline;">Server Side (.NET)</span></strong></p>
<p style="padding-left:30px;">public class DoNotSendMyCustomException : Exception { ... }</p>
<p style="padding-left:30px;">[KnownType] / [RegisterKnownCslaException]<br />public class SendMyCustomException : Exception { ... }</p>
<p style="padding-left:30px;">[KnownType] / [RegisterKnownCslaException]<br />public class SendMyOtherCustomException : Exception { ... }</p>
<p><strong><span style="text-decoration:underline;">Client Side (Silverlight) </span></strong><br /><em>(likely this could be &quot;Linked&quot; like we&nbsp;link the same file&nbsp;for Csla business object class definitions between the .NET and Silverlight BusinessLogic assemblies)</em></p>
<p style="padding-left:30px;">[KnownType] / [RegisterKnownCslaException]<br />public class SendMyCustomException : Exception { ... }</p>
<p>Lets start with the <strong>Server Side (.NET) </strong>code - when the WcfErrorInfo graph is being built, only the &quot;SendMyCustomException&quot; and the &quot;SendMyOtherCustomException&quot;&nbsp;exceptions will have their &quot;raw data&quot; sent&nbsp;along to the Client (in a Byte Array / XML form) because they have the attribute marker (or some other registration).</p>
<p>Then on the <strong>Client Side (Silverlight)</strong> end, during the rehydration of the WcfResponse stream into objects, I foresee that only the &quot;SendMyCustomException&quot; is created for the NativeException property on the WcfErrorInfo instance. <br />The &quot;SendMyOtherCustomException&quot; is not created and left null&nbsp;because even though &quot;raw&quot; data for it was send from the server, the class / type for it didn&#39;t exist on the Silverlight end and thus not created (we could throw an exception here if more appropriate).<br /><br />In summary, what I&#39;m trying to say is that:</p>
<ul>
<li>I like the extending of WcfErrorInfo with a NativeException property</li>
<li>Server Side, you choose which exceptions are dehydratable by some means (attribute, configuration, code)
<ul>
<li>Inner Exceptions should follows the same premise - if the inner exception class is marked / registered then include it </li>
</ul>
</li>
<li>Client Side, you choose which exceptions are rehydratable by some hopefully similar means
<ul>
<li>Not sure whether we should throw exception if &quot;raw data&quot; for native exception is sent from server and client has not type for it, or whether we should default to null for the NativeException property</li>
<li>Inner Exceptions should also only be rehydrated if a class exists and is registered / marked</li>
</ul>
</li>
<li>During the creation of the WcfErrorInfo graph, would we be able to hydrate/rehydrate &quot;Exception&quot; classes from some &quot;Raw Data&quot; or would we need to derive from &quot;MobileException&quot; ?</li>
<li>Mental note: We should also consider AggregateException from the TPL library - a useful exception class.</li>
</ul>
<p>Is that sensible?<br /><br />Johann</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, April 27, 2011</h2><p>While this potentially solves the registration issue, you still have&nbsp;the MobileFormatter issues.&nbsp; Your custom exceptions would have to implement the IMobileFormatter interface (or else there&#39;d have to be some sort of mobile-formatter-compliant base class), otherwise you can&#39;t send them through the SL DataPortal.&nbsp; And in order for this to work, your <em>entire exception hierarchy</em>&nbsp;would have&nbsp;to be MobileFormatter-compatible.&nbsp; Since Exception isn&#39;t, the deserialization process would likely fail on the SL side.</p>
<p>(The &quot;obvious&quot; alternative is to not derive from any .NET exception, but I honestly don&#39;t know whether it&#39;s legal to throw an non-Exception-derived exception...)</p>
<p>I actually like Rocky&#39;s idea about providing hooks in the mobile-formatting process better - mostly because it&#39;s the only way I can think of to solve this problem.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" />&nbsp; I&#39;m not exactly sure how that would work in an exception scenario, but giving you the ability to inject your own data directly into the WcfErrorInfo byte stream is probably about as close as you&#39;re going to get.&nbsp; Similar hooks would have to exist on the deserialization side, where you&#39;d pull the data out and into your own structures.&nbsp; I don&#39;t think creating derived instances of WcfErrorInfo to hold your custom data would work, as then you&#39;re back to the KnownType issue...</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, April 27, 2011</h2><p>One possible compromise here, is that the code that creates the WcfErrorInfo graph could maybe be a little smarter.</p>
<p>Right now that code walks through the exception graph, copying data from each exception into a WcfErrorInfo. The result is that there&#39;s a WcfErrorInfo graph that has the same number of objects as the original exception graph. What it doesn&#39;t do is grab &quot;extra&quot; information available from various specialized exception types.</p>
<p>I can see a couple potential solutions.</p>
<p>One is for you to be able to register your own exception-&gt;errorinfo copier methods with the graph copier. Your method would be associated with a specific exception type, and the copier would invoke your method to do the copy, instead of using its default implementation. This way you could copy any information you wanted from the exception to the WcfErrorInfo. The WcfErrorInfo would probably need a dictionary property into which you&#39;d copy this data.</p>
<p>So you&#39;d have (in concept):</p>
<p>var info = new WcfErrorInfo();<br />info.ExtraData[&quot;Value1&quot;] = myException.Value1;</p>
<p>Another is for the copier code to examine each exception object to see if it implements IMobileObject. If an exception does implement IMobileObject, the exception could be included with the WcfErrorInfo in some OriginalException property. It would be your responsibility to ensure that any such exception types on the server are also on the client - and if you missed a reference on the client you&#39;d get one of those obscure WCF failure exceptions because deserialization would fail.</p>
<p>But the result on the client would be (assuming e is the callback args):</p>
<p>var info = e.Error.ErrorInfo;<br />Exception ex = info.OriginalException;</p>
<p>As I mentioned in my previous post, this would only work if the following is true:</p>
<ol>
<li>The server-side exception implements IMobileObject</li>
<li>The client has access to the same exception type as the server</li>
<li>We did some major surgery to WcfErrorInfo, because right now it is a light-weight WCF data contract object, and this change would force us to make it into a heavier weight MobileObject</li>
</ol>
<p>Then again, it could require some major surgery to WcfErrorInfo to allow it to return even the dictionary of simple values, because a dictionary can&#39;t be part of a data contract either...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Wednesday, April 27, 2011</h2><p>Thanks guys<br /><br />I quite like the concept of registering a &quot;TypeConverter&quot; method / delegate that is invoked when a particular exception is encountered by the WcfErrorInfo graph logic. I don&#39;t like that this could result in some heavy-weight changes to WcfErrorInfo :-( <br /><br /><em>Off topic: I guess such a TypeConverter&nbsp;concept could be extended to any type - not just exception for that matter and allow scenarios where compact lightweight or custom serialization payloads could be implemented - in theory. But I digress...<br /></em><br />Implementing the IMobileObject interface on custom exceptions will solve quite a few scenarios, but as mentioned before, does little for .NET Framework exceptions. Maybe we can&#39;t have our cake afterall...</p>
<p>What I&#39;m wondering is if there isn&#39;t an alternative or at least some existing design to leverage. I found an interesting article embedded in MSDN regarding WCF&nbsp;with Silverlight and the serialization of Exceptions (both built-in and custom). I would appear that on the Silverlight end, the exception arrives as an &quot;ArrayOfXElement&quot; structure which the proxy class uses to extract and re-hydrate a Silverlight Instance of the original exception.</p>
<p>Here&#39;s the link: <a href="http://blogs.msdn.com/b/suwatch/archive/2009/01/21/wcf-silverlight-exception-and-serialization.aspx">http://blogs.msdn.com/b/suwatch/archive/2009/01/21/wcf-silverlight-exception-and-serialization.aspx</a>&nbsp;<br />Does this help at all? Since WcfErrorInfo is already a WCF data contract object, could we not in some way leverage its ability to serialize/de-serialize exception objects?<br />Maybe that&#39;s what can be used as the &quot;intermediate raw serialised data&quot; for the exception?</p>
<p>Thanks for the input -&nbsp;I wish I could suggest more concrete solution options...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, April 27, 2011</h2><p>This is interesting.</p>
<p>The <em>cheapest</em> thing we could do is an interesting combination of these ideas.</p>
<p>Specifically, add a string UserData property to WcfErrorInfo, and allow you to register a delegate/lambda with the WcfErrorInfo type in Csla.Server.Hosts.Silverlight (.NET only).</p>
<p>Basically what I&#39;m suggesting is that you could register a Func&lt;string, Exception&gt; with CSLA, so when your particular type of exception is encountered your code would return a string containing whatever data you want to return to the client. This string would be put into the UserData property of the WcfErrorInfo object.</p>
<p>You could return an XElement (as a string) if you wanted - and then on the client you could easily convert the string back into an XElement.</p>
<p>This would allow CSLA to pass the data back to the client, without restricting (much) what you might choose to send.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Thursday, April 28, 2011</h2><p>I like it!</p>
<p>Would we be able know the &quot;Type Name&quot; of the original exception on the Silverlight side?&nbsp;</p>
<p>If so, a Generic Method on the CSLA WcfErrorInfo that accepts a delegate/lambda could then attempt to create that exception instance from the &quot;UserData&quot;? </p>
<p>On a related note, I tried to build a simple solution with Silverlight 4 and WCF 4 as per the above article to see the generated code, hoping to glean some insight into what is possible on the Silverlight side. <br />What is very interesting is that with WCF 4.0 it doesn&#39;t seem to work like that anymore. More accurately, I was unable to get the Silverlight Service Proxy generator (slsvcutil.exe) - that gets invoked when adding a &quot;Service Reference&quot; to Silverlight - to generate the intermediate bits for deserializing a custom exception. I does work for the built in exception types, but there is a caveat: It doesn&#39;t work when you specify the base class (e.g. Exception) for the contract but then serialize an instance of a more derived class (e.g. DivideByZeroException).</p>
<p>I&#39;m not sure if I&#39;m doing something wrong, or it&#39;s just not designed to work that way... this could be a death knell for the idea.<br />(I&#39;d be happy to email/attach the simple solution if interested - it&#39;s very basic).</p>
<p>In my &quot;travels&quot; I did come across a System.ServiceModel.ExceptionDetail class that is apparently intended to &quot;wrap&quot; Exception graphs for serialization. This works well and has no issue with serialization/deserialization no matter what exception I provide it (Exception, DivideByZeroException, CustomException). But in many ways this is similar to the WcfErrorInfo class... I think?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jaans replied on Thursday, April 28, 2011</h2><p>Scratch that... I managed to get it working now.</p>
<p>I needed to move the CustomException into a separate class library (both .NET and SL) and ensure the [KnownType] attributes are complete.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 28, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>Jaans<br></b>
<p>Would we be able know the &quot;Type Name&quot; of the original exception on the Silverlight side?&nbsp;</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>The original type name is already available through the ExceptionTypeName property of WcfErrorInfo. So I think it is safe to say yes :)</p>
<p>I suspect the other solution you discovered is something Juval Lowy wrote to solve the same problem as WcfErrorInfo. Although I&#39;m sure more people than just Juval and I have tried to address this issue.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, April 28, 2011</h2><p>Presuming you&#39;re talking about ExceptionDetail, that&#39;s actually a class built into .NET to provide additional information when the &quot;includeExceptionDetailInFaults&quot; service option is set.&nbsp; It allows you to&nbsp;throw a FaultException&lt;ExceptionDetail&gt; fault that provides information fairly similar to what WcfErrorInfo uses.&nbsp; Its constructor takes an exception and builds a WCF-compliant&nbsp;graph of ExceptionDetail objects.</p>
<p>It&#39;s recommended to shut that off in production environments, since it exposes detailed exception info.&nbsp; But there&#39;s nothing actually stopping you from using it.</p>
<p>HTH</p>
<p>- Scott</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
