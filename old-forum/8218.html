<html><header><title>Lambda Function in AllowExecute and CanExecuteMethod</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Lambda Function in AllowExecute and CanExecuteMethod</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8218.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>shawndewet posted on Thursday, December 24, 2009</h2>Would it be possible to change the AllowExecute and the CanExecuteMethod methods to accept a Lambda Expression instead of a string to indicate the method name that the authorization is to apply to?<br />It just seems that this would be so much cleaner, providing compile-time validation of method names.<br /><br />Or perhaps better still, how about changing the CanExecuteMethod method to have an overload that does not require a MethodName parameter, but rather uses reflection to determine the method name in which the call to CanExecuteMethod is being raised?  Would the performance impact on this be unacceptable?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lukky replied on Thursday, December 24, 2009</h2>I'm all for lambda expressions wherever a string is expected. I've had it with being bitten by a change in method/property name.<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 24, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>shawndewet:</strong></div><div>Or perhaps better still, how about changing the CanExecuteMethod method to have an overload that does not require a MethodName parameter, but rather uses reflection to determine the method name in which the call to CanExecuteMethod is being raised? Would the performance impact on this be unacceptable?</div></BLOCKQUOTE></P>
<P>Sadly there's no safe way to actually do this.</P>
<P>CSLA .NET still has some methods (now marked as Obsolete) that actually do this - from much older versions of the framework.</P>
<P>I used to have overloads for things like CanReadProperty() that did exactly this. You can't actually use reflection, but you can use the stack trace.</P>
<P>The problem is that you have to turn off certain compiler optimization features or that isn't reliable. And then it turns out that there are some compiler differences between x86 and x64 platforms that make it unreliable - and that was the point when I gave up and made those overloads obsolete.</P>
<P>Adding a lambda overload for AllowExecute() is a fine idea - that runs once per AppDomain, so the use of reflection there is no big deal.</P>
<P>Adding a lambda in CanExecuteMethod() is maybe OK, but it would require reflecting against the lambda on each method call. I think it is probably fine as long as I leave the string overload intact for cases where people find the performance hit too big.</P>
<P>Of course there's already an overload that takes&nbsp;a PropertyInfo&lt;T&gt;, and there's an item in the wish list to create a MethodInfo instead - to make it more clear and to enable the use of a lambda in the RegisterMethod() call that would come as part of this change. Odds are that I'll use the MethodInfo/RegisterMethod() approach, because it gets rid of the string literal, allows a lambda and doesn't require reflection on a per-call basis.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
