<html><header><title>KeyedCollection ?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>KeyedCollection ?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2872.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>HappyJack posted on Tuesday, May 15, 2007</h2><P>Has anyone tried to create a BusinessListBase descendant from KeyedCollection?&nbsp; I was looking at using a dictionary in order to find items by key values since I have large lists.&nbsp; I found the abstract KeyedCollection which seems to be a good solution since it can be accessed by both a key or an index.&nbsp; Also since it implements IList(of T) the sorting and filter binding lists should work so you can easily get a view to bind to a grid which is not possibly to do with a dictionary.</P>
<P>Thanks,</P>
<P>HappyJack</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 15, 2007</h2><P>I think the issue you'll face here is that dictionary/hashtable and other keyed lists won't data bind - at least not directly. Nor will SortedBindingList auto-fix this, because the items in the list are some complex type, not your actual data (each item is the key/value pair).</P>
<P>So if you want data binding, you can't have a keyed list and visa versa.</P>
<P>However, if you are willing to forego data binding, there's no reason why you couldn't create your own base class similar to BLB by inheriting from one of the existing keyed list types and adding code similar to what's in BLB.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HappyJack replied on Tuesday, May 15, 2007</h2><P>Rocky,</P>
<P>Thanks for the response.&nbsp; I agree that this was the issue with the old HashTable or even the Dictionary.&nbsp; But the abstract System.Collections.ObjectModel.KeyedCollection(Of TKey, TItem)&nbsp;is an IList(of T) instead of the ICollection(of KeyValuePair(Of TKey, TValue)).&nbsp; So this means that the items are not a complex type like you suggest.&nbsp; Also since this is an IList(Of T)&nbsp; then you can databind with it directly or you could use the sorting and filter bindinglist helpers to get a different view.&nbsp; So I guess the&nbsp;real difference is that this is an IList(of T) instead of the BindingList(Of T) so it would not be as a friendly with databinding.&nbsp; I'm not sure how difficult it would be to implement all the interfaces that BindingList(of T) implements.&nbsp; Thanks for any other information about this.</P>
<P>Thanks,</P>
<P>HappyJack</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 15, 2007</h2><P>Ahh, I see.</P>
<P>Well then you'd have your work cut out for you a bit. To emulate BindingList&lt;T&gt; you need to implement:</P>
<UL>
<LI>IBindingList</LI>
<LI>ICancelAddNew</LI>
<LI>IRaiseChildEvents (or something like that)</LI></UL>
<P>The latter two are pretty straightforward as far as I know, but IBindingList is complex and idiosyncratic. On the other hand, you can look at BusinessCollectionBase from CSLA .NET 1.53 to see an implementation of that interface, and you could probably build on that as a start - though some work would be required to accomodate the CSLA .NET 2.1.4 model.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Henrik replied on Wednesday, May 16, 2007</h2><P>Another way, which I've used a couple of times is to have a hashtable, that holds the key and index of the object, contained within your BusinessList.</P>
<P>In your DataPortal_Fetch, you first add the fetched object to&nbsp;your BusinessListBase and then add an entry into your hashtable with the objects key and it's index in the list.</P>
<P>Then add a FromKey method to your BusinessList that looks the objects index up in the hashtable&nbsp;by key ~O(1)&nbsp;and return the object from the list on that index.</P>
<P>I only use this method if I need really fast lookups. Most times a simple for each loop O(n)&nbsp;will perform well enough.</P>
<P>Cheers<BR>/Henrik</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HappyJack replied on Wednesday, May 16, 2007</h2><P>I agree, after thinking about it some more I think it would be easier to do excatly that which is the same thing that Rocky suggested years back.&nbsp; I just found the KeyedCollection in the .Net framework the other day and I always like trying to figure out where and when it makes sense to use the built-in framework classes.&nbsp;&nbsp;In this case, I think I would lose to much binding functionality and it&nbsp;would&nbsp;be&nbsp;too&nbsp;much work to put that back in when the result at the end of the will be the same.</P>
<P>Thanks,</P>
<P>HappyJack</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
