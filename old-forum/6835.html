<html><header><title>CSLA, Generics and Inheritance</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA, Generics and Inheritance</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6835.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>MTmace posted on Wednesday, April 22, 2009</h2><P>All of my business objects have a hand full of properties in common. So I have an abstract class (DataObject) that inherits from BusinessBase.<FONT color=#0000ff size=2></P>
<P>public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>abstract</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>class</FONT><FONT size=2> </FONT><FONT color=#2b91af size=2>DataObject</FONT><FONT size=2>&lt;T&gt; : Csla.</FONT><FONT color=#2b91af size=2>BusinessBase</FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2>DataObject</FONT><FONT size=2>&lt;T&gt;&gt;<BR></FONT><BR>I would like to define a GetObject method that accepts a SafeDataReader as an arguement and return the instanciated object.<FONT size=2></P>
<P></FONT><FONT color=#0000ff size=2>internal</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>static</FONT><FONT size=2> T GetObject(Csla.Data.</FONT><FONT color=#2b91af size=2>SafeDataReader</FONT><FONT size=2> Reader)<BR>{<BR>T obj = </FONT><FONT color=#0000ff size=2>new</FONT><FONT size=2> T();<BR>obj.Fetch(Reader);<BR></FONT><FONT color=#0000ff size=2>return</FONT><FONT size=2> obj;<BR>}</FONT></P>
<P><FONT size=2>The problem is in order to instanciate a generic class the class must have a public empty constructor.<BR>Can anyone help me with this or design a better solution?<FONT color=#0000ff size=2></P>
<P>public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>abstract</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>class</FONT><FONT size=2> </FONT><FONT color=#2b91af size=2>DataObject</FONT><FONT size=2>&lt;T&gt; : Csla.</FONT><FONT color=#2b91af size=2>BusinessBase</FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2>DataObject</FONT><FONT size=2>&lt;T&gt;&gt; where T : new()<BR></FONT></FONT><FONT size=2><BR>Thanks,</FONT></P>
<P><FONT size=2>MTmace</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 23, 2009</h2><P>Your "leaf node" object type (the actual business object type) can't be generic. The UI technologies like WPF, Windows Forms, etc don't work with generic types (not well anyway), so your actual object instance must be non-generic.</P>
<P>This means you don't ever want to create an instance of your generic base class - only the actual non-generic business class.</P>
<P>The data portal will help you here, as long as you use criteria objects that inherit from CriteriaBase (or implement ICriteria) because then you can specify the actual business object type that you want created, and the data portal will create it for you.</P>
<P>However, if you search way back in the forum, you'll find threads where I (and others) point out that this is a bad idea. Inheritance is for inheriting <EM>behavior</EM>, not fields or properties. By trying to inherit to get fields/properties you will run into code complexity, maintenance&nbsp;and performance issues, because the persistence model gets very ugly very fast.</P>
<P>Inheritance is one of the most tightly coupled relationships in existence. Coupling is one of the most dangerous and bad things you can introduce into an application. Thus, inheritance usually causes a radical increase in coupling, and thus a radical decrease in the quality of your code.</P>
<P>One of the best practices for OO programming is to "favor composition over inheritance". This is because inheritance is such a double-edged sword, and the bad edge is dipped in poison.</P>
<P>Along this line, reuse <EM>also always brings coupling</EM>. We all want reuse - but you should only accept reuse if you can get it without much coupling. Reuse through inheritance almost always increases coupling - especially when the goal is to reuse field/property declarations...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pamo replied on Wednesday, June 08, 2011</h2><p>Talk about dumbing down OO inheritance! I agree, people need to think <span style="text-decoration:underline;">a lot</span> before coupling things through inheritance, but if inheritance&nbsp;fits for the relationship you&nbsp;are modelling (i.e. and IS-A relationship), then you should be able to&nbsp;model it that way! </p>
<p>In the version of Csla I&#39;m looking at, the majority of Csla classes:<br />&nbsp;&nbsp; should&nbsp;<strong>inherit</strong>&nbsp; from Csla.BusinessBase(of T) <br />&nbsp;&nbsp; which <strong>inherits</strong> Csla.Core.BusinessBase<br />&nbsp;&nbsp; which <strong>inherits</strong> Csla.Core.UndoableBase<br />&nbsp;&nbsp; which <strong>inherits</strong> Csla.Core.BindableBase<br />&nbsp;&nbsp; which <strong>inherits</strong> System.Object</p>
<p>So if coupling through inheritance causes a &quot;a radical decrease in the quality of your code&quot;, does that mean Csla is low quality ;-)&nbsp; I challenge you to think about how you&#39;d have to re-design&nbsp;your entire Csla framework&nbsp;without using inheritance... </p>
<p>I&#39;d actually argue that &quot;inheriting for&nbsp;behaviour&quot; is just as&nbsp;wrong as for &quot;inheriting for properties&quot;. For example, just because a&nbsp;Grid class needs a SortYourData method and&nbsp;BookCollection needs the same SortYourData method, doesn&#39;t mean they should both inherit from a Sortable class. Quite the opposite, but maybe they should maybe implement the not tightly coupled&nbsp;ISortable Interface!&nbsp;</p>
<p>&nbsp;Just my two cents, but modelling inheritance is not always a bad thing and needs to be supported 100% by the Csla framework. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 08, 2011</h2><p>What a passionate way to ressurect an ancient thread :)</p>
<p>In some ways having things like UndoableBase be in the inheritance chain is a total PITA, and in retrospect it would have been better implemented through composition. Other things, like a lot of the data binding support, <em>has to be done through inheritance</em>, but would also be better done through composition if that were possible.</p>
<p>In any case, nothing stops you from using inheritance if you would like to do so. I was simply recommending an alternative that I think is better.</p>
<p>To use inheritance in your classes, you must understand how CSLA manages properties, and you must adjust your coding appropriately. To avoid high levels of complexity, you really want to avoid having anything but your &quot;leaf type&quot; be non-generic. Although the alternative is possible, it means giving up all the simpler generic-based RegisterProperty overloads, and that is a common source of copy-paste errors in people&#39;s code.</p>
<p>At the same time, if the benefit of inheritance is high enough to offset the increased complexity, then clearly inheritance should be used. These things are never (really) technical issues - they are cost/benefit business decisions.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RaulLozano replied on Wednesday, June 08, 2011</h2><p>OK I&#39;ll bite</p>
<p><br /><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b> <br />In some ways having things like UndoableBase be in the inheritance chain is a total PITA, and in retrospect it would have been better implemented through composition. <br /></div></p>
<p><br />Can you please educate me on how is having UndoableBase be in the inheritance chain is a total PITA? </p>
<p><br /><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b> <br />At the same time, if the benefit of inheritance is high enough to offset the increased complexity, then clearly inheritance should be used.<br /></div></p>
<p><br />I have read a couple of your post where you stress this out, but for the life of me, I cant think of a good example on why inheritance makes things more complex. So what exactly is so bad about inheriting for properties? And what&rsquo;s so bad about incresing coupling when you inherit?</p>
<p><br />I know I am an idiot, I admit it. But I will seriously thank you if you please help me understand this, perhaps a link where I can find some good explanation will be really appreciated.</p>
<p><br />Thanks.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, June 09, 2011</h2><p>I&#39;d often enjoy rehashing some of these ideas. At the moment though, I&#39;m on an extended vacation (a perk of working at Magenic for 10+ years), so I&#39;m not up for it this summer...</p>
<p>The complexity with inheriting to add properties generally comes from two sources:</p>
<ol>
<li>Business rules are &quot;cumulative&quot; and base class rules may become awkward or non-applicable once more properties have been added, yet you are stuck with them</li>
<li>Data access and data mapping is complex - though the object factory concept can help with this - but it is still awkward</li>
</ol>
<p>The business rule thing should be pretty obvious with just a little thought. Rules defined and designed for a class with certain properties might not apply to a class with more extensive properties. But the rules are associated with properties in each class, and unless you start adding conditional code to avoid it, those rules will apply to subclasses too. If you have to add conditional code of that nature, you are clearly violating OOP best practices. There are entire books about that sort of thing.</p>
<p>The data access issue is usually the first thing people encounter though, because it is hard to solve efficiently.</p>
<p>Create a class A that has properties X and Y. It will use a DAL that retrieves X and Y from the database, and all is well.</p>
<p>Now create a subclass B that adds property Z. How do you load X, Y, and Z now? Do you replicate the DAL to add&nbsp;Z to this query? And even if you do that, B can&#39;t load A&#39;s properties - so you need some base class method you can invoke to allow A to load itself with data - at which point there&#39;s no abstraction or &quot;black box&quot; concept - all subclasses must know everything about the data required by the base class.</p>
<p>Or do you call the A DAL, and then also call a B DAL (two database queries)? At least this preserves encapsulation and avoids having data queries scattered all over the place.</p>
<p>The ultimate question, is when you add a new property to A, how many places do you need to fix/test to make that work across all the subclasses?</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
