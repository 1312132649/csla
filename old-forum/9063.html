<html><header><title>Problem: Root object is treated as a child object when added to a collection</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Problem: Root object is treated as a child object when added to a collection</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9063.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>CBoland posted on Thursday, June 10, 2010</h2><p>I&#39;m having a problem with what seems to be a case for a switchable object. The apparent problem is that an otherwise root object is being treated as a child object when added to a collection, and it doesn&#39;t need to be treated as such.<br /><br />To illustrate, I have a Book that inherits BusinessBase(T) and a BookList that inherits BusinessListBase(T, Book). Books are otherwise root objects, with BookList serving primarily as a bindable collection for use with the BindingSource control designer, but also as a factory for obtaining various filtered collections of Books. There is no need for a collection of Books to be owned by a parent object of any kind.<br /><br />My program displays a BookListEdit screen where a user can not only edit Books in a grid, but also add or remove Books, all of which is cancelable. <br /><br />To create new Books from the BookListEdit screen, a new Book object is created (it will then be a root) and displayed in a BookEdit screen. If the user accepts the edits, the new Book object is added to the BookList collection, and control is returned to the BookListEdit screen. The user can then save or cancel any pending edits. <br /><br />All of this works except for a single case: an error is thrown when a new Book is removed from the collection before saving. The exception is thrown in BusinessBase.DeleteChild, and is: NotSupportedException: Invalid for root object - use Delete instead. Keep in mind that the exception is thrown when BookList.Remove(aBook) is called, well before any save operation is attempted.</p>
<p>After looking it over for awhile, here are things I&#39;ve considered to do and not do:</p>
<p>Approaches:<br /><br />- Let the Book exist as a root, but mark it as a child if it gets added to a BookList. This is my preferred approach, and I&#39;m doing it by:<br />&nbsp;&nbsp;&nbsp; a) Adding a internal Book.MarkAsChildInternal() method to have Book call its own MarkAsChild() method.<br />&nbsp;&nbsp;&nbsp; b) Overriding InsertItem() in BookList and calling Book.MarkAsChildInternal().<br /><br />- Use a different base class for BookList, one that doesn&#39;t care about root or child status. I like the CSLA infrastructure, so I&#39;d rather use one within the framework.<br /><br />Approaches not taken:<br /><br />- Change the use case. Adding, editing, removing Books are all valid operations from a usability standpoint; they shouldn&#39;t have to change.<br /><br />- Implement BookList.AddNew(). This breaks the ability for Book to be a root object, and unnecessarily modifies the BookList collection during the new Book edit.<br /><br />An interesting observation: All other CRUD operation scenarios are working, it&#39;s only the case of adding then removing a new Book before a save.</p>
<p>Can anyone add to this discussion, or offer an alternative?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, June 10, 2010</h2><p>&quot;Switchable&quot; objects are only switchable when they are first created - that&#39;s the time you have to decide if it is a root or child.</p>
<p>A BusinessListBase collection can only contain child objects. If you put a root object into a BLB you&#39;ll run into trouble - which you have. There&#39;s actually an item in the to-do list to add a check and throw an exception when a root object is mistakenly added to a BLB - it just hasn&#39;t floated to the top of the queue yet, because this isn&#39;t a terribly common issue.</p>
<p>If you want a collection of root objects, use ERLB - though that comes with a set of other consequences (like auto-saving of root objects based on data binding interacting with the collection).</p>
<p>There is no collection type that works with root and child objects. That&#39;s not really possible, since the data access implementations are different between the two (DataPortal_XYZ vs Child_XYZ), and there&#39;s no way to know you did both sets of data code for any given object, nor would there be a clear way for the data portal to know which to invoke.</p>
<p>I nearly always recommend against the use of a switchable object&nbsp;- they always introduce complexity. In my view it is almost always better to have two types for the different responsibilities.</p>
<p>In your case however, you might consider having two parent/root types instead - thus allowing Book to always be a&nbsp;child. For your collection case you already have what you need. Just create another parent - another BusinessBase, or a command object - that can save that one child for the single-object scenario. Once it is saved, just add it to the collection and discard the old parent (I haven&#39;t actually tried that - but it should work fine).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CBoland replied on Friday, June 11, 2010</h2><p>Thanks for the reply and the suggestion to use ERLB; I was previously unaware of that class.</p>
<p>I changed over to ERLB and it worked ok, but I&#39;m not a fan of the auto-save, as you mentioned in your reply. I like the interaction model of BLB, where edits are saved/canceled by the user (or me, the developer!). However, the &quot;child&quot; problem was getting in the way of BLB, even though I really don&#39;t Books to be child objects (but BLB requires them to be children). Because of this, all things considered, I&#39;ve decided to punt and go with my original workaround, which is to have the collection mark the Book as a child whenever one is added to the collection.</p>
<p>I was thinking more about this problem last night (before I had read your suggestions) and it seems to me that an object&#39;s &quot;child-ness&quot; is determined by virtue of being added to the collection, not the manner in which its loaded (e.g. constructor that accepts a DataReader), and that the collection&#39;s marking its elements as children makes sense. But this is only one aspect of the parent-child relationship, and there could be other consequences of doing this.</p>
<p>Thanks again for your input, Rocky!</p>
<p>&nbsp;</p>
<p>Craig</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
