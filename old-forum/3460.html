<html><header><title>1.5 to 2.1.4 Performance Hit</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>1.5 to 2.1.4 Performance Hit</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3460.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>CodeWampus posted on Friday, August 31, 2007</h2><P>I've written several apps using CSLA 1.5, including a medium sized commercial app with about 20 CSLA editable object classes&nbsp;and matching collection object classes and 10 name-value lists.&nbsp; I upgraded to VS2005 and .Net 2.0 in the middle of that project but stayed with CSLA 1.5 since it was fulfilling all my needs.&nbsp;&nbsp;</P>
<P>More recently, I've been&nbsp;gearing up on an ambitious project that could potentially use all of the DataPortal methods: Local, Web Services, Remoting, etc.&nbsp; In order to give myself the widest range of options, I planned to migrate to CSLA 2.1.4.</P>
<P>As a test case, I selected an existing CSLA 1.5 switchable object with 12 properties and coded up 2.1.4 versions of the object and an EditableChildCollection to go with it, using the Templates and ProjectTracker as my models, with some minor tweaks covered in your 2.1 e-book. I then wrote a simple test program to read the collection and display it in a grid.&nbsp; The data for the collection is an SQL Server table with 35K rows.</P>
<P>To my surprise, the 2.1.4 version took almost&nbsp;<U>26 times</U> as long to load the collection.</P>
<BLOCKQUOTE dir=ltr>
<P>1.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.6 sec.</P>
<P>2.1.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;41.6 sec.</P></BLOCKQUOTE>
<P>I loaded the collection into an Infragistics grid, which gives you the ability to sort by clicking on a column header.&nbsp; Sorting in this way also showed the same order of magnitude time difference between the old and new.&nbsp; My new objects have "Slow" attached to them!</P>
<P>I'm assuming this is my problem and not CSLA's, but I'm at a loss as to where to start looking.&nbsp; Despite the many differences between the old and new objects, the code path is&nbsp;virtually identical, at least&nbsp;for this operation.&nbsp; The difference seems to be in the objects and the way they&nbsp;perform in a collection.&nbsp; Any suggestions?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Friday, August 31, 2007</h2>Well, do your objects have rules? What kind of rules? Are you using instance or static rules? Static rules perform WAAAAY better during an intense loading such as this scenario.<br>Do you use reflection at any step? Or the rules provided by csla? These rules are pretty good for general use, but when you have a huge data load, it may not perform as well as a hand coded rule since they use reflection.<br><br>Are you running validations in both versions upon load?<br>Are you using remoting or running local? Do you have any circular references?<br>Are you using n-level undo at any point? Note that when binding to the grid, you'll be increasing the edit level for all of your objects, and that takes a lot of time. Beware of circular references here too mark them as NotUndoable().<br><br>Did you try profiling the app to see where the bottleneck is?<br><br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CodeWampus replied on Friday, August 31, 2007</h2><P>Thanks for the reply!&nbsp; It led me to the problem.</P>
<P>I'm running local.&nbsp; No circular references. No n-level undo.</P>
<P>My entire program, outside of the CSLA objects, is:</P>
<BLOCKQUOTE dir=ltr><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Dim</FONT><FONT size=2> testCollection </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> EventHeaders = EventHeaders.GetEventHeaders()</P>
<P>grdListView.DataSource = testCollection</P></BLOCKQUOTE>
<P dir=ltr></FONT>Since this was a first-time-test object, there were no validation rules, no modifications to CSLA, and the only authorization rule on the object and the collection was the following:</P><FONT size=2></FONT><FONT color=#0000ff size=2><FONT size=2>
<BLOCKQUOTE dir=ltr>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanGetObject() </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> ApplicationContext.User.IsInRole(</FONT><FONT color=#a31515 size=2>"EHUser"</FONT><FONT size=2>)</P>
<P></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></BLOCKQUOTE>
<P></FONT></FONT><FONT color=#000000>This seemed fairly innocuous, but to&nbsp;control for all variables&nbsp;I changed it to:</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> CanGetObject() </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Boolean</P></FONT><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Return True</FONT><FONT size=2>&nbsp;</FONT></P>
<P><FONT size=2></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</P></BLOCKQUOTE>
<P><FONT color=#000000 size=3>Load time dropped from 40+ seconds to 1.1 seconds!!!&nbsp; I don't know why this authorization is so resource heavy, but at least now I know where to focus my attention.</FONT></FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Friday, August 31, 2007</h2>Well, I don't know how I led you to figuring that out! :)<br><br>Anyway, in scenarios like this, it is best to have the CanGetObject at the collection level instead of the child, so it will only ever run once per fetch (unless you have some very specific security).<br>While string comparison or creation seems trivial, it can hog your resources as you can see. Believe it or not, the whole reason for moving to static rules started out because of one string that gets created when a rule is added to an object.<br>In this case you were probably looping through a list of roles (that's what most people do at least) 36k times and comparing them one by one. If your roles are rather "fixed" (and they usually are), it is sometimes a good idea to have the answer to the IsInRole question cached somewhere...<br><br>Your class could call something like SecurityHelper.IsEHUser and that static property caches the result for the test, like:<br><br>Public Class SecurityHelper<br>Private Shared mIsEHUser As Boolean<br>Public Shared ReadOnly Property IsEHUser As Boolean<br>&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  Return mIsEHUser<br>&nbsp;&nbsp;&nbsp; End Get<br>End Property<br><br>Public Shared Sub CheckSecurityAccess()<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; mIsEHUser = Csla.ApplicationContext.User.IsInRole("EHUser")<br>End Sub<br>End Class<br><br><br>Of course, you'd have to take care of calling CheckSecurityAccess() every time you login/out of your app, but you get the picture. (you can have the principal take care of that)<br>Also, you might have to go a slightly different way if running a web app (like storing an instance of a similar class in session or something like that).<br><br>You could also store similar properties in your identity object if it suits you better (but you'll end up doing a lot of type checking if you go that route).<br><br>Andrés<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
