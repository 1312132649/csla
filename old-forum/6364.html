<html><header><title>Feature request</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Feature request</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6364.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jack posted on Friday, February 06, 2009</h2>It would be nice if some of the recursive functions that throw exceptions could either re-raise and throw the exception or include some basic information that would help a developer determine where it happened.<br><br>For example I was struggling with a CopyState / BeginEdit() issue and while I had an idea where it was happening my object graph was sufficiently convoluted that step debugging was horrendous.&nbsp; I ended up modifying the exception thrown in FieldDataManager.CopyState to include the FieldName/loopIndex so I had somewhere to start.<br><br>Throw in remote proxies and debugging gets even tougher.<br><br>Thanks<br><br>jack<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, February 06, 2009</h2>I don't disagree, but I've found that usually, if you are in the debugger, that if you cause the debugger to break at the time an exception is thrown (versus only on unhandled exceptions), you can usually see what field was being manipulated by looking back a few levels on the call stack. (at least in the case of the dreaded edit level mismatch exceptions, which usually occur client side)</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
