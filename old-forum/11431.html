<html><header><title>Using async/await from within DataPortal_XYZ methods</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Using async/await from within DataPortal_XYZ methods</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11431.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pcanada posted on Monday, June 25, 2012</h2><p>In CSLA 4.5.1 (alpha) is it safe (or would it have the expected behavior) if you used await from within DataPortal_Fetch or DataPortal_Update/etc?</p>
<p>In my particular case, the business objects retrieve and store all their data from a WCF service, in a service-oriented architecture (NOT using WCF data portal).</p>
<p> It has been recommended to call WCF service methods using the task-based async pattern with the await keyword, so the calling thread is not blocking while waiting for a response. This leads to having the await keyword in the DP_XYZ methods, but I wonder if the rest of the internal code between the DataPortal.FetchAsync&lt;T&gt;() call and the execution of the DataPortal_Fetch() is designed to handle the await symantics.</p>
<p> From my understanding, when it gets to the await, it will likely exit the DP_XYZ method prematurely and return to the previous caller(s) on up the stack, but a brief review of the CSLA code made me think that in order to properly work with the await keyword, the one who called DP_XYZ would need to also await (or .Wait()) for the results. I did not see such support there, and I think the calling code would continue on without the DP_XYZ method having fully done its job, especially if the await occurred in a DataPortal_Update() where a new BO needs to be returned using data that we are still waiting on from the wcf service (and what if the wcf service call fails).</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, June 26, 2012</h2><p>I am trying to figure out exactly how to approach this problem, yes.</p>
<p>One solution is to change the method signature of DataPortal_XYZ methods to return a Task object. This is probably the ideal solution, except that it would be a breaking change for over 99% of all existing CSLA code...</p>
<p>So I&#39;m researching ways to avoid making such a drastic change...</p>
<p>Btw, I DO plan to make that change for the local Silverlight and WinRT data portal implementation. The amount of local data portal code on Silverlight is comparatively low, and of course there&#39;s none on WinRT yet, so the impact is relatively low and the benefit quite high.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pcanada replied on Tuesday, June 26, 2012</h2><p>For what its worth, we are using full .NET and would certainly benefit from Task based support throughout CSLA.</p>
<p>The data portal sure is getting messy as I read in another post ( http://forums.lhotka.net/forums/t/11428.aspx ). Perhaps it has come to the point of needing separate a separate .dll for each dataportal/platform. It seems that the &#39;noise&#39; is just going to get worse for the next few years until we can all target Win8/RT in our apps.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, June 26, 2012</h2><p>I absolutely intend to support async/await at the DataPortal_XYZ level - don&#39;t let my rambling thoughts mislead you as to my intent :)</p>
<p>We already do create a different Csla.dll for each platform, so the noise is actually pretty minimal. For example, WP7 only sees the event-driven async options (BeginFetch, etc) because nothing else works there.</p>
<p>The one platform that sees everything (all three options) is full .NET, because all three options are perfectly valid on full .NET.</p>
<p>I could arguably drop the sync and event-driven versions in 4.5, but that would mean breaking backward compatibility - preventing people from easily moving to .NET 4.5 just for the sake of &quot;purity&quot;.</p>
<p>Now I <em>might</em> eliminate the sync and event-driven options in CSLA 5, as that would give people substantial warning of the upcoming change. But I won&#39;t do it in 4.5 because I can&#39;t now provide sufficient advance notice, nor is there a true pressing need to create such a breaking change.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pcanada replied on Wednesday, June 27, 2012</h2><p>What if a new attribute was introduced, very similar to the RunLocal attribute, maybe RunLocalAsync? This could cause new DataPortal (and related) classes to be instantiated which are async/await aware so it doesn&#39;t break backward compatibility.</p>
<p>The desire to use async/await on the &quot;server&quot; side really only applies when you are running the dataportal locally without a server. Doing async data access from an actual server might be more trouble than its worth.</p>
<p>Can you think of any other workaround? Seems like I might be able to do asynchronous data access using the ObjectFactory approach, but is there any similar overload that takes a callback for non-object factory implementations? Our current project targets .NET 4.5 specifically so that we can take advantage of some of its new features.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 27, 2012</h2><p>I can do better than that to be sure. I can detect whether the method returns a Task&lt;T&gt; and can do an await in that case.</p>
<p>What I&#39;m struggling with right now is what to define as T. The methods are currently void, and the data portal needs no return value at all, so I don&#39;t really need a T at all except to enable the await keyword. So I&#39;m considering making T be type object and you can return a null or whatever - but it will be ignored.</p>
<p>From what I can see T needs to be a fixed type, because I haven&#39;t been able to figure out how to cast object to a Task&lt;T&gt; where I don&#39;t know T until runtime. But if I hard-code T as a type, then it works fine.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pcanada replied on Wednesday, June 27, 2012</h2><p>Couldn&#39;t the methods just return the non-generic Task? I believe you can await on that as well. Even though it looks funky in code:</p>
<p>&nbsp;</p>
<p>await dp.Fetch();</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, June 30, 2012</h2><p>Yes, this seems to be the best overall solution. I have a prototype of this working, and need to merge it into the actual data portal.</p>
<p>My prototype auto-detects whether your method is void or returns Task, and therefore does an await when appropriate. This should allow for backward compatibility with existing code, while at the same time allowing some/all of your methods to switch to being async (as long as they return Task).</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
