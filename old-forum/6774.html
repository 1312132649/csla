<html><header><title>CSLA Indexed LINQ Queries</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Indexed LINQ Queries</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6774.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 posted on Friday, April 10, 2009</h2>There is a new feature in CSLA 3.6 which uses advanced search technology to speed up LINQ queries.<br />A standard LINQ query for 1 million records could require 1 million comparisons to locate a given record.<br /> <br />Using an indexed query works just like a database index. The advanced data structure is known as a Red-Black tree and to find 1 record in a million requires at most 22 comparisons. As you can see  it is significantly faster!<br /><br />Bottom Line:<br />Indexed queries are useless in a Web environment.<br /><br />Details:<br />If you apply a custom attribute to a property in a class then that property can be used in an indexed search.<br />e.g. <br />Indexable(IndexModeEnum.IndexModeOnDemand) _<br />Public ReadOnly Property Key() As Integer<br /><br />When the collection loops over the dr and calls Add(item) the CSLA framework class BusinessListBase calls its InsertItem method.<br />This method does a lot of work but the key step related to indexed queries is the call to InsertIndexItem(item).<br /><br />InsertIndexItem calls DeferredLoadIndexIfNotLoaded (which is called by most methods).<br />This checks if the internal field _indexSet is null or not. If it is null then it creates an instance of the IndexSet class using the item type as the T parameter.<br />The constructor for the IndexSet class loops over the list of propertyInfo objects for T and looks for the Indexable attribute. If it finds it then it stores the property name and a BalancedTreeIndex into an internal Dictionary named _internalIndexSet. <br /><br />The bottom line is that the BLB collection knows which child properties are indexed.<br /><br />The BLB method InsertItem then calls base.InsertItem(index, Item) to actually insert the item into the collection.<br />So as items are added to the collection the index is also “kept up to date”. Ditto for Remove, etc.<br />Think of it as the exact same thing as a database index which is kept up to date when you Insert or Delete rows.<br /><br />Since it is “expensive” to build the index it must only be done in cases where you plan to do more than 1 search.<br /><br />A good example for this is a MasterDetail pagethat lists the lines for each Header as it is selected. <br /><br />If I choose another header record then I need to filter the lines collection by the Key to get back just those lines.<br /><br />The indexed query “works” but not as I hoped. <br />This is because the index is destroyed when the BO is serialized to Session state.<br /><br />The problem is outlined in Chapter 14 of the 2008 book:<br /><br />Serialization and Indexing<br />When a CSLA .NET collection is serialized, the indices within the collection do not pass the serialization boundary. <br />This would be possible in theory, but the performance implications of having not<br />only the objects themselves but all the indices on those objects get passed over the wire are not insignificant.<br />In addition, the indexing mechanism depends on hash-code generation of objects that is<br />only consistent at the scope of a physical machine—that is, hash codes are not guaranteed to be<br />equivalent on, say, a 64-bit operating system and a 32-bit operating system—so it would be impractical<br />to translate the index values during serialization in the absence of a generic hash code generator<br />that could guarantee durability across machine boundaries.<br />Although the index itself is not passed over the serialization boundary, the index is re-created<br />according to the options specified on the child class. This typically happens upon the first instance<br />of a query that utilizes the index on the other side of the serialization boundary.<br /> <br />As you can tell from the above text – the index is destroyed every time we leave the web page because the BO is serialized into Session state.<br /><br />Therefore the penalty to re-build the index is incurred every time you postback the page.<br /><br />So the “advantage” of building the index once and re-using it is never achieved!<br /><br />Therefore I conclude that it is better to not use this new feature of CSLA in a Web environment.<br /><br />Joe<br /><br />PS - this assumes that session is stored out of process using a State Server or SQL Server. IMO you should never run a Production app in-process anyway. The appdomain recycles way too often and your users lose their session.<br /><br />PPS - the attribute above is missing the angle brackets - this forum won't show them so I omitted them intentionally.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, April 13, 2009</h2><P>Thank you Joe, well put.</P>
<P>I added a link to this post from the <A href="http://www.lhotka.net/cslanet/faq">new FAQ</A>.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
