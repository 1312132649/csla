<html><header><title>Internal interfaces &amp; .NET - Implicit vs. Explicit implementation</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Internal interfaces &amp; .NET - Implicit vs. Explicit implementation</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1324.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 posted on Monday, September 25, 2006</h2><P>This is really more of a .NET question - I'm working to implement an internal interface among different concrete types of a base class for a polymorphic collection. </P>
<P>Why isn't this valid? </P>
<P>internal interface IMyInterface</P>
<P>{ void Test(); }</P>
<P>public class MyClass : IMyInterface </P>
<P>{</P>
<P>internal void Test() {...}</P>
<P>}</P>
<P>It finds a couple options OK:</P>
<P>public void Test() {...} &lt;-- I don't want this, because I don't want it to be public! </P>
<P>void IMyInterface.Test() {...} &lt;-- I'd rather not do this for code gen reasons.&nbsp; </P>
<P>The former is gotten without explicit implementation and the latter with explicit implementation. </P>
<P>Why isn't the very first one valid? I just don't get it. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Monday, September 25, 2006</h2><P>The short answer is that interfaces members must be&nbsp;public by Microsoft's definition.</P>
<P>You can "hide" the interface itself from outsiders with accessibility modifiers, but you're expected to trust yourself when using it internally.&nbsp; :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 25, 2006</h2><P>If you actually explicitly implement the interface it does keep the members as internal. I did a really quick test to make sure of this.</P>
<P>So it seems like for the purposes of implicit implementation, you can't do it and make it internal - you have to explicitly implement the interface in order for it to be truly internal. </P>
<P>Just seems a little backasswards to me. If I declare my interface is internal my implementations should be internal, end of story. </P>
<P>Oh well! Thanks for your response. </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Monday, September 25, 2006</h2><P>I can see your point of view, but on the other hand the very purpose of an interface is to declare in a very public way that I support such-and-such functionality.</P>
<P>Explicit implementations come with their own quirks, and I would expect </P>
<P>void IMyInterface.Test() </P>
<P>to really be creating an&nbsp;public method in the implementing class and that</P>
<P>internal void IMyInterface.Test() </P>
<P>wouldn't compile.&nbsp; Did you check trying to access MyClass from outside the assembly in your second case to verify it really was internal?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 25, 2006</h2><P>It actually is hidden - yeah, I tested it from a separate project - the explicit implementation is indeed internal and the implicit implementation (publicly declared) is obviously public. </P>
<P>The only reason why I was going to utilize this is for purposes of the Update method of a polymorphic collection - it needs to Update(), DeleteSelf() and Insert() on interface members and I don't want those three methods public - so I figured I'd utilize an internal interface. </P>
<P>Just doesn't seem like there's a really&nbsp;elegant way to handle the problem. &nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Monday, September 25, 2006</h2><P>Oh yeah, I see where you're going.&nbsp; That's one of the primary reasons Rocky went the reflection route on the DataPortal_XYZ methods as I recall.</P>
<P>But the explicit implementation working that way is news to me and a little surprising.&nbsp; Since interface methods are public by definition, and the default accessibility for a method is private unless otherwise specified, I don't understand how we got to internal.&nbsp; It's like the method has the accessibility of the interface itself if it's explicitly implemented.</P>
<P>But the stated purpose of an explicit implementation is&nbsp;essentially to "hide" the implementation, so maybe that makes sense - and serves your purposes.&nbsp; In other words, Microsoft's position is</P>
<OL>
<LI>interface members are public by definition</LI>
<LI>explicitly implement the interface if you want to hide them</LI></OL></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Monday, September 25, 2006</h2><P>Yeah, I think that would be the recommended solution the more I think about it.&nbsp; Since the interface itself is not public, you wouldn't be able to cast the object to it from outside the assembly, and without doing that you couldn't see those methods that were explicitly implemented.&nbsp; Exactly what you want, but perhaps a little more convoluted than you'd like.&nbsp; But I think it all makes sense taken as a whole.</P>
<P>And, if that's the case, why couldn't this be used for the DataPortal_XYZ methods Rocky?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Monday, September 25, 2006</h2>Would that not be because a CSLA interface would need to be publicly visible to be implemented by your business objects?&nbsp; This kind of solution would need to be implemented within a business object assembly.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 25, 2006</h2><P>Ignore this post, its in flux. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, September 25, 2006</h2>Reflection I would think is much slower than casting.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Monday, September 25, 2006</h2><P>You're definitely correct on that one, Andy. </P>
<P><A href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncscol/html/csharp02172004.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncscol/html/csharp02172004.asp</A></P>
<P>Another post, probably a more practical one, is here:</P>
<P><A href="http://west-wind.com/weblog/posts/351.aspx">http://west-wind.com/weblog/posts/351.aspx</A></P>
<P>Of course, on a Web app like mine, this is not going to be the bottleneck. I am probably going to utilize reflection for a "cleaner" solution for now and then come back to it later. I have a few code gen issues otherwise that I don't want to deal with right now. </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, September 26, 2006</h2>Yes, reflection is slower, but there are better things to optimize first.&nbsp; Data access and for a web app, getting pages from server to client are the biggest bottlenecks.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, September 25, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>DansDreams:</strong></div><div>And, if that's the case, why couldn't this be used for the DataPortal_XYZ methods Rocky?</div></BLOCKQUOTE><br><br>I think so that you can create your own DP's without forcing them into the Csla assembly.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, September 25, 2006</h2>Dan,<br><br>The reason the explicit implementation works as it does is because you cannot see explicitly defined members unless you cast to the interface... and if the interface is not public, you can never cast to said interface.<br><br>Its not that explicitly implemented interfaces are 'hidden' per say; it just means to 'see' the implemntation, you must cast explicitly to the interface.&nbsp; Try this:<br><br><font color="#0000ff">public interface</font> <font color="#008000">IPerson </font>{<br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">string </font>Name { <font color="#0000ff">get</font>; }<br>}<br><br><font color="#0000ff">public class</font> <font color="#008000">Person </font>: <font color="#008000">IPerson </font>{<br>&nbsp;&nbsp;&nbsp; <font color="#0000ff">string </font><font color="#008000">IPerson</font>.Name { <font color="#0000ff">get </font><font color="#ff0000">"My Name"</font>; }<br>}<br><br><font color="#0000ff">public static void</font> Main() {<br>&nbsp;&nbsp; <font color="#008000">Person </font>p;<br>&nbsp;&nbsp; <font color="#008000">IPerson </font>iP;<br><br>&nbsp;&nbsp; p = new Person();<br>&nbsp;&nbsp; <font color="#008000">//Console.WriteLine( p.Name ); // This wont' compile if uncommented</font><br><br>&nbsp;&nbsp;&nbsp; iP = (<font color="#008000">IPerson</font>)p;<br>&nbsp;&nbsp;&nbsp; <font color="#008000">Console</font>.WriteLine( iP.Name );<br>}<br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
