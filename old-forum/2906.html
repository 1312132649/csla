<html><header><title>Generating temporary unique (int) ID values for objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Generating temporary unique (int) ID values for objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2906.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wayne2K posted on Saturday, May 19, 2007</h2>In <a href="http://www.lhotka.net/Article.aspx?area=4&amp;id=252e4f20-f202-4ba5-b6ff-4d629a2b7dcc">one of</a> Rockford's articles he shows some code to generate a unique integer by using a static member variable. Here is the C# example:<br><br><p class="MsoNormal"><font color="#000000" face="Courier New"><span>Public Class SomeChild<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span>{<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp; </span>private static int _lastId;<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><o:p>&nbsp;</o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp; </span>private SomeChild()<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp; </span>{<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp;&nbsp;&nbsp; </span>// require use of factory methods<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp;&nbsp;&nbsp; </span>_id = _lastId â€“ 1;<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp;&nbsp;&nbsp; </span>_lastId = _id;<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span><span>&nbsp; </span>}<o:p></o:p></span></font></p>
<p class="MsoNormal"><font color="#000000" face="Courier New"><span>}</span></font></p><p class="MsoNormal"><br><font color="#000000" face="Courier New"><span></span></font></p><font color="#000000"><font face="Arial">Won't this cause problems if two different threads are creating objects of the same class?<br><br>What do you think about the code below as an alternative? It produces seemingly random negative numbers, but there IS a 1 in 2 billion chance that there can be a collision.<br><br><font face="Courier New">int id = - Math.Abs(Guid.NewGuid().GetHashCode());<br>Debug.Print("New Id: " + id.ToString() );<br><br><font face="Arial">Generating a Guid and hashing it is also a lot more work than just decrementing a static int. Another idea I had was to just use Interlocked.Decrement all the time (probably not a good idea).<br><br>Yet another idea was to get the pointer to the object and use that...I'm not really sure that I can trust an unmanaged pointer to remain the same throughout an object's lifetime though...<br></font></font></font></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Saturday, May 19, 2007</h2>Do a search of the forums.&nbsp; There are several examples of a thread safe version of this.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wayne2K replied on Monday, May 21, 2007</h2>I found the other threads, thanks.<br><br>I ended up using Interlocked.Decrement because I saw that Microsoft uses the Interlocked class in the constructor for System.Data.DataRow, so there must not be a huge performance penalty for doing it.<br><br>Thanks!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 22, 2007</h2>Since this is at least the second time this has come up, I've now updated the article on my web site to use Interlocked. That is a more correct solution.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, May 23, 2007</h2><P>This thread had another interesting approach...</P>
<P><A HREF="/forums/post/13401.aspx">http://forums.lhotka.net/forums/post/13401.aspx</A></P>
<P>The post:</P>
<P><EM>&nbsp;This has been an interesting thread to read. We took the compromise route in our office. None of our transactional objects (customer orders, purchase orders, etc.) know their primary key when they are new. <BR><BR>We have two private fields in these objects to handle the identity. One is the primary key and the other is a GUID. DataPortal_Create instanatiates the guid variable. DataPortal_Fetch instantiates the primary key variable.<BR><BR>Our GetIdValue overrides look like this for these objects:<BR>Public Overrides Sub GetIdValue() As Object<BR>&nbsp;&nbsp;&nbsp; Return IIf(Me.IsNew, mFakeID, mPrimaryKey)<BR>End Sub<BR><BR>The GUID doesn't go in the database, so the performance people on our team are satisfied. It really just gets used for comparison purposes. We don't explicitly use GetIdValue in any of our business or UI code.</EM></P>
<P>What I liked about this was a case where one has polymorphic behavior through an inheritance chain. Let's say you have IContactMethod with Emails, Phones, Websites, etc. If you have a polymorphic collection you can't just have each class generate their own negative numbers through a static variable on the concrete classes - it's possible you'll have collisions. The use of Guids here (not for persistance but for uniqueness of new objects) seems to be a good solution. Not to mention, this behavior can&nbsp; happen at the highest level of business objects (right under BusinessBase that most of our business objects descend from, rather than in each concrete class). </P>
<P>If there are drawbacks I'm missing w/ regards to this I certainly would be interested (as we're taking this approach).</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Wednesday, May 23, 2007</h2>Another thing to think of is that you do not have to have a separate set of negative numbers per type of object.&nbsp; One set of negative numbers will work fine across all object types.&nbsp; Another choice you can make is to just give every object a Guid that has nothing to do with the real id values in the object.&nbsp; In the case of giving all objects the same set of numbers to work from, you can have a separate class that all classes have access to, and this separate object is in charge of decrementing ids through static methods.&nbsp; There is nothing wrong with the method you are looking at using, but it may be more complicated than you need.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
