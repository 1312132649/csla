<html><header><title>Private backing fields and non generic LoadProperty</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Private backing fields and non generic LoadProperty</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10037.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>zep2j posted on Monday, February 07, 2011</h2><p>Hi, I am new to CSLA and I am trying to use properties with&nbsp;private backing fields in business rules.</p>
<p>I have registered my properties with RelationshipTypes.PrivateField.&nbsp; When I use the non generic LoadProperty method with these private backing fields I get an exception stating &quot;Attempt to read/load private field property in managed properties&quot;.</p>
<p>This seems to be a contradiction to what has been stated in the CSLA 4 documentation and previously stated on this forum:</p>
<p><em>&quot;The PrivateField flag is intended to tell CSLA that you are using a private field. So you do need to use the private field syntax in your property declaration - and now you can tell CSLA that this is what you are doing.</em></p>
<p><em>That is important, because it means that the non-generic ReadProperty and LoadProperty methods then know that they should use BypassPropertyChecks and reflection to interact with the property, rather than using the field manager.&quot;</em></p>
<p>I have looked at the CSLA code and the non&nbsp;generic LoadProperty method calls the generic LoadProperty method using reflection which subsequently calls FieldManager.GetFieldData which throws an exception if the property is registered with PrivateField.</p>
<p>This becomes an issue when trying to use context.AddOutValue in a business rule as LoadProperty is called to set the property value once the rule has completed.</p>
<p>From looking at the CSLA code ReadProperty seems to behave correctly with private backing fields.</p>
<p>Is this a bug or am I doing something completely wrong?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, February 07, 2011</h2><p>This appears to be a bug, I&#39;ll add it to the bug list.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, February 07, 2011</h2><p>Hmm, digging into this a little further, I&#39;m not sure it is a bug. I think this is by design to the best of my recollection.</p>
<p>And here&#39;s why:</p>
<p>Exactly how would something like LoadProperty(IPropertyInfo, object) ever figure out which backing field to use?</p>
<p>At one point in the evolution of the code we did have LoadProperty call the property setter via reflection, but that&#39;s not a workable solution because the setter could be non-public (it always is in a read-only object), so it is not accessible. And this is why the non-generic LoadProperty now invokes the generic LoadProperty.</p>
<p>But as you note, this only works with managed property values.</p>
<p>So we&#39;re back to this core issue - .NET has no idea how to map any given property to a specific private field. There&#39;s no mechanism for this within .NET anywhere - other than the code you write in your getter and setter, and that code can&#39;t be assumed to be accessible.</p>
<p>I suppose we could do something interesting, such as:</p>
<ol>
<li>In the generic LoadProperty detect that this is a private field property</li>
<li>In that case cast the object to some IHavePrivateFields interface</li>
<li>Call a SetFieldValue method from IHavePrivateFields like: SetFieldValue(IPropertyInfo, newValue)</li>
<li>You would manually implement IHavePrivateFields in your business class, and in the SetFieldValue method you would map IPropertyValue values to the appropriate backing field values</li>
</ol>
<p>We did implement something like this at one point in the evolution of CSLA 4, but the functionality was removed because it leads to code that is hard to maintain. Specifically, that SetFieldValue method is basically a big nested if..then or switch block that is easy to get wrong or forget to update as you add/remove properties and fields.</p>
<p>Ultimately we decided that people using private fields can come up with their own mechanism to interact with their fields. The primary reason for using private fields is performance, in which case having us do all sorts of fancy reflection and so forth is entirely counter-productive and people should have used managed fields to start with :)</p>
<p>To retain the perf benefits of using private fields, I think it is best if people come up with their own light-weight access schemes that avoid reflection or dynamic method/property invocation.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, February 07, 2011</h2><p>Actually, what you should do is override the Non-generic LoadProperty to set your private fields, like this: </p>
<pre style="font-family:consolas;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">override</span>&nbsp;<span style="color:blue;">void</span>&nbsp;LoadProperty(<span style="color:#2baaaf;">IPropertyInfo</span>&nbsp;propertyInfo,&nbsp;<span style="color:blue;">object</span>&nbsp;newValue)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />      // Set private fields <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(propertyInfo.Name&nbsp;==&nbsp;NameProperty.Name)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _name<span style="color:red;"></span> =&nbsp;(<span style="color:blue;">string</span>)&nbsp;newValue;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />      // call base implementation to set managed properties<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">else</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">base</span>.LoadProperty(propertyInfo,&nbsp;newValue);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />For the performance and access reasons given in Rocky&#39;s post. </pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, February 07, 2011</h2><p>Ahh, good job Jonny - I <em>thought</em> we had an answer for this, but it totally slipped my mind...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>zep2j replied on Monday, February 07, 2011</h2><p>Yeah, I am already overriding LoadProperty.</p>
<p>I just thought I would raise it because the documentation stated something different and the ActionExtenderSample project has an override of LoadProperty commented out which I assumed was implying that you do not&nbsp;need to do that anymore with CSLA 4.</p>
<p>Thanks.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
