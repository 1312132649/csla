<html><header><title>Tests FAIL running in VS2012, but PASS in VS2010</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Tests FAIL running in VS2012, but PASS in VS2010</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11545.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>mattruma posted on Wednesday, August 22, 2012</h2><p>&nbsp;</p>
<p>In VS2010 my MSTest tests run just fine.</p>
<p>When running in VS2012 I am getting an error. The test sets the Csla.ApplicationContext.User with a Custom Business Principal. When EntityFramework is asked to provide a new ObjectContext I receive a SerializationException saying that my Custom Business Principal type cannot be found.</p>
<p>So far all tests that use EntityFramework fail when running through VS2012&#39;s test runner or Resharper7&#39;s test runner. I have tried NCrunch&#39;s test runner and they all pass.</p>
<p>Anyone else having issues like this? Any help would be much appreciated.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, August 23, 2012</h2><p>I think Microsoft did some major rework on the way mstest hosts and runs tests in VS12. My understanding is that these changes were necessary to support the ability they now have to host various test runners, not just mstest.</p>
<p>I haven&#39;t looked into this in depth, but the typical issue comes because the tests end up running on a thread that crosses AppDomain boundaries between the test runner and the actual test code.</p>
<p>The test code AppDomain has access to all your types, but the test runner AppDomain doesn&#39;t because it isn&#39;t hosting your code.</p>
<p>The solution is to ensure that the ApplicationContext.User property (System.Threading.Thread.CurrentPrincipal) is set to a neutral type before the test completes (before the thread leaves the AppDomain hosting your code and returns to the test runner AppDomain). A neutral type is like GenericPrincipal - something that is native to .NET itself.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mattruma replied on Thursday, August 23, 2012</h2><p>Thanks Rocky! I&#39;ll take a look at this and let you know what I find out ...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jamie-altizer replied on Friday, August 24, 2012</h2><p>Thanks Rocky, your feedback verified some assumptions and pushed us in the correct direction. </p>
<p>Ultimately our issue was that we use reflection to load our data access layer and thus EF is referenced there and does not know about the custom principle. It is interesting that EF cares about the principal. Our immediate solution was to wrap the call to the ObjectContextManager and manage the setting and resetting of the principal. Thank you for your help and nudge, it gave us a few things to try that led to our ultimate issue.</p>
<p>On an associated tangent, do you think an IoC container would have&nbsp;alleviated the issue of not knowing about our custom principal?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>MikeGoatly replied on Wednesday, May 01, 2013</h2><p>I think I&#39;ve got to the bottom of this now. The problem that Rockford is talking about was something that manifested itself prior to 2012 in my experience - this is something all together different!</p>
<p>I think that the key behavioural difference between the 2010 and 2012 test runners is that the 2010 runner causes the ConfigurationManager class to be fully&nbsp;initialized prior to&nbsp;running the test.</p>
<p>When ConfigurationManager is initialized it reads from AppDomain.Evidence, which causes a stack walk - if you have placed a custom principal on the thread this ends up being de-serialized in the original AppDomain, which fails with the SerializationException you&#39;re seeing.</p>
<p>The fix is a little dirty, but if you make a call to ConfigurationManager.GetSection(&quot;ANY DUMMY TEXT&quot;) prior to&nbsp;your test then things should start working again.</p>
<p>FWIW, we have a base class that all our unit test classes&nbsp;derive from - putting this call in the constructor of that base class works fine.</p>
<p>HTH,</p>
<p>Mike</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
