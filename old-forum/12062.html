<html><header><title>ApplicationContextManager issue and WCF</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ApplicationContextManager issue and WCF</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12062.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks posted on Monday, July 08, 2013</h2><p>It looks like we have a nasty problem with ApplicationContext which I am hoping someone can help with.</p>
<p>We have some WCF services hosted within an ASP.NET website (where the website also contains ASPX pages) so that we can expose data to JavaScript for client-side functionality (such as auto-complete dropdowns.) All of the WCF services have AspNetCompatibility set to Required so that we can access Session contents. We&#39;re using IIS 7.5 to host the website and Csla 4.1 with .NET 4.</p>
<p>Csla.Web is in the \Bin folder so that we are using the HttpContext-based ApplicationContentManager.</p>
<p>Most of the time everything works just fine, but every once is a while our WCF services stop working. After patient debugging it appears that we end up with Csla.ApplicationContext.User returning the wrong principal (not our custom principal), so all of our authorisation then fails. This problem remains until we restart the AppDomain, when everything starts working normally again.</p>
<p>Having looked at the Csla implementation of ApplicationContext it is clear that the ContextManager property could cause us problems. It appears that on each request the IsValid property of the current IContextManager is checked and if IsValid returns false a new instance of the non-web ApplicationContextManager is created. In Csla.Web the ApplicationContextManager.IsValid property checks whether HttpContext.Current is null. If this were ever to happen then Csla would switch to the wrong ApplicationContextManager and this would not be corrected until the AppDomain restarts.</p>
<p>I have no idea why HttpContext.Current would ever be null, unless it is to do with the fact that we are using async service methods for some of our services to support best scalability. At the moment it is a guess that this is happening, because the problem doesn&#39;t occur regularly we have difficulty debugging it fully.</p>
<p>Has anyone else ever seen this problem and did they come up with a solution? Thanks.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks replied on Monday, July 08, 2013</h2><p>Further to my previous post the developer who managed to recreate it whilst debugging found that after the WCF service started to fail the Csla.ApplicationContext.User result was different to HttpContext.Current.User. Csla.ApplicationContext.User returned an unauthenticated user with no roles whereas HttpContext.Current.User returned the custom principal with all of its roles as we would expect.</p>
<p>The only way I can see these two returning different values is if the wrong context manager is in use, and the only way I can see that changing through the life of the AppDomain is if, on the rare occasion, HttpContext.Current returns null and the code in the ContextManager property of the ApplicationContext class uses this to identify that it needs to create a new instance of the wrong context manager.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Monday, July 08, 2013</h2><p>Hi,</p>
<p>This was fixed in CSLA 4.2.2</p>
<p>See:&nbsp;<a href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=944">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=944</a>&nbsp;<br />And: <a href="http://www.lhotka.net/Article.aspx?id=2607a4ef-e6a9-4801-aa0b-518c51267339">Csla 4.2.2 Change Log&nbsp;</a></p>
<p>HttpContext.Current will be null when you execute code on a background thread. (ex BackgroundWorker)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks replied on Monday, July 08, 2013</h2><p>Hi Jonny,</p>
<p>Thanks for your rapid response. That&#39;s very useful information and it looks like the code changes should ensure we don&#39;t run into this one again, or at least we would run into it only in sections of the code that run on background or custom threads and would not spread to change the behaviour of the AppDomain for the test of its lifetime.</p>
<p>We&#39;ll test out the new version and I&#39;ll verify the answer if it does indeed solve the problem -&nbsp;I can&#39;t see why it wouldn&#39;t, but time will tell.</p>
<p>Best wishes,</p>
<p>&nbsp;</p>
<p>Andrew</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks replied on Tuesday, July 16, 2013</h2><p>Thanks Jonny, you were absolutely right. The problem is solved with the code in the later release.</p>
<p>I appreciate your time.</p>
<p>&nbsp;</p>
<p>Andrew</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
