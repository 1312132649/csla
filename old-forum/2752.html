<html><header><title>SafeDataReader, IDisposable and Undeterministic Destruction</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>SafeDataReader, IDisposable and Undeterministic Destruction</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2752.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>William posted on Monday, April 23, 2007</h2>I am giving some thoughts on SafeDataReader.<br><br>SafeDataReader implements IDataReader and IDisposable. In C#, best practice when using disposable objects is to explicitly call the Dispose() method when you are done. Typically, in DataPortal_Fetch() method of CSLA business objects,<br><br><font face="Courier New" size="2">protected override void DataPortal_Fetch(object criteria)<br>{<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; using (SafeDataReader dr = new SafeDataReader(cmd.ExecuteReader))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  // Fetch data.<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  dr.NextResult();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  _childObject.Fetch(dr);<br>&nbsp;&nbsp;&nbsp; }<br>}</font><br><br>Then, in the child object, I would like to maintain the genericity of using IDataReader instead of SafeDataReader. The primary reason is that this allows flexibility in switch between real DataReader and DataTableReader, which both implements IDataReader.<br><br><font face="Courier New" size="2">internal void Fetch(IDataReader dr)<br>{<br>&nbsp;&nbsp;&nbsp; using (SafeDataReader sdr = new SafeDataReader(dr))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  ...<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br></font>This pattern will close the underlying data reader when the using block exits - correct practice, but it also closes the underlying data reader, which it is not supposed to.<br><br>Another way,<br><br><font face="Courier New" size="2">internal void Fetch(IDataReader dr)<br>
{<br>
&nbsp;&nbsp;&nbsp; SafeDataReader sdr = new SafeDataReader(dr);<br><br>&nbsp;&nbsp;&nbsp; // Fetch data and return. No Dispose() call.<br>}<br></font>
<br>This version does not explicitly call the Dispose method. However, the destructor of SafeDataReader does call Dispose method. It is undetermined when the destructor will be called, which I think will close the underlying data reader in an unattended manner.<br><br>I am concerning if I am using SafeDataReader in the correct way or there are other special considerations I need to be aware of.<br><br>Please advise.<br><br>Regards,<br>William<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>William replied on Monday, April 23, 2007</h2>Rocky,<br><br>What is the intended and correct usage of SafeDataReader for the scenario described above?<br><br>Regards,<br>William<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Monday, April 23, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>William:</strong></div><div><br><font face="Courier New" size="2">internal void Fetch(IDataReader dr)<br>{<br>&nbsp;&nbsp;&nbsp; using (SafeDataReader sdr = new SafeDataReader(dr))<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  ...<br>&nbsp;&nbsp;&nbsp; }<br>}<br></font></div></BLOCKQUOTE><br>In my opinion, there is no reason to pass an IDataReader if you are immediately going to wrap it in a SafeDataReader again.&nbsp; Just pass the SafeDataReader from parent to child.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
