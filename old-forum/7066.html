<html><header><title>Data Bind to a TreeView Control in WPF?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Data Bind to a TreeView Control in WPF?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7066.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>kevnworking posted on Tuesday, June 09, 2009</h2><font size="3"><font face="Tahoma">Hey All,<br><br>I have a two-part question.&nbsp; First, can someone turn me on to an example of databinding a child collection of objects to a TreeView control?&nbsp; I've been wrestling with this for a few hours now and I can't figure it out - I THINK I'm doing it correctly but I get a big bag of nothing on the form.&nbsp; I would think it would be fairly easy, something like:<br><br>&lt;TreeView DataContext="{Binding Source={StaticResource UserModuleCollection}}"&gt;<br>&lt;/TreeView&gt;<br><br>I could be way off on this - I'm new to WPF (obviously) but have found it quite easy to databind textboxes, labels and datepickers to my objects in XAML.&nbsp; The treeview solution escapes me though.&nbsp; I was hoping that the one line above would give me something to build on.<br><br>Second, and this is somewhat related to the first part, when needing to access a collection of child objects in a root parent object do you have to create another CslaDataProvider for that collection or is there some way to bind (in XAML) the child collection from the parents data provider?&nbsp; I looked in the book but couldn't find the answer - perhaps my brain is fried from working all day.<br><br>Thanks for any help that you can offer...<br><br>Kevin<br></font></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Wednesday, June 10, 2009</h2><P>Take a look at the following article by Josh Smith: <A href="http://www.codeproject.com/KB/WPF/TreeViewWithViewModel.aspx">http://www.codeproject.com/KB/WPF/TreeViewWithViewModel.aspx</A></P>
<P>IMHO if you are using WPF then you make your life easier (in the long run) by following the MVVM pattern.&nbsp; Others will disagree ;-)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kevnworking replied on Tuesday, June 23, 2009</h2><font face="Arial">Sorry for the late reply.&nbsp; I did finally get this figured out, at least it displays and binds.&nbsp; :0)<br><br>I will check out the article you suggested - I have noticed that every time I refresh the datasource the treeview collapses back to the root level objects instead of staying expanded where the user changed something.&nbsp; I'm hoping the solution to that is in the article you suggested.<br><br>So, to answer my own question just in case someone wonders across this.&nbsp; The second part of my question first - I figured this out after rereading that part of the book, the collection is exposed through it's parent class - so in this case I had a "User" class and the "Modules" class is exposed through user as a child collection.&nbsp; So basically you just refer to the "Modules" collection property in User for your binding path.<br><br>Here is the XAML code I ultimately used for the treeview:<br>&lt;TreeView Name="trvModules" ItemsSource="{Binding Path=Modules}"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;TreeView.ItemTemplate&gt;<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;HierarchicalDataTemplate ItemsSource="{Binding UserModules}"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;StackPanel Orientation="Horizontal"&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;CheckBox Margin="1,1,5,1" IsChecked="{Binding Path=HasAccess, Converter={StaticResource IdentityConverter}, Mode=TwoWay}" /&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;TextBlock Text="{Binding Path=ModuleDescription}" /&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;TextBlock Text="(" /&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;TextBlock Text="{Binding Path=UserModuleId}" /&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;TextBlock Text=")" /&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;/StackPanel&gt;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;/HierarchicalDataTemplate&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/TreeView.ItemTemplate&gt;<br>&lt;/TreeView&gt;<br><br>I hope this helps someone in the future.<br><br>Kevin<br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, June 23, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Fintanv:</strong></div><div>
<P>IMHO if you are using WPF then you make your life easier (in the long run) by following the MVVM pattern.&nbsp; Others will disagree ;-)</P>
<P></div></BLOCKQUOTE></P>
<P>The question is <EM>which</EM> MVVM pattern? There are several variants with different pre-conditions and consequences.</P>
<P>Many of the MVVM pattern variants assume an anemic Model, such as a bunch of DTO/proxy/entity objects you get back from calling a service or something like EF or L2S. Those variants require that you do a lot of work in the VM to overcome the lack of functionality in the Model, and that's fine.</P>
<P>However, CSLA .NET ensures that your Model is far from anemic. In fact, it is incredible rich, with the DataTable being the only thing I know of that comes close. Fortunately there are variants of MVVM where the VM exposes the Model as a property, along with various methods (commands) that can be bound to buttons, etc.</P>
<P>That type of MVVM implementation works really well with CSLA .NET.</P>
<P>On the other hand, if you use one of the "anemic model" variants of MVVM with CSLA objects, you'll have to do <EM>more</EM> work in your VM or sacrifice a lot of functionality. Your VM could have to implement and delegate (bi-directionally) all the data binding interfaces, authorization, business rule and other functionality that is built directly into CSLA.</P>
<P>In <EM>either</EM> case (anemic or rich Model), if your object graph is complex (parent-child-grandchild-etc) your VM can become incredibly complex very rapidly, as you try to flatten or duplicate the shape of the Model.</P>
<P>I've had people argue that the point of the VM is to "reshape" the Model for the UI. And I agree that if your Model was not designed using good OOD (is data-centric rather than respnsibility-driven) then your VM will probably have to do that - which is really lame, and simply means you did a crappy job with your object model.</P>
<P>On the other hand, if you use responsibility-driven design for your business objects, your object model should naturally follow the shape of the use case, as should the UI. Since they follow the same use case, the objects should <EM>already be the right shape</EM>.</P>
<P>Lots of opinion there, but that's my current way of thinking about MVVM.</P>
<P>Yes it is good. Some variants work really well with CSLA. Other variants cause you to do so much work that I can't possibly imagine it is of long-term benefit.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
