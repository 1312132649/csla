<html><header><title>Problem using MobileFormatter.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Problem using MobileFormatter.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8069.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell posted on Tuesday, December 01, 2009</h2>Dear sirs and ladies.<br><br>I am in the process of porting our CSLA based business logic infrastructure to Silverlight (the client side, of course). In the process I have to transition several types to support IMobileObject interface.<br>If I understand it correctly, the MobileFormatter infrastructure in general is not limited in any way to the Silverlight platform, thus I unit test my changes on the .NET platform.<br><br>And here I have a certain problem. It is probably because I misunderstand something important about the mobile objects. Anyway, I came up with a small code to demonstrate the problem. Observe:<br><br>&nbsp; [Serializable]<br>&nbsp; internal class ComplexObject&lt;T&gt; : MobileObject, IEquatable&lt;ComplexObject&lt;T&gt;&gt;<br>&nbsp;&nbsp;&nbsp; where T : IEquatable&lt;T&gt;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; private T m_state;<br><br>&nbsp;&nbsp;&nbsp; internal T State<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return m_state; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { m_state = value; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnGetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.AddValue("m_state", m_state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnGetState(info, mode);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnSetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnSetState(info, mode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_state = info.GetValue&lt;T&gt;("m_state");<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public bool Equals(ComplexObject&lt;T&gt; other)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_state.Equals(other.m_state);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>&nbsp; public static class Program<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; private static object GetDeepCopy(object obj)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var formatter = new MobileFormatter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var ms = new MemoryStream())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; formatter.Serialize(ms, obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.Position = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return formatter.Deserialize(ms);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private static void Test&lt;T&gt;(T value) where T : IEquatable&lt;T&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = new ComplexObject&lt;T&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.State = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var copy = (ComplexObject&lt;T&gt;)GetDeepCopy(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Assert(obj.Equals(copy));<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public static void Main()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Test&lt;int&gt;(100);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Test&lt;string&gt;("100");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Test&lt;DateTime&gt;(DateTime.Now);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Test&lt;ComplexObject&lt;int&gt;&gt;(new ComplexObject&lt;int&gt;() { State = 100 });</b><br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>The code simply creates deep copies of various ComplexObject&lt;T&gt; instances using MobileFormatter and checks that the deep copy actually equals to the original.<br><br>The last line fails (see the exception at the end of this post). I guess I have implemented ComplexObject&lt;T&gt;.OnGetState and ComplexObject&lt;T&gt;.OnSetState wrong. What is the correct way to implement them?<br><br>Thanks.<br><b><br>The last test fails with the following exception:</b><br>System.Runtime.Serialization.SerializationException was unhandled<br>&nbsp; Message="Type 'A.ComplexObject`1[[System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' with data contract name 'ComplexObjectOfint:http://schemas.datacontract.org/2004/07/A' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer."<br>&nbsp; Source="System.Runtime.Serialization"<br>&nbsp; StackTrace:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeAndVerifyType(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, Boolean verifyKnownType, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithXsiType(XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle objectTypeHandle, Type objectType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle, Type declaredType)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerializeReference(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at WriteSerializationInfo.FieldDataToXml(XmlWriterDelegator , Object , XmlObjectSerializerWriteContext , ClassDataContract )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.ClassDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter, Object obj, XmlObjectSerializerWriteContext context)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerializeReference(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at WriteKeyValueOfstringSerializationInfo.FieldDataOzoZvLrmToXml(XmlWriterDelegator , Object , XmlObjectSerializerWriteContext , ClassDataContract )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.ClassDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter, Object obj, XmlObjectSerializerWriteContext context)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at WriteArrayOfKeyValueOfstringSerializationInfo.FieldDataOzoZvLrmToXml(XmlWriterDelegator , Object , XmlObjectSerializerWriteContext , CollectionDataContract )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.CollectionDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter, Object obj, XmlObjectSerializerWriteContext context)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerializeReference(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at WriteSerializationInfoToXml(XmlWriterDelegator , Object , XmlObjectSerializerWriteContext , ClassDataContract )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.ClassDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter, Object obj, XmlObjectSerializerWriteContext context)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerialize(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.InternalSerializeReference(XmlWriterDelegator xmlWriter, Object obj, Boolean isDeclaredType, Boolean writeXsiType, Int32 declaredTypeID, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at WriteArrayOfSerializationInfoToXml(XmlWriterDelegator , Object , XmlObjectSerializerWriteContext , CollectionDataContract )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.CollectionDataContract.WriteXmlValue(XmlWriterDelegator xmlWriter, Object obj, XmlObjectSerializerWriteContext context)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.WriteDataContractValue(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializerWriteContext.SerializeWithoutXsiType(DataContract dataContract, XmlWriterDelegator xmlWriter, Object obj, RuntimeTypeHandle declaredTypeHandle)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.DataContractSerializer.InternalWriteObjectContent(XmlWriterDelegator writer, Object graph)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.DataContractSerializer.InternalWriteObject(XmlWriterDelegator writer, Object graph)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.XmlObjectSerializer.WriteObjectHandleExceptions(XmlWriterDelegator writer, Object graph)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at System.Runtime.Serialization.DataContractSerializer.WriteObject(XmlWriter writer, Object graph)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at Csla.Serialization.Mobile.MobileFormatter.Serialize(XmlWriter writer, Object graph) in c:\Dev\3rd_party\csla\Serialization\Mobile\MobileFormatter.cs:line 86<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at Csla.Serialization.Mobile.MobileFormatter.Serialize(Stream serializationStream, Object graph) in c:\Dev\3rd_party\csla\Serialization\Mobile\MobileFormatter.cs:line 42<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at A.Program.GetDeepCopy(Object obj) in C:\Home\work\A\Program.cs:line 46<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at A.Program.Test[T](T value) in C:\Home\work\A\Program.cs:line 56<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; at A.Program.Main() in C:\Home\work\A\Program.cs:line 65<br>&nbsp; InnerException: <br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, December 01, 2009</h2>I'm not sure MobileObject supports generic types. This isn't a definite answer, just a guess, but I think it is a good guess :)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Wednesday, December 02, 2009</h2>Thanks Rocky for the prompt reply.<br>Here is a sample code without any generics that produces the same regretfully negative result:<br><br>&nbsp; [Serializable]<br>&nbsp; internal class SimpleObject : MobileObject, IEquatable&lt;SimpleObject&gt;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; private int m_state;<br><br>&nbsp;&nbsp;&nbsp; internal int State<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return m_state; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { m_state = value; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnGetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.AddValue("m_state", m_state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnGetState(info, mode);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnSetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnSetState(info, mode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_state = info.GetValue&lt;int&gt;("m_state");<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public bool Equals(SimpleObject other)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_state.Equals(other.m_state);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>&nbsp; [Serializable]<br>&nbsp; internal class ComplexObject : MobileObject, IEquatable&lt;ComplexObject&gt;<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; private SimpleObject m_state;<br><br>&nbsp;&nbsp;&nbsp; internal SimpleObject State<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return m_state; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { m_state = value; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnGetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>info.AddValue("m_state", m_state);</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnGetState(info, mode);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnSetState(SerializationInfo info, StateMode mode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnSetState(info, mode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_state = info.GetValue&lt;SimpleObject&gt;("m_state");<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public bool Equals(ComplexObject other)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_state.Equals(other.m_state);<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>&nbsp; public static class Program<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; private static object GetDeepCopy(object obj)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var formatter = new MobileFormatter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var ms = new MemoryStream())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; formatter.Serialize(ms, obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ms.Position = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return formatter.Deserialize(ms);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private static void TestSimpleObject()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = new SimpleObject() { State = 100 };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var copy = (SimpleObject)GetDeepCopy(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Assert(obj.Equals(copy));<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private static void TestComplexObject()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = new ComplexObject() { State = new SimpleObject() { State = 200 } };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var copy = (ComplexObject)GetDeepCopy(obj);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Assert(obj.Equals(copy));<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public static void Main()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestSimpleObject();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>TestComplexObject();</b><br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br><br>TestComplexObject() crashes with the same exception. I must be doing something wrong inside the ComplexObject.OnGetState method.<br><br>Regarding your reply. Then why MobileList&lt;T&gt; is supported? It is a generic type after all.<br><br>Thank you very much.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Wednesday, December 02, 2009</h2>I have found how to make the sample code work. One has to replace the OnGetState and OnSetState overrides in the ComplexObject with the following overrides:<br><br>&nbsp;&nbsp;&nbsp; protected override void OnGetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var childInfo = formatter.SerializeObject(m_state);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; info.AddValue("m_state", childInfo.ReferenceId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnGetChildren(info, formatter);<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; protected override void OnSetChildren(SerializationInfo info, MobileFormatter formatter)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnSetChildren(info, formatter);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var referenceId = info.GetValue&lt;int&gt;("m_state");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_state = (SimpleObject)formatter.GetObject(referenceId);<br>&nbsp;&nbsp;&nbsp; }<br><br>Is it the right way to achieve the serialization of nested mobile objects?<br><br>Thanks.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, December 02, 2009</h2><P>I don't have time to look into this in the near future, as I'm traveling this week and next.</P>
<P>I suggest you look at the unit tests for serialization, as I know we have tests specifically for private backing field serialization. Maybe they will help you identify what is missing/wrong in your test.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Wednesday, December 02, 2009</h2>Great, thanks. Have a good trip.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
