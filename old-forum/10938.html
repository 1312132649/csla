<html><header><title>IClientChannel.OperationTimeout issue</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>IClientChannel.OperationTimeout issue</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10938.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Cuong posted on Friday, December 02, 2011</h2><p>Hi Rocky,</p>
<p><br />In my SL app, sometimes I have to execute commands which run in a long time (&gt; 60 minutes). I already set closeTimeout, openTimeout, receiveTimeout, sendTimeout to a big value (i.e 12:00:00) in both client and server but I always get a timeout exception after a command exceeds 10 minutes of running. I found the reason resides on IClientChannel.OperationTimeout which is 10 minutes by default. I tried to create my own custom WcfProxy and overrode the GetProxy like below and I see the timeout problem is resolved.</p>
<p>protected override Csla.WcfPortal.WcfPortalClient GetProxy()<br />{<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; var proxy = base.GetProxy();<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy.InnerChannel.OperationTimeout = TimeSpan.FromHours(12);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return proxy;<br />}</p>
<p>I look into CSLA SL source code and I see you already declared the WcfProxy.TimeoutInMinutes static property but it is private. It is possible if you declare it as a public static property to allow users change timeout value and this timeout value will be also set to IClientChannel.OperationTimeout when CSLA SL creates proxies?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, December 02, 2011</h2><p>So you are tying up one of your 2 channels for possibly more than 60 minutes? </p>
<p>I&#39;d suggest that you look into using one-way binding on the webservice call (just start and forget) and rather have a &quot;poll&quot; method to check the status. That way no channels is tied up and client will perform much better. . </p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, December 02, 2011</h2><p>This seems like a flawed architecture at a basic level.</p>
<p>If you have long-running tasks (things that take minutes, much less hours), you should really look at a model where the client submits the task to a service or app running on the server.</p>
<p>The client can check in periodically (every few seconds or minutes) to see how the task is progressing, but web protocols just aren&#39;t designed for (essentially) permanent connections like you are trying to use.</p>
<p>There are various technologies for this, including MSMQ, SQL server queues, Windows services, etc.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Cuong replied on Friday, December 02, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b></p>
<p>So you are tying up one of your 2 channels for possibly more than 60 minutes? </p>
<p>I&#39;d suggest that you look into using one-way binding on the webservice call (just start and forget) and rather have a &quot;poll&quot; method to check the status. That way no channels is tied up and client will perform much better. . </p>
<div style="clear:both;"></div>
<p></div></p>
<p>In my app, these commands do not always execute in a long time. They may execute in a short time and they may fail =&gt; so I need the server returns the result (SUCCEEDED/FAILED) to the client</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
