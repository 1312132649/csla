<html><header><title>Asynchronous Data Access</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Asynchronous Data Access</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/287.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tim FOrd posted on Tuesday, June 06, 2006</h2>Evening All,<br><br>I'm currently using the latest version of CSLA and was wondering if it was possible to implement Asynchronous database funcationality for mulitple database executions from the business object using the DataPortal Fetch??<br><br>Would i need to extend the framwork to handle this??<br><br>Thanks, Tim.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Tuesday, June 06, 2006</h2><P>A concrete example might help us understand your situation a bit better.&nbsp; Although I don't make asynchronous database calls, I do run quite a few queries on background threads.&nbsp; That doesn't require any framework modifications.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tim FOrd replied on Tuesday, June 06, 2006</h2>

<p class="MsoNormal">Hi Mark,<br>
<br>
Because of the way Iâ€™m working with the business objects, for instance we have
a customer which has multiple child objects as properties which need to load
data from the database. We have thought about loading some of this data on
demand, but there will be cases where we need to load a full object all, this
is where I thought I might be about to add asynchronous data calls which would
allow me to execute multiple commands against the database.<br>
<br>
I had previously done some work with the Background Worker in VS.net 2005 and
it worked really well, which could sit in the UI and work with the business
object and wondered if I might be able to implement this with in the Fetch Area
of the business object using _Begin &amp; _End<br>
<br>
Thanks, Tim.<span><o:p></o:p></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark replied on Tuesday, June 06, 2006</h2><P>All the processing has to be complete by the time the DataPortal Fetch method finishes executing.&nbsp; Once it exits, the DataPortal assumes you're done and passes the results back to the client, so any callback methods would be for naught (although it might work -by&nbsp;pure chance - if you're running local.&nbsp; I sincerely doubt if it would work via remoting).&nbsp; So, sample code...</P>
<P>private void DataPortal_Fetch(Criteria crit)<BR>{<BR>&nbsp;&nbsp; //Normal setup stuff for cmd1 and cmd2 <BR>&nbsp;&nbsp; IAsyncResult result1 = cmd1.BeginExecuteReader();<BR>&nbsp;&nbsp; IAsyncResult result2 = cmd2.BeginExecuteReader();<BR>&nbsp;&nbsp; while (!result1.IsCompleted &amp;&amp; !result2.IsCompleted)<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Kill time - sleep, whatever<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; using (SqlDataReader reader = cmd1.EndExecuteReader(result1))<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Populate&nbsp;object 1<BR>&nbsp;&nbsp; }<BR>&nbsp;&nbsp; using (SqlDataReader reader = cmd2.EndExecuteReader(result2))<BR>&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Populate&nbsp;object 2<BR>&nbsp;&nbsp; }<BR>}</P>
<P>This should work, but I'm not sure if it's what you're truly after.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tim FOrd replied on Wednesday, June 07, 2006</h2>Hi Mark,<br><br>That does actaully clear things up for me. I'm pretty sure i could actually use the BackgroundWorker component to handle the threading of the business object from the UI and thus acheiving and Asynchronous result.<br><br>Thanks, Tim.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AKaplan replied on Friday, April 17, 2009</h2>I would like to add to this discussion with asynchronous data calls. This is my structure of my asynchronous ado.net. <br /><br />Private Sub ExecuteFetch(ByVal cn As SqlConnection)<br />        Using cm As SqlCommand = cn.CreateCommand<br />            cm.CommandType = CommandType.StoredProcedure<br />            cm.CommandText = "esp_SelectTaxRatesAll"<br />            cm.BeginExecuteReader(New AsyncCallback(AddressOf FetchResult), cm, CommandBehavior.CloseConnection).AsyncWaitHandle.WaitOne(3000, True)<br />        End Using<br />    End Sub<br /><br />    Private Sub FetchResult(ByVal ar As IAsyncResult)<br />        Dim cm As SqlCommand = CType(ar.AsyncState, SqlCommand)<br />        If Not ar.IsCompleted Then<br />            Using cm.Connection<br />                Using dr As New SmartSafeDataReader(cm.EndExecuteReader(ar))<br />                    While dr.Read()<br />                        Me.Add(TaxRate.GetTaxRate(dr))<br />                    End While<br />                End Using<br />            End Using<br />        End If<br />    End Sub<br /><br />What happens in this manner is that ExecuteReader is executed and then csla continues on without the results of the DB. After the UI has binded, the callback has it's results and tries to populate the BO. I get an error of "The asynchronous callback has already completed.", and a TypeLoadException is thrown. Is there any way I can workaround this and still keep asynchronous ado, or am I just going to have to fall back to synchronous? </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 17, 2009</h2>Well, this is a rather old thread.  The latest version of Csla has Asyncronous dataportal support, because it was required for Silverlight.  There are some gotchas though.. the UI must be able to handle getting a null back instead of a child instance.  Search around the forum for more details.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AKaplan replied on Friday, April 17, 2009</h2>thanks</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AKaplan replied on Friday, April 17, 2009</h2>I'm using csla 3.5 with asp.net. Are you saying if I use csla 3.5 asynchronous data access, i have to silverlight? or can it be used with asp.net?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, April 20, 2009</h2>No, I'm saying that if you use Silverlight, all DataPortal calls have to be asynchronous.... but that's a silverlight thing.<br /><br />I don't think async would benefit much on asp.net... how would you get the result back?  By then the page would be on the client's browser.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Paul Czywczynski replied on Monday, April 20, 2009</h2>It is useful for some ASP.NET web sites but not a cure all for a badly designed application.<br><pre>With asynchronous pages, a thread which assigned from the thread-pool
to process page request, is returned to the thread pool instead of
waiting for an I/O operation to complete. This means more threads
available to process incoming requests, and when I/O operation is
completed, another thread from the pool is guarantee to send back the
response.</pre><a href="http://blogs.microsoft.co.il/blogs/egady/archive/2008/09/29/asynchronous-asp-net-2-0-programming.aspx">http://blogs.microsoft.co.il/blogs/egady/archive/2008/09/29/asynchronous-asp-net-2-0-programming.aspx</a><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, April 20, 2009</h2><P>The async data portal feature could, technically, be used in an ASP.NET scenario, as long as you use some sort of thread synchronization primitive to block the main "UI thread" until all the async data portal calls return.</P>
<P>In reality, you are probably better off using sync data portal calls, and managing your own threading outside of the data portal - in the ASP.NET environment.</P>
<P>The async data portal works <EM>very</EM> well in Silverlight and WPF. It works ok in Windows Forms. But in the block mode world of ASP.NET or other pure server-side settings, I think you are usually better off managing your own threads.</P>
<P>I say this, because the async data portal can automatically do thread marshalling in SL/WPF/WinForms thanks to Microsoft providing the underlying plumbing. But in server-side scenarios Microsoft didn't build any plumbing to do the heavy lifting, and there's no way for me to predict how someone might use threading in their application, so I can't really implement that plumbing either.</P>
<P>So it is, in the end, up to you to decide how to synchronize your threads on the server - which means you are better off using the sync data portal and doing all the heavy lifting in your own code.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
