<html><header><title>Inheritance + Generics .. time to give up?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Inheritance + Generics .. time to give up?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4731.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i posted on Tuesday, April 22, 2008</h2><P>I have been <STRONG>fighting</STRONG> this for ages now because I just cannot believe that inheritance is such a no-no in the Csla world......I use inheritance a LOT (and deeply) and it has served me very very well over the years but now, with Csla <EM>generic'd</EM>, I'm pretty much at a dead-end so please help me out with a practical exaple........</P>
<P>As a really simplified example take the following class:</P>
<P>User / Users<BR>Every application in the company has this shared concept. They all potentially share the same behaviour and business logic but if one system wants to specialize the basic User it simply inherits and alters the behaviour - overloading/overriding/introducing. </P>
<P>For example, a Order Processing app might inherit User because all of its 'Users' have 0 or more orders - OrderAppUsers["joe"].Orders.Count.....These users are still subject to all the rules and constraints of the base User. The Orders part might be lazy loaded or the data access portion might be overridden but with a call the base to ensure the correct object population, etc. </P>
<P>OrderProcessingAppUser : User<BR>{<BR>&nbsp; private Orders _orders;<BR>}</P>
<P>OrderProcessingAppUsers : Users<BR>{<BR>&nbsp;public new OrderProcessingAppUser this[int index]<BR>&nbsp;{<BR>&nbsp;&nbsp;get<BR>&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;return (OrderProcessingAppUser)List[index];<BR>&nbsp;&nbsp;}<BR>}</P>
<P>Now, as wee aside: how User/Users/OrderProcessingAppUser/OrderProcessingAppUsers "behave" in my world is determined at creation time - this is a flexibilty I need to avoid having many code bases for the same entity - example, we do not have a Child/Readonly/etc.User but a User that can be "created" as a child (User.Load("joe", IsChild | IsReadonly | Is....etc.).</P>
<P><BR>Now, consider a different application that has not need of further specializing the user concept - it simply accesses User/Users. Consider other apps not yet dreamed up - we know they will have, at the very least, Users.</P>
<P>The compromise has been either to cast all OrderProcessingAppUsers to the approriate type in, say, the UI or simply override the indexer and cast appropriately from the underlying List in the inheriting class(as above).</P>
<P>&nbsp;</P>
<P><STRONG>Problem </STRONG>now is that because BusinessBase/BusinessListBase use generics if User/Users inherit from them they cannot be inherited to implement further specialization - the User is <EM>typed</EM> and none of my overrides can cast it. This is a <STRONG>DISASTER</STRONG> in the deep object hierarchies I have. </P>
<P><BR>Old Csla was great because it allowed me to inherit all the great work in the equivalents of BusinessBase/BusinessListBase yet still implement my own object management strategy (single object source with runtime behaviour,shared rules, etc.).&nbsp; </P>
<P>With new Clsa I'm scr*wed - even at its simplest I cannot access the old List (CollectionBase) and cast to get me back on track. Interfaces don't help because I want OrderProcessingAppUsers to inherit behaviour - example, I want the UI to be able to call orderProcessingAppUsers["joe"].TelephoneNumber even though OrderProcessingAppUser only has a TelephoneNumber because its implemented on User. I want the order processing app to be able to change a user's telephone number. <BR>I don't want every possible User specialization for years to come to "copy" all the properties of the base user and implement them again or somehow delegate to the base User - this approach WILL fail because this company is not interested in the software - only in the individual apps.</P>
<P>&nbsp;</P>
<P>Surely, surely others out there use inheritance in a way similar to what I describe here - how the heck do you use Csla these days?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, April 22, 2008</h2><P>First and foremost, chill out.</P>
<P>Second, I use inheritance just fine. Apply an interface to your base classes and your child classes will inherit use of this interface and may override the behavior. There on out, you're passing around IUser objects. If you want IUser to show some of the ISavable/etc. members to make usage more natural, so be it - IUser : ISavable, ....</P>
<P>I use factory classes to assist in the creation/fetching/etc of instances. UserFactory.GetUser(X), etc, which would return an IUser, for example. </P>
<P>Bottom line, it can be done, and I know my methodology for inheritance is different than one or two others that are being used by others on this forum. </P>
<P>Chris</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Tuesday, April 22, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div>
<P>First and foremost, chill out.</P>
<P></div></BLOCKQUOTE></P>
<P>:) I've been overcoming the problem but i'm majorly worried about the future of our "business object framework" - I see doors closing and/or complexity increasing incredibly.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div> </P>
<P>Second, I use inheritance just fine. Apply an interface to your base classes and your child classes will inherit use of this interface and may override the behavior. There on out, you're passing around IUser objects. If you want IUser to show some of the ISavable/etc. members to make usage more natural, so be it - IUser : ISavable, ....</P>
<P></div></BLOCKQUOTE></P>
<P>I suppose this is where I'm majorly worried - I have done this to a degree already but I'm thinking that every single class in the system needs it's own interface to allow it be inherited later. </P>
<P>Also, doesn't the IUser negate the benefit of generics in terms of not having to cast.</P>
<P>&nbsp;</P>
<P>Lunch, now to calm me down (maybe&nbsp;a pub lunch :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, April 22, 2008</h2><P>One thing you can consider, though I opted not to, is to create a base class directly from Core.BusinessBase, which is not generic. If you look at what BusinessBase&lt;T&gt; implements, it's not a great deal.</P>
<P>Please refer to this post on that subject: <A href="/forums/post/2852.aspx">http://forums.lhotka.net/forums/post/2852.aspx</A></P>
<P>I opted against doing&nbsp;this because I was wary about breaking away from the standard approach to using the framework. (Though in the post above Rocky says that Core.BusinessBase is there (at least in part) for exactly this reason.)</P>
<P>I know I had a bit of disappointment that "extra had to be done" to use inheritance, but I guess it's a balance to using the framework. If you want the implementation BusinessBase&lt;T&gt; provides for you in terms of additional methods, then you have to deal with some of the inheritance issues. </P>
<P>I've seen Rocky speak before and have heard a couple podcasts where I think he expressed some disappointment generics aren't polymorphic, himself - c'est la vie. </P>
<P>I'm not sure what you mean about "doesn't the IUser negate the benefits of generics in terms of not having to cast".</P>
<P>Good luck.</P>
<P>Chris</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Tuesday, April 22, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div>
<P>One thing you can consider, though I opted not to, is to create a base class directly from Core.BusinessBase, which is not generic. If you look at what BusinessBase&lt;T&gt; implements, it's not a great deal.</P>
<P></div></BLOCKQUOTE></P>
<P>This is one of my options but bypassing all Rocky's great work at that level really is not something I want to do.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div></P>
<P>Please refer to this post on that subject: <A href="/forums/post/2852.aspx">http://forums.lhotka.net/forums/post/2852.aspx</A></P>
<P></div></BLOCKQUOTE></P>
<P>Thanks for this link. Wish he came up with a best-of-both worlds approach :)</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div></P>
<P>I'm not sure what you mean about "doesn't the IUser negate the benefits of generics in terms of not having to cast".</P>
<P></div></BLOCKQUOTE></P>
<P>Is the approach you meant? </P><FONT size=1>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>interface</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>IUser</FONT><FONT size=1>{}</P>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>class</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>xUser</FONT><FONT size=1> : </FONT><FONT color=#008080 size=1>IUser</FONT><FONT size=1>{<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>string</FONT><FONT size=1> xUserSpecific;<BR>}</P>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>class</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>xUsers</FONT><FONT size=1> : </FONT><FONT color=#008080 size=1>BusinessCollectionBaseEx</FONT><FONT size=1>&lt;</FONT><FONT color=#008080 size=1>xUsers</FONT><FONT size=1>, </FONT><FONT color=#008080 size=1>IUser</FONT><FONT size=1>&gt;{<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>override</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>IUser</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>this</FONT><FONT size=1>[</FONT><FONT color=#0000ff size=1>int</FONT><FONT size=1> index]{</FONT><FONT color=#0000ff size=1>get</FONT><FONT size=1>{ </FONT><FONT color=#0000ff size=1>return</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>base</FONT><FONT size=1>[index]; } </FONT><FONT color=#0000ff size=1>set</FONT><FONT size=1>{ </FONT><FONT color=#0000ff size=1>base</FONT><FONT size=1>[index] = </FONT><FONT color=#0000ff size=1>value</FONT><FONT size=1>; }}<BR>}</P>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>class</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>OAPUser</FONT><FONT size=1> : </FONT><FONT color=#008080 size=1>xUser</FONT><FONT size=1>{<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>string</FONT><FONT size=1> OAPUserSpecific;<BR>}</P>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>class</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>OAPUsers</FONT><FONT size=1> : </FONT><FONT color=#008080 size=1>xUsers</FONT><FONT size=1>{}</P>
<P></FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> </FONT><FONT color=#0000ff size=1>class</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>dosomething</FONT><FONT size=1>{<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1>public</FONT><FONT size=1> dosomething()<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT size=1>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#008080 size=1>OAPUsers</FONT><FONT size=1> oap = </FONT><FONT color=#0000ff size=1>new</FONT><FONT size=1> </FONT><FONT color=#008080 size=1>OAPUsers</FONT><FONT size=1>();<BR><FONT><FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oap[0].??? no good - have to cast...</FONT><BR></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((</FONT><FONT color=#008080 size=1>OAPUser</FONT><FONT size=1>)oap[0]).xUserSpecific;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, April 22, 2008</h2><P><FONT face=Arial color=#000000 size=2>If you have a polymorphic collection of Users, you're going to have to cast it whether it's using an ancestor class or an interface.</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Arial color=#000000 size=2>UserCollection : BusinessListBase&lt;UserCollection, BaseUser&gt;</FONT></P>
<P><FONT face=Arial color=#000000 size=2>UserCollection : BusinessListBase&lt;UserCollection, IUser&gt;</FONT></P></BLOCKQUOTE>
<P><FONT face=Arial color=#000000 size=2>Neither BaseUser or IUser knows what "OAPUserSpecific" would be. That is, _myUserCollection[0] is either a BaseUser or IUser with no idea what the actual derived class might contain. Casting either to an OAPUser (when the cast is valid) would provide you with access to OAPUserSpecific. </FONT></P>
<P><FONT face=Arial color=#000000 size=2>If you want a collection to hold only OAPUsers, then </FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Arial color=#000000 size=2>OAPUserCollection : BusinessListBase&lt;UserCollection, OAPUser&gt;</FONT></P></BLOCKQUOTE>
<P><FONT size=2><FONT face=Arial><FONT color=#000000>That aspect doesn't change whether you use interfaces or not.</FONT> </FONT></FONT></P>
<P><FONT face=Arial size=2>Maybe I'm misunderstanding your question?</FONT></P>
<P><FONT face=Arial size=2>Chris</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Tuesday, April 22, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div>
<P><FONT face=Arial color=#000000 size=2></FONT></P>
<P><FONT face=Arial color=#000000 size=2>OAPUserCollection : BusinessListBase&lt;UserCollection, OAPUser&gt;</FONT></P>
<P></div></BLOCKQUOTE></P>
<P>this won't work for the old.... 'UserCollection' must be convertible to 'Csla.BusinessListBase&lt;UserCollection,OAPUser&gt;' in order to use it as parameter 'T' in the generic type or method 'Csla.BusinessListBase&lt;T,C&gt;'&nbsp;....reason</P>
<P><FONT size=2><FONT face=Arial><FONT color=#000000>And really what I'd want is that OAPUsersCollection to inherit from Users yet somehow manage the item types into OAPUser objects..... OAPUser this[int index]</FONT></FONT></FONT></P>
<P><FONT face=Arial size=2><FONT face="Times New Roman" size=3><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>skagen00:</strong></div><div></FONT></FONT></P><FONT face=Arial size=2>
<P><FONT size=2><FONT face=Arial><FONT color=#000000>That aspect doesn't change whether you use interfaces or not.</FONT> </FONT></FONT></P>
<P>Maybe I'm misunderstanding your question?</FONT></P>
<P></div></BLOCKQUOTE></P>
<P>I don't think you misunderstand - my point was that passing interfaces about it fine but they do have to be cast to something specific at some point whereas the point of generics is to do away with the need to cast. Or something like that :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Tuesday, April 22, 2008</h2><P><FONT face=Arial size=2>Sorry I mistyped </FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Arial size=2>OAPUserCollection : BusinessListBase&lt;UserCollection, OAPUser&gt;</FONT></P></BLOCKQUOTE>
<P><FONT face=Arial size=2>I meant</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT face=Arial size=2>OAPUserCollection : BusinessListBase&lt;OAPUserCollection , OAPUser&gt;</FONT></P></BLOCKQUOTE>
<P><FONT face=Arial size=2>Anyways, good luck. If I have time later on I'll try to figure out a solution to what you're talking about. </FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Tuesday, April 22, 2008</h2><P>Very much appreciate your input already. Great to have someone to bounce this off.&nbsp; Thank you.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, April 22, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>jh72i:</strong></div><div>I don't think you misunderstand - my point was that passing interfaces about it fine but they do have to be cast to something specific at some point whereas the point of generics is to do away with the need to cast. Or something like that :)</div></BLOCKQUOTE></P>
<P><FONT face=Tahoma size=2>In the end, if you're not willing to create your own BusinessBase class, then I don't think you're going to get what you want.</FONT></P>
<P><FONT face=Tahoma size=2>It seems that your problems are with your collection classes.&nbsp; Going with an interface won't help, because you can't use it as the "C" type in BusinessListBase, unless you make your custom interface get all the CSLA interfaces on it.&nbsp; But I don't see where that helps you a whole lot, as every subclass would have to re-implement most of the methods to get the interface type case appropriately.&nbsp; The bad part is that much of the re-implementation is not of the "new" variety - it would be additional methods that sit beside the base ones.&nbsp; Depending on how you want your collection subclasses to work, you probably would also have to "new" all the base methods to throw an exception, to make sure you get the right types into your collections.&nbsp; I'm assuming it's all this that you're objecting to.</FONT></P>
<P><FONT face=Tahoma size=2>So you'll probably end up having to create a collection class for each subtype, but you should be able to inherit from your "User" class just fine.&nbsp; The only other option is to create a non-generic BusinessListBase of your own.&nbsp; Nothing intrinsically wrong with that, though it sounds like you're not liking that option.</FONT></P>
<P><FONT face=Tahoma size=2>In the end, I'm not exactly sure what having a base collection class gets you.&nbsp; Obviously, I haven't seen your collection classes, so maybe there's a lot of common business logic you'd have to re-implement.&nbsp; But you could factor&nbsp;that out into its own interface and create an internal helper class for that.&nbsp; Yes, it's a bit of a hack, but it gets the job done.&nbsp; But if your collection classes don't do very much, then I don't see a big gain in an inheritance chain there.&nbsp; Sure, you're writing the same little bits of code a bunch of times - but you'd probably be mucking about with a good portion of that in a collection subclass anyway, in order to get the types cast correctly.</FONT></P>
<P><FONT face=Tahoma size=2>Just MHO...</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Wednesday, April 23, 2008</h2><P>Thanks for that input Scott.</P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>tmg4340:</strong></div><div>
<P><FONT face=Tahoma size=2>In the end, I'm not exactly sure what having a base collection class gets you.</FONT></P>
<P>
<P><FONT face=Tahoma size=2></FONT></P></div></BLOCKQUOTE></P>
<P>I'm not sure my problems are limited to collections but consider&nbsp;a scenario from the&nbsp;simple example above.&nbsp; That OAP application wants to be able to make calls like:</P>
<P>OAPUsers users = OAPUsers.GetCollection(someRole)</P>
<P>which is actually implemented&nbsp;in the Users class and not the OAPUsers class(collection). My world does a lot more stuff that I wouldn't want to have to reimplement - and its not just about inconvenience its also about the level of knowledge required for a developer to utlilize work already completed. </P>
<P>I could,&nbsp;of course,&nbsp;have a Generic BaseUsers collection but I suppose my major major disappointment is that the extensibility of my object models is lost - I need to think not just about the current application but the next and the one after that - my goal has been to have one complete "library" of business objects/collections that follow a consistent pattern so that&nbsp;when a new&nbsp;system is required we can look to extend and enchance much of what we have already - kind&nbsp;of like&nbsp;saying the 40% of the next app is already built. I also have a huge desire to ensure that the next developer passing through can "inherit" the complexity and concentrate purely on what his/her goal is. And while I use "User/s"&nbsp;as an example really the objects/classes/concepts are far more complex.</P>
<P>I will plug away for a while longer but all comments from folks solving the problems is always, always welcome.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
