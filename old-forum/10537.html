<html><header><title>MVVM and bfx example</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>MVVM and bfx example</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10537.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius posted on Tuesday, July 19, 2011</h2><p>I&#39;m trying to educate myself and learn up on MVVM. At the moment, I&#39;m just trying to get my arms around Rocky&#39;s ultra light-weight bfx framework used in the CSLA demos. I get most of what&#39;s in the</p>
<p>http://www.lhotka.net/Article.aspx?id=389bb59d-2760-4309-aee2-f55a976ef100</p>
<p>Will I need to create a ViewModel class that is utilized by a presenter class for EVERY csla object? Further, will I have a presenter for every ViewModel? In the bfx example there&#39;s a hard coded &quot;start&quot; int and the presenter is shared amongst multiple ViewModels based on the hard coded value - it isn&#39;t clear to me if that was just done to save time or if there&#39;s something I&#39;m missing here.</p>
<p>If there&#39;s a viewmodel and presenter for each &quot;model&quot; being a csla object, that seems somewhat excessive to me for items like readonlylists that populate things like drop downs with one way bindings. Am I missing something here? is there a value add that I don&#39;t get?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Tuesday, July 19, 2011</h2><p>Rocky has a video series on the subject that you can buy for a nominal price.&nbsp; It goes through the basics and gets you a good start.</p>
<p>I&#39;ve used bfx to learn MVVM and I&#39;m glad to have had it as a resource.&nbsp; We should remember that the B stands for Basic, and it probably isn&#39;t the best viable option for writing larger applications as it has some difficiencies that require a lot of coding to implement.&nbsp; I&#39;m not trying to knock bfx, just understand what it is and you&#39;ll be fine.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, July 20, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>Curelom<br></b>We should remember that the B stands for Basic</div></p>
<p>Thanks, yea, that&#39;s why I chose it as a starting point.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, July 20, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>Curelom<br></b>Rocky has a video series on the subject that you can buy for a nominal price.&nbsp;</div></p>
<p>Oh yeah, how about a link?</p>
<p>And does anyone know what the deal with this hard coded &quot;start&quot; variable I mentioned is?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, July 20, 2011</h2><p>Okay, so while I do plan to get the MVVM video at a later date, I&#39;ve went ahead and moved toward the MVVM light framework. </p>
<p>I&#39;ve listened to Rocky&#39;s introductory video and it all makes a lot of 
since as I am starting to get the goals behind the pattern and why they&#39;re there. I still don&#39;t see a clear solution on how to incorporate CSLA 
into the picture in some places. For example, some UI specific things business logic (like wizards for example) do not make much since to make into a csla model (though I COULD see advantages if you wanted to utilize it for validation purposes). Anyway, I end up with models that aren&#39;t csla models (mixing rich and non-rich models into one app). Is it bad practice to include some of these concepts directly into the CSLA viewmodel and not create models for the smaller pieces?&nbsp; (i.e. you have a <b>ShoppingCart</b> CSLA object and a&nbsp;<b>ShoppingCartVm</b> view model that also encapsulates the wizard concepts instead of creating a <b>Wizard</b> model object and a <b>WizardVm</b>).</p>
<p>With bfx, I see an immediate need to create a view model for every csla object, since the ViewModelBase class utilizes a &quot;Model&quot; property by design. I like the simplicity of this, but MVVM light however provides you the ability to implement your own properties in ViewModelBase giving the developer the capability to &quot;alter/reorg&quot; the interface to the view model compared to the interface of the model itself. Now, I&#39;m trying to understand, is this a good thing to do or bad? </p>
<p>And with MVVM light, I could see it possible to create just one viewmodelbase that&#39;s used for EVERYTHING. That doesn&#39;t seem to be best practice, but why not?</p>
<p>Consistency between layers makes things easy to interpret, but implementing a view model for EVERY read only list seems excessive in some cases. Applications that utilize lots of drop downs == lots of view models whose only purpose is to provide a data connectivity test. </p>
<p>In MVVM light, it seems that you could, say create a single view model for such items called something like &quot;DropDownsVm&quot; or something, and then create a property that serves up your csla model ReadOnlyList object. </p>
<p>I was just curious what other people out there are doing, keep the layers consistent, or simplify it a bit for things like this? Thoughts?</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, July 21, 2011</h2><p>I also ran into this situation and I&#39;m unsure if I&#39;m on the right track:</p>
<p>class A is a BusinessBase. Class B is a ReadOnlyList. Class A has property Foo.&nbsp; On the UI, when A.Foo changes, B fetches new values based on A.Foo. </p>
<p>The ViewModel layer consists of ClassAViewModel, which exposes these properties:</p>
<p>Model (an instance of class A, the BusinessBase)</p>
<p>ListB (an instance of class B, the ReadOnlyList)</p>
<p>Instantiating this viewmodel adds a property changed eventhandler on Model.Foo to refresh ListB with the appropriate contents.</p>
<p>&nbsp;</p>
<p>How would this be done if you had one View Model for every CSLA object? I obviously just don&#39;t get something, because based on the way I&#39;m doing things this wouldn&#39;t be possible in BFX due to the single Model property.&nbsp; </p>
<p>I know I&#39;m at least in the right direction, because I&#39;ve eliminated codebehind entirely, but I&#39;m not sure if I&#39;ve got the whole pattern down right based on the above. I wire up the View to the ViewModel fine, but I don&#39;t know if my ViewModel layer is &quot;standard&quot;. am I on the right track?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, July 21, 2011</h2><p>I think Rocky&#39;s video series will help with these questions, but ultimately it looks to me like you&#39;re trying too hard.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>Because of the nature of CSLA BO&#39;s, ViewModels in that space don&#39;t function quite like other places.&nbsp; CSLA objects already have what they need to essentially function as a viewmodel - they support binding, have the business rules (and associated UI interaction capabilities), etc.&nbsp; And when you throw in the concept that CSLA BO&#39;s should be built around necessary behaviors instead of data, they end up looking an awful lot like ViewModels in other MVVM scenarios.</p>
<p>As such, Rocky&#39;s recommendations have been that VM&#39;s you create in CSLA are there for you to&nbsp;create methods/properties that support the UI functionality.&nbsp; The &quot;Model&quot; property contains your CSLA BO (or your CSLA BO list), which you directly bind to in your UI for everything else.&nbsp; As such, you don&#39;t have to create a&nbsp;VM for every single CSLA BO you have.&nbsp; Again, the videos go over this in greater detail, but in your list situation, I only see a need for one VM that wraps Class A.&nbsp; You don&#39;t need a VM for your list, since that&#39;s there presumably to support data within Class A.</p>
<p>There also isn&#39;t necessarily a restriction to one &quot;Model&quot; property.&nbsp; AFAIK, you can have as many &quot;Model&quot; properties as you want - they&#39;re just different paths in your XAML databinding.&nbsp; There&#39;s certainly nothing stopping you from creating multiple (possibly nested)&nbsp;ViewModels, much like you&#39;d construct your CSLA BO graph.&nbsp; But there isn&#39;t a &quot;one model object per VM&quot; restriction that I know of.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, July 21, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b> You don&#39;t need a VM for your list, since that&#39;s there presumably to support data within Class A.</div></p>
<p>Unless the list is a child of A, how would you bind it to the view without a view model? Do you typically structure your lists as child objects if they are to be used by A? I suppose the traditionalist &quot;use-case&quot; philosophy recommends that, though I don&#39;t always go that route.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b>But there isn&#39;t a &quot;one model object per VM&quot; restriction that I know of.</div></p>
<p>Yes, clearly I haven&#39;t reviewed bfx in great detail, but in MVVM light you just add your properties to an extended ViewModelBase class. I guess what I&#39;m referring to is what I&#39;ve seen so far in the examples and the class design I&#39;ve seen thus far - A generic parameter defines the type for the &quot;Model&quot; property which is then binded to the views xaml. So I guess you&#39;re suggesting (if you want to have multiple objects to one view model) just extend extend extend, which I suppose could be possible but kinda clustered!</p>
<p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b>I think Rocky&#39;s video series will help with these questions, but ultimately it looks to me like you&#39;re trying too hard.&nbsp;</div></p>
<p>Quite possible :) I do that. Though I&#39;ve just been confused with bfx is all. MVVM I picked up very quick and was immediately hooking up relaycommands to my CSLA etc. But if I apply the same approach in bfx the train stops hehe. I&#39;ll just have to wait and check out the videos when I have time. Thanks for the help so far.</p>
<p>&nbsp;</p>
<p>In the mean time, I&#39;ve atleast solved the problems that MVVM sets out to solve with MVVM Light... I now have a completely bind driven separation to test with.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, July 21, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>decius<br></b>
<p>Unless the list is a child of A, how would you bind it to the view without a view model? Do you typically structure your lists as child objects if they are to be used by A? I suppose the traditionalist &quot;use-case&quot; philosophy recommends that, though I don&#39;t always go that route.</p>
<p></div></p>
<p>Just like you did in pre-XAML UI&#39;s.&nbsp; CSLA objects are bindable in and of themselves, so there&#39;s nothing stopping you from binding your XAML forms directly to your CSLA BO&#39;s.&nbsp; In fact, that&#39;s what Rocky encourages.&nbsp; The path capabilities of XAML-based binding make this rather simple.</p>
<p>In terms of your specific scenario: no, I would not make your list a child of A.&nbsp; I&#39;d use a Unit Of Work object.&nbsp; Then your Class A and your List B would be &quot;children&quot; of the UOW.&nbsp; You still don&#39;t have to create a VM for your child list, nor do you really have to create one for your UOW object.&nbsp; Remember - in the CSLA world, VM&#39;s are there to support UI-specific methods/properties, not to wrap your CSLA object.&nbsp; Ultimately, when you&#39;re binding your XAML UI, most of it is going to bind directly to your CSLA BO properties/methods.&nbsp; It takes a small amount of gymnastics, but in the end the UOW is your main DataContext, and your child VM pulls from that (and becomes the DataContext for your Class A &quot;region&quot;), while your read-only list is directly bound to whatever list control you have that it&#39;s supposed to populate.&nbsp; Again, the path capabilities of XAML binding make this relatively easy.</p>
</p>
<p><div style='padding-left: 50px;background-color:silver'><b>decius<br></b></p>
<p>Yes, clearly I haven&#39;t reviewed bfx in great detail, but in MVVM light you just add your properties to an extended ViewModelBase class. I guess what I&#39;m referring to is what I&#39;ve seen so far in the examples and the class design I&#39;ve seen thus far - A generic parameter defines the type for the &quot;Model&quot; property which is then binded to the views xaml. So I guess you&#39;re suggesting (if you want to have multiple objects to one view model) just extend extend extend, which I suppose could be possible but kinda clustered!</p>
<p></div></p>
<p>Again, you may want to look at UOW objects.&nbsp; And&nbsp;I think the first video in the series (which at least at one point was free) touches on how Rocky sees building VM&#39;s using CSLA objects.&nbsp; BXF is designed to support that type of VM construction, as are the base VM classes he created.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>decius<br></b></p>
<p>Though I&#39;ve just been confused with bfx is all. MVVM I picked up very quick and was immediately hooking up relaycommands to my CSLA etc. But if I apply the same approach in bfx the train stops hehe. I&#39;ll just have to wait and check out the videos when I have time. Thanks for the help so far.</p>
<p>
<p>In the mean time, I&#39;ve atleast solved the problems that MVVM sets out to solve with MVVM Light... I now have a completely bind driven separation to test with.</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>There&#39;s&nbsp;nothing wrong with using MVVM Light over BXF - in the end, it&#39;s whatever you can grok and get working. MVVM Light is a great product, and if you can get it work, then by all means use it!&nbsp; MVVM Light is built on a &quot;one model, one VM&quot; concept, because it&#39;s mainly there to assist in the &quot;dumb model&quot; concept (of which CSLA is not).</p>
<p>The last thing to consider is that BXF is, primarily, a teaching tool - it&#39;s certainly useful in some scenarios, but Rocky wasn&#39;t intending to create a full-fledged &quot;production ready&quot; MVVM framework. BXF is basically showing you the minimum level of coding necessary to support the MVVM style of development.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 21, 2011</h2><p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b>
<p>The last thing to consider is that BXF is, primarily, a teaching tool - it&#39;s certainly useful in some scenarios, but Rocky wasn&#39;t intending to create a full-fledged &quot;production ready&quot; MVVM framework. BXF is basically showing you the minimum level of coding necessary to support the MVVM style of development.</p>
</div></p>
<p>Absolutely! Bxf doesn&#39;t really compare with full featured UI frameworks, and isn&#39;t intended to do so. It is intended to show the <em>minimum</em> necessary plumbing to support the MVVM design pattern.</p>
<p>Also, to reinforce what Scott has said, I am a firm believer that there are two types of &#39;model&#39;: anemic and rich.</p>
<p>Most MVVM (and MVC/MVP) examples assume an anemic model, where the model is composed of objects that just contain data. Not smart, not bindable - dumb-ass objects that just contain data. Like you get from the EF designer, or adding a service reference.</p>
<p>And that&#39;s fine if that&#39;s all you have.</p>
<p>But if you are using CSLA, then you have a rich model. Moreover, your model should have been designed following your user scenarios (user stories, use cases, etc), and therefore should directly reflect the needs of the particular scenario where the objects will be used. Just like the UI (views).</p>
<p>The result is that the objects <em>already have the right shape</em> for the view. So you don&#39;t need a heavy-weight viewmodel to reshape the model, or to add data binding, or to invoke business rules - <em>because the model already does all that</em>.</p>
<p>Therefore, the viewmodel becomes simple. Its primary job is to add UI-specific verbs (methods) that wouldn&#39;t naturally be part of the model. And sometimes (often?) also add UI-specific derived properties (like a FullName property, or an Age property - all calculated off the underlying model properties).</p>
<p>The ViewModelBase/ViewModel classes in Csla.Xaml help you do this.</p>
<p>Bxf is a completely separate thing. Totally separate. It has nothing to do with CSLA at all. The only connection is that I created Bxf so I had a super-simple UI framework for building CSLA samples. But Bxf works without CSLA, and CSLA works without Bxf.</p>
<p>The really, really, really important thing to understand is that properly designed CSLA business object models are a &#39;rich model&#39; for MVVM, so your viewmodel types can be simple. If your viewmodel is complex (and you have a CSLA model), you are doing something wrong.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Friday, July 22, 2011</h2><p>All: thanks for the help. Rocky, thanks, your first video illustrates all these points quite well. What I&#39;m missing though, is while I understand csla is a rich model, the UI specific stuff (like if the user changes a property on one object and you need to go fetch a new RO list) Should I be making a ViewModel for both objects? Or may I just create one view model that exposes both objects? I&#39;ve been doing #2 and am afraid that&#39;s bad practice.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b>Just like you did in pre-XAML UI&#39;s.&nbsp; CSLA objects are bindable in and of themselves, so there&#39;s nothing stopping you from binding your XAML forms directly to your CSLA BO&#39;s.&nbsp; In fact, that&#39;s what Rocky encourages.&nbsp; The path capabilities of XAML-based binding make this rather simple.</div></p>
<p>Yes, I understand binding - but how would you do it WITHOUT a view model and still be MVVM?&nbsp; tmg4340 said &quot;You don&#39;t need a VM for your list, since that&#39;s there presumably to support data within Class A.&quot; I must be missing something here...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, July 22, 2011</h2><p>I always have at least one viewmodel per view. The view binds to the viewmodel, and often binds to the model via the Model property of the viewmodel.</p>
<p>Sometimes my viewmodel will have several &quot;Model&quot; properties if the view requires access to several objects. This is pretty common if you are using a UOW model object to retrieve several other objects.</p>
<p>I do not always have a viewmodel for every child object or child control in the view. A viewmodel is typically only necessary when you need to add verbs or calculated properties to the model.</p>
<p>So you always need at least one viewmodel, because that&#39;s what the view binds to - and that top-level viewmodel always manages retrieval of the object(s), and often provides Save/Cancel verbs.</p>
<p>But you may or may not need a viewmodel to add verbs to child objects as they are bound to child controls in the view.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
