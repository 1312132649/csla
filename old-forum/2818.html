<html><header><title>Interaction between Use Cases and similar objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Interaction between Use Cases and similar objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2818.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brad posted on Thursday, May 03, 2007</h2>Greetings,<br><br>I have a situation where I am torn on how to use two different (but similar) business objects. <br>The first use case is to list a set of "User" objects. I've implemented this by created a read only list (UserInfoList) and a read only object (UserInfo) that retrieves some data. The second use case is to edit a "user" object (User). For this, I have created a editable business object.<br><br>The UI interaction is as follows: I open the "User List" view. A list of read-only "UserInfo" objects are displayed. I select a row, and the id of the UserInfo object is used to populate an editable "User" object - which is displayed in a dialog. I then change some settings on the "User" object via the UI, and press the button which saves my changes and returns back to the "user list" view.<br><br>My dilemma is that I need to update the "user list" view - which is what is displayed after the user closes the "Edit a User" dialog (specifically one "UserInfo" object) with the potentially changed data. Now when I close the dialog, I know which user has been updated - and in fact I just happen to have all the data I need. However, my UserInfoList object controls the "get" of the data for the UserInfo objects. <br><br>So, do I take the hit to the db to get the entire list of UserInfo objects (which is the cleanest conceptually, but slowest and requires both a hit to the db and a lot of data to bring over the wire); vs take the hit to update the one business object (and break the design of the UserInfoList and UserInfo objects for the sake of a speed increase of less data over the wire); vs just update the object in memory (which seems to break the design of the CSLA business objects, but is very fast).<br><br>Any thoughts?<br><br>Cheers,<br>-Brad<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Thursday, May 03, 2007</h2><P><FONT face=Verdana size=2>Rambling idea off the top of my head:</FONT></P>
<P><FONT face=Verdana size=2>On your read-only UserInfo object, add internal setters to the properties.</FONT></P>
<P><FONT face=Verdana size=2>Create an instance method on your User object called something like ToUserInfo(UserInfo userInfo).&nbsp; Inside this method, update the passed-in userInfo's properties&nbsp;with the current User object's properties.</FONT></P>
<P><FONT face=Verdana size=2>Back in your UI, after the form is closed simply pass the selected UserInfo into the just-edited User object's ToUserInfo.&nbsp; Databinding should update your list!</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, May 03, 2007</h2><P>Seems to me that you've got three options:</P>
<OL>
<LI>Refresh the whole list, as you've said. This would be the most commonly used approach.</LI>
<LI>Implement some hybrid way of updating the read-only object with the editable object used in the form as was suggested about.&nbsp; I don't like the sounds of this one as it sounds unnecessarily complex.</LI>
<LI>Convert your list to a read-only collection of editable objects. Cache the collection in memory. When you open the data entry form, retrieve the object from the collection using the passed Guid value - this means that both the list and the form reference the same object.&nbsp; When the form closes, simply re-bind your list to the original collection without making a round-trip to the database and the item will update to reflect the change.</LI></OL>
<P>Option 3 works if caching the list in memory is reasonable and the application isn't multi-user because you'll never see changes resulting from the actions of other users unless you make round-trips to the database.&nbsp; If it is a multi-user app, then #1 is still the best option despite the possible performance impact.</P>
<P>HTH</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Friday, May 04, 2007</h2><P><FONT face=Verdana size=2>Excellent points.&nbsp; The best solution, as always, depends on the use case.&nbsp; If the editable User objects are relatively light-weight and there will be a relatively small number of them in the list, I think having a read-only collection of editable User objects would be a great solution.&nbsp; Instead of using a guid value on the edit form to look up the object in the cached collection though, I'd just say pass in the whole User object to the edit form since you already have a reference to it in the UI list control.&nbsp; That edit form would update the object and the parent form's list control would be updated dynamically behind the form.</FONT></P>
<P><FONT face=Verdana size=2>However, if the user objects are "heavy" with lots of properties, children, collections, etc. and/or there will be LOTS of user records then I still like option 2.&nbsp; I think of a read-only object not necessarily as just an object with read-only properties.&nbsp; I think of it more as an object that can only be fetched from the data portal, but after that it can still change its state or be modified by another process or behavior (usually internal).&nbsp; Also, by keeping the property setters internal, you don't expose them to the UI developer to play with.&nbsp; Just look at ToUserInfo() as another behavior exposed by User; in this case User imprints itself onto an existing UserInfo object by using the internal property setters.&nbsp; To take advantage of this, the UI just asks the just-edited User object&nbsp;to imprint itself on a reference to a UserInfo item in its list control.</FONT></P>
<P><FONT face=Verdana size=2>I'm not sure I consider refreshing the whole list after an edit to a single user *normally* part of the use case of "editing a user,"&nbsp;even for a multi-user app.&nbsp; I understand that other users may be making changes to other items in the list, but that's what a refresh button at the top is for, yes? :) Again, I'd say this would depend on the specific use case here, especially dealing with user load and the possibility of several users working on the list at once.&nbsp; However, I might just be being argumentative because&nbsp;I really shouldn't be worried about performance of refreshing the whole list after each edit; after all, your application&nbsp;either has a smallish number of users, in which case your hardware is more than likely way over-powered anyway, or you have a HUGE number of concurrent users editing this list in which case not only is performance a concern, but you probably need to modify your use case significantly anyway to handle&nbsp;all the&nbsp;multi-user editing, such as timed refreshes or change notifications of some sort.&nbsp; It seems rare to be forced in between those scenarios after analyzing the cost/benefits of how the UI will actually be used.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, May 04, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>joshpainter:</strong></div><div>
<P><FONT face=Verdana size=2>Excellent points.&nbsp; The best solution, as always, depends on the use case.&nbsp; If the editable User objects are relatively light-weight and there will be a relatively small number of them in the list, I think having a read-only collection of editable User objects would be a great solution.&nbsp; Instead of using a guid value on the edit form to look up the object in the cached collection though, I'd just say pass in the whole User object to the edit form since you already have a reference to it in the UI list control.&nbsp; That edit form would update the object and the parent form's list control would be updated dynamically behind the form.</FONT></P>
<P><FONT face=Verdana size=2><FONT face="Times New Roman" size=3></div></BLOCKQUOTE></FONT></FONT></P>
<P>Very true. This is not an approach I have used very much but you are correct that passing the actual object would make more sense if it is cached in memory.</P>
<P><FONT face=Verdana size=2><FONT face="Times New Roman" size=3><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>joshpainter:</strong></div><div></FONT></FONT></P>
<P><FONT face=Verdana size=2>However, if the user objects are "heavy" with lots of properties, children, collections, etc. and/or there will be LOTS of user records then I still like option 2.&nbsp; I think of a read-only object not necessarily as just an object with read-only properties.&nbsp; I think of it more as an object that can only be fetched from the data portal, but after that it can still change its state or be modified by another process or behavior (usually internal).&nbsp; Also, by keeping the property setters internal, you don't expose them to the UI developer to play with.&nbsp; Just look at ToUserInfo() as another behavior exposed by User; in this case User imprints itself onto an existing UserInfo object by using the internal property setters.&nbsp; To take advantage of this, the UI just asks the just-edited User object&nbsp;to imprint itself on a reference to a UserInfo item in its list control.</FONT></P>
<P><FONT face=Verdana size=2><FONT face="Times New Roman" size=3></div></BLOCKQUOTE></FONT></FONT></P>
<P>Keep in mind that allowing the user to edit the item in the list (via a DataGridView or whatever) would also require the list to contain editable items.&nbsp; So, this is not an unusual way to go.&nbsp; Again, depends on the use-case.&nbsp; But, yes, the heavier the object, the more overhead you will incur.</P>
<P>The issue I have with this option is that you are either a) putting the UI in charge of maintaining and updating your objects or b) coupling the User and UserInfo objects together so that the latter is updated by the former when changes are applied.&nbsp; Not saying this is wrong or bad, just not something I've personnaly done and doesn't give me the "warm and fuzzies."</P>
<P><FONT face=Verdana size=2><FONT face="Times New Roman" size=3><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>joshpainter:</strong></div><div></FONT></FONT></P>
<P><FONT face=Verdana size=2>I'm not sure I consider refreshing the whole list after an edit to a single user *normally* part of the use case of "editing a user,"&nbsp;even for a multi-user app.&nbsp; I understand that other users may be making changes to other items in the list, but that's what a refresh button at the top is for, yes? :) Again, I'd say this would depend on the specific use case here, especially dealing with user load and the possibility of several users working on the list at once.&nbsp; However, I might just be being argumentative because&nbsp;I really shouldn't be worried about performance of refreshing the whole list after each edit; after all, your application&nbsp;either has a smallish number of users, in which case your hardware is more than likely way over-powered anyway, or you have a HUGE number of concurrent users editing this list in which case not only is performance a concern, but you probably need to modify your use case significantly anyway to handle&nbsp;all the&nbsp;multi-user editing, such as timed refreshes or change notifications of some sort.&nbsp; It seems rare to be forced in between those scenarios after analyzing the cost/benefits of how the UI will actually be used.</FONT></P>
<P></div></BLOCKQUOTE></P>
<P>It sounds like you are making the assumption that this is a Windows application.&nbsp; That has not been specified.&nbsp; There is no such thing as change notifications to update the UI in Web apps.&nbsp; And, if that is the case (which I also assume it is not), this discussion is mute because the list will always be updated as a natural part of the process anyway - unless the app uses multiple browser windows such as my last big project.</P>
<P>Furthermore, in a distributed, multi-user environment, there is no way to know if another user has made changes in the database except to refresh the data you have locally.&nbsp; I don't know if was ever acceptable to display a list and allow the user to edit an object only to notify them of a conflict AFTER they perform all of their work and try to save.&nbsp; While this is inevitable, for it to be the only option went out of style...well, I can think back at least ten years ago when my clients were having issues with it.</P>
<P>Again, all of this goes back to the use cases.&nbsp; The first being Windows vs. Web app.&nbsp; If Windows, the next is stand-alone or multi-user.&nbsp; If a stand-alone Windows app, then the refresh issue isn't an issue and I'd go with having the list bound to a read-only collection of editable objects and have your form bind to the actual object.&nbsp; If it's an MDI, memory consumption could increase if you have multiple lists available but an SDI app should have no problem.</P>
<P>One other option to consider and the path I had to take in a recent app that had to provide pseudo-realtime monitoring capability. This was a multi-user app in a truly distributed environment (multiple facilities, not just systems) with users in various locations and roles making changes to the underlying data all the time.&nbsp; The way I handled ensuring that the data being viewed on the "administrative" or "monitoring" interfaces stayed current was to add smart refresh capability to my business lists.&nbsp; By this I mean that I added a Refresh method to the class that was called by the UI at regular timed intervals.&nbsp; This method performed a call through the data portal to retrieve a current copy of the data which by the very nature of the data portal was returned in a new collection object.&nbsp; The refresh method then iterated through the collection and updated the existing collection with changes to the objects.&nbsp; For example, if a record that is contained in the existing collection came back from the db marked as deleted, it was likewise deleted from the local copy.&nbsp; Property changes were applied using reflection and since all property setters are wrapped with an if (existingValue != newValue) condition, only actual changes were applied and PropertyChanged events raised.</P>
<P>By tweaking the interval, we were able to achieve the affect of a real-time app in such an environment.&nbsp; Of course it wasn't truly real-time, but close enough to satisfy the customer who could bring up the app and just sit back and watch as other users performed their jobs and the data worked its way through their systems.</P>
<P>Anyway, that was done like everything else described here, to satisfy a particular use-case.&nbsp; So to go back to my original statement, you need to clarify your use cases and I think the answers will come to you.</P>
<P>Good luck.&nbsp; HTH</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Friday, May 04, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div> 
<P>The issue I have with this option is that you are either a) putting the UI in charge of maintaining and updating your objects or b) coupling the User and UserInfo objects together so that the latter is updated by the former when changes are applied.&nbsp; Not saying this is wrong or bad, just not something I've personnaly done and doesn't give me the "warm and fuzzies."</P>
<P><FONT face=Verdana size=2><FONT face="Times New Roman" size=3></div></BLOCKQUOTE></FONT></FONT></P>
<P><FONT face=Verdana size=2>This may be my own inexperience of what "UI in charge" means, but I feel like the UI is already "in charge" of calling the load/save methods, popping up forms, etc.&nbsp; Seems like another&nbsp;behavior of the UI would be invalidating a list item after an edit form has been closed since it could have changed.&nbsp; Or invalidating the whole list and refreshing it as has been suggested.</FONT></P>
<P><FONT face=Verdana size=2>As far as coupling the objects together, you could easily have another helper class that had a single responsibility of updating a UserInfo object with properties from the User object.&nbsp; That way the two objects don't "know" about each other if that is your goal.</FONT></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div></P>
<P>It sounds like you are making the assumption that this is a Windows application.&nbsp; That has not been specified.&nbsp; There is no such thing as change notifications to update the UI in Web apps.&nbsp; And, if that is the case (which I also assume it is not), this discussion is mute because the list will always be updated as a natural part of the process anyway - unless the app uses multiple browser windows such as my last big project.</P>
<P></div></BLOCKQUOTE></P>
<P><FONT face=Verdana size=2>Woops! I certainly was making that assumption.&nbsp;I've been working on a WinForms project recently and immediately went into "how would I do this on my project" mode.&nbsp; However, with Ajax on the scene, the point may not necessarily be moot. :)</FONT></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div></P>
<P>Furthermore, in a distributed, multi-user environment, there is no way to know if another user has made changes in the database except to refresh the data you have locally.&nbsp; I don't know if was ever acceptable to display a list and allow the user to edit an object only to notify them of a conflict AFTER they perform all of their work and try to save.&nbsp; While this is inevitable, for it to be the only option went out of style...well, I can think back at least ten years ago when my clients were having issues with it.</P>
<P></div></BLOCKQUOTE></P>
<P><FONT face=Verdana size=2>I think we are disconnecting here...in option 2, the listcontrol would be bound to a Read-Only list of UserInfo objects, but when you double-click one, the selected guid would be passed to the Fetch static method of User, so it would load the latest data from the db.&nbsp; Users wouldn't be editing out-of-date data, so the only conflict notification that the user would see is a&nbsp;normal concurrency violation where another user updated the same data AFTER they opened the form but before they saved.&nbsp; So the only out-of-date data that the user would potentially see would be the read-only UserInfo objects.&nbsp; But I think we've both hit upon the solution there...just use some sort of timer to update that read-only list of UserInfo objects if heavy multi-user editing is expected.</FONT></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div></P>
<P>Anyway, that was done like everything else described here, to satisfy a particular use-case.&nbsp; So to go back to my original statement, you need to clarify your use cases and I think the answers will come to you.</P>
<P></div></BLOCKQUOTE></P>
<P><FONT face=Verdana size=2>Agreed.&nbsp; Being architecture astronauts is fun, but give us more details! :)</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brad replied on Friday, May 04, 2007</h2><P><FONT face=Verdana>Firstly, thank you both for a thoughtful discussion on this topic. It has provided me with some interesting ideas to think on.</FONT></P>
<P><FONT face=Verdana></FONT>&nbsp;</P>
<P><FONT face=Verdana>Now, some more detail. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /> This is a multi-user windows application. This particular area of the application will not receive many data changes (more than likely this will be an administrative function, that is performed by one person at a time). The </FONT><FONT face="Courier New">User</FONT><FONT face=Verdana> objects are quite heavy (numerous properties and 4 child collections - 2 of which are computationally expensive). There are a number of other use cases which also feed off the list of user objects view: Delete a User, Add a User, Disable a User Account. There is a refresh button, which refreshes the list. At this stage, I'm expecting a few hundred users, but depending on some decisions to be made later, that could balloon into thousands.</FONT></P>
<P><FONT face=Verdana></FONT>&nbsp;</P>
<P><FONT face=Verdana>Originally I thought this was a common pattern that would be used in numerous areas of the application. While this may still be the case, there are certainly&nbsp;variations based on a couple of keys facts (how "current" the data needs to be, and how heavy the editable objects are). One thing is for sure - I will need to carefully consider each (set of) use case(s).</FONT></P>
<P><FONT face=Verdana></FONT>&nbsp;</P>
<P><FONT face=Verdana>Interestingly, the majority of the other use cases (Delete, Add, Refresh) all will retrieve the complete list of "current" users from the database. Maybe, from a UI consistency point of view, updating is the most logical action. It's certainly the easiest, and cleanest from a maintenance angle. However, I am tempted to try the <FONT face="Courier New">ConvertUserToUserInfo</FONT> idea (either by a static helper class, or public method on the User&nbsp;class). Carefully implemented (by using a <EM>memento</EM> pattern), it could potentially provide only a limited coupling. However, it is <EM>a coupling</EM> between business objects (and/or interfaces to business objects)&nbsp;and that does make me feel uneasy. Without proper control, it could get out of hand.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mr_lasseter replied on Saturday, May 05, 2007</h2>In some of my apps I have the same senario.&nbsp; What I do is use the
observer pattern as well as event channels (I use the ActiveObjects
Observer.dll
http://csla.kozul.info/Documentation/Activecodev16/Observer/tabid/153/Default.aspx).&nbsp;
In my case, the ReadOnlyList is created and subscribes to any events
published by the EditableObject.&nbsp; In the EditableObject, Events
are published in the either the update, insert, or delete functions (or
any other events that I want respond to).&nbsp; I don't use the data
portal as I have stripped down CSLA to get the functionality
that I want from it (mainly the validation), so I don't have to worry
about serializtion/deserailization of the objects and trying to
determine if the object was inserted/updated.<br>
<br>
When an event is published the ReadOnlyList updates the item in the
list that changed.&nbsp; The ReadOnlyList does get a copy of the
Editable object so there is some coupling involved, but I don't have a
problem with this since the ReadOnlyList and the Editable Object
actually represent the same thing.&nbsp; In my mind there should be
some coupling involved.&nbsp; <br>
<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Monday, May 07, 2007</h2><P><FONT face=Verdana size=2>Sounds like you have a plan.&nbsp; One other interesting observation:&nbsp; Microsoft's AD Users and Computers MMC snap-in does not refresh the whole user list after you double-click a user and edit the account.&nbsp; It only refreshes the one item in the list after you close the window.&nbsp;&nbsp;Looks like&nbsp;Microsoft made the cost/performance/benefit choice of not automatically refreshing the whole&nbsp;list for an obviously multi-user&nbsp;application for that specific use-case.</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
