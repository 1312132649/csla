<html><header><title>Aync call from behind the dataportal using remoting</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Aync call from behind the dataportal using remoting</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7163.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>grantj posted on Wednesday, June 24, 2009</h2>We've just started using the async dataportal calls in 3.6.2 and we're noticing some odd behavior while debugging in VS. If we make an async call when we're already behind the dataportal, everything works fine on the dataportal side but control never returns to the client, which is left blocking indefinitely. So for instance, executing the following code:<br><br>static Obj GetObj(object crit) {<br>&nbsp;&nbsp; return DataPortal.Fetch&lt;Obj&gt;(crit); //client is left blocking here<br>}<br><br>
Dataportal_Fetch(object crit) {
    <br>&nbsp;&nbsp;&nbsp; AsyncCommand.BeginExecute();
<br>}

<br>...<br>&nbsp;static BeginExecute()
{
    <br>&nbsp;&nbsp;&nbsp; DataPortal.BeginExecute(new AsyncCommand(), null);
<br>}<br><br>We tried specifying the callback as well as using the BackgroundWorker directly and disposing it in the callback, but got the same results. The weird thing is in a deployed environment it seems to work fine. Furthermore, we've noticed stepping through the code that if the worker thread completes before the main thread returns to the client, it works, otherwise it hangs.<br><br>Any ideas?<br>Thanks,<br>Grant<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 24, 2009</h2><P>The async data portal isn't designed for that scenario. Maybe it could be, but it isn't.</P>
<P>Stop and think about what you are suggesting.</P>
<OL>
<LI>Client calls server, so client is still running, and server is now running on ThreadA.</LI>
<LI>When ThreadA completes, it will respond to client and that's the end of the cycle.</LI>
<LI>Server calls server, so now has ThreadA and ThreadB, but ThreadA is not blocked.</LI>
<LI>Unless something stops ThreadA until ThreadB completes, you can't know if ThreadB will finish before ThreadA returns - and when ThreadA returns that's it - the client moves on and that's that.</LI></OL>
<P>As I say, I imagine we <EM>could</EM> make this work, but enhancing the data portal to use a locking mechanism to block the calling thread (or maybe the original thread handling the client request), and automatically unblock it as appropriate.</P>
<P>But that was outside the scope of our enhancements for 3.6.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>grantj replied on Wednesday, June 24, 2009</h2>I understand it doesn't make sense if it's an async call for which you care about the result, but in this particular case it is a logging call and is fire-and-forget. If I did care about the result then I would absolutely accept responsibility for blocking the main thread until it completed.<br><br>I may be wrong but I seem to remember one of the earlier principles of CSLA being that it shouldn't matter where a dataportal method was being called from - be it client or server. If I'm right then this scenario breaks that principle - an async call works fine if called from the client, but not if called from the server.<br><br>In any case, do you think this is a consequence of using remoting, and if so, could it be alleviated by switching to WCF?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 24, 2009</h2><P>Oh, I agree that this isn't entirely ideal. </P>
<P>One of the design principals is that it shouldn't matter. But async processing is entirely non-trivial, so for this version I chose to break that principal to maintain reasonable parity with Silverlight. I'll probably live to regret it, but I didn't have the time/budget to make it entirely transparent.</P>
<P>I honestly don't know why you are seeing what you are seeing - async is complex, and it is clearly some unforseen interaction.</P>
<P>Fire-and-forget sounds nice, but is not a safe concept when dealing with general async environments. It is quite possible that the background thread is a child of the calling thread, and it dies when the calling thread completes. Or they may be peers (which I think is probably the case) and the backgroundworker is maintaining a back-reference of some sort to the calling thread.</P>
<P>My <EM>guess</EM> is that Remoting is getting confused because the 'main thread' completes, but still has some outstanding hook from the backgroundworker, so that thread can't really complete or be released, and this locks up Remoting. Total speculation on my part, but it sounds good :)</P>
<P>Switching to WCF might help - but I'd be nervous, because who knows what might happen under load as background callbacks occur onto a thread that is now running under a different user request, possibly in a different security context, etc.</P>
<P>Your best bet is probably to create and use a synchronization primitive (like an AutoResetEvent) that the background task can set when it completes, so the 'main thread' can block at the bottom of the DataPortal_XYZ method.</P>
<P>That's basically what I'd do if (or when) I address this in the data portal itself. You can be async on a server, but the 'main thread' can never complete until all outstanding async requests complete - that's a general rule of async processing.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
