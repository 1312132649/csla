<html><header><title>How Do We Prevent DLL Abuse?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How Do We Prevent DLL Abuse?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6906.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx posted on Wednesday, May 06, 2009</h2>HOW DO WE PREVENT DLL ABUSE?<br /><br />We have a large ASP.NET web application we use to support several hundred franchises.  We've been gradually re-writing the business logic using CSLA.  Now that many of the core business objects are complete, we are considering converting the UI from ASP.NET to Windows forms (and using a remote data portal).  <br /><br />However, we are very concerned about our DLLs getting distributed to the franchises' client machines (installed along with the Windows UI).  We've already experienced some abuse of our ASP.NET application by some 3rd party developers hired by a handful of our franchises. So we're confident that similar abuse would occur if we distribute DLLs....and we're speculating it could be much worse.  Because of politics within the organization we are trying to address this abuse issue technically rather than legally.<br /><br />Are there any techniques we can use to prevent someone from abusing the DLLs that would get distributed with our Windows app?  <br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 06, 2009</h2><P>That is very difficult.</P>
<P>You can use obfuscation, but you can't obfuscate public member names (like properties) because that breaks things like data binding and CSLA features like validation/business/authorization rules that drive off the property names. Anything that uses reflection against property names (again, like data binding) can't operate if the property names are randomized.</P>
<P>So obfuscation can protect your algorithmic code (to some degree), but can't stop someone from referencing and using your assembly - and I think that's what you are trying to avoid...</P>
<P>You might consider using Silverlight, as it is harder (maybe impossible?) for someone to create a separate application that interacts directly with the DLLs downloaded as part of a Silverlight application.</P>
<P>I suppose, though, that they could still use JavaScript from a hosting web page to interact with the Silverlight application. I think this is more limited than the arbitrary interaction that would be possible if a developer had direct access to a client-side .NET assembly.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Wednesday, May 06, 2009</h2><br />Your response sparked another question...<br /><br />(particularly the part about Silverlight, which I don't have any experience with)<br /><br />By switching from a Web UI to a Windows UI, our goal was to provide our users with a more interactive UI that was also easier/faster for us to to develop and maintain.  <br /><br />Is there a different UI technology we should consider for achieving this goal?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 06, 2009</h2><P>It is true that a smart client technology is a far cheaper way to give your users a more interactive UI. And the end result is more scalable than the web.</P>
<P>But the drawback, as you note, is that your assemblies end up on the client workstations and are more vulnerable to hacking.</P>
<P>Windows Forms is a fine technology, but it is nearing the end of its life.</P>
<P>WPF is a similar technology, at the start of its life.</P>
<P>Silverlight is somewhat similar, but today it only runs in the browser - and in any case runs in an isolated sandbox. This is why it may be a good option, as external code has no access to your assemblies, even though they are running on the client.</P>
<P>Without understanding the nature of the hacking threat it is hard to provide more insight. Security is all about threat and risk analysis - determining the attack scenarios, likelihood of attack, cost of successful attacks, cost of preventing each type of attack, etc. Based on that information you can make sound business decisions about what attacks to block or ignore.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Wednesday, May 06, 2009</h2>Thanks Rocky!  I appreciate the advice.  I'll do some research on Silverlight and probably WPF too.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, May 06, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><br /><P>Silverlight is somewhat similar, but today it only runs in the browser - and in any case runs in an isolated sandbox.</P><br /></div></BLOCKQUOTE><br /><br />I thought that MS recently announced that Silverlight can be run outside the browser now making it a truly cross-platform environment. It would still be in a sandbox though. You might ask why not use WPF in that case? 1. WPF does not run on a Mac.  2. Easier to deploy the Silverlight run time.<br /><br />Joe<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 06, 2009</h2>True, Silverlight 3 will run outside the browser.<br /><br />But even in that case it is running in an isolated sandbox, so (to my<br />knowledge) no other Windows (or Mac) application can directly interact with<br />the assemblies.<br /><br />If you use WPF to do the same thing, the assemblies are technically<br />accessible to other Windows applications - they just need to reference the<br />DLLs.<br /><br />The only thing with WPF is that if you use ClickOnce, the assemblies are in<br />an obfuscated folder under each individual user's profile folder. And each<br />time a new version comes out the new version goes into a different<br />obfuscated folder. The result is that, while someone could use the<br />assemblies, they'd have to do some fixup work each time you release a new<br />version via ClickOnce - so it would be inconvenient anyway...<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Wednesday, May 06, 2009</h2>Conceptually - what you are looking for is the technique of <a href="http://msdn.microsoft.com/en-us/library/0tke9fxk.aspx%20">Friend assemblies</a> (follow the link)<br><br>A:<br><ul><li>Use <a href="http://msdn.microsoft.com/en-us/library/system.security.permissions.strongnameidentitypermission.aspx">StrongNameIdentityPermission</a> so that only assemblies signed with a certain key (your key) have access to your public functions. Requires strong named assemblies. <br></li></ul>B:<br><ul><li>make all functions "Internal" in your Business Layer</li><li>you should (but must not) use signed assemblies</li><li>use the "Internals visible to" attribute on your business layer to make "internals" available to your UI/business assemblies - in case of signed assemblies this also requires you to supply the public part of the key for the assembly</li><li>only your declared friend assemblies will have access to your internal methods.</li></ul><br>Solution B will make sure at compiletime -&nbsp; that only those given assemblies are allowed to see your "internal" methods/classes. <br><br>At least - no other developer outside your company will then have access to your Business layer. <br><br>Extract from MSDN: <br><i>"The <span><span class="selflink">StrongNameIdentityPermission</span></span> class is used to define strong-name requirements for access to the public members of a type. The <span><a id="ctl00_mainContentContainer_ctl38" href="http://msdn.microsoft.com/en-us/library/system.security.permissions.strongnameidentitypermissionattribute.aspx">StrongNameIdentityPermissionAttribute</a></span>
attribute can be used to define strong-name requirements at the
assembly level. In the .NET Framework version 2.0 and later versions,
you can also use <span><a id="ctl00_mainContentContainer_ctl39" href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.internalsvisibletoattribute.aspx">InternalsVisibleToAttribute</a></span> to specify that all nonpublic types in that assembly are visible to another assembly. For more information, see <span><a id="ctl00_mainContentContainer_ctl40" href="http://msdn.microsoft.com/en-us/library/0tke9fxk.aspx">Friend Assemblies (C# Programming Guide)</a></span> or <span><a id="ctl00_mainContentContainer_ctl41" href="http://msdn.microsoft.com/en-us/library/bb384772.aspx">Friend Assemblies (Visual Basic)</a></span>. "</i><br><br>/jonnybee<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Thursday, May 07, 2009</h2>Wow....I wasn't aware of that functionality.  At first glance, this appears to be exactly what we need.  I'll play around with it and see how it works.  Thanks!</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, May 07, 2009</h2><P><FONT face=Tahoma size=2>One potential issue I can see with using this technique is that some of CSLA may stop working - specifically, parts of the Data Portal might not be able to work under this environment.&nbsp; It's also possible that&nbsp;parts of the CSLA base classes could have some issues with this as well.</FONT></P>
<P><FONT face=Tahoma size=2>You&nbsp;might be able to&nbsp;get it to work&nbsp;by signing your CSLA assemblies with your key, and adding additional attributes for those assemblies.&nbsp; But that could get pretty murky pretty quick.&nbsp; Certainly worth trying, though.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Tuesday, May 12, 2009</h2><br />DOES ANYONE SEE ANY FLAWS IN THIS APPROACH?<br /><br />1.) We sign our assembly with our company's strong name key.  <br /><br />2.) In all of our factory methods we call the "CanCallAssembly()" method shown below.  <br /><br />3.) If the "CanCallAssembly()" method returns False, we throw a security exception.<br /><br />' - - - - - - - - - - - - - - - - - - - - - - - - - -<br /><br />    Public Shared Function CanCallAssembly() As Boolean<br /><br />             ' Get the name of the calling assembly.<br />             Dim callingAssembly As String = System.Reflection.Assembly.GetEntryAssembly.FullName<br /><br />             ' Get the name of the assembly being called (this assembly).<br />             Dim thisAssembly As String = System.Reflection.Assembly.GetCallingAssembly().FullName<br /><br />             ' Get the public key for each assembly.<br />             Dim tokenIndex1 As Integer = thisAssembly.LastIndexOf("PublicKey")<br />             Dim tokenIndex2 As Integer = callingAssembly.LastIndexOf("PublicKey")<br />             Dim testString1 As String = thisAssembly.Substring(tokenIndex1, 31)<br />             Dim testString2 As String = callingAssembly.Substring(tokenIndex2, 31)<br /><br />             ' Do the public keys match?<br />             Return testString1.Equals(testString2)<br /><br />    End Function</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, May 12, 2009</h2>Wouldn't someone be able to decompile and remove the check?  Strong naming doesn't help against that.<br /><br />I think you're in a crunch here.. the only way to be sure would be to expose your application as a web service, and give assemblies that business units can use for rich interactivy... but ultimately the DataPortal_YX calls send out to a web service where the same rules are run.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xxxJasonxxx replied on Tuesday, May 12, 2009</h2>Good thought!<br /><br />What if we ran our stuff through an obfuscation tool, like PreEmptive Solutions Dotfuscator, to prevent someone from decompiling and altering our code.....then would we be in good shape?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, May 12, 2009</h2>You can only obfuscate so much and still have CSLA work.  The reflection (and some other advanced .NET techniques) used in CSLA will fail on obfuscated assemblies, depending on the techniques used.  Rocky has touched on that in previous posts, so a forum search should give you the particulars.<br /><br />There have been many discussions on this forum regarding this issue.  It's a salient issue in .NET, and not one that's easily dealt with.  You can NGEN your assemblies to native code, but that pretty much has to be done on the client machine, and it requires that the original IL assemblies be present, so that doesn't really buy you much.  You can obfuscate - but again, only so far if you still want CSLA to work.  Using strong naming and some .NET CAS attributes will help, but you'd probably have to propagate much of that throughout CSLA to have all of it work - assuming it does.  I have no reason to think it won't, but I've never tried it.  You could investigate some sort of licensing scheme, but that's not foolproof either.<br /><br />Ultimately, as Justin has mentioned, you have no real way to guarantee that a third party won't crack your code base - unless you don't give it to them.  Hide your business logic behind a web service, don't trust any calls that come in through the web service, and deal with the consequences of the type of application you have to build under those parameters.<br /><br />In the end, it's a risk/reward analysis.  How much work do you want to go through to mitigate your risk?  How much do you want to alter how your application works to make sure some untoward individual doesn't do something they shouldn't?  If it really is that important to keep prying eyes out, you don't have a lot of options other than denying them the code base to begin with.<br /><br />- Scott</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, May 13, 2009</h2>Just to add what the others have said about obfuscation... even if you could obfuscate everything, it will only slow the determined party down, it won't stop them.  So you need to figure out the risk / reward.<br /><br />Now, if you decide you can't trust the client, that means you'll be building two applications.  A web service, with Csla business objects behind it to run your validation / auth rules, and the API client you give to your customers.. which run the same rules.  You might be able to figure out a way to do something similar to Csla Silverlight development, where you have some compiler directives to keep most of the code the same, but swap out the data portal code.  (The client's DP_XYS would call your web service.. your web service business layer would have DP_XYZ that actually does the update)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Tuesday, May 12, 2009</h2>What kind of abuse are you trying to prevent?<br /><br />We have found that no matter you architecture, it's very difficult to prevent this sort of thing.<br /><br />We finally decided to embrace it, we made a well documented soap API and support customer or third parties using it. Any "abuse" is considered our responsibility and we try enforce things better in the server API to prevent the abuse rather than obfuscating the client.<br /><br />Basically it's a never trust the client approach as the client may be ours or coded by some third party who has no idea what they are doing or are even malicious.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
