<html><header><title>Some of my thoughts regarding Security code</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Some of my thoughts regarding Security code</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7929.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo posted on Monday, November 02, 2009</h2>Hello,<br /><br />I finished going through the Security code this past Saturday and here are some thought regarding the subject. I hope they make sense and I didn’t totally miss the mark.<br /><br />Thanks guys.<br /><br />------<br /><br />I am looking at the implementation of the RolesForProperty and RolesForType and can’t help but wonder why such similar classes don’t share the same design.<br /><br />There are a couple of things here:<br /><br />1) RolesForProperty declares all its backing fields variables at the beginning of the class while RolesForType declares them adjacent to its property get() implementation.<br /><br />2) RolesForProperty implements code that check permissions while RolesForType implements to add roles. <br /><br />3) Both RolesForProperty declares its member as public but RolesForType declares them as internal. Both classes are scoped as internal so I would personally scope all members as public but that is just me.<br /><br />There is really nothing fundamentally wrong with the way things are implemented right now, but I would think that there is also nothing wrong with in having consistency in the code. And yes, I realize I am being anal but I am on my little quest to try to make it easier for people to understand the CSLA code and every bit matters to me.<br /><br /> ------<br /><br />Besides that, I would also move the:<br /><br /> public delegate bool IsInRoleProvider(IPrincipal principal, string role);<br /><br />from the AuthorizationRulesManager class and put it in the AuthorizationRules and mark AuthorizationRulesManager as internal. I think that exposing the AuthorizationRulesManager class just to have access to the delegate declaration may be an overkill. By far, most (if not all) of the developer’s validation interactivity involves using AuthorizationRules so to me it only makes sense to put that delegate declaration there.  Let’s give developers only one class to worry about when dealing with authorization issues.<br /><br /> ------<br /><br />I think I would also merge AuthorizationRulesManager and SharedAuthorizationRules into one class. I mean after all, it looks like SharedAuthorizationRules is nothing more that factory methods to obtain AuthorizationRulesManager instances so to me, all that functionality really belongs in only one class.<br /><br /> ------<br /><br />I also noticed that the AccessType enum does not appear to be in used unless I am missing something here. Anyone knows where that enum is used?<br /><br /> ------<br /><br />Also, PrincipalCache does not seems to be used anywhere either. A search in the e-book seems to say something regarding that the PrincipalCache is used for WCF purposes. If that is the case, should that class not be on a WCF folder or namespace?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 02, 2009</h2><P>I appreciate your feedback, thank you.</P>
<P>You should keep in mind that this codebase has existed (at least some of it) since 1999 or 2000. Coding styles and preferences (at least mine) change over time. I suspect most people look back at things they wrote 6-12 months ago and see things they'd have done differently. Try doing that with code you wrote 7-9 years ago!</P>
<P>Of course this is production code, used by thousands of people around the world. So while I value code cleanliness and consistency (a lot), there's something to be said for leaving working code alone. Changing code purely for aestheic reasons is rarely a high enough bar to make it worth the time/effort/testing/etc.</P>
<P>And there are backward compatibility concerns. It is true, I might choose to organize some classes or types differently in retrospect. Or not, because some choices were made in anticipation of possible future features/enhancements/changes. But in any case, moving public members around from place to place is always a breaking change and so I try to avoid doing so when possible.</P>
<P>Finally there's the "fun factor". The framework is free, and sales of books and videos don't really cover my time. This is a labor of love as much as anything.</P>
<P>So when I sit down to work on CSLA I look at the wish list, and I tend to order my work based on a few priorities:</P>
<OL>
<LI>Is it a bug with no workaround?</LI>
<LI>Will it help a Magenic client/project?</LI>
<LI>Is it fun/interesting/intellectually stimulating to me?</LI>
<LI>Will it help make the lives of a reasonable number of users better?</LI>
<LI>Is it easy (low-hanging fruit)?</LI>
<LI>Does it make CSLA .NET more "complete"? (like the MVVM stuff)</LI></OL>
<P>And there are some anti-priorities:</P>
<OL>
<LI>Is it boring? Or worse, boring <EM>and time consuming</EM>?</LI>
<LI>Does it increase complexity without amazing payoff in productivity/flexibility?</LI>
<LI>Does it increase my testing/support surface area?</LI>
<LI>Does it focus on "legacy" technologies (now including Windows Forms, Remoting, asmx, Enterprise Services and maybe Web Forms)?</LI>
<LI>Does it solve a problem that's already been solved? (like ORM stuff or UI framework stuff)</LI></OL>
<P>These priorities are especially important during point releases, but they certainly factor into major releases (like 4.0) as well. Though the "fun factor" becomes a much bigger priority for major releases, and tactical things like bug fixes or specific Magenic client requirements are usually not as big an issue.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
