<html><header><title>Implementation of Edit mode</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Implementation of Edit mode</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8624.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lennon posted on Friday, March 05, 2010</h2><p>Hi, I&#39;m looking to implement an &#39;Edit&#39; mode for our WPF UI - in other words, the controls on the form bound to the business object should not be available until the user clicks an &#39;edit&#39; button.&nbsp; At which point the &#39;edit&#39; button should become disabled, and a &#39;save&#39; button enabled (once the data has changed, and the BO is dirty).</p>
<p>What would be the recommended approach for this?&nbsp; It seems as though an Edit method and Editable boolean property should be added to a custom ViewModel&lt;T&gt; derived from ViewModelBase&lt;T&gt;.&nbsp; However, we are also using the CSLA PropertyStatus control to perform our form validations, and therefore we would want each control (TextBoxes, ComboBoxes etc) to be disabled until this &#39;Edit&#39; button has been clicked.</p>
<p>I don&#39;t want to modify the CSLA.NET core code, so I&#39;m wondering what might be the best approach?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, March 07, 2010</h2><p>Are you allowing PropertyStatus to set the IsReadOnly/IsEnabled properties of your UI controls?</p>
<p>I would stop doing that (I don&#39;t use that feature of PropertyStatus anymore personally), because it won&#39;t help you solve your problem.</p>
<p>Notice though, that PropertyStatus exposes properties you can use to turn on/off your UI control through binding. So the IsEnabled property of your UI control can bind to the CanWrite property of the PropertyStatus (for example).</p>
<p>If you are already doing that, then the next steps will be easier (possible).</p>
<p>Xaml binding has a thing called a multivalue converter. This allows you to take multiple input values, and basically merge them into one output value. I suspect that you can use a multivalue converter to solve your problem.</p>
<p>Bind your UI control&#39;s IsEnabled property to a multivalue converter that generates its value from both the PropertyStatus CanWrite and viewmodel EditMode properties. Basically the converter would only return true if both input properties are true.</p>
<p>That way you leverage both the per-property authz features of your object, and the per-form feature of your edit button.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lennon replied on Monday, March 08, 2010</h2><p>Thanks Rocky, that was the sort of thing I was looking for.&nbsp; However, I&#39;m not sure that we could justify a multi value converter for every control on the form.&nbsp; Therefore, I&#39;m wondering if rolling our own PropertyStatus control might be the way to go.&nbsp; That way, I can rework HandleTarget() to check the EditMode property of the current DataContext, or also add an additional EditMode property to the PropertyStatus control which can bind to the EditMode property of the ViewModel in XAML.</p>
<p>We also want to set the MaxLength property of TextBox controls based on the validation rules (StringMaxLength) of the bound BO.&nbsp; Therefore, this logic can also go in HandleTarget.</p>
<p>My only concern with this approach is that we will have to track and migrate any changes/fixes to your PropertyStatus control across to ours on each new release.&nbsp; Do you plan on making your PropertyStatus control more tailored for people making their own custom versions?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 08, 2010</h2><p>I hadn&#39;t planned on changing PropertyStatus to be more extensible, no.</p>
<p>Why don&#39;t you try your idea by creating a subclass and just changing PropertyStatus as little as possible (maybe making a couple things virtual or whatever). If the required changes to PropertyStatus are minor you and I can discuss what they are and I&#39;ll consider working them into the codebase.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lennon replied on Monday, March 08, 2010</h2><p>Thanks Rocky, am I correct in saying that PropertyStatus only checks property level authorization rules, and not type level authorization?&nbsp; Is this by design?&nbsp; If that&#39;s the case, how could I retrieve the object type within HandleTarget() to pass to Csla.Security.AuthorizationRules.CanEditObject() ?&nbsp; I would like to check type level authorization and then property level authorization, or is this functionality already built into CanWriteProperty() called by HandleTarget() ?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 08, 2010</h2><p>CslaDataProvider and ViewModelBase check type level authz rules.</p>
<p>It isn&#39;t clear to me how property level rules would be affected by the per-type rules. The per-type rules control whether the user is allowed to do create/fetch/save/delete operations. A given user might be able to create a new object, but not edit existing ones - so they&#39;d still need to edit some or all of the properties.</p>
<p>The idea is that you&#39;ll use both concepts together. If a user isn&#39;t allowed to edit an object at all, then you&#39;d probably set their role so it can&#39;t edit any properites, can&#39;t create the&nbsp;type or save or delete the type. But they&#39;d presumably still be able to get/fetch the type.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lennon replied on Tuesday, March 09, 2010</h2><p>Hi Rocky, I&#39;ve implemented my own PropertyStatus control by creating a derived type from yours (with a few minor changes to your code).&nbsp; I will send these changes across when everything is complete, but I am now at the stage where I wish to set the MaxLength property of TextBox controls based on the validation rules of the BO.&nbsp; Do you have any thoughts on how these could be accessed externally from the BO?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, March 09, 2010</h2><p>If you use the DataAnnotations attributes there&#39;s a length attribute you can use. CSLA honors those attributes, and your PropertyStatus subclass could reflect against the property to get the attribute, and then expose its own MaxLength property so the UI can bind to that value.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lennon replied on Monday, March 15, 2010</h2><p>Hi Rocky,</p>
<p>I managed to create a custom PropertyStatus control derived from your type, with just the following changes:</p>
<p>private object _source = null; changed to protected object _source = null; <br />private string _bindingPath = string.Empty; changed to protected string _bindingPath = string.Empty;<br />private bool _isReadOnly = false; changed to protected bool _isReadOnly = false;<br />CanRead and CanWrite setters changed from private to protected<br />private void HandleTarget changed to protected virtual HandleTarget<br />private void GoToState(bool useTransitions) changed to protected virtual void GoToState(bool useTransitions)</p>
<p>If these changes could be incorporated into a future version of PropertyStatus, it would be very helpful!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
