<html><header><title>CSLA.NET &amp; Concurrency</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA.NET &amp; Concurrency</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/684.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pauldaly1982 posted on Thursday, July 20, 2006</h2>Does CSLA.NET provide a mechanism for handling concurency issues?<BR><BR>We're currently checking update timestamps on rows in the database.&nbsp; I'm wondering if the framework could notify the users if another user has an object "checked out" for writing... so that I could only allow the second user read access.&nbsp; Could the framework send that second user a notification (via an event???) when the object is available for writing (when the first user "checks in" the object).<BR><BR>Thanks in advance for your help,<BR><BR>Paul Daly</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, July 20, 2006</h2>CSLA does not handle something like this automatically.&nbsp; You would need to build it yourself.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 20, 2006</h2>And the reason it isn't in the framework is that it is really, really hard, and it requires some sort of server component. I think it impractical to come up with an answer that would fit into any IT environment, and so I've avoided putting any sort of answer into the framework.<br><br>To make this really work, what you need is a distributed lock and notification manager. The last one of these that I saw was on OpenVMS about 12 years ago - VAX clusters rocked! <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br>What I'm talking about is a server that manages the communication, setting up publish/subscribe links between all the clients in your system. <br><br>This almost certainly has to be done with TCP sockets, because servers can almost never reliably initiate contact with clients. The client always needs to initiate contact with the server. Yet for this purpose you'd need virtually instant communication so polling is unlikely to work - so you end up with TCP socket connections. Much like IM software in many ways.<br><br>I wrote one of these a couple years ago, using Remoting. And it was cute, but largely useless, because it assumed that the server could contact the client to deliver messages... It was mostly a proof-of-concept in a sense.<br><br>The other thing to consider is the user experience. Concurrency is a best-guess until it happens, so you can't give the user a guarantee - just an indication.<br><br>Finally (and this is related), consider scalabiltiy and performance impacts. All this messaging isn't free, and you need to make sure to do it in a manner that will have the least performance impact. Beyond that however, is the scalabilty impact of all this message traffic buzzing around, and what it does to both your application and the network at large.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bowman74 replied on Monday, July 24, 2006</h2><P>&lt;quote&gt;<BR>To make this really work, what you need is a distributed lock and notification manager. The last one of these that I saw was on OpenVMS about 12 years ago - VAX clusters rocked! ;)<BR>&lt;/quote&gt;</P>
<P>You and your silly VAX... ;)</P>
<P>Thanks,</P>
<P>Kevin</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Allann replied on Thursday, July 20, 2006</h2><P><FONT size=2>Something that may help...&nbsp; Rocky's answer would be the ultimate but I think there is a compromise depending on how critical the data is.</FONT></P>
<P><FONT size=2>I use something like this;&nbsp;Note:&nbsp; Tables that need to be monitored must use a Guid (or&nbsp;identity column)&nbsp;as the only primary key.</FONT></P>
<P><FONT size=2>Create a "lock" table that contains the following columns </FONT></P>
<P><FONT size=2><STRONG>TableName </STRONG>= The table where the record is that needs to be locked for edit<BR><STRONG>RecordKey</STRONG> = Guid of the record<BR><STRONG>SessionId</STRONG>&nbsp;=&nbsp;Session&nbsp;or Computer name of the locking host</FONT><FONT size=2><BR><STRONG>LockedTime </STRONG>= Time when the record is locked<BR><STRONG> MaxAgeInSec</STRONG>&nbsp;= How long can the record be locked (this is important, because people may load the record and walk away, or even worse, there session may crash, leaving the record in the "Lock" table)</FONT></P>
<P><FONT size=2>When record is read via EditableRoot (Store procedure writes&nbsp;the lock record with current time, and the max time this record can be locked.)</FONT></P>
<P><FONT size=2>When another EditableRoot accesses the record the SP will check the "lock" table and mark the item as ReadOnly (a new property on these special EditableRoots) and starts a poll timer (mine is set to 1 min) which will check if the record still exists in "lock" table, or if the "lock" has expired.</FONT></P>
<P><FONT size=2>When the intial EditableRoot is Cleared, Disposed or a new record loaded, it deletes the lock record.</FONT></P>
<P><FONT size=2>You get a slight increase in the SQL traffic with this implementation but because concurrency conflicts are not REALLY common the polling is not started, and you don't need to create a complex messaging system.</FONT></P>
<P><FONT size=2>One final thing, you also need a service on the database server that monitors the "lock" table to remove expired locks.</FONT></P>
<P><FONT size=2>Hope this makes sense, and fits your requirements.</FONT></P>
<P>Allan</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
