<html><header><title>Windows Workflow Foundation examples?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Windows Workflow Foundation examples?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3161.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>mongo posted on Tuesday, July 10, 2007</h2><P>Are there any samples around using CSLA with Workflow Foundation components?&nbsp; </P>
<P>I have been reading the other posts around the integration of CSLA and WF, but not&nbsp;much code.&nbsp;&nbsp; I understand Rocky's point of the synchronous vs. asynch nature&nbsp;between the two and my design can be made to accommodate this (i.e. command-base writes a command record (think GoF command pattern)&nbsp;to a DB and kicks off a workflow).&nbsp;&nbsp;I am hoping&nbsp;to see an implementation to get some concrete ideas on wiring this up.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 10, 2007</h2><P>There is a small WF example in the CSLA .NET 3.0 download. Unfortunately it doesn't address your question, about submitting async workflows...</P>
<P>It is important to realize that something, on the server, must host the workflows. In other words, some EXE must be running on the server, within which your workflow can run asynchronously.In most cases this means a Windows service.</P>
<P>My first instinct, and what'd I'd probably try first, is to use MSMQ. Have your command object get to the app server, and write an entry into a private MSMQ queue by using System.Messaging. That's easy. It might also write data into the database, and just put a key into the queue - that's typically the best approach.</P>
<P>Then you'd write a Windows service that uses System.Messaging to listen for messages to arrive in the queue. Again, this isn't hard. When a message arrives, an event is raised, and you just need to handle that event to process the message: in this case by kicking off a workflow - passing in the data from the queued message.</P>
<P>The complexities you'll encounter are (at a minimum) these:</P>
<UL>
<LI>Making the Windows service multithreaded isn't hard, but throttling the threads can be tricky (unless you are OK with 25 workflows running per CPU on your server - that's the default throttle provided by the thread pool)</LI>
<LI>Retries in case of failure, because by default a failure means the item just disappears. Unless you take steps in your service to handle failure and re-queue the item it may just be gone.</LI></UL>
<P>There aren't trivial answers to these issues (especially the retry one), other than perhaps Biztalk Server. Remember that WF is not designed to replace Biztalk, and if you want a robust async workflow engine on your server, WF is just a bare core on top of which you'll need to build plumbing somewhat like that provided by Biztalk Server.</P>
<P>One other option is to use COM+ queued messaging. They automatically do retries and have a mechanism for doing throttling (using COM+ object pooling). Getting .NET messages into queued messaging is a little harder than using raw MSMQ, but it is probably simpler than trying to roll your own retry infrastructure, etc.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Wednesday, July 11, 2007</h2><P>There is also the option of using SharePoint Services.&nbsp; I've found the capabilities you get for <FONT color=#ff0000><STRONG>free</STRONG> </FONT>to be quite impressive and include document management, forums, surveys etc. capabilities as well as workflow hosting.</P>
<P>I'd suggest that if you're thinking of integrating a CSLA-based applilcation with WF, you&nbsp;may very well also&nbsp;need workflows that are pretty independent of that application.&nbsp; So you may need to look for something like SharePoint anyway.</P>
<P>As we've discussed before, the SOA/WF kool-aid is that&nbsp;the collection of workflows&nbsp;<EM>is</EM> the enterprise application.&nbsp; Dino Esposito gave a prensentation to that end chock full of illogic and falsehoods at Tech Ed which I thought was the most ridiculous&nbsp;thing I've heard on WF to date - but I digress.</P>
<P>If you still believe that n-tier is a good thing and believe in the principles behind CSLA, it is important to maintain the proper understanding of WF as not encroaching on the business layer, as has also been discussed at length previously.&nbsp; But as someone who's spent some time looking at WF and SharePoint, I can see those technologies having a much more significant place in an enterprise than I previously thought.</P>
<P>BTW, on a related note - I just read an article this morning about a survey that&nbsp;reported most people doing SOA are happy with the increase in integration capabilities, but most have not realized any increase in code reuse and some other things that are typically part of the SOA drink-the-kool-aid presentations.&nbsp; Just as those of us (including a very vocal Rocky) looking objectively would have predicted.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mongo replied on Wednesday, July 11, 2007</h2><P>Dan,</P>
<P>Thanks for the details around Sharepoint Services - that is something new to me.&nbsp; My scenario can be handled largely by MSMQ, so I think I will go that route.&nbsp; But in the meantime, can you recommend any good books on Sharepoint Services?&nbsp;I see Ted Pattison has one out from MSPress - I am assuming that would be a good one based on his earlier books.</P>
<P>I don't doubt the SOA survey results - it's great for integration, but it introduces an entirely new bundle of issues.&nbsp; </P>
<P>Thanks again,<BR>-Steve</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mongo replied on Wednesday, July 11, 2007</h2><P>Thank you, Rocky.&nbsp; I just downloaded the 3.0 bits - I am looking forward to digging into this.</P>
<P>My approach is better suited to raw MSMQ initially and then possibly moving to Biztalk server for the reasons you mention.&nbsp;The approach you mention makes a lot of sense - I am backing off the WWF angle for now.&nbsp; </P>
<P>I am taking&nbsp;an approach&nbsp;of extending the CommandBase&lt;&gt; object to build an AsyncCommandBase&lt;...&gt;.&nbsp; Your earlier posts on the issue of remaining transport agnostic makes a lot of sense, and the approach didn't hit until I thought about typical Ajax scenarios (submit request, periodic poll for completion, etc).&nbsp; The approach should work the same whether using a local indirection or MSMQ - with locally described timeout periods to aid the presentation layer.&nbsp; I am still working through the details, but this is an interesting/fun problem to work on.</P>
<P>Thank you for taking the time to reply and going over the options.<BR>-Steve</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
