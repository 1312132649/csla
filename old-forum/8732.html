<html><header><title>Database Keys and CSLA</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Database Keys and CSLA</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8732.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>FrazerS posted on Friday, March 26, 2010</h2><p>I am using Entity Framework and Linq to EF on top of SQL Server for my data access and storage layers.</p>
<p>One issue that I have run into, which&nbsp;might be&nbsp;a common one, has to do with the generation of database keys.&nbsp;</p>
<p>As is typical, my business object layer contain several object relationships (one to many, many to many).&nbsp; From a performance perspective, the ideal PK would be an auto-incremented integer identify column.&nbsp; However, EF can only return an autogenerated key value when SaveChanges() is called on the context.&nbsp; This means that everytime I wanted to create a relationship in the business layer, I would need to commit the changes to get the generated key, if I want to use this key model.&nbsp;&nbsp;This is not desirable, since I want to work through list objects, for the most part.&nbsp; (Add, update, delete objects through the list and save the list to commit all changes at one time).</p>
<p>So, what I am left with is generating the keys in the business objects.&nbsp; The only reliably unique key value is a GUID and I am using this approach.&nbsp; However, using GUIDs as PKs brings a performance cost, especially if there is a lot of insert activity, because rows are essentially inserted in random locations in the tables and index maintenance brings a cost.</p>
<p>So, I am wondering whether anyone else has encountered this situation and if so, have found a way around this?</p>
<p>Frazer</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, March 26, 2010</h2><p>I suggest that you are thinking about this incorrectly.</p>
<p>Business objects are not data entities. They don&#39;t have FK relationships, they just have object relationships. Relationships between objects exist through the references they hold to each other in memory.</p>
<p>In other words, your object model isn&#39;t held together by data relationships, it is held together by the references each object holds to other objects. So concrete FK values are simply meaningless in the object world.</p>
<p>When you are dealing with <em>existing data</em> you often need to carry FK values around so you can persist the data later. But even then the FK values in the objects are there as a plumbing detail to make the database happy - they have no value to the objects or object model.</p>
<p>When you are dealing with <em>new data</em> the FK values in the objects can usually be left as default values (often 0) because they have no meaning anyway. Your DAL code will know to do an insert because IsNew is true.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>FrazerS replied on Friday, March 26, 2010</h2><p>My biases are revealed.&nbsp; :)</p>
<p>After reading Rocky&#39;s reply, I went back through my business object code to see if, in fact, I could eliminate (or at least drastically reduce) the use of database keys in the business layer.&nbsp; In some cases, I can see where that is quite possible, but in some instances, it&#39;s a bit more difficult.&nbsp; One such area is where I have implemented many-to-many relationships. The approach that I took is not that much different from the Resources model from PTracker.&nbsp; The problem area is with the Assign method - if you do not have some kind of unique identifier for the business object you are Assign-ing then how else do you identify it?&nbsp; From PTracker::Resources:</p>
<p><br />&nbsp;&nbsp;&nbsp; public void Assign(int resourceId)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(Contains(resourceId)))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ProjectResource resource = ProjectResource.NewProjectResource(resourceId);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(resource);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new InvalidOperationException(&quot;Resource already assigned to project&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p>What am I missing?</p>
<p>Frazer</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, March 26, 2010</h2><p>I think that you may be trying to do work that EF can do for you.&nbsp; Maybe I&#39;m missing something, but you can take Rocky&#39;s comments (think in object relationships) and apply it to EF too.&nbsp; EF maintains the object-graph relationships just like CSLA objects do, and they&#39;re assignable as well.&nbsp; When you do that, EF should take care of propagating the appropriate values for your PK/FK relationships automatically.</p>
<p>In the case of your example, you should already have an appropriate ID for your assignment, as (in this case) the resource has to exist before you assign it to a project.&nbsp; So while your BO doesn&#39;t necessarily care about the ID, you can still bring it along for the ride.&nbsp; If you can create projects and resources at the same time, then I think you have a muddled use case.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dmnc replied on Friday, March 26, 2010</h2><p>If you create GUIDs as PKs for new objects you could use a so called COMB GUID to get around the issue of index fragmentation.<br />A COMB GUID relies on time to increase. <a href="http://www.informit.com/articles/article.aspx?p=25862">http://www.informit.com/articles/article.aspx?p=25862</a>&nbsp;has detailed information.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>FrazerS replied on Friday, March 26, 2010</h2><p>Good points, Dan.</p>
<p>I found a little snippet of code to generate Combs in C# and I am going do some benchmarking, then switch them in for NewGuid() and see what kind of difference it makes.</p>
<p>&nbsp;</p>
<p>thanks,</p>
<p>Frazer</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
