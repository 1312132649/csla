<html><header><title>GetIdValue() and Composite Keys</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>GetIdValue() and Composite Keys</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/113.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Howard posted on Tuesday, May 16, 2006</h2><P>Hi</P>
<P>I'm implementing an EditableRootCollection/EditableChild portion of our object model and as the subject suggests am curious as to how to implement GetIdValue() for data that does not have a single uniquely identifying integer key (surrogate key?).</P>
<P>In this particular case the Root has 2 keys and the Child has 3 keys of which 2 are shared with the root.</P>
<P>Having not fully read your book although I've read chapters 1,2 and skimmed most of the rest of it, the only dependencies on this method to my knowledge are Equals(), GetHashCode() and ToString() in BusinessBase&lt;T&gt;.</P>
<P>I was thinking of implementing 2 public structures say RootKey and ChildKey and use these inplace of the integer type&nbsp;ID in the templates.</P>
<P>Will this work? Is this&nbsp;best practice&nbsp;CSLA?</P>
<P>Any help much appreciated.</P>
<P>Thanks in advance</P>
<P>Howard</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>LayeredDev replied on Tuesday, May 16, 2006</h2><P>Hi Howard,</P>
<P>I would suggest revising the data model and making a single uniquely identifying integer the primary key for both the root and the child. If your requirements require you to have unique values in a set of columns, then create a unique constraint/index on those columns in the root or child table but keep the primary key a unique integer column in both the root and child data sets.</P>
<P>Thank you,</P>
<P>&nbsp;</P>
<P>Cosmic Ovungal</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Howard replied on Tuesday, May 16, 2006</h2><P>Thanks for the response, I'll pass this on to the DBA.</P>
<P>However, if the DBA turns round and says no, is the approach I outlined still valid/workable?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>LayeredDev replied on Tuesday, May 16, 2006</h2><P>Hi Howard,</P>
<P>The approach you outlined may work but it will not be standard CSLA practice. It will also lead to maintenance nightmare later on down the road. Thats because you are using composite key as a primary key. In my experience, the primary key should always be a single column, usually a unique integer which is given the identity property in SQL Server.&nbsp;</P>
<P>If you are planning for replication or&nbsp;inserting data from other table, then&nbsp;you would choose a&nbsp;RowGuid as your primary key which generates&nbsp;a primary key based on NIC card on your machine.&nbsp;</P>
<P>Cosmic Ovungal</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Tuesday, May 16, 2006</h2>Seriously... you can't change your data model just because of GetIdValue!! Mainly because there's nothing wrong in having a composite pk.<br><br>One thing you can do in this cases, (I realize this may be frowned upon) is join all this values and get it's hashcode as your own internal id:<br><br>Dim pk1 as Integer = 10<br>Dim pk2 as String = "hello!"<br><br>String.Concat(pk1.ToString(), pk2).GetHashCode()<br><br><br>Andrés</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>LayeredDev replied on Tuesday, May 16, 2006</h2><P>Andres,</P>
<P>There's is nothing wrong in having composite PKs but it complicates matters a lot. Its best to avoid having composite PKs because you have to take all the columns that compose a PK and import it into another table as a FK. </P>
<P>Its best to keep matters simple by having a single column PK and implementing business requirements of uniqueness among columns by creating a unique index/constraint on&nbsp;such columns. This has been my practical experience. </P>
<P>But if a composite key is required, then your method would be the way to go.</P>
<P>Cosmic Ovungal</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Howard replied on Tuesday, May 16, 2006</h2><P>Cosmic - What&nbsp;kind of maintenance nightmare you are referring to? Surely everything is encapsulated within the structure itself? With&nbsp;Equals() implemented and perhaps an operator override for =, I don't really see how this makes life any harder other than having to code a handful of very simple structures and having more parameters to pass around? Also, the structures and parameters themselves would be inherently more readable rather than surrogate integers or guids thus making debugging easier. Am I missing your point?</P>
<P>Andres - having just read the help on Object.GetHashCode() I think your solution is the only option short of actually implementing a custom hashing algorithm and I for one don't want to go there :) </P>
<P>Although of course you would need to make some effort to ensure that&nbsp;clashes do not occur&nbsp;perhaps by introducing a&nbsp;delimiter character between the strings?</P>
<P>Rockford - What is&nbsp;your&nbsp;stance/advice on this?</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, May 16, 2006</h2>I'll have to agree with xal here.&nbsp; There are valid reasons for composite keys and your datamodel shouldn't change due to your business object model.<br><br>Whats wrong with having this:<br><br>protected override GetIdValue() {<br>&nbsp; return string.Format( "{0}:{1}", intId1.ToString(), intId2.ToString();<br>}<br><br>Seems like that would be sufficient.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Howard replied on Tuesday, May 16, 2006</h2><P>Yeah, doh (slaps head). Quite right. Just got off messenger with&nbsp;designer and came to exactly the same answer (with delimiter character tho.).</P>
<P>Thx.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 16, 2006</h2><P>Absolutely - just concatenate the parts of the key with a delimiter and you should be all set. That's what I do. Sometimes compound keys are the right answer, no doubts there.</P>
<P>Alternately, GetIdValue() doesn't necessarily need to reflect the database at all. You could keep a Guid value private to your object as its "id" value while in memory. This can get confusing, so I don't know that it is always the right answer, but in the case that you don't have any other unique identifier for your object this can be the right answer.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Thursday, May 18, 2006</h2>I've been forced to work with composite keys for several years now. Concatenating is required. The only question is how to concatenate.<br><br>Delimiters is a good idea, but you have make sure you choose a delimiter that won't be in the value. In our database, some of the keys can contain any printable character.<br><br>Another option is concatenating padded fields. This is what we do. We maintain "smart" data objects in our editable business objects. These smart data objects store the maximum length of their fields when they are retrieved from the data reader. This maximum length is used by the UI to prevent the user from typing too many characters, but it is also used to provide a padded value. This approach works as long as your composite key columns are all varchar or char. If you get into dates and integers in your key fields, it's a little less intuitive, but the padded values could be have formats like 20060518 for a date or 000001458 (9 characters) for an integer.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, May 18, 2006</h2>

<p class="MsoNormal">Natural keys are great in theory but are usually lousy in practice.<span>&nbsp; </span>This is why I usually use surrogate keys now.<span>&nbsp; </span>If the user is able to change any of the
values of the key, you will need to store the old values of the key in the
object so you can update the key in the db.<span>&nbsp;
</span>DBA’s with little to no programming experience are probably more likely
to use natural keys.<span>&nbsp; </span>However, you should
not change your db structure to fit your code.<span>&nbsp;
</span>I have used concatenation and GUIDs in the past.<span>&nbsp; </span>Both methods work; however they are a hassle
when compared to the alternative.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, May 19, 2006</h2>There's nothing wrong with natural keys.&nbsp; The problem is usually the
mistake of thinking that natural key X can never change.&nbsp; Using an SSN
for example would have this problem.&nbsp; It may change if the person is
recovering from ID theft, for example.<br>
<br>
However, a model number isn't likely to be recycled by a company, and I would say model number could be a great natural key.<br>
<br>
At any rate, we are discussing composite keys, not natural keys. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br>
<br>
Andy</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>LayeredDev replied on Friday, May 19, 2006</h2><P>Can't a composite key be a natural key? And vice versa can't a natural key be a composite key? Just wondering. And is SSN a natural key. I would think the DNA fingerprint would be the only natural key for humans. Again, just wondering.</P>
<P>Cosmic Ovungal</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Friday, May 19, 2006</h2><p class="MsoNormal"><span>Ajj3085,</span></p>
<p class="MsoNormal"><span>The reason
why I brought up natural keys is because composite keys are usually made up of natural
keys.<span>&nbsp; </span>If you use surrogate keys instead of composite keys, you
have no need for composite keys.<span>&nbsp; </span>BTW, I
did not say all natural keys are bad.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RanceDowner1234 replied on Friday, May 19, 2006</h2>I would suggest using a GUID instead...<br><br>&nbsp;&nbsp;&nbsp; Private _id As Guid = Guid.NewGuid<br>&nbsp;&nbsp;&nbsp; Protected Overrides Function GetIdValue() As Object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return _id<br>&nbsp;&nbsp;&nbsp; End Function<br><br>I ran into a problem when trying to databind a collection to an editable datagrid.&nbsp; If you use database values as the key for the object it will give you all kinds of woes if you allow the user to create new rows, if the Key values are not filled out until after a database update (for example using SQL Server 'seeded' fields).&nbsp; The datagrid&amp;CLSA apparently try to remove all rows that share the same value returned from GetIdValue( ) when an undo is called.&nbsp; So unless you are generating any Key values automatically on Object creation, they will be blank for any newly created objects, until you save and return primary key from database.&nbsp; Using a GUID seemed to solve all these problems.&nbsp; The other workaround, as stated, would be to make sure that your values are autogenerated when you create the object.&nbsp; But GUIDs just seem to be the most elegant solution.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
