<html><header><title>Initialising static fields in classes inheriting from BusinessBase</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Initialising static fields in classes inheriting from BusinessBase</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7544.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>sturdytree1 posted on Monday, August 31, 2009</h2>I've read page 248/249 of Business Objects 2008 and am puzzled by a couple of things, and will be grateful to anyone who can 'unpuzzle' me!<br /><br />Rocky states that where a class inherits from a base class that in turn inherits from a csla base class (such as Businessbase), then there is an issue to consider (though V 3.6.1 has now fixed this).<br /><br />The issue was that the timing of static field initialisation was uncertain, and so in a typical field/property such as:<br /><br />private static PropertyInfo NameProperty = RegisterProperty(new PropertyInfo("Name","Name"));<br />public string Name<br />        {<br />            get { return GetProperty(NameProperty); }<br />        }<br />            set { SetProperty(NameProperty, value); }<br />        }<br /><br />there is a danger the Name property is accessed before the static NameProperty is initialised (and RegisterProperty processed). In such a case GetProperty/SetProperty will fail as they will not find NameProperty in FieldManager.<br /><br />But, if that scenario does happen, will not the very act of running, say 'SetProperty(NameProperty, value)' reference the static NameProperty, thus causing all static fields to be initialised before the SetProperty code is run? Clearly this does not happen, but I'm not sure why?<br /><br />Also, Rocky mentions in his book the above is not a problem for a class inheriting directly from a csla base class (direct case), but only where a class inherits from a custom base that in turn inherits from a csla base (indirect case). Why should this matter, as even with a direct case you could access an instance property before the static fields are initialised?<br /><br />The following is an old post that deals with this issue, but does not seem to shed light on the above:<br /><br />http://forums.lhotka.net/forums/1/26436/ShowThread.aspx <br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 31, 2009</h2><P>It is because of the way .NET initializes static fields. They are initialized <EM>per class</EM> not per object.</P>
<P>So if you have an inheritance hierarchy of A&lt;-B&lt;-C and touch a static member defined in A and C that'd force all static fields in A and C to be initialized, but not in B.</P>
<P>Yes, I know that your object is an instance of C (and thus A and B), but the static fields are initialized <EM>per class</EM>, so the fields defined in A, B and C are all initialized separately.</P>
<P>When you call SetProperty() on a field defined in C you force initialization of all C fields. And SetProperty() uses static members in BusinessBase&lt;T&gt;, which forces initialization of the CSLA base class. But if you have an intermediate class inbetween, nothing forces initialization at that level.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sturdytree1 replied on Monday, August 31, 2009</h2>Rocky,<br /><br />Thanks for the response.<br /><br />I do understand the static fields are initialised per class (and not per object or per inheritance hierarchy), but if we take the specific case:<br /><br />class MyBase: BusinessBase<br />{ // no code }<br /><br />class Customer : MyBase<br />{<br />//NameProperty as defined in earlier post<br />}<br /><br />then, if I wrote:<br /><br />Customer c = new Customer:<br />string name = c.Name;<br /><br />That would cause GetProperty(NameProperty) to run. When the Runtime references the NameProperty, why would that not cause the static NameProperty that belongs to Customer to be initialised? If it does, then the property will be registered before GetProperty runs, avoiding any problems. Sorry if I'm missing something obvious.<br /><br />If I had <br /><br />class Customer: BusinessBase<br />{<br />//NameProperty as defined in earlier post<br />}<br /><br />Why would this not cause a problem, as there would still be the possibilty that the instance property Name is accessed before the static field is intiialised?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 31, 2009</h2>With CSLA there's also the n-tier aspect.<br /><br />If your DataPortal_XYZ or object factory methods are running on the app<br />server, then your LoadProperty() or SetProperty() calls would occur on the<br />server, initializing the static fields on the server.<br /><br />The object instance is then serialized to the client, where the object graph<br />rehydrates without invoking any static members at all. So (unless something<br />else occurs) the static fields are uninitialized until your GetProperty()<br />call.<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sturdytree1 replied on Monday, August 31, 2009</h2>Thanks again, but <br /><br />1) would you agree that in my example above there would equally be a problem where Customer inherits directly from Businessbase? If not, then I'll really be grateful if you could indicate why (I'm only asking so I can understand your statement in the Business Objects book that the problem does not arise on a direct inheritance). <br /><br />2) What is the flaw (and there obviously is one!) in my argument on there apparantly not being a problem if the NameProperty reference in Set/Get causes the static intiialisation. If the answer is it does not cause the initialisation, do we know why not?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 31, 2009</h2>I'm afraid I don't have time to re-hash all that in my mind to form a<br />complete description of .NET's behavior.<br /><br />Brad Abrams wrote a blog post a couple years ago where he carefully walked<br />through how static fields are initialized in .NET. This was my starting<br />point (once I realized I had a problem).<br /><br />I then wrote numerous test apps with various static field combinations and<br />used them in one AppDomain and serialized across AppDomains to study the<br />behavior. This was necessary because Brad didn't discuss serialization in<br />the blog post.<br /><br />I then thought I had it, until someone (Joe I think?) pointed out the<br />problem with intermediate classes in the inheritance hierarchy, which is<br />very real. The _forceInit technique solves the problem.<br /><br />But this was a major pain point as 3.5 rolled out, which is why 3.6<br />introduces a more automated solution, using reflection to touch one static<br />field per class, once per type per AppDomain. The cost is low, and the<br />benefit is incredibly high.<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sturdytree1 replied on Monday, August 31, 2009</h2>Great, thanks Rocky.<br /><br />Your time on this is much appreciated.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
