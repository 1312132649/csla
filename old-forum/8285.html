<html><header><title>CSLA 4 business rules changes</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 4 business rules changes</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8285.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka posted on Monday, January 04, 2010</h2><P>In CSLA .NET 4.0 I plan to make some fairly major changes to the business rules subsystem. This will include breaking changes, but I think they are necessary and good breaking changes. Hereâ€™s the bugtracker issue for the change</P>
<P><A title=http://www.lhotka.net/cslabugs/edit_bug.aspx?id=623 href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=623"><STRONG>http://www.lhotka.net/cslabugs/edit_bug.aspx?id=623</STRONG></A></P>
<P>At a high level my goals are 
<OL>
<LI>Support shared hosting scenarios 
<LI>Change naming/coding to better reflect business rules, not just validation 
<LI>Provide consistency between sync and async rules</LI>
<LI>Allow a rule to add/remove multiple broken rule entries (enable rule chaining)</LI></OL>
<P>As you can imagine, these changes will have at least some impact on existing rule methods and AddBusinessRules() methods. I hope that the changes are pretty mechanical (and thus easy to make), but this will improve readability and open up some new scenarios that are hard/impossible today.</P>
<P>My current thinking includes a few changes:</P>
<OL>
<LI>Rename the ValidationRules protected property to BusinessRules 
<LI>Eliminate the bool return from rule methods, instead returning the result via RuleArgs with the default being true (so business rules can ignore the whole thing, while validation rules will set e.Result = false for failure) 
<LI>Provide a RuleContext value in RuleArgs that allows you to get/set property values from the target object in an abstract manner, much the way async rules work today, but bi-directional 
<LI>With sync and async rules, after the rule completes (so the code is running on the UI thread), update changed property values from RuleContext back into the object 
<LI>Maybe call a lambda (Action&lt;T&gt;) after the rule completes and the code is running on the UI thread (whether sync or async) 
<LI>Allow "rule chaining", where a rule can call other rules, and can aggregate&nbsp;the results of those rules into RuleArgs so post-processing occurs against all the results 
<LI>Possibly use MEF to dynamically discover and load rule methods in a more abstract manner 
<LI>Add the concept of "rule domains", so a business type can have multiple rule sets, each belonging to a domain - this would support shared hosting scenarios for server apps and app servers 
<LI>If I can get the sync/async rule syntax to match by using RuleContext, I may use an [AsyncRule] attribute so you can indicate that a rule is required to run async by putting that attribute on the rule method 
<LI>Add a BusinessRuleAttribute (subclass of ValidationAttribute) that implements ObjectFactory-like protected members, making it easier to create a rule attribute that can get/set values in the target object</LI></OL>
<P>You can imagine AddBusinessRules() looking more like this: 
<P>protected override void AddBusinessRules()<BR>{<BR>&nbsp; base.AddBusinessRules();<BR>&nbsp; BusinessRules.AddRule(MyRule, MyProperty);<BR>&nbsp; BusinessRules.AddRule(MyRule, MyOtherProperty);<BR>} 
<P>And you can imagine a rule looking like this: 
<P>private static void MyRule&lt;T&gt;(T target, RuleArgs e) where T : MyType<BR>{<BR>&nbsp; if (some condition is met)<BR>&nbsp;&nbsp;&nbsp; return;<BR>&nbsp; else<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; e.Description = "oops";<BR>&nbsp;&nbsp;&nbsp; e.Result = false;<BR>&nbsp; }<BR>} 
<P>or a mutator rule like this: 
<P>private static void MyRule&lt;T&gt;(T target, RuleArgs e) where T : MyType<BR>{<BR>&nbsp; e.RuleContext.PropertyValues[e.PropertyName] =&nbsp;<BR>&nbsp;&nbsp;&nbsp; e.RuleContext.PropertyValues[e.PropertyName].ToString().ToUpper();<BR>}</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Monday, January 04, 2010</h2>Rocky, <br>I also would like to also see support for validation rules separation in csla 4.0.&nbsp; Like ObjectFactory, this would make it easier to test the validation logic.&nbsp; <br><br>The implementation could look something like the following:&nbsp; <br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; private static MyBoValidator rule = new MyBoValidator();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void AddBusinessRules()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BusinessRules.AddRule(rule.MyRule, MyProperty);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
<br>The separated validation rule can be implemented as follow<br>&nbsp;&nbsp;&nbsp; class MyBoValidator<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void MyRule(MyBo target, RuleArgs e) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //validation code goes here<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>If we can access bo's protected members from RuleContext, then I guess the above implementation will just work with the new 4.0 validation.&nbsp; If not then csla 4.0 can help by creating base class for validator that implements the ObjectFactory's protected methods.<br><br>Thanks,<br>Ricky<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, January 04, 2010</h2><P>The only trick with that is it requires creating an object instance. The rule method can't be static, it has to be an instance method, and CSLA will need to create the instance.</P>
<P>Using a singleton scheme would probably be best - but will cause support headaches, because developers aren't generally used to coding singletons.</P>
<P>Of course you can do this today. You could implement a singleton object that inherits from ObjectFactory and exposes rule methods. So maybe I don't really need to do any work, since the feature already exists :)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Tuesday, January 05, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>The only trick with that is it requires creating an object instance. The rule method can't be static, it has to be an instance method, and CSLA will need to create the instance.</div></BLOCKQUOTE><br><br>Yes, which is the intent so that we can easily test the validation rules in isolation which is very usefull for complex validation.&nbsp; Like ObjectFactory, I'm seeing this method can be another alternative to in object static method, and users who are not familiar with singleton pattern don't need to use it (they probably don't do test. just kidding...;))<br><br>Agree, we can do this today by inheriting from ObjectFactory but it nice to have "official" class, so that it doesn't sound hacky.<br><br>@jonnybee,<br>Yes, we can use this method to create common validation rules within some bounded context.&nbsp; That's a very nice example.<br><br>Ricky<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Tuesday, January 05, 2010</h2>Hi Ricky, <br><br>You could even do it this way: <br><font face="Courier New" size="1">&nbsp;&nbsp;&nbsp; public static class MyCommonRules<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private class Accessor : ObjectFactory<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal IDisposable BypassPropertyChecks(object o)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return base.BypassPropertyChecks((BusinessBase)o);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal object ReadProperty(object target, string property)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var propertyInfo = PropertyInfoManager.GetRegisteredProperties(target.GetType()).Where(p =&gt; p.Name == property).FirstOrDefault();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var fieldManager = (FieldDataManager) MethodCaller.CallMethod(target, "get_FieldManager");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (propertyInfo != null &amp;&amp; fieldManager.FieldExists(propertyInfo))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var info = fieldManager.GetFieldData(propertyInfo);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (info != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return info.Value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return MethodCaller.CallPropertyGetter(target, property);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static bool SmartDateIsFuture(object target, RuleArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var accessor = new Accessor();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (accessor.BypassPropertyChecks(target))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var value = (SmartDate) accessor.ReadProperty(target, e.PropertyName);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value &lt; DateTime.Today) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Description = string.Format("{0} must be larger than {1}", e.PropertyFriendlyName, DateTime.Today);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br></font><br><br>The "hack" with methodcaller allows me to implement my own non-generic ReadProperty in my accessor. If ObjectFactory would (in future) include a non-generic ReadProperty
then I'd rather use that call to read actual fieldvalue. <br>
<br>I want to get acces to the FieldValue because of&nbsp; SmartDate (and other custom structs) where the FieldData and actual property are different types (ex SmartDate and string). When properly coded in BO this will also work with private backing fields (old style) and ManagedProperties with private backing field. <br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, January 05, 2010</h2>If you are going to make breaking changes, perhaps you could consider:<br /><br />1. Enforcing rule priority across properties. Currently short-circuiiting can't be used to guarantee the order that rules execute when property dependencies are present. <br /><br />2. Provide for the capability to manually execute a specific rule versus only based on a property change. If the rule so invoked fails, it gets added to the broken rules collection, if it succeeds, then it is removed from the broken rules collection.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Tuesday, January 05, 2010</h2>Well unfortunately, I don&#x2019;t really have enough deep understanding of the CSLA to give you any meaningful feedback but I trust you know what you are doing and I will simply adapt to whatever changes you have in mind.<br /><br /><br />Nevertheless, if you don&#x2019;t mind me suggesting something, what I would personally like to see would be the complete integration of the PropertyInfo, RulelMethod and RulesArgs. In other words, I don&#x2019;t like to do this:<br /><br /><br />ValidationRules.AddRule(CommonRules.StringMaxLength, new ommonRules.MaxLengthRuleArgs(CategoryProperty, 30));<br /><br /><br />There are too many mismatch things that could occur here (from what I can tell):<br /><br /><br />1.	CategoryProperty could be a property that represents a data type that is not a string (we are expecting it to be a string in the example above)<br />2.	The &#x201c;AddRule&#x201d; method can take anything that derives from RuleArgs (So we could pass a RuleArgs used to validate DateTimes to validate a string).<br />3.	The rule method is expected to match the RuleHandler signature so it can be anything. <br /><br /><br />So to give an example, the code above could be changed to the code shown below and I will only get a runtime error but not compile time error:<br /><br /><br />ValidationRules.AddRule(CommonRules.StringMaxLength, new CommonRules.IntegerMaxValueRuleArgs(CategoryProperty, 30));<br /><br /><br />Notice how I am using &#x201c;IntegerMaxValueRuleArgs&#x201d; for a &#x201c;StringMaxLength&#x201d; method. Clearly this is not something that you want to do.<br /><br /><br />So in my world, I would prefer to have a single (all in one) class for validation like the snippet show below:<br /><br /><br />------------------------------------------<br /> <br />public class NiceStringMaxLength : DecoratedRuleArgs<br />{<br />    public NiceStringMaxLength(PropertyInfo&lt;string&gt; propertyInfo, int maxLength)<br />        : base(propertyInfo)<br />    {<br />        this[&quot;MaxLength&quot;] = maxLength;<br />        this[&quot;Format&quot;] = string.Empty;<br />    }<br /><br />    public int MaxLength<br />    {<br />        get { return (int)this[&quot;MaxLength&quot;]; }<br />    }<br /><br />    public virtual bool CheckRule(object target)<br />    {<br />        int max = (int)this[&quot;MaxLength&quot;];<br />        string value = (string)Utilities.CallByName(target, this.PropertyName, CallType.Get);<br />        if (!String.IsNullOrEmpty(value) &amp;&amp; (value.Length &gt; max))<br />        {<br />            string format = (string)this[&quot;Format&quot;];<br />            string outValue;<br />            if (string.IsNullOrEmpty(format))<br />                outValue = max.ToString();<br />            else<br />                outValue = max.ToString(format);<br />            this.Description = String.Format(Resources.StringMaxLengthRule, RuleArgs.GetPropertyName(this), outValue);<br />            return false;<br />        }<br />        return true;<br />    }<br />} <br /><br />------------------------------------------<br /><br />So I could be totally type safe and add a validation rule like this:<br /><br /><br />ValidationRules.AddRule(new NiceStringMaxLength(CategoryProperty, 30));<br /><br /><br />NOTE: The code above is totally untested. Something tells me that I am suggesting here would not fly so I didn&#x2019;t apply myself here.<br /><br /><br />Thanks.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, January 05, 2010</h2><P>Rocky,</P>
<P>One of my key concerns with mutator rules is that setting the Property of the BO causes all of the rules to run again. There were various suggestions to get around this issue including short circuiting and using rule priorities. But it would nice if the framework handled all of this for the developer so that they could concentrate on the rules themselves without being concerned about how many times they get executed.</P>
<P>1. Will your proposed changes take this into account?</P>
<P>2. Will mutator rules always run before Validation rules? (Why validate something that you are about to change?)</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2><P>This is all good input - which is what I'd hoped for when starting the thread :)</P>
<P>Andy and Joe, I don't have answers for whether my proposed changes will do these things. They weren't on my list, and I'm glad you are bringing them up.</P>
<P>One thing that is on my list is to make sync/async and validation/mutation rules all look and work the same. So making mutator rules run first would require making them NOT look the same so CSLA could detect them and default them to a lower priority or something.</P>
<P>An earlier post also suggested&nbsp;(basically) merging all rules from multiple (dependent) properties into a consolidated list, sorting them by priority and then running them as a single list - thus merging all short-circuiting from all properties into a single run. I think this would be an unworkable mess - but I'm interested to hear what others think about the idea.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, January 05, 2010</h2><P><FONT face=Tahoma size=2>While I think that making validation and mutation rules "all look and work the same" is perfectly fine (and also much wanted), I think you can't <EM>process</EM> them the same, for many of the reasons already listed.&nbsp; As Joe mentioned, there's little point in running a validation rule on a property that's going to be mutated later.&nbsp; And I also see value in Andy's (and others') suggestion to allow for specific scenarios where sets of rules are run, or allow for certain sets of rules to be run programmatically.&nbsp; </FONT><FONT face=Tahoma size=2>Creating a rule type would also allow you to relatively-easily insert some latch functionality into the mutator processing, thus satisfying Joe's request.</FONT></P>
<P><FONT face=Tahoma size=2>Perhaps this is something that could be shoehorned into the rule-domain concept.&nbsp; Rule domains are essentially a way to group rules, so you could essentially pre-create two domains.&nbsp; Then you can keep much of the semantics of rule construction identical.&nbsp; Perhaps you weren't considering the concept of nested domains, but it seems to me to be a logical extension that wouldn't add a ton of overhead.</FONT></P>
<P><FONT face=Tahoma size=2>I also see a lot of value in rxelizondo's suggestion of matching up rules with types.&nbsp; I've been bitten by that bug a&nbsp;few times...</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2>






 





<div class=Section1>

<p class=MsoNormal><span>Let&#8217;s not forget the sync/async issue too.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>At least today, sync rules run synchronously, according to
priority. Async rules (only validation today) are then launched at the end and finish
when they finish. There&#8217;s no sense of priority for async rules, because they
run concurrently and asynchronously.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I plan to enable async mutator rules, which will STILL run at
the end and will finish when they finish. A mutator rule will be able to change
multiple properties (it will return a dictionary of changed values). But since
it is async, its completion is indeterminate &#8211; we don&#8217;t know when it will get
done.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>That adds a very interesting wrinkle into this whole discussion &#8211;
as you all ask for more control, the async world is providing (arguably) less
control.<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, January 05, 2010</h2><P>Async mutator rules sound like a problem waiting to happen.</P>
<P>What happens when two async rules change the same property to different values?&nbsp; Which rule "wins" in that case?&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, January 05, 2010</h2><P>Couldn't both the "run only on property changed" and "this is a mutator" rule be handled by adding a parameter to the AddRule call, indicating that this should should only run on property changed or that it's a mutator?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2>Or using attributes on the rule method?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, January 06, 2010</h2>Yes, I think an attribute would work fine too.&nbsp; </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>
<P>Couldn't both the "run only on property changed" and "this is a mutator" rule be handled by adding a parameter to the AddRule call, indicating that this should should only run on property changed or that it's a mutator?</P>
<P></div></BLOCKQUOTE></P>
<P>Which ever mutator ends last would win. It is true that multiple async mutator rules would be problematic.</P>
<P>But there are two features that I think will offset the issue:</P>
<OL>
<LI>Rule chaining</LI>
<LI>Post-processing callback</LI></OL>
<P>Rule chaining means that one rule can create multiple brokenrule entries and/or can call other rules. The primary motivation here is to allow creation of a rule that invokes an external rule engine that creates numerous broken/unbroken rule results.</P>
<P>Post-processing callback means that you can provide a delegate/lambda that is invoked when a rule is complete. This will occur on the UI thread (or so goes my plan) so you can do any post-processing you'd like to do.</P>
<P>Combine post-processing with chaining and you should be able to invoke a set of syncrhonous rules upon completion of an async rule.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, January 06, 2010</h2><FONT face=Tahoma size=2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>Which ever mutator ends last would win. It is true that multiple async mutator rules would be problematic.</FONT>
<P><FONT face=Tahoma size=2>But there are two features that I think will offset the issue:</FONT></P>
<OL>
<LI><FONT face=Tahoma size=2>Rule chaining </FONT>
<LI><FONT face=Tahoma size=2>Post-processing callback</FONT></LI></OL>
<P><FONT face=Tahoma size=2>Rule chaining means that one rule can create multiple brokenrule entries and/or can call other rules. The primary motivation here is to allow creation of a rule that invokes an external rule engine that creates numerous broken/unbroken rule results.</FONT></P>
<P><FONT face=Tahoma size=2>Post-processing callback means that you can provide a delegate/lambda that is invoked when a rule is complete. This will occur on the UI thread (or so goes my plan) so you can do any post-processing you'd like to do.</FONT></P>
<P><FONT face=Tahoma size=2>Combine post-processing with chaining and you should be able to invoke a set of syncrhonous rules upon completion of an async rule.</div></BLOCKQUOTE></FONT></P>
<P><FONT face=Tahoma size=2>Given that "multiple async mutator rules would be problematic", this would seem to be another point in favor of separating the two types of rules.&nbsp; This way, when your SL app asynchronously launches the business-rule validation process, the server-side code can process the mutation rules first - and synchronously - before launching any validation rules.&nbsp; This also feeds into the "don't validate before mutating" concept as well.&nbsp; The way I read it, neither rule chaining or post-processing callbacks solve this issue.&nbsp; But maybe I'm missing something.</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mbblum replied on Tuesday, January 05, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><P>An earlier post also suggested&#160;(basically) merging all rules from multiple (dependent) properties into a consolidated list, sorting them by priority and then running them as a single list - thus merging all short-circuiting from all properties into a single run. I think this would be an unworkable mess - but I'm interested to hear what others think about the idea.</P></div></BLOCKQUOTE><br /><br />This is a "nice to have", but to me a lower priority to be in CSLA than the other items. I have coded brute force walk of the BrokenRulesCollection down the object hierarchy to get a list for display. <br /><br />What I would request is a property that can be used to order the display of broken rules. One implementation is a integer SortOrder property, default = 0, on the BrokenRule, which can be set from a RulesArg property of the same name, i.e. e.SortOrder = 10. <br /><br />The Severity allows grouping into Error, Warning, Information. This can simplify display sorting when required for a use case wanting specific BrokenRules to be at the top of the list. <br /><br />The other comments are looking like good improvements.<br /><br />Thanks.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, January 05, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>mbblum:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>
<P>An earlier post also suggested&nbsp;(basically) merging all rules from multiple (dependent) properties into a consolidated list, sorting them by priority and then running them as a single list - thus merging all short-circuiting from all properties into a single run. I think this would be an unworkable mess - but I'm interested to hear what others think about the idea.</P>
<P></div></BLOCKQUOTE> This is a "nice to have", but to me a lower priority to be in CSLA than the other items. I have coded brute force walk of the BrokenRulesCollection down the object hierarchy to get a list for display. </div></BLOCKQUOTE></P>
<P>I think you misunderstand the question.</P>
<P>The earlier post suggests a change to the way rules are EXECUTED, so rules from dependent properties are merged into a single ordered list, then executed. So a rules for properties A, B and C might run all intermixed, and a short-circuit in property B would stop rules for A and C.</P>
<P>----</P>
<P>There is a backlog item for a consolidated brokenrules collection feature. That's an entirely different thing, and I may add that - but I agree that it is a relatively low priority since you can do this today with little effort.</P>
<P>The sort order idea is interesting though.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mbblum replied on Wednesday, January 06, 2010</h2>Regarding earlier post, you're correct that I misunderstood. But my main request to provide for ordering the resulting broken rules came through.<br /><br />Here is another "wish list" item. Business Rules that run on the common DataPortal activities, and can be specified to run before or after there execution. As I look at this, it can also be viewed as a request to make DataPortal_OnDataPortalInvoke() and DataPortal_OnDataPortalInvokeComplete() available via Business Rules.<br /><br />One problem area might be determining when to run client side, server side or both.<br /><br />(If you need more scenario, let me know.)<br />Thanks, mbb</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, January 06, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>mbblum:</strong></div><div>...<br />Here is another "wish list" item. Business Rules that run on the common DataPortal activities, and can be specified to run before or after there execution. As I look at this, it can also be viewed as a request to make DataPortal_OnDataPortalInvoke() and DataPortal_OnDataPortalInvokeComplete() available via Business Rules....</div></BLOCKQUOTE><br /><br />I was going to bring up something like this yesterday as there have been prior forum discussions on having server-side rules, but I thought there might not be much interest (and it might merit a thread on on its own). <br /><br />I can certainly see a possible use for rules that don't get executed until you actually try to save the object (and then might even need to run server side if they are "expensive").  However, I'm not sure how this fits in with the CSLA model, which seems to assume that an object will generally save successfully as long as IsValid is true and you then replace the original reference with the returned object. If rules break "later", you either have to return the object unsaved (which UI would need to new code to test for) or handle an exception (in which case the deferred broken rules may not be associated with the original object any more but instead on the copy returned in the DataPortal exception).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, January 05, 2010</h2><P>Since you're going to be rework this anyway..</P>
<P>Could there be a way where:</P>
<P>1.&nbsp; Rules run just like they do now</P>
<P>2.&nbsp; Rules ONLY which run in a response to a&nbsp;Property changed (SetProperty).</P>
<P>#2 seems most useful the the "mutation" style rules, which alter values.&nbsp; While you may want to validate data as you read it from your database, these rules I would think wouldn't need to be run.&nbsp; In the past, I've been bitten by this; a Password property which encypted via&nbsp;a rule method would attempt to reencrypt when the instance was loaded from the database.&nbsp; There were other validation rules that I did have to run, so I had to hack together a solution.</P>
<P>I've hit a few other similar scenarios like this as well.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, January 06, 2010</h2><P>Async rules exist on .NET and SL. And they aren't just server-side rules. They are just async rules - could run on client or server.</P>
<P>Today async rules are validation only - there's no model by which the rule can change the object. My plan is to follow the lead of WF (more or less) and allow the rule to build a Dictionary&lt;PropertyInfo, object&gt; and once the rule is done and processing is on the UI thread, CSLA will update the properties with the values in that dictionary. The result is a safe mutator rule that does its work on&nbsp;a background thread or a server or whatever.</P>
<P>What I hear you saying Scott, is that I shouldn't do this. Shouldn't enable async business rules at all.</P>
<P>But I don't think that's an entirely valid solution, because today you can't do long-running calculations on a background thread, and you can't do database lookups (user enters field A, we go find the value for field B) on SL, etc.</P>
<P>I really think there's&nbsp;a need for async business rules.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, January 06, 2010</h2><P><FONT face=Tahoma size=2>I wasn't trying to say we shouldn't have async rules.&nbsp; I know that async rules are necessary (i.e. pretty much the only way to do things) in SL, and they have real benefits in traditional client/server situations.&nbsp; I don't work in SL, but I've found async rulse to be a pretty slick feature in my WPF stuff.</FONT></P>
<P><FONT face=Tahoma size=2>I just think that if we're going to create rules that specifically change property values, then there should be some sort of mechanism to control the execution of those rules, so that the validation rules are ensured of working with "valid" property data - i.e. data that has already gone through any mutation rules.&nbsp; As Joe mentioned in a previous post, why validate data that's going to change after the validation rules run?</FONT></P>
<P><FONT face=Tahoma size=2>Yes, maybe the change is nothing more than an upper-case rule - but maybe it's not.&nbsp; Maybe it's changing "1M" to "1,000,000", and there's a validation rule that checks to make sure the data is numeric (since we've essentially converted a numeric field in the database to a textual field in the UI.)&nbsp; If I can't guarantee that the mutator rule has run, then my validation rule has to be able to deal with non-mutated data, and I've got basically the same code in two places.</FONT></P>
<P><FONT face=Tahoma size=2>I know this kind of thing can, and maybe should,&nbsp;be handled differently (i.e. maybe this is handled in a property-change event instead), so perhaps this is a bad example.&nbsp; But if you're going to allow the concept of mutator rules, then a part of me says that&nbsp;this kind of property-change code should be&nbsp;put there - after all, the ability to enter "1M" is a business rule, isn't it?&nbsp; And if it's in a mutator business rule, then I only have to write the code once, instead of in each object where I need to accept those values.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, January 06, 2010</h2>I think what Rocky said though is that you would change your validation rule to run after your mutation rule, and that scenario will work out fine.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, January 06, 2010</h2><P>I do not know if I am worrying about nothing here but the idea of re-running validation rules after mutator rules bothers me. It becomes very easy to get lost in the stack of rules that is running multiple times because the underlying Property value keeps changing due to the mutator rules.</P>
<P>For example say I have 10 validation rules and 4 mutator rules. The property changes in the UI and I expect 14 rules to run. But if the 4 mutator rules run at the end then the validation rules will end up running 50 times and the first mutator rule will run 5 times, the second 4 times, the third 3 times and the fourth 2 times. (Assuming that a mutator rule causes the set of rules to be re-run right away.)</P>
<P>The simplest idea is to always run the 4 mutator rules first and then run the 10 validation rules once afterward.</P>
<P>Now if Rocky can devise a way to set the value of a Property in a mutator rule without causing the rules to be re-run then perhaps the re-running of rules&nbsp;is not such a big deal. I can envision running the 14 rules and then re-running all of them because a mutator rule has run. A second run of rules maybe isn't too bad - I just don't want to see multiple runs. After all some of these rules hit the database and are expensive!</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, January 06, 2010</h2><P>I don't see anything that suggests the rules would be more than once, unless you somehow set it up to do that.&nbsp; I doubt he's planning to rerun rules when a property is changed in response to a mutator business rule.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, January 06, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>
<P>I don't see anything that suggests the rules would be more than once, unless you somehow set it up to do that.&nbsp; I doubt he's planning to rerun rules when a property is changed in response to a mutator business rule.</P>
<P></div></BLOCKQUOTE></P>
<P>Well, he may not be planning it but that is the way the current system works. Which is why I am concerned about it.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, January 07, 2010</h2>I'm not sure I follow, because it doesn't seem like the current system is like that.&nbsp; In SL, there are no such thing as mutators, and for .Net, it depends on how you setup your rules.&nbsp; If you're using LoadProperty or setting a private backing field, I don't see why the rules would run again.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, January 07, 2010</h2>^^^^<br /><br />In the current system, if a business rule changes the value via the setter, then I believe the same rule gets run again. <br /><br />As you noted, you could use a private backing field or LoadProperty to avoid this, but now you've made a property change that escapes validation by other rules that might actually be interested in the change. <br /><br />If the mutator rules for a property change ran first, then the changes made would be validated either way. I suppose you can simulate this just be giving the mutator rules priority so they run first (but then I'm not sure how dependencies come into play)</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, January 07, 2010</h2><P>Right, I should add that I use priorities to ensure that mutator rules always run before validation type rules as well.</P>
<P>Of course, I haven't dived into async rules, so perhaps that's where we're encountering different expereiences, but again my understanding is that right now&nbsp;there is no way to do a mutator rule asyncly.&nbsp; I can see this being a problem with async mutator rules, but it sounds like Rocky believes rule chaining will take care of this problem.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 07, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>
<P>I can see this being a problem with async mutator rules, but it sounds like Rocky believes rule chaining will take care of this problem.</P>
<P></div></BLOCKQUOTE></P>
<P>Well, Rocky believes that someone who knows what they are doing will be able to use rule chaining to implement their scenario.</P>
<P>I don't think there's any magic here - async and/or multi-threaded software is always more complex.</P>
<P>But just because async business rules will allow people to screw up doesn't mean I shouldn't enable the scenario. When used carefully and knowledgably, the results should be pretty cool :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, January 07, 2010</h2><P>Sorry, I don't mean to be putting words in your mouth.&nbsp; We're all just trying to work out what the changes mean I think.&nbsp; </P>
<P>I agree that the async rules should be an option... it seems pretty likely someone will want to do just this, and if its not there will be stuck.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 07, 2010</h2><P>Today it depends on whether you are writing a private or public rule.</P>
<P>Private rules can easily use BypassPropertyChecks, LoadProperty or a private backing field.</P>
<P>Public rules don't have that luxury unless you build them as instance rules in an ObjectFactory subclass.</P>
<P>I don't plan to change any of that directly.</P>
<P>But as I've said, rules will be able to create a dictionary of output values. That dictionary will be used by CSLA to update the properties specified in the dictionary. Presumably this will be done by calling LoadProperty, but will happen before the post-processing callback. </P>
<P>In other words, the post-processing callback will run <EM>after the property values are updated</EM>, allowing you to trigger or explicitly execute validation rules on the mutated value(s).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, January 07, 2010</h2><P>So what will that triggering look like?&nbsp; Right now its ValidatoinRules.CheckRules.. which will run everything again, or passing a property name will run just for that property, but may run everything for that property again.</P>
<P>Is there going to be something like a RegisterRule method, and each rule will have a token of some kind (like the PropertyInfo for properties) so that we can selectively run rules, or is this where the "rule domain" concept fits in?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Thursday, January 07, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>
<P>Today it depends on whether you are writing a private or public rule.</P>
<P>Private rules can easily use BypassPropertyChecks, LoadProperty or a private backing field.</P>
<P>Public rules don't have that luxury unless you build them as instance rules in an ObjectFactory subclass.</P>
<P></div></BLOCKQUOTE></P>
<P>This is the point I was making about the re-running of rules. I stated it explicitly in the original thread which the bug ID refers to. When I centralize a rule I have to reflect against the BO and set a Public Property which causes the rules to re-run. A private rule inside a BO can use any of the other techniques to set the backing field and avoid the Property Set.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, January 07, 2010</h2>Joe, that's what I was missing here, so I get now&nbsp;where you're coming from.&nbsp; I've dodged the issue by using interfaces with explicit implementations&nbsp;(which using Read / Load property, or go against the backing fields)&nbsp;and keeping things internal, and if I need to share rules I include the rule&nbsp;code and interface as a linked file.&nbsp; Probably not the best way, but it explains why I didn't see the problem. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 07, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JoeFallon1:</strong></div><div>
<P>This is the point I was making about the re-running of rules. I stated it explicitly in the original thread which the bug ID refers to. When I centralize a rule I have to reflect against the BO and set a Public Property which causes the rules to re-run. A private rule inside a BO can use any of the other techniques to set the backing field and avoid the Property Set.</P>
<P></div></BLOCKQUOTE></P>
<P>And I don't plan to change this behavior at all, other than maybe creating a base class like ObjectFactory for building rule classes. If I do that then there'd be a clear way to build public rule methods so they can use BypassPropertyChecks and/or LoadProperty() as necessary.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Peran replied on Monday, January 11, 2010</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div><p>other than maybe creating a base class like ObjectFactory for building rule classes.</p></div></BLOCKQUOTE><br><br>This 'CommonRulesBase' class sounds like a good idea from a readability point of view.&nbsp; In my mind 'ObjectFactory' relates to data access a should probably not be included in code targeting the dotNet 4 ClientProfile.<br><br>----------------<br><br>I have just watched the Core 38 video on business rules and in particular the 'batch mode' processing part using ValidationRules.SuppressRuleChecking to ensure rules are only run once after all properties have been set.<br><br>I can see a possible need where in 'batch mode' I would want my mutator ToUpper rules to run, but not my validation rules.&nbsp; Would the current ideas support this?<br><br><br>Peran<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Des Nolan replied on Wednesday, January 06, 2010</h2><P>Rocky,</P>
<P>making changes mechanical is good</P>
<P>if there automateable with Search and Replace using a helper tool or Regular Expressions that would be even better, as my CSLA application has 250K lines of code</P>
<P>(just signed up to listen to you talk in Boston, and am looking forward to hearing about what's in my future in regards to CSLA -- thanks for&nbsp;the great development framework...this is my second opportunity to see you live, but unlike Vermont, this time around, I won't be riding the Big Yellow Bike from Norwalk there...it's too cold)</P>
<P>Des Nolan</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, January 11, 2010</h2><P>I think there's a logic flaw with the idea that "mutator rules should run first".</P>
<P>GIGO: garbage in, garbage out</P>
<P>Simple mutator rules like a <EM>ToUpper</EM> might need to run before validation. But complex mutator rules like <EM>look up the customer details</EM> would only run after you've validated the CustomerId value (or whatever).</P>
<P>In other words, the thought that you can <EM>always</EM> run mutator rules without running validator rules is flawed. I could see a rule set like this:</P>
<OL>
<LI>Required (validator)</LI>
<LI>ToUpper (mutator)</LI>
<LI>ValidFormat (validator)</LI>
<LI>GetCustomerDetails (mutator)</LI></OL>
<P>You'd want short-circuiting before doing 4. You'd also want to make sure 2 runs before 3.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, January 11, 2010</h2>What is your thinking on the "run all rules" vs. "run only validation rules (such as just before a dataportal_fetch completes) suggestion?&nbsp; Would it be possible to do that one with your currently planned implemeation?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, January 11, 2010</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>What is your thinking on the "run all rules" vs. "run only validation rules (such as just before a dataportal_fetch completes) suggestion?&nbsp; Would it be possible to do that one with your currently planned implemeation?</div></BLOCKQUOTE></P>
<P>You'll note this wasn't in my original scope. I'm entertaining the idea because it has been brought up, but I'm struggling with how it would work in practice.</P>
<P>If you step back and think about this, what CSLA provides is a primitive linear workflow for the rules attached to any given property. Once side-effect of the CSLA 4 changes is that you really could use a WF 4 workflow per property for your rules (or so I hope).</P>
<P>Separating business from validation rules implies two workflows that run one after another. But as I just pointed out, that ignores the very real scenario where business and validation rules are intermixed, and interdependent.</P>
<P>So do you really think it is realistic to just run validation rules, when some mutators are required for validation to work? Or to just run business rules, when you don't know if the data is valid?</P>
<P>If you don't trust the data in your database (hence you want to run validation rules in DP_Fetch), why do you trust its format? Don't you want to run at least your basic mutators on it too?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, January 11, 2010</h2><P>My thinking was that, using an attribute or something similar, the rule list would still be a single list, and as csla is running through it, it would know (because you asked it to) to simply not run the ones not indicated as validation.</P>
<P>Its a good point that some mutators are required for validators to work, or maybe the other way around, but I think its still important to enable this scenario as well, and I already have a few places where, in the DP_F I have to set a flag, call CheckRules, then disable the flag.&nbsp; There's another case where it got even more complicated than that, where I had to run all the rules again in certain cases, but there was a mutator rule I couldn't run, so I&nbsp;don't think its always the case that you trust your data, but not its format.</P>
<P>Here's the scenarios I have:</P>
<P>1.&nbsp; There's a concept of a product bundle; its just a grouping of products into a unit and assigned a part number.&nbsp; Users can choose to have the bundle calculate its pricing, or set fixed pricing. Going back and forth should calculate or restore the fixed pricing (if it was fixed to begin with).&nbsp; The way it works is that its not good enough to simply store the original value on fetch, this was causing unexpected behavior.&nbsp; So I have logic that runs when the pricing type changes, which asks each price to calculate or "uncalculate" which deteremines the apprpriate value to use depending on how the object's state when first loaded.&nbsp; On each load, I can't have that business rule running, and it should only run in response to a property changed for the price type.</P>
<P>2.&nbsp; Consider the use case of an "edit account" type scenario.&nbsp; You may have rules on some properties, some which may only be warnings, which you want to run and should run right out of the database.&nbsp; But being a good programmer, you create a salt value and hash the password when the user types a new password into the text box.&nbsp; This ensures the clear-text password never travels over the network.&nbsp; But again in the fetch, attempting to run all rules will rehash the already hashed password fetched from the database, unless some hackery is put into place.&nbsp; </P>
<P>Maybe these scenarios aren't worth the effort, but I know I'd find it very&nbsp;useful. I think there is precedent for this too, as Wpf allows seperate validation vs. property changed methods when you create a DependencyProperty.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, January 11, 2010</h2><P>I think a more general solution may be in order.</P>
<P>One of the changes that is part of my core requirements is to alter the method signature for rule methods. It will basically be something along this line:</P>
<P>void RuleMethod(RuleArgs e)</P>
<P>But RuleArgs will now be substantially more sophisticated than it is today, providing a relatively broad set of input and output capabilities.</P>
<P>One thing it could contain is some userstate object that you provide to CheckRules(). This would allow you to use the userstate to do anything you wanted really, in terms of deciding whether a rule should run or not. It would enable your scenario, my scenario and other scenarios - much more flexible than if CSLA hard-codes some specfic scheme and thus precludes the others.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, January 11, 2010</h2>That would work perfectly for me, since my initial suggestion was tacking on a value to CheckRules or AddRule anyway!</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
