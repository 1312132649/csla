<html><header><title>Deep &amp; wide parent-child-grandchild implementation ?'s</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Deep &amp; wide parent-child-grandchild implementation ?'s</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2009.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, December 19, 2006</h2><P>Okay, I'm looking for some quick advice from all the guru's out there.&nbsp; I find myself in the typical position of trying to rationalize behaviorally versus my instinctive desire to think data-centrically and am doing nothing but pulling my hair out re-reading the book and pouring through forum posts.</P>
<P>I have an application that is both wide and deep in its hierarchy.&nbsp; This may be because I have been working on this app for 15+ hours a day for the last two weeks getting it spec'd, designed and documented&nbsp;and am at the point where I'd like to be getting more coding done than wrestling with design issues still.&nbsp; But I am trying to sort this out and make sure that my implementation is consistent with a behavioral-based approach and it seems like things just keep getting more and more complicated the more I try to simplify!</P>
<P>Anyway, the application is web-based, multi-user and divisional in nature.&nbsp; What I mean by the last one is that the application must support multiple divisions within the company with no sharing of data except for those higher up.&nbsp; That isn't where the problem stands - at least not at this point - as the data model has been designed with a pseudo-domain/organizational unit structure.&nbsp; In other words, everything is tied to an OU including the users so that they can access only the data within their OU.&nbsp; Some users have "domain" access which allows them to run aggregate queries, etc. for reporting and so on.&nbsp; This is all accomplished by passing the current user's ID value along&nbsp;to every query to the database so the result set is filtered accordingly.</P>
<P>My problem starts at the level just below the&nbsp;OU - with a Customer.&nbsp; Going down the hierarchy, a Customer can have multiple Projects created for him/her.&nbsp; Each Project can have multiple Quotes generated and each Quote can have multiple Orders placed against it with multiple Packing Slips for each of those then we have Invoices, Payments and so on down the line.</P>
<P>That's the depth.</P>
<P>Each object has a standard set of child collections that go along with it.&nbsp; For instance, the Customer has Contacts, Attachments, Notes and History (Events)&nbsp;and Resources - in addition to its Projects.&nbsp; So, my dilemma is trying to figure out the right implementation to accomodate this.</P>
<P>In reading the book and reviewing the sample app, etc. I see that the queries for all root objects return a result set for their&nbsp;child objects as well.&nbsp; This concerns me because I would have to handle seven (7) result sets in my DataPortal_Fetch method for the Customer class.&nbsp; Although, my initial concern about how to carry this to the next level was tempered when I looked at things from the UI perspective (something I was trained NOT to do!).</P>
<P>The UI will consist of a multi-tab page with the Customer's direct properties on one page and lists/grids displaying the child collections on the other seven (7) tabs (one per).&nbsp; So, that tells me that all I really need for my Customer object is to have read-only lists for the child collections.&nbsp; To drill into a Project, the Project's ID value can be pulled from the list/grid when the user double-clicks the row and passed to the new page that is opened displaying the Project's properties and child objects/collections in the same manner.</P>
<P>So, my old-school, data-centric way of wanting to be able to say ThisCustomer.Projects[0].Quotes[0].Orders[0].Status is just that, obsolete - right?&nbsp; Am I correct that this is not how it is supposed to work?&nbsp; (Can someone give me an example of how I would perform this type of drill-down with Csla?)</P>
<P>Limiting the discussion to just the Customer at this point, here is what I think I need:</P>
<UL>
<LI>Customer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read/write root object) 
<LI>CustomerContactList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only list) 
<LI>CustomerContact&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only child object) 
<LI>CustomerAttachmentList (read-only list) 
<LI>CustomerAttachment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only child object) 
<LI>CustomerNoteList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only list) 
<LI>CustomerNote&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(read-only child object) 
<LI>CustomerEventList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(read-only list) 
<LI>CustomerEvent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(read-only child object) 
<LI>CustomerResourceList&nbsp;&nbsp;&nbsp;&nbsp; (read-only list) 
<LI>CustomerResource&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(read-only child object) 
<LI>CustomerProjectList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only list) 
<LI>CustomerProject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (read-only child object)</LI></UL>
<P>I will have similar classes for the Project, etc.&nbsp; Would it make sense to have interfaces common between classes like CustomerResource and ProjectResource (IResource)?&nbsp; Or a common base class?&nbsp; This gets confusing because we will want a way to list all of the Customers, Projects, etc. that a Resource has been assigned to - but, thankfully, this parallels what Rocky did in the book.</P>
<P>To add a new Contact to a Customer, for instance, I would need to display a separate form that is bound to a Contact object via a CslaDataSource.&nbsp;&nbsp;After&nbsp;the InsertObject handler saves the new Contact, we would use the ID value to add the Contact to the Customer and refresh that page.</P>
<P>I guess this is where I am the most fuzzy because the book &amp; example only demonstrate how to "assign" an existing child object to the parent.&nbsp; In my case this will work fine for the CustomerResources but the other child collections allow for new items to be created that are in a many-to-many relationship with the customer (only Notes and Events have true parent-child relationships with Customer).&nbsp; My guess is that I will need to implement this as a two-step process where the new record is saved to the database then the relationship established, as I described above.</P>
<P>Okay, that's probably enough info to get ya going, eh?&nbsp; I'm anxious for your feedback to evaluate where I am in this process and if I'm anywhere near ready to start coding!</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 22, 2006</h2>No one has anything to contribute/answers to my queries?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 22, 2006</h2>I think all those read only lists should be root objects in their own rights.&nbsp; They are read only, so don't need to exist within the Customer object because there's no need to track changes for them at all.&nbsp; You could have navigational methods off the Customer class to get the appropriate readonly list.<br><br>An IResource would only make sense if there are some common behaviors between a CustomerResource and ProjectResource, and it doesn't matter which one you have when invoking those behaviors.<br><br>The CustomerContact editable object should be a root in its own.&nbsp; You can have a New factory method that requires a Customer object though, to force the client code to tie the contact to a customer.<br><br>Does this help at all with some key points?&nbsp; You posted quite a bit of info, and I'm not sure I digested it all correctly..<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 22, 2006</h2><P>Yea, I'm with you on all of it except the lists being root objects as well.&nbsp; I don't see how that makes sense without them existing within the context of a Customer.&nbsp; Or are you saying that the static Get...() method should require the id of the Customer?</P>
<P>I was looking at some of the ADO.NET classes - just for reference and example of approach.&nbsp; From that I took the following:</P>
<P>1. I've added a CreateProject() method to my Customer class.&nbsp; This will ensure that the returned object has the associated Customer pre-set.&nbsp; I'd considered automatically adding the object to the Customer's Projects collection but that is not consistent with what I've seen and would lead to more hassle dealing with "cancelled" objects.&nbsp; But, I did add validation code to ensure that any Project added to a Customer's Projects collection has either no Customer defined or is matching the Customer it is being added to.</P>
<P>2. I allow a Project to be created on its own, via NewProject().&nbsp; But, I don't allow it to be saved without a valid Customer set.&nbsp; Then, on saving the object, I verify that it exists in the Customer's Projects collection, adding it if not.</P>
<P>Does that make sense?</P>
<P>Back to the "dependant" lists, I used the ProjectTracker app as a basis for my thinking.&nbsp; In that app, the ProjectResources collection is not publicly creatable.&nbsp; So, I guess this is where my confusion lies with regard to making them root objects.&nbsp; Can you elaborate?</P>
<P>Thx.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 22, 2006</h2>Pirate,<br><br>Yes, the Get method for the lists would only accept a customer object (or customer id, depending on how you want to implement it).<br><br>Your methods sounds just fine too, I do this thing quite a bit.<br><br>You can have editable collections as root objects as well; you just define new or get as always requiring a customer id so that the customer tie in is always there.<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 22, 2006</h2><P>Alright, let me give it some more thought and see what I can come up with.&nbsp; This is the one area that I have found a bit difficult to wrap my head around.&nbsp; Mostly because I am so used to thinking hierarchically (e.g. Customer.Projects[0].Quotes[0].Orders[0].Status) - which is very data-centric (and coupled!!!).&nbsp; So breaking that train of thought, especially when it comes to this type of dependancy, has taken a bit more effort to grasp.&nbsp; In my previous implementations, I've skirted the issue by following the more "dot-oriented" structure.&nbsp; But, I am trying very hard this time to fully adapt/adopt the behavioral approach as well as a better OO design.</P>
<P>The problem my brain is having is the question "where does the customer id come from if not being passed from parent to child?"&nbsp; Again, this is very data-centric, I know.</P>
<P>I'm also suffering from the SOA mentallity that you design with the UI out of mind and am somewhat glad that this has gone in the direction that it has because that was always a sore point with me.&nbsp; After all, how can you design behavior if you aren't looking at how it is to be used?</P>
<P>Do you find that the approach you've described facilitates or hinders representing your objects in a tree-view structure?&nbsp; Obviously the dot-oriented approach makes it easy to crawl an object model and populate a tree.&nbsp; But, I'm thinking that the approach you are describing might actually be better because it supports lazy-loading and even AJAX-supported implementations rather than traversing the entire object model and pre-populating the tree - or re-instantiating the object so you can climb into the next branch.</P>
<P>It seems that this approach will allow a simple callback using the id value of the parent to get an instance of the child collection (as if it were a root object) to populate the branch.</P>
<P>This is something on the application's to-do list and thinking this way is helping me wrap my head around the concepts.&nbsp; Am I on the right page?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 22, 2006</h2><P>One more thing...&nbsp; In the ProjectTracker example, Rocky binds the ProjectResources list using the Project.Resources property.&nbsp; Are you suggesting that using ProjectResources.GetProjectResources(ProjectID) is a better way to accomplish this?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, December 22, 2006</h2><P>Hi,</P>
<P>Some comments.</P>
<P>1. The Customer BO should NOT carry around all of those collections all of the time. Sometimes a Root BO will always have a contained child collection - think Invoice and InvoiceLines. But this one may not always need these child objects.</P>
<P>2. For each screen (or UseCase) you will need the Customer root BO and 1 or more of the ROCs. This means that each ROC must be able to get the correct data for the current customer. So you need code like this:</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Shared</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> GetCustomerContactList(customerID</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Integer</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> CustomerContactList</P>
<P></P></FONT>
<P>3. For each screen/UseCase create a higher level BO which contains Customer and the ROCs needed *just for that screen*. I called this higher level BO a Unit Of Work (UOW). Others called it Use Case Controller. The second name may be better but I already have many UOWs so...</P>
<P>This BO is fairly simple. It is also a Root BO and has its own BrokenRules. The key point is that when you navigate to the screen and get an instance of this BO you pass it the CustomerID to fetch the CustomerBo and the ROCs. All data on the screen passes through the UOW to the underlying BOs. You can Save the UOW (which saves Customer and any other data.) You can also check if it IsValid and list broken rules across multiple BOs.</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Saturday, December 23, 2006</h2>&nbsp;
<P>There is a lot of stuff in that post.</P>
<P>&nbsp;</P>
<P>I believe, first of all, that hierarchies should not be avoided.<SPAN>&nbsp; </SPAN>Even with "good OO", natural hierarchies exist. Some problem domains have very deep ones that simply cannot be avoided. If you have one of those, well, you do.<SPAN>&nbsp; </SPAN>As long as you are not imposing a hierarchy upon it because of the nature of the persistence mechanism, no harm done.</P>
<P>&nbsp;</P>
<P>That being said.<SPAN>&nbsp; </SPAN>Looking at your customer object I don't see that much trouble if you set up each of the contained classes as roots.<SPAN>&nbsp; </SPAN>When I say roots I mean objects that are responsible for building themselves or getting their own data given a set of criteria. By doing this you can avoid the long dot chain you mention.<SPAN>&nbsp; </SPAN>For example the OrdersCollection could take a CustomerID (or even a customer) to present the orders for that customer.<SPAN>&nbsp; </SPAN>The OrdersCollection could have another factory method that would take a customer and a Quote and return the order for that criteria pair.<SPAN>&nbsp; </SPAN>Each order could have the Quote(s) that it is associated with as well.<SPAN>&nbsp; </SPAN>Whether you expose Orders through the dot chain or not is up to you.</P>
<P>&nbsp;</P>
<P>So for example you could Have Customer.OrderStatus(q as Quote) as OrderStatus.<SPAN>&nbsp; </SPAN>Of course this type of thing could also be done with the Read only lists and what not.<SPAN>&nbsp; </SPAN>The benefit of using roots, especially in a web app, is that you can limit the data retrieved for a method call.</P>
<P>&nbsp;</P>
<P>As for the necessary ID creation the best solution to this is have the objects themselves produce the ID.<SPAN>&nbsp; </SPAN>That way you don't have to go back to the DB to get it.<SPAN>&nbsp; </SPAN>GUIDs are the easiest (especially in web apps) way but there are other options.<SPAN>&nbsp; </SPAN>The GUID doesn't have to be the primary key as long as the field in the DB is unique.<SPAN>&nbsp; </SPAN>It just makes things soooo much easier when the objects control the data.</P>
<P><SPAN>&nbsp; </SPAN></P>
<P>Another option is to use the DataPortal_Create that will generate the ID of the new object while also saving the ID of the parent at the same time.<SPAN>&nbsp; </SPAN>Does require some over riding of the base classes but does work.</P>
<P>&nbsp;</P>
<P>As far as wether you should have interfaces or base classes.<SPAN>&nbsp; </SPAN>I think many times that is not even necessary.<SPAN>&nbsp; </SPAN>You mentioned CustomerResource and ProjectResource.<SPAN>&nbsp; </SPAN>Is it possible that there isn't a real distinction between the two, that they are simply a Resource?<SPAN>&nbsp; </SPAN>I have found that often that is the case with my classes.<SPAN>&nbsp; </SPAN>For example I had a StudentAttendance and a InstructorAttendance. Really the behavior was no different between the two.<SPAN>&nbsp; </SPAN>Both simply recorded weather the individual was at the appointed place and time. Another object ended up deciding the significance of that fact. I guess I cheated a bit when I let the some other object determine if the AttendanceType of the Attendance was valid.<SPAN>&nbsp; </SPAN>But maybe not.<SPAN>&nbsp; </SPAN>Who cares, I simplified my object model and completed the goal.<SPAN>&nbsp; </SPAN>But I will say that I think that having an interface is often useful but only if it is in another dll.<SPAN>&nbsp; </SPAN>The only drawback is if you have to change the interface.<SPAN>&nbsp; </SPAN>It can result in a whole bunch of work if that interface is used in a bunch of places.<SPAN>&nbsp; </SPAN></P>
<P>&nbsp;</P>
<P>I like what Joe describes but for me it is way to much work. I am very lazy.<SPAN>&nbsp; </SPAN>I do have what I call entryPoints.<SPAN>&nbsp; </SPAN>They retrieve date (or fail) based upon the role of the logged in user and what part of the application they are logged into.<SPAN>&nbsp; </SPAN>Examples are InstructorEntryPoint, GaurdianEntryPoint, StudentEntryPoint etc.<SPAN>&nbsp; </SPAN>So a studentEntryPoint will only retrieve the data relevant to that student and nothing more. This is easy because everything is a root so I don't have to create special classes to support it.<SPAN>&nbsp; </SPAN>Outside of that it behaves much as Joe describes. It is a root BO and it tracks all it's contained object and has it's own broken rules and so on.</P>
<P>&nbsp;</P>
<P>Maybe this helps?<SPAN>&nbsp; </SPAN></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Saturday, December 23, 2006</h2><P>Joe: So I'm guessing you are in favor of a more lazy-load approach to the child collections?&nbsp; I'm thinking we'd have properties like:</P>
<P><CODE>public class Customer<BR>{<BR>&nbsp; &nbsp; :<BR>&nbsp; &nbsp; :<BR>&nbsp; &nbsp; public CustomerNoteList Notes<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (_notes == null)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _notes = CustomerNoteList.GetCustomerNoteList(this.UniqueID);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return _notes;<BR>&nbsp; &nbsp; }<BR>&nbsp;&nbsp;&nbsp; :<BR>&nbsp; &nbsp; :<BR>}</CODE></P>
<P>where GetCustomerNoteList triggers the DataPortal_Fetch method to retrieve the collection's contents from the database???</P>
<P>I guess I can wrap my head around that idea.&nbsp; Seems like the best of both worlds.&nbsp; Wasn't there a reason Rocky shyed away from lazy-loading?&nbsp; I'm assuming it is because of the number of round-trips to the DB.</P>
<P>In my case, it may make more sense to NOT lazy load, though, when looking at how the UI works.&nbsp; I am using a tab control with the first containing a FormView bound to the Customer's (root object's) properties.&nbsp; The other tabs correspond to each of the child collections.&nbsp; So, for instance, there is a Notes tab that has a GridView bound to the Customer's Notes property - just as Rocky does it in the ProjectEdit.aspx page.&nbsp; Because of this, I know that these child collections will always be used so it makes more sense to go with Rocky's approach and have a single query return the multiple result sets and have my Customer object populate all of the child collections.&nbsp; BUT, I do see the merits in the approach you described and will keep it mind elsewhere in the app.</P>
<P>pelinville: lots of good stuff.&nbsp; Part of what I like about the approach Joe described is that it would support a full hierarchical view of the object model.&nbsp; Because Customer would have a Projects property that uses ProjectList.GetProjectList(customerID) to instantiate the collection and a Project would have a Quotes property that uses QuoteList.GetQuoteList(projectID), I could walk&nbsp;the heirarchy like:&nbsp;Customer.Projects[0].Quotes[0].Status.&nbsp; Again, best of both worlds.&nbsp; Except, as we all know, nothing works all the time and I think the way my UI is setup drives the need to reduce the number of round-trips by eliminating the lazy load.&nbsp; However, I can still limit this to only one level deep, I guess.</P>
<P>I am thinking I would end up with two objects: ProjectList and CustomerProjectList.&nbsp; The former being a root object responsible for its own data routines and the latter being a child object loaded from the parent Customer record.&nbsp; Same for QuoteList and ProjectQuoteList and so on.&nbsp; Then I can start at any level or walk the hierarchy.&nbsp; Every other level in the heirarchy would be a root object so my CustomerProject object would call QuoteList.GetQuoteList(projectID) if that branch was traversed.</P>
<P>Make sense?&nbsp; Or, are you suggesting a single object, such as ProjectList that can exist as either a root object or child object (i.e. switchable) based on the criteria passed through overloaded factory methods??</P>
<P>As for the interface/base class question, I have several use cases in mind.&nbsp; First, the CustomerResource/ProjectResource example is exactly like what Rocky has in the book where I do have a root object, Resource, that represents just that.&nbsp; CustomerResource and ProjectResource represent the assignment of that resource to the Customer or Project.&nbsp; So, my intent is to follow the same model presented by Rocky with a central Assignment class that handles the common behaviors.&nbsp; But, I am also looking to have an IResource interface shared by the object that establishes the contract that is espected in the implementing classes.&nbsp; Why?&nbsp; Because I can then have a single Web Server Control to render the list/object by programming it against the IResource/IResourceList interfaces.&nbsp; Then, it will work whether I am displaying CustomerResources or ProjectResources.</P>
<P>Second is the case where I don't have a "free-standing" object but a truly dependant child object, such as CustomerNote.&nbsp; Every "external" object (by that I mean Customer, Project, Quote, etc) has notes attached.&nbsp; A "note" is defined the same no matter the object: a time/date stamp, the user that created it and the content of the note.&nbsp; While a note cannot exist without a parent, I can have a Note object that represents the note itself and have CustomerNote, ProjectNote, etc. represent the relationship.&nbsp; Again, by having a common base class for these objects, I can code my UI control against the base class and gain reuse of the control in my UI.&nbsp; And, in this case, I am leaning towards an abstract base class as being more appropriate than an interface to gain code reuse of the common properties that are shared by all xxxNote objects.</P>
<P>The other use would be in what I described before where I have a Project class and a CustomerProject class with the former being a root object and the latter a child object.&nbsp; If they share interface IProject, then other code can make use of the objects without distinction - and using interfaces helps to ensure that both classes are compliant with the "contract".&nbsp; My UI controls and other classes can code against the IProject interface and not be concerned with object is being used.</P>
<P>Make sense?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Monday, December 25, 2006</h2><P>Pirate,</P>
<P>The lazy loading approach is fine&nbsp; For the given use case since you need all the ROCs as part of the Customer because you plan on using them all on the same screen. You can even fetch them all directly (once you have the correct CustID value).</P>
<P>The one thing I would do differently is make a separate UOW BO and place the Customer in it and then place each ROC in it. So you are working with the UOW for this use case and have access to each ROC as:&nbsp; MyUOW.MyROC.</P>
<P>Using this pattern the Customer BO is not "polluted" with all the ROCs. So you can fetch it on other screens and not worry about bringing back all those ROCs which are not needed on other screens.</P>
<P>Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
