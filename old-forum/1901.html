<html><header><title>Multiple &quot;views&quot; of the same data</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Multiple &quot;views&quot; of the same data</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1901.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, December 05, 2006</h2><P>I have a situation where I have a set of business objects, we'll go with Projects for consistency.&nbsp; In code, we have created a Project BO and a read-only ProjectInfo BO - just as in the book.&nbsp; Then we have a ProjectCollection (read/write using Project - allows use to add, modify &amp; remove via DataGrids, etc.) and a ProjectList (read-only using ProjectInfo for listing).&nbsp; We've already begun receiving requests to add additional "views" of this data.&nbsp; For instance...</P>
<P>We need to be able to generate a list/collection of Open Projects, Closed Projects, Deleted Projects and Archived Projects - just for starters.&nbsp; Implementing these are relatively simple as they are just filters based on the current state and/or age of the project.</P>
<P>In addition, we are looking to allow users the ability to define their own "custom" filters to apply to the list/collection displayed.&nbsp; These filters could then be saved as part of their personalization of the interface.</P>
<P>My question is what approach to use that will satisfy our need for multiple "views" and&nbsp;allowing the user to create their own views that are dynamically recreated at run-time.</P>
<P>Our first thought was to create a separate OpenProjectList class, etc. but that hardly seems practical as the number of "views" can increase dramatically.&nbsp; AND, we wouldn't be able to support dynamic filtering this way.</P>
<P>So, it occurred to me that perhaps we are dealing with coding the basic read-only "view"&nbsp;- ProjectList - as these filters would only apply to read-only lists anyway and treating all of these variations as "Views" much like the System.Data.DataTable does.&nbsp; Then, we would define a mechanism for defining the filtering applied by the user (there have been several other posts along these lines with were VERY helpful in developing this part).&nbsp; So, in the end, we would instantiate our ProjectList class, create a new View by applying our filtering logic and bind our UI&nbsp;to&nbsp;the view&nbsp;rather than the ProjectList class.</P>
<P>Is this wise though?&nbsp;&nbsp;It would mean that our ProjectList class would do no filtering of its own and would have to be populated with every record in the table whether deleted, closed, open or otherwise so that the filtering could be applied in memory, dynamically.&nbsp; As the application moves forward, this could mean hundreds of thousands of records when all the user may want&nbsp;is a view of&nbsp;projects in an Open state that have been assigned to him/her - and may only be 10-20 items out of several hundred thousand.</P>
<P>Thoughts/suggestions?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 05, 2006</h2>I would have the ProjectList accept different criteria.&nbsp; You may even want to expose some kind of criteria bo that ProjectList would understand.<br><br>This has popped up on the forum before.&nbsp; For starters, check out <a HREF="/forums/thread/1078.aspx">this thread</a>.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, December 05, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>
<P>I have a situation where I have a set of business objects, we'll go with Projects for consistency.&nbsp; In code, we have created a Project BO and a read-only ProjectInfo BO - just as in the book.&nbsp; Then we have a ProjectCollection (read/write using Project - allows use to add, modify &amp; remove via DataGrids, etc.) and a ProjectList (read-only using ProjectInfo for listing).&nbsp; We've already begun receiving requests to add additional "views" of this data.&nbsp; For instance...</P>
<P></div></BLOCKQUOTE></P>
<P>Don't want to hijack this thread, but I use Project and ProjectList, ProjectInfo and ProjectInfoList as naming conventions.&nbsp; That way, it's dirt obvious which object goes in which collection and whether it's readonly or not.&nbsp; hth.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, December 05, 2006</h2><P>Andy, yea, I took part in that thread.&nbsp; Wasn't connecting the two since my mind was on the whole "view" concept.&nbsp; But, I think you pointed me in the right direction that the so-called "filter" is nothing but a set of criteria passed to the same BO (collection).&nbsp; This will also allow us to implement static methods for the canned "views" - which was one of the things on my wish-list.&nbsp; So, for instance, we would have:</P>
<P><CODE>ProjectInfoList.GetProjects(); // returns only non-deleted items.<BR>ProjectInfoList.GetAllProjects(); // returns all projects, regardless of their deleted flag.<BR>ProjectInfoList.GetOpenProjects(); // returns all projects in an 'open' state.<BR>ProjectInfoList.GetClosedProject(); // returns all projects in a 'closed' state.<BR>etc.</CODE></P>
<P>And these can simply make use of a pre-defined criteria object and use the same data access methods to retrieve the data from the database.&nbsp; And we only pull the data we actually want out of the database - which I like.</P>
<P>I'll have to go back and revisit that thread - and the one referenced from it - and retrace our steps to see how we implemented this before so we can make use of it here.&nbsp; I believe we made use of a special SearchCommand object and custom CommandBuilder that used the criteria object and created the SQL for the SearchCommand to execute in a manner similar to what you described in the other topic.</P>
<P>I guess there would be one downside&nbsp;to this approach.&nbsp;Even the "canned views" would be treated as dynamic queries when they really don't have to be.&nbsp; What I mean is, let's say we have a stored procedure, GetProjects, that is used by default to retrieve the records.&nbsp; This is great and we get all the benefits of using a sproc for data access.&nbsp; But, in order to implement the dynamic search functionality, we have to go with dynamic-SQL instead of a sproc for our query.&nbsp; To create the Open Projects "view" created using the GetOpenProjects() factory method, we would use the same dynamic facility that is used for user-defined searches rather than simply calling a GetOpenProjects stored procedure.&nbsp; See my point?</P>
<P>Would be nice if there was some happy middle-ground that would allow us to do both.&nbsp; Any ideas?</P>
<P>&nbsp;</P>
<P>(BTW - I use the same conventions you described, David.&nbsp; I&nbsp;just got sloppy in typing my original post.&nbsp; I agree that it becomes too confusing otherwise.)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Tuesday, December 05, 2006</h2><P>I create new sproc for each of the "views" so </P>
<P><FONT face="Courier New">ProjectInfoList.GetProjects(); </FONT></P>
<P>would use the GetProjects sproc and</P>
<P><FONT face="Courier New">ProjectInfoList.GetAllProjects();&nbsp; </FONT></P>
<P>would use the GetAllProjects</P>
<P>While you would have separate queries, you wouldn't have to mess with dynamic sql.</P>
<P>Or am I missing your point <img src="/emoticons/emotion-10.gif" alt="Embarrassed [:$]" /></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Tuesday, December 05, 2006</h2><P>Trouble here is integrating this into the data portal mechanism.&nbsp; At some point there needs to be a way to distinguish which sproc to call based on which method is used to instantiate the collection.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Norty replied on Tuesday, December 05, 2006</h2><P>Your table has a set number of fields.&nbsp; The filter can be any combination of these fields.</P>
<P>I create a search Proc that has 1 parameter for each possible search field (allowing nulls).&nbsp; Your DP_Fetch only passes in the parameters that it cares about.&nbsp; The query sorts out the nulls from the values passed in.&nbsp; If no parameters are passed in, then ALL data is returned, else data is filtered by all passed in parameters.</P>
<P>Hope this helps</P>
<P>Des</P>
<P>&nbsp;</P>
<P>create procedure dbo.sprProjectSearch<BR>(<BR>&nbsp;&nbsp; @ProjectID uniqueidentifier = null <BR>&nbsp;, @ProjectName varchar (50) = null <BR>&nbsp;, @ResourceID int = null <BR>) as </P>
<P><BR>&nbsp;select [ProjectID], [ProjectName], [ResourceID] -- , etc, etc<BR>&nbsp;from tblProject </P>
<P>&nbsp;where <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ProjectID is null THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ProjectID] = @ProjectID THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1 </P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; and CASE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ProjectName is null THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ProjectName] = @ProjectName THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- WHEN [ProjectName] like <A href="mailto:'%'+@ProjectName+'%'">'%'+@ProjectName+'%'</A> THEN 1 -- For partial matches<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp; and CASE<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ResourceID is null THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ResourceID] = @ResourceID THEN 1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1</P>
<P>GO<BR></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, December 06, 2006</h2><P>I use a special BO to trap all the fields in the Search form that the user selects.</P>
<P>If certain things are not selected then they are omitted from the SQL.</P>
<P>This special BO outputs a filter (the WHERE clause without the WHERE) and then this filter is used in a dynamic SQL statement. This is much easier than coding dozens of SPs. This is one of the places that dynamic SQL shines. Naturally you have to validate the input prior to generating the filter to avoid SQL Injection.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>I am not opposed to coding multiple sprocs if necessary in order to take advantage of their benefits.&nbsp; I agree that this is pointless (and wasteful) - not to mention impossible - for user-defined queries.&nbsp; But, there are a handful of queries that I know going in are needed.&nbsp; We will always need to have the capability to list "Open" Projects, for instance.</P>
<P>A good example of what I mean can be found in Outlook 2003+ where you have your "Favorite Folders" view.&nbsp; By default, this list includes not only your Inbox, Sent Items, etc. but the special folders/views "Unread Mail" and "For Follow Up".&nbsp; These are simply filtered views of the same data but they are pre-defined views - as opposed to user-defined.</P>
<P>So, I am looking for the best way to implement a combination or pre-defined and user-defined views on the same data.&nbsp; Here are the possible approaches as I see them:</P>
<OL>
<LI>Create a separate BO for each pre-defined view (e.g. ProjectList, OpenProjectList, ClosedProjectList, etc.) and a special BO to support dynamic searching/filtering by the user.</LI>
<LI>Create a single BO that always accepts the dynamically-defined search criteria object.&nbsp; When null, the object returns the full list; otherwise, the specific filter is applied.&nbsp; This means one BO, one sproc and a ton of dynamic code.&nbsp; (This can be done by either generating the SQL in code or passing the applicable parameters to a sproc as described in the previous posts.)</LI>
<LI>Create a single BO that exposes View child objects which can be used to sort, filter, etc. the data to match the specific criteria.&nbsp; Unless the View is instantiated directly, this would mean that the BO retrieves all of the data from the data source so that the filter has a source to work on.&nbsp; This would be consistent with the way the DataTable and DataSource classes are designed (by MS).</LI></OL>
<P>To recap, what we are trying to achieve is:</P>
<OL>
<LI>A&nbsp;list of all&nbsp;projects in the system (that have not been flagged as deleted).</LI>
<LI>A list of all projects in an "open" state.</LI>
<LI>A list of all projects in a "closed" state.</LI>
<LI>A list of all projects in an "open" state assigned to "Bob Smith".</LI></OL>
<P>The first three represent pre-defined "views" while the last is an example of something that a user may defined at run-time.</P>
<P>I'm still not convinced which approach makes better sense, offers the scalability we need and remains consistent with CSLA and expected behavior of such objects.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, December 07, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Norty:</strong></div><div><p>Your table has a set number of fields.&nbsp; The filter can be any combination of these fields.</p>
<p>I create a search Proc that has 1 parameter for each possible search field (allowing nulls).&nbsp; Your DP_Fetch only passes in the parameters that it cares about.&nbsp; The query sorts out the nulls from the values passed in.&nbsp; If no parameters are passed in, then ALL data is returned, else data is filtered by all passed in parameters.</p>
<p>Hope this helps</p>
<p>Des</p>
<p>&nbsp;</p>
<p>create procedure dbo.sprProjectSearch<br>(<br>&nbsp;&nbsp; @ProjectID uniqueidentifier = null <br>&nbsp;, @ProjectName varchar (50) = null <br>&nbsp;, @ResourceID int = null <br>) as </p>
<p><br>&nbsp;select [ProjectID], [ProjectName], [ResourceID] -- , etc, etc<br>&nbsp;from tblProject </p>
<p>&nbsp;where <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CASE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ProjectID is null THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ProjectID] = @ProjectID THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; and CASE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ProjectName is null THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ProjectName] = @ProjectName THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- WHEN [ProjectName] like <a href="mailto:%27%%27+@ProjectName+%27%%27">'%'+@ProjectName+'%'</a> THEN 1 -- For partial matches<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; and CASE<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN @ResourceID is null THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN [ResourceID] = @ResourceID THEN 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ELSE 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END = 1</p>
<p>GO<br></p></div></BLOCKQUOTE><br>This is the tactic I use, but the following where clause <i>might</i> be more efficient by avoiding the searched case statements (depends on what the query optimizer does to it).<br><br><p><font face="Courier New">create procedure dbo.sprProjectSearch<br>(<br>&nbsp;&nbsp; @ProjectID uniqueidentifier = null <br>&nbsp;, @ProjectName varchar (50) = null <br>&nbsp;, @ResourceID int = null <br>) as</font> </p>

<p><font face="Courier New" size="3">select [ProjectID], [ProjectName], [ResourceID] -- , etc, etc<br>from tblProject<br>where</font></p>
<p><font face="Courier New" size="3">&nbsp;&nbsp;&nbsp; isnull (@ProjectId, ProjectId) = ProjectID<br>&nbsp;&nbsp;&nbsp; and @ProjectName like '%' + isnull (@ProjectName, ProjectName) + '%'<br>&nbsp;&nbsp;&nbsp; and isnull (@ResourceID, ResourceID) = ResourceID</font><font face="Courier New" size="3"><br>GO</font><br></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>Not to step on anyone's toes, but I don't need help on implementing dynamic searches.&nbsp; And for anyone that does, there have been at least two other threads that have covered the topic in much greater detail.&nbsp; So, in the hopes of getting the thread back on topic...</P>
<P>My concern/question has to do with the best approach to use when implementing a combination or pre-defined and user-defined views on the same list of data.&nbsp; Obviously we need one form or another of the search mechanism described for the user-defined view(s).&nbsp; However, the question still remains whether this is the best approach for views that we know we will need up-front - when we can hard-code them into our app and potentially realize better performance, security, etc.</P>
<P>Again, let's use the following 4 views as examples:</P>
<OL>
<LI>Pre-defined: A&nbsp;list of all&nbsp;projects in the system (that have not been flagged as deleted). 
<LI>Pre-defined: A list of all projects in an "open" state. 
<LI>Pre-defined: A list of all projects in a "closed" state. 
<LI>User-defined: A list of all projects in an "open" state assigned to "Bob Smith".</LI></OL>
<P>Do we:</P>
<OL>
<LI>Create a separate BO for each pre-defined view (e.g. ProjectList, OpenProjectList, ClosedProjectList, etc.) and a special BO to support dynamic searching/filtering by the user. 
<LI>Create a single BO that always accepts the dynamically-defined search criteria object.&nbsp; When null, the object returns the full list; otherwise, the specific filter is applied.&nbsp; This means one BO, one sproc and a ton of dynamic code.&nbsp; (This can be done by either generating the SQL in code or passing the applicable parameters to a sproc as described in the previous posts.) 
<LI>Create a single BO that exposes View child objects which can be used to sort, filter, etc. the data to match the specific criteria.&nbsp; Unless the View is instantiated directly, this would mean that the BO retrieves all of the data from the data source so that the filter has a source to work on.&nbsp; This would be consistent with the way the DataTable and DataSource classes are designed (by MS).</LI></OL>
<P>or is there another option not mentioned yet?&nbsp; What are the pro's and con's of each of these approaches and why use one over the other?</P>
<P>I'm not so much concerned about the implementation as I am with understanding why.</P>
<P>Thx.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, December 07, 2006</h2>It sounds like one list to me.&nbsp; Same list, same data, different options of how much of it to pull down.&nbsp; So I would personally just make several factory methods on a single list.<br><br>To talk about it in the manner that is all the rage:<br>Responsibility: Display a list of projects<br>Behaviour: Display different contents based on what the user wants<br><br>Whether the user wants open, closed or polka-dotted projects, the fact that you are displaying a list of projects does not change.&nbsp; Unless you do different things with open vs. closed projects?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>I agree completely.&nbsp; That is why I posted the original message - cuz I didn't think creating separate objects for each "view" was the way to go.&nbsp; But, given that we will have a single ProjectList BO, are we treating each "view" as an actual view pulled off the original BO, implementing "dynamic search" for each static (factory) method or somehow filtering the data in the data portal method(s)?</P>
<P>I hesitate to go with a total dynamic search approach because of performance concerns.&nbsp; If we are hard-coding factory methods, then we can hard-code what is necessary to implement data access for those methods.&nbsp; I believe that we should be able to use the standard Criteria object for this purpose.&nbsp; It would expose a State property, for instance, that when set would use the GetProjectsByState sproc accepting the state value as an argument.</P>
<P>That still leaves the question over using true Views to accomplish this.&nbsp; I just spent a bit of time going through the CslaDataSource set of classes and am intrigued by the model used.&nbsp; Under this approach, our ProjectList class would serve as a pass-through placeholder for the various views on the actual data.&nbsp; Just as with the CslaDataSource, we could create multiple ProjectListView classes and add them to the internal list.&nbsp; Each ProjectListView would be our actual BO with the logic necessary to access the back-end data store.&nbsp; One of our views would support a dynamic definition for user-defined views.&nbsp; This seems appealing because its extensible, allows us to use BOs to represent each view, etc. - and we don't have to use dynamic queries to implement our pre-defined views.</P>
<P>Thoughts?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>Obviously the object (and data) model presented by the ObjectDataSource and emulated in the CslaDataSource classes is new but it certainly provides for an interesting approach to this type of scenerio.</P>
<P>I can see having our "core" business collection, ProjectInfoList, expose a static DefaultView property that will return a bindable, data-driven BO containing all of our ProjectInfo objects.&nbsp; We could add other static properties or methods, such as GetOpenProjects() or OpenProjectView (whatever name works) that will create and return other, pre-defined views implemented in a similar way to how the ObjectDataSource/CslaDataSource classes are defined.</P>
<P>This seems like a pretty powerful model but I am concerned that this may be more complicated to implement than it is worth.</P>
<P>Thoughts?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Monday, December 11, 2006</h2>Here is some pseudo code that may be of help:<br><br><font face="Lucida Console" size="2"><br /><br />ProjectFilter myFilter = new ProjectFilter();<br />ProjectSort mySortOptions = new ProjectSort();<br /><br />myFilter.ProjectStatus = &quot;Open&quot;;<br />myFilter.ProjectAssigned = &quot;Bob Smith&quot;;<br />mySortOptions.SortByName = SortOrder.Desc;<br /><br />ProjectList myList = ProjectList.GetProjectList(myFilter, mySortOptions);<br /><br /></font><br><br>&gt;&gt; Create a separate BO for each pre-defined view (e.g. ProjectList,
OpenProjectList, ClosedProjectList, etc.) and a special BO to support
dynamic searching/filtering by the user. &lt;&lt;<br><br>I don't think this is necessary. Your pre-defined views can be just previously saved filters. <br><br>&gt;&gt; Create a single BO that always accepts the dynamically-defined search
criteria object.&nbsp; When null, the object returns the full list;
otherwise, the specific filter is applied.&nbsp; This means one BO, one
sproc and a ton of dynamic code.&nbsp; (This can be done by either
generating the SQL in code or passing the applicable parameters to a
sproc as described in the previous posts.) &lt;&lt;<br><br>You can encapsulate specific filter/sort objects like the example above. The dynamic sql stuff can be handled by a different object. What we do is pass the filter/sort objects to a Sql Translator that generates the appropriate sql. The translated filter/sorting sql is then sent to the stored proc. <br><br>I prefer filtering on the database rather than bringing back 10k records that are then filtered. <br><br>HTH<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Monday, December 11, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>
<P><CODE>ProjectInfoList.GetProjects(); // returns only non-deleted items.<BR>ProjectInfoList.GetAllProjects(); // returns all projects, regardless of their deleted flag.<BR>ProjectInfoList.GetOpenProjects(); // returns all projects in an 'open' state.<BR>ProjectInfoList.GetClosedProject(); // returns all projects in a 'closed' state.<BR>etc.</CODE></P>
<P>And these can simply make use of a pre-defined criteria object and use the same data access methods to retrieve the data from the database.&nbsp; And we only pull the data we actually want out of the database - which I like.</P>
<P>I'll have to go back and revisit that thread - and the one referenced from it - and retrace our steps to see how we implemented this before so we can make use of it here.&nbsp; I believe we made use of a special SearchCommand object and custom CommandBuilder that used the criteria object and created the SQL for the SearchCommand to execute in a manner similar to what you described in the other topic.</P>
<P>I guess there would be one downside&nbsp;to this approach.&nbsp;Even the "canned views" would be treated as dynamic queries when they really don't have to be.&nbsp; What I mean is, let's say we have a stored procedure, GetProjects, that is used by default to retrieve the records.&nbsp; This is great and we get all the benefits of using a sproc for data access.&nbsp; But, in order to implement the dynamic search functionality, we have to go with dynamic-SQL instead of a sproc for our query.&nbsp; To create the Open Projects "view" created using the GetOpenProjects() factory method, we would use the same dynamic facility that is used for user-defined searches rather than simply calling a GetOpenProjects stored procedure.&nbsp; See my point?</P>
<P>Would be nice if there was some happy middle-ground that would allow us to do both.&nbsp; Any ideas?</P>
<P></div></BLOCKQUOTE></P>
<P>Had an idea that might be some middle ground.&nbsp;&nbsp; </P>
<P><STRONG>Pluses:</STRONG></P>
<UL>
<LI>More secure than pure dynamic sql</LI>
<LI>Less network traffic than filtering it all in the business objects</LI></UL>
<P><STRONG>Minuses:</STRONG></P>
<UL>
<LI>More load on the database than a pure dynamic sql approach.</LI></UL>
<P>First of all, in sql server 2005 and in oracle, you can define a procedure to run as a given user or role.</P>
<P>Example (sql server 2005 syntax):</P>
<P>CREATE PROCEDURE BLAHBLAH WITH EXECUTE AS 'ReallySafeUserRole' AS ...</P>
<P>So, ReallySafeUserRole could be defined to only have the authority to select privileges on the tables that are necessary to service the allowable dynamic queries.&nbsp; If someone slipped in some nasty dynamic sql, it simply wouldn't be able to do very much.</P>
<P>Secondly, if you needed to add some more protection (at the cost of more load on the database), you could make a change to the ReallySafeUserRole privileges.&nbsp; Instead of having select access on the necessary tables, it would only have execute authority to run a specific stored procedure (which I explain next).</P>
<P>The stored procedure it would run would return a list of the four main categories you mentioned (&nbsp;all, non-deleted, open, closed).&nbsp; (If you needed 4 procedures to do that instead of one, then this procedure would have the authority to run all four.)&nbsp; You execute them like this:<BR><BR><FONT color=#0000ff size=2>create</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>table</FONT><FONT size=2> #project_list<BR></FONT><FONT color=#808080 size=2>(project_</FONT><FONT size=2>id </FONT><FONT color=#0000ff size=2>int</FONT><FONT size=2> </FONT><FONT color=#808080 size=2>null<BR>, etc...<BR></FONT><FONT color=#808080 size=2>)</P></FONT><FONT color=#0000ff size=2>
<P>insert</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>into</FONT><FONT size=2> #project_list </FONT><FONT color=#0000ff size=2>exec</FONT><FONT size=2> GetProjectData(@project_sub_list_flag)<BR></FONT><FONT size=2><BR></FONT><FONT size=3>You then build a dynamic query against #project_list.</FONT></P>
<P>I *think* this would be pretty secure.&nbsp; Comments?</P>
<P><FONT size=2>&nbsp;</P></FONT><FONT size=2></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Monday, December 11, 2006</h2><P>darn.&nbsp; still have to worry about cross-page scripting.&nbsp; Have to use html encoding to stop that from the business object side.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, December 12, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>
<P>darn.&nbsp; still have to worry about cross-page scripting.&nbsp; Have to use html encoding to stop that from the business object side.</P>
<P></div></BLOCKQUOTE></P>
<P>I was wrong on that, which means I was actually right. :)</P>
<P>Using two procs as I described earlier should be quite secure and avoids overloading the network by moving data that will be filtered out, while still preventing sql injection attacks.&nbsp; Can't wait to build one this way!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Wednesday, December 13, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div> 
<P>Would be nice if there was some happy middle-ground that would allow us to do both.&nbsp; Any ideas?</P>
<P></div></BLOCKQUOTE></P>
<P>Had an idea that might be some middle ground.&nbsp;&nbsp; </P>
<P><STRONG>Pluses:</STRONG></P>
<UL>
<LI>More secure than pure dynamic sql 
<LI>Less network traffic than filtering it all in the business objects</LI></UL>
<P><STRONG>Minuses:</STRONG></P>
<UL>
<LI>More load on the database than a pure dynamic sql approach.</LI></UL>
<P>First of all, in sql server 2005 and in oracle, you can define a procedure to run as a given user or role.</P>
<P>Example (sql server 2005 syntax):</P>
<P>CREATE PROCEDURE BLAHBLAH WITH EXECUTE AS 'ReallySafeUserRole' AS ...</P>
<P>So, ReallySafeUserRole could be defined to only have the authority to select privileges on the tables that are necessary to service the allowable dynamic queries.&nbsp; If someone slipped in some nasty dynamic sql, it simply wouldn't be able to do very much.</P>
<P>Secondly, if you needed to add some more protection (at the cost of more load on the database), you could make a change to the ReallySafeUserRole privileges.&nbsp; Instead of having select access on the necessary tables, it would only have execute authority to run a specific stored procedure (which I explain next).</P>
<P>The stored procedure it would run would return a list of the four main categories you mentioned (&nbsp;all, non-deleted, open, closed).&nbsp; (If you needed 4 procedures to do that instead of one, then this procedure would have the authority to run all four.)&nbsp; You execute them like this:<BR><BR><FONT color=#0000ff size=2>create</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>table</FONT><FONT size=2> #project_list<BR></FONT><FONT color=#808080 size=2>(project_</FONT><FONT size=2>id </FONT><FONT color=#0000ff size=2>int</FONT><FONT size=2> </FONT><FONT color=#808080 size=2>null<BR>, etc...<BR></FONT><FONT color=#808080 size=2>)</P></FONT><FONT color=#0000ff size=2>
<P>insert</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>into</FONT><FONT size=2> #project_list </FONT><FONT color=#0000ff size=2>exec</FONT><FONT size=2> GetProjectData(@project_sub_list_flag)<BR></FONT><FONT size=2><BR></FONT><FONT size=3>You then build a dynamic query against #project_list.</FONT></P>
<P>I *think* this would be pretty secure.&nbsp; Comments?</P>
<P></div></BLOCKQUOTE></P>
<P>I think this is a really cool approach.&nbsp; It's simple, fast to code, should run fast, and is also sql-injection safe. </P>
<P>Why no interest in it?&nbsp; </P>
<P>Is it just because all you OOO&nbsp;(Object Oriented Only) types couldn't possibly find something done in the database&nbsp;cool?&nbsp; :)&nbsp;&nbsp; Or did I not provide sufficient detail to explain it properly?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 13, 2006</h2>Well personally I think that's more work than just using dynamic sql... which you end up using anyway, just in the database instead of the .Net code, from my understanding of your post.&nbsp; So wouldn't it just be easier to get a policy changed that allows selects to be built dynamically?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Tuesday, December 19, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Well personally I think that's more work than just using dynamic sql... which you end up using anyway, just in the database instead of the .Net code, from my understanding of your post.&nbsp; So wouldn't it just be easier to get a policy changed that allows selects to be built dynamically?<BR></div></BLOCKQUOTE></P>
<P>Sorry for the delay in answering, but life and work got in the way.&nbsp; </P>
<P>It <STRONG><EM>IS</EM></STRONG> more work than just using dynamic sql - it is also more secure.&nbsp; :)</P>
<P>I've thought of several flavors for this technique so that the added complexity better matches the scenario.</P>
<P>Let's say someone has a security role that allows them to select, insert, update and delete data from lots of tables in the database.&nbsp; However, their ability to do issue a malicious sql command is limited because their only interface to the database is via application screens.&nbsp; Letting a user type in whatever they want, then constructing a sql statement from that and dynamically executing it totally destroys the application layer of security.&nbsp; They can query or destroy any data that their role gives them access to.</P>
<P>This is, to put it mildly, a bad thing.</P>
<P>It's a whole lot of coding work to try to outsmart the hackers by checking what they type in for malicious intent.&nbsp; It's also not a secure approach when the user can make use of free-text fields.</P>
<P>My technique lets you completely avoid all that work and still be secure.</P>
<P>+++++++++++++++++++++++++++<BR>Simplest Version<BR>+++++++++++++++++++++++++++</P>
<P>Let's take the simplest version.&nbsp; You have two tables you want to issue a dynamic query against:&nbsp; project and project_status_code.&nbsp;&nbsp;&nbsp;Any user with access to these tables would be able to see any record in them.&nbsp;&nbsp;<BR></P>
<P>In this case,&nbsp;just create a database role called "Query_Projects" and&nbsp;<STRONG><EM>ONLY</EM></STRONG> grant it select access to project and project_status_code.&nbsp;&nbsp;&nbsp;Create your sql statement in your object code, or pass in the parameter values to a stored procedure and have the procedure construct the sql statement.&nbsp;&nbsp;I don't care which.&nbsp;&nbsp; When the stored procedure is created, use&nbsp;a "with execute as Query_Projects" clause.</P>
<P>A hacker can slip in whatever they want, but any statement that does anything other than select data from project or project_status_code will fail due to a security error.&nbsp;&nbsp; That's as simple as it gets!</P>
<P>+++++++++++++++++++++++++++<BR>More complex data security needs<BR>+++++++++++++++++++++++++++</P>
<P>Let's say that a user should NOT be allowed to see every project in the table.&nbsp; (Your company is managing projects for competitors, and you have to safely compartmentalize the data from teams working for those competitors. )<BR><BR>One way to do that would be to create a my_projects view&nbsp;that filtered out only those projects that each user was allowed to see.&nbsp; In that case, don't grant select access on project to the Query_Projects role, &nbsp;grant select on the my_projects view instead.&nbsp; Done.&nbsp; Still simple.<BR><BR>++++++++++++++++++++++++++<BR>Really complex data security needs<BR>++++++++++++++++++++++++++<BR><BR>In this case, not only must we limit what rows a user can see in the project table, but we also need to limit it to other tables we will need to dynamically query on.&nbsp; Plus, the rules are so convoluted we want to make sure that our skilled database programmers do that coding (both to get it right and to get it running efficiently).</P>
<P>In this case, we need to split the work (and thus partition the business risk) into two stored procedures.&nbsp; The first procedure (the public one directly called from the application) still executes as if the Query_Projects role was running it.&nbsp; However, instead of being given direct access to the underlying data tables and views, we only give the Query_Projects role the authority to execute a second procedure.&nbsp; The second procedure's job is to return a superset of data to the first, public procedure.&nbsp; We then issue a dynamic sql statement against those results.&nbsp; </P>
<P>By doing this, a hacker never has the opportunity to gain access to the data tables or database objects, and therefore can't cause that kind of mischief.&nbsp; </P>
<P>++++++++++++++++++++++++++<BR>Lots of data<BR>++++++++++++++++++++++++++<BR>Now, let's suppose that there are 100,000 records that could potentially be returned.&nbsp; The second procedure hands 100,000 records to the first one, which then discards the ones it does not want.&nbsp; That's a bit inefficient, but way more efficient than moving 100,000 records across the network and then discarding them in the&nbsp;object layer!&nbsp; How could we make this more efficient?</P>
<P>Well, if we pass in parameters instead of a completed statement to the first procedure, it can pass some of them (those that are both safe and cheap to code) to the second procedure in order to restrict the number of records returned to the first procedure.&nbsp; Even a&nbsp;couple parameters out of dozens of possible ones&nbsp;might lower the number of records chosen to a few hundred or so, which would greatly improve the overall efficiency.</P>
<P>So, that's four different, secure ways to simply and cheaply issue dynamic sql queries.&nbsp; HTH</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 21, 2006</h2>I still don't see how that's better than just properly setting permissions on the database objects themselves.&nbsp; As your scenarios get more and more complex, it sounds like more and more business rules are creeping into the database.&nbsp; Authroization rules are business rules as well, and its been my exprierence that changing the business layer is a lot easier than the db layer.. expecially when you start linking procs together which issue dynamicly built sql to each other..<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, December 21, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>I still don't see how that's better than just properly setting permissions on the database objects themselves.&nbsp; As your scenarios get more and more complex, it sounds like more and more business rules are creeping into the database.&nbsp; Authroization rules are business rules as well, and its been my exprierence that changing the business layer is a lot easier than the db layer.. expecially when you start linking procs together which issue dynamicly built sql to each other..<BR></div></BLOCKQUOTE></P>
<P>I'll try again. :)</P>
<P>A given user is allowed to update and delete some projects in a table, but not others.&nbsp;&nbsp; You have decided to put the business logic controlling which projects can be updated/deleted in your csla business objects - because that's the way OO people seem to&nbsp;like it.</P>
<P>Now, if you want to&nbsp;"keep things simple"on the database, that means that you have granted me access to update and delete on the Projects table.</P>
<P>That means that, as far as the database is concerned, I can update or delete ANY project in the Projects table.&nbsp;&nbsp; However, your Csla business objects limit my behavior to the correct projects, so it doesn't matter.</P>
<P>Now someone writes a new program that uses dynamic sql.&nbsp; It's got gobs and gobs of fields to validate, many of which are free-text, and&nbsp;that allows me to inject a sql select, update or delete statement of my own devising into the database.&nbsp;&nbsp; </P>
<P>Using injected sql select statements and the database dictionary, I learn about your table structure.&nbsp; Then I update my competitor's projects to make them go badly, and update my own to get a price break or even have you write me a refund check.&nbsp; Or,&nbsp;I slip in a "delete from projects;" command and your database just got trashed.&nbsp; &nbsp; </P>
<P>Now, you can argue - quite rightly! - that you could set up views, or very fine-grained access control on the row or column level, etc., in ordre to try to prevent this.&nbsp; But then it's not a matter of which one of us is "putting business logic in the database", it's a question of which method we are using to do so! :)</P>
<P>I propose that the method that I put forth is simpler and safer than trying to lock things down in the database using access controls.&nbsp; Why?&nbsp; Because it's simpler.&nbsp; New tables get added?&nbsp; My way automatically protects them.&nbsp; The access control method on the tables only protects them if they get set up with that protective layer.&nbsp; Not everything will.&nbsp; It might be another application in the database (that you didn't&nbsp;write!) that gets hacked.&nbsp; The method I proposed would protect against sloppy developers better. :)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 21, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Now someone writes a new program that uses dynamic sql.&nbsp; It's got gobs and gobs of fields to validate, many of which are free-text, and&nbsp;that allows me to inject a sql select, update or delete statement of my own devising into the database.&nbsp; </div></BLOCKQUOTE><br><br>Ahh, well now you have problems where you're allowing unknown and / or untrusted applications to communicate with your database.&nbsp; I think a better option would be to address that problem, but depending on the environment maybe you can't.<br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Now, you can argue - quite rightly! - that you could set up views, or very fine-grained access control on the row or column level, etc., in ordre to try to prevent this.&nbsp; But then it's not a matter of which one of us is "putting business logic in the database", it's a question of which method we are using to do so! :)</div></BLOCKQUOTE></p><p></p>Perhaps the BO should be putting the appropriate security on the row (does sql 2005 now allow permissions for specific rows of data?).&nbsp;&nbsp; If row level security is not available though, you still have the same problem with your solution.&nbsp; A crafty sql statement embedded in the stored procedure call could still update data that shouldn't be updated.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I propose that the method that I put forth is simpler and safer than trying to lock things down in the database using access controls.&nbsp; Why?&nbsp; Because it's simpler.&nbsp; New tables get added?&nbsp; My way automatically protects them.&nbsp; The access control method on the tables only protects them if they get set up with that protective layer.&nbsp; Not everything will.&nbsp; It might be another application in the database (that you didn't&nbsp;write!) that gets hacked.&nbsp; The method I proposed would protect against sloppy developers better. :)</div></BLOCKQUOTE><br><br>Well I'm not sure that there should be some magic proc that figures out security; we should always be thinking of it, especially when adding new tables and such.&nbsp; Plus, what if you get the proc wrong?&nbsp; How do you know?&nbsp; As far as sloppy developers go, we need to stop letting sloppy developers do work on applications which must be highly secure (or any work at all, for that matter).<br><br>At any rate the idea that you and your competitor are storing data on the same database seems far fetched to me... mostly for fear of hacking you describe.&nbsp; A more maintainable solution would just to be another database possibly on another server all together.. no magic stored procedures and associated maintance costs with it.&nbsp; Yes, you have two product dbs to keep updated now, but you did buy Sql Compare right???? <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, December 21, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Now someone writes a new program that uses dynamic sql.&nbsp; It's got gobs and gobs of fields to validate, many of which are free-text, and&nbsp;that allows me to inject a sql select, update or delete statement of my own devising into the database.&nbsp; </div></BLOCKQUOTE><BR><BR>Ahh, well now you have problems where you're allowing unknown and / or untrusted applications to communicate with your database.&nbsp; I think a better option would be to address that problem, but depending on the environment maybe you can't.'</P>
<P></div></BLOCKQUOTE></P>
<P>Gosh, we sure are not communicating well!&nbsp; :(</P>
<P>No, absolutely not.&nbsp; I am not talking about allowing unknown/untrusted applications to communicate with the database.&nbsp; I am talking about someone writing a web page for their own application that allows a user of that page to inject unwanted sql commands into it - all because they dynamically constructed the sql statement by truncating user-entered strings together.&nbsp; Are we mis-communicating because you don't see how this is a problem?</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Now, you can argue - quite rightly! - that you could set up views, or very fine-grained access control on the row or column level, etc., in ordre to try to prevent this.&nbsp; But then it's not a matter of which one of us is "putting business logic in the database", it's a question of which method we are using to do so! :)</div></BLOCKQUOTE></P>
<P></P>
<P>Perhaps the BO should be putting the appropriate security on the row (does sql 2005 now allow permissions for specific rows of data?).&nbsp;&nbsp; If row level security is not available though, you still have the same problem with your solution.&nbsp; A crafty sql statement embedded in the stored procedure call could still update data that shouldn't be updated.<BR></div></BLOCKQUOTE></P>
<P>Again, we are not communicating.&nbsp; If your business object accepts user-entered free-form text&nbsp;and constructs the sql statement to be issued by concatenating the strings together, a user of that web page&nbsp;has the capability to totally and completely subvert the security the business object tries to add.&nbsp;&nbsp;</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I propose that the method that I put forth is simpler and safer than trying to lock things down in the database using access controls.&nbsp; Why?&nbsp; Because it's simpler.&nbsp; New tables get added?&nbsp; My way automatically protects them.&nbsp; The access control method on the tables only protects them if they get set up with that protective layer.&nbsp; Not everything will.&nbsp; It might be another application in the database (that you didn't&nbsp;write!) that gets hacked.&nbsp; The method I proposed would protect against sloppy developers better. :)</div></BLOCKQUOTE><BR><BR>Well I'm not sure that there should be some magic proc that figures out security; we should always be thinking of it, especially when adding new tables and such.&nbsp; Plus, what if you get the proc wrong?&nbsp; How do you know?&nbsp; As far as sloppy developers go, we need to stop letting sloppy developers do work on applications which must be highly secure (or any work at all, for that matter).<BR></div></BLOCKQUOTE></P>
<P>I agree that proper usage of database roles is good practice - and I will continue to use it.&nbsp; It's a good, basic level of security that's very cost effective.&nbsp; This technique is a quick and&nbsp;inexpensive way to safely use dynamically created sql on a query page.&nbsp; That's all.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><BR>At any rate the idea that you and your competitor are storing data on the same database seems far fetched to me... mostly for fear of hacking you describe.&nbsp; A more maintainable solution would just to be another database possibly on another server all together.. no magic stored procedures and associated maintance costs with it.&nbsp; Yes, you have two product dbs to keep updated now, but you did buy Sql Compare right???? <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><BR></div></BLOCKQUOTE></P>
<P>It's not far-fetched.&nbsp; Happens in big business all the time.&nbsp;&nbsp;Depending upon software&nbsp;licensing arrangements, using a different database server and database instance might cost huge pots of money in licensing fees.&nbsp; Plus extra hardware.&nbsp; And extra rent, heating, cooling, hardware maintenance and repair fees, etc.&nbsp; Plus the extra labor cost - even with code utilities to help out&nbsp;- of keeping multiple installations synchronized.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Friday, December 22, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div> 
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Ahh, well now you have problems where you're allowing unknown and / or untrusted applications to communicate with your database.&nbsp; I think a better option would be to address that problem, but depending on the environment maybe you can't.'</P>
<P></div></BLOCKQUOTE></P>
<P>Gosh, we sure are not communicating well!&nbsp; :(</P>
<P>No, absolutely not.&nbsp; I am not talking about allowing unknown/untrusted applications to communicate with the database.&nbsp; I am talking about someone writing a web page for their own application that allows a user of that page to inject unwanted sql commands into it - all because they dynamically constructed the sql statement by truncating user-entered strings together.&nbsp; Are we mis-communicating because you don't see how this is a problem?</P>
<P></div></BLOCKQUOTE></P>
<P>David, I think it's because <EM>you're</EM> missing the point.&nbsp; A page that allows users to inject SQL is the problem, not dynamic sql, since that can be easily shielded from those attacks just like stored procedures&nbsp;via parameterization.&nbsp; </P>
<P>Mind you, as I've stated, I'm speaking strictly of reading data and agree sprocs are a good idea for updates.</P>
<P>[Ok, maybe this is just going to continue in this thread.&nbsp; :) ]</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Friday, December 08, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>
<P>I have a situation where I have a set of business objects, we'll go with Projects for consistency.&nbsp; In code, we have created a Project BO and a read-only ProjectInfo BO - just as in the book.&nbsp; Then we have a ProjectCollection (read/write using Project - allows use to add, modify &amp; remove via DataGrids, etc.) and a ProjectList (read-only using ProjectInfo for listing).&nbsp; We've already begun receiving requests to add additional "views" of this data.&nbsp; For instance...</P>
<P>We need to be able to generate a list/collection of Open Projects, Closed Projects, Deleted Projects and Archived Projects - just for starters.&nbsp; Implementing these are relatively simple as they are just filters based on the current state and/or age of the project.</P>
<P>In addition, we are looking to allow users the ability to define their own "custom" filters to apply to the list/collection displayed.&nbsp; These filters could then be saved as part of their personalization of the interface.</P>
<P>My question is what approach to use that will satisfy our need for multiple "views" and&nbsp;allowing the user to create their own views that are dynamically recreated at run-time.</P>
<P>Our first thought was to create a separate OpenProjectList class, etc. but that hardly seems practical as the number of "views" can increase dramatically.&nbsp; AND, we wouldn't be able to support dynamic filtering this way.</P>
<P>So, it occurred to me that perhaps we are dealing with coding the basic read-only "view"&nbsp;- ProjectList - as these filters would only apply to read-only lists anyway and treating all of these variations as "Views" much like the System.Data.DataTable does.&nbsp; Then, we would define a mechanism for defining the filtering applied by the user (there have been several other posts along these lines with were VERY helpful in developing this part).&nbsp; So, in the end, we would instantiate our ProjectList class, create a new View by applying our filtering logic and bind our UI&nbsp;to&nbsp;the view&nbsp;rather than the ProjectList class.</P>
<P>Is this wise though?&nbsp;&nbsp;It would mean that our ProjectList class would do no filtering of its own and would have to be populated with every record in the table whether deleted, closed, open or otherwise so that the filtering could be applied in memory, dynamically.&nbsp; As the application moves forward, this could mean hundreds of thousands of records when all the user may want&nbsp;is a view of&nbsp;projects in an Open state that have been assigned to him/her - and may only be 10-20 items out of several hundred thousand.</P>
<P>Thoughts/suggestions?</P>
<P></div></BLOCKQUOTE></P>
<P>This may seem cheesy and very anti oop but it works for what we do in some cases.</P>
<P>First I define a superset of "views". These are the factory methods of the collection class.&nbsp; As you mentiond "Open", "Closed" etc.&nbsp; These base views are determined by potential amount of rows/objects returned AND security concerns.&nbsp; So if "Archived" could potentially return tens of thousands of records the factory method must supply a date range, for example, to limit the amount of data returned.</P>
<P>Now here is where it gets kinda cheesy.&nbsp; Developer Express has this great grid that can persit it's state (an I am sure other vendors offer this as well). This includes sort order, filter(s), column order&nbsp;and just about everything else with a single call.&nbsp; I let the user set this up and save the current state of the grid so that they can recall the "view" with a right click of the grid.</P>
<P>This allows me to only worry about limiting the amount of data retrieve (for perfomance reasons) in the factory method of the collection.&nbsp; Something else is concerned, I feel correctly, about how that data is displayed to the user. I have a hard time concerning my self in the middle tier about what data is returned outside of security concerns.</P>
<P>On a slightly less cheesy note. There are cases where the grid stuff is not useful. For example when it is not a UI deal.&nbsp; In this case I create another class that takes the BO collection in the ctor.&nbsp; The class also has a number of properties and methods that will produce another collection based on the filters.</P>
<P>And don't discount the dynamic criteria creation.&nbsp; I personally don't believe in stored procedures unless they provide something that a parameratized query can't accomplish.&nbsp; That does not happen very often.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Saturday, December 09, 2006</h2><P>I have to disagree with you on the stored procedure&nbsp; issue but won't engage in a debate as the merits of stored procedures over coded SQL are well established including security and performance - just to mention a couple.&nbsp; But, I do agree that there is a difference between UI view settings and what I am referring to as a "view" which reflects the&nbsp;make-up of the data that is retrieved from the database.&nbsp; My concern is to limit the bandwidth to only handle what is required for the request.&nbsp; In other words, if we only want to see a list of projects in an Open state (OpenProjectsList), then we certainly don't want to retrieve the whole list and apply a filter in memory as would be the case if we used the <EM>traditional</EM>, MS-designed collection approach.</P>
<P>And, I am right there with you on the idea of using static, factory methods to create our pre-defined views/collections.&nbsp; Am I correct that when doing so, you are simply setting up the Criteria object for your collection per the method that was called and passing this along to your DataPortal_Fetch method for handling so that the appropriate results are returned?&nbsp; So, in the end, regardless of the criteria, you are returning the same type every time?</P>
<P>The wrinkles I am trying to iron out include the need for dynamic searching/filtering on top of the list of pre-defined views.&nbsp; Is it better to treat all of these the same and have the underlying data access code treat a pre-defined view the same as a user-defined view in that the data access code doesn't know the difference between a call that was initiated through one of the factory methods or based on some criteria established by the user in the UI -or- would it be better to have these predefined views be BOs of their own?</P>
<P>I think the concensus is NOT to have each view be a BO of its own; however, after looking at the 'x'DataSource/CslaDataSource model, I find it an interesting idea to implement this type of scenario in a similar way to where we define a set of 'views' for a particular set of data and have them managed by our core object which instantiates the requested object via our factory methods.&nbsp; This would allow us to maintain our development standard of not allowing code direct access to database elements - code MUST use sprocs - for each view and provide for extensibility by simply creating additional views that can be added to the core object.&nbsp; This would allow us to persist the user-defined views and have them recreated in code for access in a similar manner as the pre-defined views.</P>
<P>I'll tell you one of the reasons that this is appealling is that we are looking to add a "Folder List" type component to our UI.&nbsp; This would list all of the different views that a user has available to view data.&nbsp; It would come out-of-the-box with "All Projects", "Open Projects", "Closed Projects", etc. - our pre-defined views - and would expand to also include the names given to the custom views created by the user.&nbsp; So, if our user wanted to always see a list of all Projects for a particular region or projects worth more than 'x' amount in revenue, etc., they would define their filter/criteria, such as (Project.EstimatedRevenue &gt;= $1 Mil), save it as "High Yield Projects" and it would automatically appear in the Folder List for that user alongside the others.</P>
<P>By having this custom view, "High Yield Projects", created as another View within our ProjectList object (again, following the DataSource model) we can simply return a list of available views using the GetViews method or enumerate the Views property and our Folder List UI component can properly create the list and interact with our ProjectList BO to retrieve the requested list when the user selects the item in the UI component - via the GetView(string name) factory method.</P>
<P>What do you all think?</P>
<P>I guess at this point, I'm looking for a reason to not try this approach and see how it goes since the more we've thought about it, the more this model seems appealing and condusive to some more features that we'd like to implement than a straight collection would provide.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I have to disagree with you on the stored procedure&nbsp; issue but won't engage in a debate as the merits of stored procedures over coded SQL are well established including security and performance - just to mention a couple.&nbsp; </div></BLOCKQUOTE><br><br>Well, not getting into the debate too much, don't just assume those assumptions are true.&nbsp; There are times where dynamic sql actually performs better than the equivolent stored procedure. And are you just as secure creating a view (and can specify column level security) and limiting what can be done with that.&nbsp; Stored procedures are no magic bullet.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>My concern is to limit the bandwidth to only handle what is required for the request.&nbsp; In other words, if we only want to see a list of projects in an Open state (OpenProjectsList), then we certainly don't want to retrieve the whole list and apply a filter in memory as would be the case if we used the <em>traditional</em>, MS-designed collection approach.</div></BLOCKQUOTE><br><br>What was wrong with exposing a criteria object, which your collection BO interperates and builds the correct sql or calls the correct procedure.&nbsp; I do this all the time.&nbsp; It doesn't make sense to bring back rows you know you are just going to filter out.<br>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>And, I am right there with you on the idea of using static, factory methods to create our pre-defined views/collections.&nbsp; Am I correct that when doing so, you are simply setting up the Criteria object for your collection per the method that was called and passing this along to your DataPortal_Fetch method for handling so that the appropriate results are returned?&nbsp; So, in the end, regardless of the criteria, you are returning the same type every time?</div></BLOCKQUOTE></p><p>That's one way to go.&nbsp; Another would be to have a single internal criteria object and have your static methods translate the publicly exposed criteria object to the internal one.&nbsp; The benefit there is that you have one DP_F routine that handles all cases.&nbsp; Its more complex, but you save on having lots of simplier code to maintain as well (since you still need the complex scenario).<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>The wrinkles I am trying to iron out include the need for dynamic searching/filtering on top of the list of pre-defined views.&nbsp; Is it better to treat all of these the same and have the underlying data access code treat a pre-defined view the same as a user-defined view in that the data access code doesn't know the difference between a call that was initiated through one of the factory methods or based on some criteria established by the user in the UI -or- would it be better to have these predefined views be BOs of their own?</div></BLOCKQUOTE></p><p></p>It might be easier to have the different methods end up calling a more complex DP_F routine.&nbsp; As i said above, its a more compelx routine, but it handles everything you need to.&nbsp; <br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I think the concensus is NOT to have each view be a BO of its own; however, after looking at the 'x'DataSource/CslaDataSource model, I find it an interesting idea to implement this type of scenario in a similar way to where we define a set of 'views' for a particular set of data and have them managed by our core object which instantiates the requested object via our factory methods.&nbsp; This would allow us to maintain our development standard of not allowing code direct access to database elements - code MUST use sprocs - for each view and provide for extensibility by simply creating additional views that can be added to the core object.&nbsp; This would allow us to persist the user-defined views and have them recreated in code for access in a similar manner as the pre-defined views.</div></BLOCKQUOTE></p><p>The method I'm recommending to you should be able to handle it just fine.&nbsp; Its actually what I'm doing, and I'll also need to store user defined searches.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I'll tell you one of the reasons that this is appealling is that we are looking to add a "Folder List" type component to our UI.&nbsp; This would list all of the different views that a user has available to view data.&nbsp; It would come out-of-the-box with "All Projects", "Open Projects", "Closed Projects", etc. - our pre-defined views - and would expand to also include the names given to the custom views created by the user.&nbsp; So, if our user wanted to always see a list of all Projects for a particular region or projects worth more than 'x' amount in revenue, etc., they would define their filter/criteria, such as (Project.EstimatedRevenue &gt;= $1 Mil), save it as "High Yield Projects" and it would automatically appear in the Folder List for that user alongside the others.</div></BLOCKQUOTE></p><p></p>Sounds like what I am doing, more or less copying the Outlook 2003 style application. For exmaple, there's an Invoicing group (where in outlooky ou'd have Mail, Calendar,etc) and the items are Open, Closed, Pending, ect..&nbsp; and I'll be adding custom search folders as well.<br><br>Good luck with whatever solution you come up with!<br><br>Andy<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Monday, December 11, 2006</h2>&gt;&gt; <br>Well, not getting into the debate too much, don't just assume those
assumptions are true.&nbsp; There are times where dynamic sql actually
performs better than the equivolent stored procedure. And are you just
as secure creating a view (and can specify column level security) and
limiting what can be done with that.&nbsp; Stored procedures are no magic
bullet. <br>&lt;&lt;<br><br>If you start a new thread, I would like to discuss your views on the above comments. <br><br>Thx.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2>I don't think we need another such thread, especially here.&nbsp; Just google around though and you'll find plenty of posts where dynamic sql ends up performing better than a proc.&nbsp; As far as security goes, views are just as securable and can hide the actual schema (although I don't count that as 'security') just as well as a proc can.<br><br>Just to qualify my statement though, this applies mostly to selecting data.&nbsp; I think procs are probably the best way to modify data, mainly because it becomes very easy to add full row level auditing later if you're going through procs first.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Monday, December 11, 2006</h2>That is fine if you don't want to start a new thread. As far as googling, pretty much all of my previous research and experience says otherwise (performance, security, maintenability, etc...) about using dynamic sql from a client application, that is why I was wondering if you had a specific link so I can look it up and research further.<br><br>Thx. <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Tuesday, December 19, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>xAvailx:</strong></div><div>That is fine if you don't want to start a new thread. As far as googling, pretty much all of my previous research and experience says otherwise (performance, security, maintenability, etc...) about using dynamic sql from a client application, that is why I was wondering if you had a specific link so I can look it up and research further.<BR><BR>Thx. <BR></div></BLOCKQUOTE></P>
<P>This was quite a pet topic of mine a year or two ago&nbsp; - back when I had more time for debating for the fun of it.&nbsp; LOL.&nbsp; </P>
<P>There are a gazillion articles discussing this including ones taking the ad-hoc point of view.&nbsp; I can't believe you didn't find any of them.</P>
<P>After spending WAY too many hours researching, listening and debating, the simple conclusion for me is that there's no hard and fast answer.&nbsp; Many of the arguments for stored procedures are based in pure myth or ancient testing using SQL Server 7.0 or earlier.&nbsp; Things changed in SQL 2000 rendering many of those old assumptions invalid - but lots of SQL gurus cling to them.&nbsp; </P>
<P>The other of what I see as the two biggest dangers in sproc fanaticism is blindly assuming they're best for <EM>all</EM> scenarios.&nbsp; It's not difficult to write a sproc that is a horrid mess to maintain and&nbsp;isn't even acting like a sproc from SQL Server's point of view (in terms of performance).</P>
<P>Well, we could go on for hours here.&nbsp; The bottom line is my advice is to understand stored procedures offer advantages and disadvantages.&nbsp; One should not blindly accept the disadvantages when you either don't understand the advantages or haven't explored other ways of achieving them.&nbsp; (This is my general advice and not meant specifically for you or to accuse you of anything.)</P>
<P>I personally use mostly views for reading with the occasional sproc thrown in when necessary, and sprocs exclusively for writing because I want the control they offer.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xAvailx replied on Thursday, December 21, 2006</h2>I am not looking for a neverending debate. As I previously posted, I was looking for specific verifiable and reliable resources so I can research further. <br><br>Again, pretty much all of my previous research and experience says otherwise (performance,
security, maintenability, etc...) about using dynamic sql from a client
application and I am not looking for a debate, just some reliable resources I can research further for which "specific" scenarios client dynamic sql is "better" than a stored proc. <br><br>If you have any specific links, I would appreciate if you would share. <br><br>Thx. <br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, December 21, 2006</h2>While you're reading my post, please keep in mind that for selecting data, I prefer dynamic sqls against views.&nbsp; For updates, I think the best bet are SIMPLE procedures.&nbsp; Remember, most of your logic in the Csla world should be in C# business assemblies anyway, so your procs really shouldn't be doing more than a simple update.&nbsp; <br><br>I've been looking for links regarding performance, but its hard to find things out there because of all the noise.&nbsp; I do recall reading that starting with Sql Server 2000, dynamic queries were more or less on par with stored procedures.&nbsp; I've also found some threads that indicate on some queries, dynamic sql actually performed better than the same query encapsulated in a stored procedure.&nbsp; But you'll have to search on your own.<br><br>As far as maintenablity goes, it depends on what you're doing.&nbsp; If you end up building sql with in a stored procedure, or you have lots of if the blocks to alter which query is run, i'm of the belief that maintenablity will be hurt... but it depends on who's doing the maintence.&nbsp; I'm pretty good with T-Sql and C#, but it seems to me that C# is easier to maintain than pure T-Sql.. probably because of intellisense and the fact that I have tests and the compiler in general is better at helping me figure out what's wrong.<br><br>As far as security goes... well, I never knew how anyone could honestly say that procs are more secure than dynamic sql.&nbsp; At the end of the day, even all the way back to Sql Server 6.5, you can set permissions on tables, views, stored procedures.. pretty much every database object could be secured.&nbsp; So how this whole 'procs are more secure' thing got started is beyond me... unless your putting validation logic in the proc, but with Csla you shouldn't be doing that.&nbsp; Take validation logic out of the mix, and now you're basically left with the ACLs you can define on db objects.<br><br><br>Andy</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Thursday, December 21, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>xAvailx:</strong></div><div>I am not looking for a neverending debate. As I previously posted, I was looking for specific verifiable and reliable resources so I can research further. <BR><BR>Again, pretty much all of my previous research and experience says otherwise (performance, security, maintenability, etc...) about using dynamic sql from a client application and I am not looking for a debate, just some reliable resources I can research further for which "specific" scenarios client dynamic sql is "better" than a stored proc. <BR><BR>If you have any specific links, I would appreciate if you would share. <BR><BR>Thx. <BR><BR><BR></div></BLOCKQUOTE></P>
<P>Well, you can start by looking in the SQL 2005 Books Online under Stored Procedures Basics.&nbsp; You'll note in the "benefits" section there isn't a mention of performance anywhere in sight.&nbsp; In contrast,&nbsp;in SQL 2000 Books Online there is a specific section implying (erroneously) that the compiling of stored procedures brings&nbsp;a performance benefit.</P>
<P>The following is a rather infamous blog wherein the author later corrected himself and admitted that&nbsp;the pre-compile argument was complete myth.</P>
<P><A href="http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx">http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx</A></P>
<P>The following is a fairly well-known blog on the myths of stored procedure advantages.&nbsp; Frans is perhaps a little extreme himself in his disdain for sprocs, but it gives good arguments against the myths which have fueled the "always use stored procedures" position.</P>
<P><A href="http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx">http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx</A></P>
<P>I do not doubt that you've found lots of resources spewing the mantra.&nbsp; The question is were they largely based on fallacy and utter untruths like Howard's.</P>
<P>I don't have time to repeat all my research, but as for a specific case where dynamic SQL is more performant, see what you can find googling including "coalesce".&nbsp; That was one specific example I remember - the problem being basically that in a complex sproc with lots of conditional testing going on you ended up with two problems:</P>
<P>1 - a lot more code to run compared to the business layer that likely already knows exactly what it needs to do</P>
<P>2 - the final query that ends up being performed is so variable that you really have no cached execution plans and therefore no performance benefit over the specific ad-hoc dynamic calls</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Thursday, December 21, 2006</h2>I put my previous post in a new thread more appropriate for this OT (from this thread) discussion.&nbsp; Please respond there to me so other interested parties will see the correct subject.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>d0tnetdude replied on Monday, January 08, 2007</h2><P>We also ran into the same problem, in fact we our business object handled Task information, called TaskInfoList.&nbsp; The customer wanted a vareity of different views, by status, by customer, by resource, by start date and end date.&nbsp; </P>
<P>When we first implemented CSLA we had a separate stored procedure for each, needless to say that became a maintenance nightmare whenever we added a column to the database.&nbsp;</P>
<P>Finally the customer said they wanted to be able to not only have specified views, they wanted to be able to search the data anyway the wanted!&nbsp; </P>
<P>After much deliberation we made all our lists operate using dynamic sql, but we still called a stored procedure that accepted a where clause as a parameter.</P>
<P>As long as the customer is providing some search criteria the performance is pretty good and as far as sql-injection attacks, we've tightened up the security on the account that accesses the stored procedures to minimize any major issues.&nbsp; It was a trade off, but one that I think was worth it.&nbsp; We often times create (2) stored procedures, one being the base list, GetTaskList, and then a more advanced one, GetTaskList2,&nbsp;that also joined in all the child tables, not just the foreign key tables, so the customer could really search with some power.</P>
<P>All I can say is it works, it may not be best the solution, but it made the customer happy <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /> and it makes it easy for us to implement changes.</P>
<P>Hope this helps!</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
