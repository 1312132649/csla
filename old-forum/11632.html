<html><header><title>Winform UserControls seem to always trigger validation and call all their bound BO properties setters. Is this the normal behaviour?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Winform UserControls seem to always trigger validation and call all their bound BO properties setters. Is this the normal behaviour?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11632.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Troncho posted on Sunday, October 07, 2012</h2><p>Has anybody come across this same behaviour? Is this the way it should work? Or am I missing something?</p>
<p>Just to prove my point, now I wrote a very simple UserControl with a Label and a TextBox, both private. And a unique binding property &quot;TestName&quot;</p>
<pre style="font-family:Consolas;background:white;color:black;font-size:15px;">[<span style="color:#2b91af;">DefaultBindingProperty</span>(<span style="color:#a31515;">&quot;TestName&quot;</span>)]
[<span style="color:#2b91af;">DefaultProperty</span>(<span style="color:#a31515;">&quot;TestName&quot;</span>)]
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">partial</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">TestUC</span>&nbsp;:&nbsp;<span style="color:#2b91af;">UserControl</span>
{
	<span style="color:blue;">public</span>&nbsp;TestUC()
	{
		InitializeComponent();
	}
</pre>
<pre style="font-family:Consolas;background:white;color:black;font-size:15px;"><pre style="font-family:Consolas;background:white;color:black;font-size:15px;">	<span style="color:blue;">private</span>&nbsp;System.Windows.Forms.<span style="color:#2b91af;">Label</span>&nbsp;TestNameLabel;
	<span style="color:blue;">private</span>&nbsp;System.Windows.Forms.<span style="color:#2b91af;">TextBox</span>&nbsp;TestNameTextBox;</pre>
<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">string</span>&nbsp;TestName
	{
		<span style="color:blue;">get</span>&nbsp;{&nbsp;<span style="color:blue;">return</span>&nbsp;<span style="color:blue;">this</span>.TestNameTextBox.Text;&nbsp;}
		<span style="color:blue;">set</span>&nbsp;{&nbsp;<span style="color:blue;">this</span>.TestNameTextBox.Text&nbsp;=&nbsp;<span style="color:blue;">value</span>;&nbsp;}
	}
}</pre>
<p>Then, I drop this UserControl on a form (<strong>testUC1</strong>) and bind its bindable property(<strong>TestName</strong>)&nbsp;to a BO (derived from BusinessBase) property (<strong>Alias</strong>). I also SetApplyAuthorization(..):</p>
<pre style="font-family:Consolas;background:white;color:black;font-size:15px;"><span style="color:blue;">this</span>.readWriteAuthorization1.SetApplyAuthorization(<span style="color:blue;">this</span>.testUC1,&nbsp;<span style="color:blue;">true</span>);
<span style="color:blue;">this</span>.testUC1.DataBindings.Add(<span style="color:blue;">new</span>&nbsp;System.Windows.Forms.<span style="color:#2b91af;">Binding</span>(<span style="color:#a31515;">&quot;TestName&quot;</span>,&nbsp;<span style="color:blue;">this</span>.impTaxBaseBindingSource,&nbsp;<span style="color:#a31515;">&quot;Alias&quot;</span>,&nbsp;<span style="color:blue;">true</span>));
</pre>
<p>Then, every time <strong>testUC1</strong> loses focus, the bound BO property (<strong>Alias</strong>) setter <strong>ALWAYS GETS CALLED! </strong>Just by tabbing testUC1 in and out, when it loses focus, the BO property setter gets called.</p>
<p>It seems that somewhere on the way, the UserControls private method:</p>
<p>&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.<strong>ValidateThroughAncestor</strong>(System.Windows.Forms.Control ancestorControl = {System.Windows.Forms.SplitContainer}, bool preventFocusChangeOnError = true) + 0x105 bytes&nbsp;</p>
<p>gets called, which eventually triggers all the validation events associated with the user control which eventually trigger:</p>
<p>&nbsp;&nbsp;System.dll!System.ComponentModel.<strong>ReflectPropertyDescriptor.SetValue</strong>(object component = {NrgNet.Library.Base.ImpTaxBase}, object value = &quot;somevalue&quot;) + 0x11b bytes&nbsp;</p>
<p>which calls the BO property setter...</p>
<p>Here is the Call Stack list:</p>
<p>&gt;&nbsp;NrgNet.Library.Base.dll!NrgNet.Library.Base.ImpTaxBase.Alias.set(string value = &quot;somevalue&quot;) Line 68&nbsp;C#<br />&nbsp;&nbsp;[Native to Managed Transition]&nbsp;<br />&nbsp;&nbsp;System.dll!System.SecurityUtils.MethodInfoInvoke(System.Reflection.MethodInfo method, object target, object[] args) + 0x65 bytes&nbsp;<br />&nbsp;&nbsp;System.dll!System.ComponentModel.ReflectPropertyDescriptor.SetValue(object component = {NrgNet.Library.Base.ImpTaxBase}, object value = &quot;somevalue&quot;) + 0x11b bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.BindToObject.SetValue(object value) + 0x63 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Binding.PullData(bool reformat, bool force) + 0x159 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Binding.Target_Validate(object sender, System.ComponentModel.CancelEventArgs e = {System.ComponentModel.CancelEventArgs}) + 0x1a bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs e) + 0x88 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Control.NotifyValidating() + 0x27 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Control.PerformControlValidation(bool bulkValidation = false) + 0x34 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ValidateThroughAncestor(System.Windows.Forms.Control ancestorControl = {System.Windows.Forms.SplitContainer}, bool preventFocusChangeOnError = true) + 0x105 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.EnterValidation(System.Windows.Forms.Control enterControl) + 0x7c bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.UpdateFocusedControl() + 0x8a bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.AssignActiveControlInternal(System.Windows.Forms.Control value = {System.Windows.Forms.SplitContainer}) + 0x60 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ActivateControlInternal(System.Windows.Forms.Control control, bool originator = false) + 0x48 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ActivateControlInternal(System.Windows.Forms.Control control = {NrgNet.WinForms.Base.UCTreePart&lt;NrgNet.Library.Base.GenMenuListBase,NrgNet.Library.Base.GenMenuInfoBase&gt;}, bool originator = false) + 0xae bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.SetActiveControlInternal(System.Windows.Forms.Control value = {NrgNet.WinForms.Base.UCTreePart&lt;NrgNet.Library.Base.GenMenuListBase,NrgNet.Library.Base.GenMenuInfoBase&gt;}) + 0x73 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.SetActiveControl(System.Windows.Forms.Control ctl) + 0x33 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ActiveControl.set(System.Windows.Forms.Control value) + 0x5 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.SplitContainer.SelectNextActiveControl(System.Windows.Forms.Control ctl = {NrgNet.WinForms.Base.UCTreePart&lt;NrgNet.Library.Base.GenMenuListBase,NrgNet.Library.Base.GenMenuInfoBase&gt;}, bool forward = true, bool tabStopOnly = true, bool nested = true, bool wrap = false) + 0x70 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.SplitContainer.SelectNextControlInContainer(System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) + 0xdc bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.SplitContainer.Select(bool directed, bool forward) + 0x96 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.SplitContainer.SelectNextControlInContainer(System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) + 0x192 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.SplitContainer.Select(bool directed, bool forward) + 0x96 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) + 0x7e bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Form.ProcessTabKey(bool forward = true) + 0x24 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys keyData = LButton | Back) + 0x71 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys keyData) + 0x29 bytes&nbsp;<br />&nbsp;&nbsp;System.Windows.Forms.dll!System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys keyData) + 0x2b bytes&nbsp;<br /><br /><br />Thank you all,</p>
<p>Troncho</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Sunday, October 07, 2012</h2><p>Hi, </p>
<p>I suggest you read thoroughly the <a href="http://windowsclient.net/downloads/folders/applications/entry1302.aspx">DataBindingFAQ</a>.<br />This document goes thorough what actually triggers validation and how databinding in Windows Forms work. </p>
<p>(There&#39;s a similar <a href="http://windowsclient.net/downloads/folders/applications/entry1304.aspx">DataGridViewFAQ</a> too that is valuable for databinding and datagridview.)</p>
<p>When updatemode is set to OnValidation the value is written back to the object.</p>
<p><i>By default, simple binding updates a bound data source property value as part of Control validation. <br />Control validation occurs when a Control loses focus AND whenever the user tabs into a control has CausesValidation set to true.<br />That may be the first, second, third or whenever the next control has CausesValidation set to true.<br />By default most input controls, forms and usercontrols has CausesValidation = true. </i></p>
<p><b>My preference is to NEVER to this type of databinding</b><i><b>.</b>&nbsp; </i>I my view a usercontrol is similar to a Form and should have it&#39;s own binding sources and readwriteauthorization/errorproviders. The reason being that you can only ever have one input control on the UserControl in this style. The ReadWriteAuthorization and ErrorProvider will act on the UserControl and NOT on the input controls and this would confuse the user. </p>
<p>You might get away with making the input control publicly visible but the tooling support for setting up databinding does not expose these properties (IIRC) so it would have to be defined manually.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Troncho replied on Wednesday, October 31, 2012</h2><p>Thanks for the links Jonny. I&#39;ll go through them to get a deeper understanding of the associated behaviours.</p>
<p>Let me tell you exactly what I&#39;m doing:</p>
<p>. I&#39;m using special ReadOnlyBase derived objects as properties of an normal BusinessBase object and exposing them as read only to the UI.</p>
<p>. My first approach was to use 2 separete controls on each UI form associated with each of these special ReadOnlyBase properties, while editing the main BusinessBase object that contained them.</p>
<p style="padding-left:30px;">. The first control was a LinkLabel, exposing some text asociated with the ReadOnlyBase control (<em>I actually bind the ReadOnlyBase object directy and works just fine, cause the info I want to expose gets returned by the ReadOnlyBase.ToString() which automatically gets called</em>). It doesn&#39;t matter if the underlaying bound property is writeable or not, the LinkLabel never calls the bound property setter.</p>
<p style="padding-left:30px;">. The second control is a button, which is only enabled when the 1st control (textbox) bound property is writable. When clicked, it brings up a SelectForm, allows the user to select a diferent r/o object from the list and returns the newly selected item. Here I manually update BusinessBase property with the newly obtained ReadOnlyProperty and everything works fine.</p>
<p>. My second, more sophisticated approach, was to write special User Controls that could encapsulate both the info I wanted to expose to the UI and the button allowing the user to select a different ReadOnlyBase property during the BusinessBase object editing. I bound directy the RO property to a unique new bindable property I expose on the control.</p>
<p style="padding-left:30px;">. Everything went fine till I bumped across cases where&nbsp;the&nbsp;bound ReadOnlyBase property was actually ReadOnly (<em>CanWriteProperty(..) == false</em>) to the UI during the main BO editing process. There I found that no matter what, upon exiting the UserControl, the winform validation process ALWAYS triggered this property SETTER causing the exception in cases the property is actually not writable.</p>
<p style="padding-left:30px;">. My first thought, this time, was to check inside the <strong>setter</strong> if the property had actually changed:</p>
<p style="padding-left:60px;">if (ReadProperty(..) == value)</p>
<p style="padding-left:90px;">return;</p>
<p style="padding-left:60px;">... but I find this to be NOT elegant at all (<em>more or less like doing something wrong and then having to check upon it</em>).</p>
<p>So, as a result, I poped the issue on the forum.</p>
<p>All I want to do is bind ReadOnlyBase derived properties during main BO derived objects editing. Is there any simple workaround or suggestion around User Controls the way I&#39;m trying to build them?</p>
<p>I think its not practical to add&nbsp;1 extra BindingSource&nbsp;for each of these special UC on each edit form (<em>I can have more than 10 of these special UCs on one BO edit form</em>).</p>
<p>Once again, Jonny, thank you very much for your ideas and support <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p>
<p>Troncho</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, November 02, 2012</h2><p>Have you tried to specify DataSourceUpdateMode.Never on the DataBinding?&nbsp;</p>
<p><span><a href="http://msdn.microsoft.com/en-us/library/system.windows.forms.datasourceupdatemode.aspx">http://msdn.microsoft.com/en-us/library/system.windows.forms.datasourceupdatemode.aspx</a></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Troncho replied on Friday, November 02, 2012</h2><p>Thanks for the advice. I&#39;ll give it a try and get back to you with the results.</p>
<p>Troncho,</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>Troncho replied on Friday, November 09, 2012</h2><p>Hi Jonny. I&#39;ve followed your advice. I&#39;m setting DataSourceUpdateMode.Never when the control is ReadOnly and to DataSourceUpdateMode.OnPropertyChanged when not.</p>
<p>Its working perfectly well!!!</p>
<p>Thanks! Again!</p>
<p>Troncho <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
