<html><header><title>Help with largish object hierarchy</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Help with largish object hierarchy</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2786.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Gannet posted on Thursday, April 26, 2007</h2>I have a project we've been working on for a while now.&nbsp; We used C# and CSLA 2.0.&nbsp; It's our first CSLA project, although I did mess about with an early version of Rocky's ideas back in the "Visual Basic 5 Business Objects" days.<br><br>Everything went fairly smoothly when using small sets of data.&nbsp; But as we scaled up to production volumes, performance problems arose.<br><br>Specifically, we have something that looks like this:<br><br>An Outage has a collection of Steps, each of which has a collection of Transformers, each of which has a collection of Premises.<br><br>As to volume, one Outage has about 1 to 5 Steps, each of which have 1 to dozens of Transformers, each of which has one to dozens of Premises.&nbsp; In a worst-case situation one Outage has about 5,000 Premises.<br><br>In CSLA terms, we have this:<br><br>Outage - EditableRootParent<br>has a <br>StepList - EditableChildList<br>contains<br>Steps - EditableChild<br>each has a <br>TransformerList - EditableChildList<br>contains<br>Transformers - EditableChild<br>each has a <br>PremiseList - EditableChildList<br>contains<br>Premises - EditableChild<br><br>Using the normal CSLA model of having the Fetch of the EditableRootParent get all the data for all the children is, not surprisingly, quite slow if this particular Parent has a lot of great-grandchildren.&nbsp; The thing is, we normally don't need all the children.&nbsp; We only need them if the user wants to drill in via the GUI to manipulate the children.&nbsp; Even when he does that, we normally only need to manipulate particular subsets of children.<br><br>So.&nbsp; I'm sure we're somehow doing this wrong.&nbsp; I know what I would do with our old-style less-rigorous object architectures, but I don't know how to handle it with the DataPortal.&nbsp; <br><br>How can I do "partial" or "as-needed" data retrieval of children/grandchildren/great-grandchildren?<br><br>Or does it look like our basic object model is wrong?<br><br>Any help appreciated.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 26, 2007</h2><P>Given your description of the user experience, I'd suggest that you are merging a set of different use cases into one big use case, and the result is that you are creating one big object hierarchy, where you should actually have a set of much smaller, more focused, object hierarchies.</P>
<P>Remember that objects aren't driven by data, but rather they are driven by the application's requirements in terms of functionality and behavior (the use cases).</P>
<P>In a long-winded way I'm suggesting that your object model is wrong. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Friday, April 27, 2007</h2>A more specific suggestion to augment Rocky's post:<br><br>View 1: - Outage with Steps<br>- create editableroot Outage, the Outage can be edited in itself, independently of any children<br>- create readonly list StepList with readonly StepInfo objects, to be displayed in the same view<br>- when the user 'drills down; to a particular step, like you explain in your descripiton you get to the next view ... --&gt;<br><br>View 2 - Step with Transformers<br>- create editableroot Step which can be edited independenly, like Outage it has NO editable children<br>- again a readonly list: TransformerList with readonly TransformerInfo objects<br>- double click on a particular TransformerInfo will drill-down further just like in the Outage view<br><br>View 3 - Transformer with Premises<br>- you get the idea ...<br><br><br><br>This is just to give you an idea. The following benefits will result from a setup like described:<br><br>1 - you only fetch what you need, a dozen or so records at a time (Outage + Steps or Step + Transformers or Transformer + Premises)<br><br>2a - in my suggestion there is only 1 editable object per view (the root object), all children are readonly lists. This will give you another performance boost as the readonly objects are rather lightweight when compared to the editable version<br><br>2b - if you find that you need an editable root with editable children in order to have a view functioning according to your requirements then that is fine too. Simply skip the readonly lists and work with editable children as you do now. Since there are still only a dozen or so editable objects per view it should still perform perfectly fine. Note though that instead of your current 4-level hierarchcy of editable objects you will then only have 2 levels (root + children) at a time.<br><br>Hope this helps.<br>Bayu<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Gannet replied on Monday, April 30, 2007</h2>

<p class="MsoNormal">Thank you both for the replies, they are indeed helpful.<span>&nbsp; </span>Special thanks to Bayu for taking the trouble
to show me an alternative example.<span>&nbsp; </span>I'm
the sort of fellow who has a hard time learning other than by example.</p>



<p class="MsoNormal">I've read on the forum here many times that letting the data
dictate the object model is incorrect, but I'm having a hard time wrapping my
head around what other way there is to do it.<span>&nbsp;
</span>Suggested readings appreciated.</p><o:p></o:p><br>I'm starting to try and wrap my head around just how I would deal with things in Bayu's model.&nbsp; I may be back with more questions.&nbsp; )<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
