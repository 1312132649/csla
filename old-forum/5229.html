<html><header><title>SELECT COUNT(*)...</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>SELECT COUNT(*)...</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5229.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>COBRASoft posted on Monday, August 11, 2008</h2><P>Hi,</P>
<P>I'm quite new to CSLA.Net 2.0 and higher, so sorry if I say something stupid :)</P>
<P>I've seen the 'SELECT COUNT(*) FROM ...' structure to know if an object exists or not. Why not using a SPROC here and use the EXIST statement instead of the COUNT? EXIST returns after finding 1 row, COUNT keeps counting until all are found. Should be faster.</P>
<P>Also, when used in a SPROC, it would be easy to extend this functionality to check for child tables aswell. You could even go further and put this check in the same SPROC as the delete and return if the delete did happen. This makes the need of triggers unneeded and also doesn't require to load&nbsp;all child objects before deleting a parent object, again speed improvement.&nbsp;Here is an example...</P>
<P>Greetings,</P>
<P>Sigurd</P><FONT color=#0000ff size=1><FONT color=#0000ff size=1>
<P>CREATE PROCEDURE </FONT></FONT><FONT size=1>ArticleDelete<BR>@ARTL_ID </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>uniqueidentifier<BR>AS<BR>BEGIN<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SET NOCOUNT ON<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>DECLARE </FONT></FONT><FONT size=1>@Found </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>bit<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>@Found = 0<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>DECLARE </FONT></FONT><FONT size=1>@Result </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>bit<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>@Result = 0<BR><BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>IF EXISTS</FONT></FONT><FONT size=1>(</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>* </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>FROM&nbsp;</FONT></FONT><FONT size=1>Article </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ARTL_ID = @ARTL_ID)<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>@Found = 1<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>IF </FONT></FONT><FONT size=1>@Found = 0 </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>AND EXISTS</FONT></FONT><FONT size=1>(</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>* </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>FROM&nbsp;</FONT></FONT><FONT size=1>ArticleLanguage </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ALLG_ARTL_ID = @ARTL_ID)<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>@Found = 1<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>IF </FONT></FONT><FONT size=1>@Found = 0 </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>AND EXISTS</FONT></FONT><FONT size=1>(</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>* </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>FROM&nbsp;</FONT></FONT><FONT size=1>ArticleInfo </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ALIF_ARTL_ID = @ARTL_ID)<BR>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>SELECT </FONT></FONT><FONT size=1>@Found = 1</FONT></P>
<P><FONT size=1></P>
<P></P>
<P></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>IF </FONT></FONT><FONT size=1>@Found = 0<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>&nbsp;&nbsp;&nbsp;BEGIN<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DELETE FROM&nbsp;</FONT></FONT><FONT size=1>ArticleInfo </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ALIF_ARTL_ID = @ARTL_ID<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DELETE FROM&nbsp;</FONT></FONT><FONT size=1>ArticleLanguage </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ALLG_ARTL_ID = @ARTL_ID<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DELETE FROM&nbsp;</FONT><FONT size=1>Article </FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>WHERE </FONT></FONT><FONT size=1>ARTL_ID = @ARTL_ID<BR></FONT><BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT </FONT></FONT><FONT size=1>@Result = 1<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>&nbsp;&nbsp;&nbsp;END<BR></FONT></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1><BR>SELECT </FONT></FONT><FONT size=1>@Result<BR></FONT><FONT color=#0000ff size=1><FONT color=#0000ff size=1>END</FONT></FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, August 11, 2008</h2><P>This is in reference to the sample implementation in ProjectTracker? Thanks for the tip, that sounds useful.</P>
<P>I freely (and frequently) admit to being a developer, not a database guy. Which is why I am&nbsp;a strong supporter of using stored procedures (even in this era of ORMs).</P>
<P>I <EM>know</EM> my SQL skills are lame. I am just good enough to get the <EM>functionality</EM> I want, and I work with database experts who can fix my sprocs (and table designs, etc) to make them sing.</P>
<P>In my view, we're in a period of increasing specialization, much like the medical industry. It is unrealistic to expect an x-ray expert to do surgery, or for a surgeon to understand the deep nuances of x-ray results. Both experts have overlap in their skills, but neither is qualified to do the other's job.</P>
<P>I'm an OO specialist. I dabble in the UI (all 8 of the technologies in .NET), and I dabble in data access (all 7+ of those technologies in .NET) and I dabble in database design (at least that's just SQL - whew!). And while dabbling I do learn a lot, but I don't even pretend to be an expert in those areas.</P>
<P>And I don't even <EM>try</EM> to get into BizTalk/Sharepoint/MOSS/Office automation/etc. That way leads to madness :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>COBRASoft replied on Tuesday, August 12, 2008</h2><P>Hey Rocky,</P>
<P>I'm far from an expert either, but since I'm the only developer in my company, I have to&nbsp;try to be&nbsp;a bit all-rounder. Customers ask crazy things these days.&nbsp;WinForms, WebForms, WebServices, SharePoint&nbsp;and Office integration with support for 1000 users... All within the coming 6 months and starting from scratch&nbsp;<img src="/emoticons/emotion-2.gif" alt="Big Smile [:D]" /></P>
<P>Greetings,<BR>Sigurd</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, August 12, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>COBRASoft:</strong></div><div></P>
<P>...</P>
<P>I've seen the 'SELECT COUNT(*) FROM ...' structure to know if an object exists or not. Why not using a SPROC here and use the EXIST statement instead of the COUNT? EXIST returns after finding 1 row, COUNT keeps counting until all are found. Should be faster.</P>
<P>...</P>
<P></div></BLOCKQUOTE></P>
<P>If the WHERE clause is testing the primary key for equality, why would the database "keep counting"? There can be at most one entry anyway. Of course, I'm not sure if all database engines are smart enough to optimize this way. </P>
<P>We have to support various versions of MSSQL, Oracle, and Access, so the sproc approach is out and you can't generally do direct EXISTS tests in direct SQL except in your WHERE clause.(Some db's will let you use exists in the SELECT list)</P>
<P>Another approach similar to what you suggest would be to just attempt to retrieve the object key itself as a scalar. (e.g. SELECT KEY FROM TABLE WHERE KEY=xxx). If you get the value back, the object exists, otherwise you'd get NULL, meaning the object doesn't exist. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 12, 2008</h2>I think he's refering to what the db will actually do.&nbsp; With EXISTS, it will scan the index until it finds the specified key, and since it's an index its very easy to figure out if the key exists or not.&nbsp; But with count, it MAY have to look through the entire index... indexes aren't necessarly unique.&nbsp; Now, maybe Sql Server is smart enough when handing PK columns to know there can only be one... but maybe not.<br><br>Exists AFAIK is also part of the Sql-92 standard, so it should be available in all the majors db.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>COBRASoft replied on Tuesday, August 12, 2008</h2><P>Hi,</P>
<P>I don't know so much of other database engines, but I've tested on a very large SQL Server 2005 database with millions of records. The EXIST clause was defintely faster. The difference is even more noticable when you go through the 'foreign key tables aswell like in my sample. This trick&nbsp;is even faster than triggers (a lot faster).</P>
<P>Greetings,<BR>Sigurd</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Tuesday, August 12, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>COBRASoft:</strong></div><div> 
<P>Hi,</P>
<P>I don't know so much of other database engines, but I've tested on a very large SQL Server 2005 database with millions of records. The EXIST clause was defintely faster. The difference is even more noticable when you go through the 'foreign key tables aswell like in my sample. This trick&nbsp;is even faster than triggers (a lot faster).</P>
<P>Greetings,<BR>Sigurd</P>
<P></div></BLOCKQUOTE></P>
<P>I just tried COUNT(*)&nbsp;in SQL 2000 on a table with 2.5 million rows&nbsp;and if you are doing a COUNT(*) on a primary key value, it does a clustered index SEEK with an&nbsp;1&nbsp;as the&nbsp;both the estimated number of executes and&nbsp;resulting rows.</P>
<P>select count(*) from trans where transnumber='990407'</P>
<P>The query plan for the EXISTS was almost identical (but in fact just a hair&nbsp; more complex) as the COUNT(*):</P>
<P>SELECT case WHEN EXISTS (SELECT * FROM TRANS WHERE TRANSNUMBER='990407') then 1 else 0 end</P>
<P>So, for clustered primary keys in SQL Server 2000, COUNT(*) and EXISTS for a primary key value will perform almost identically.</P>
<P>I certainly would agree that EXISTS will do better for a nonunique or (especially) unindexed query. </P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>matt tag replied on Friday, August 15, 2008</h2><font size="2" face="Verdana">some other questions about your stored procedure:<br><br>1. shouldn't the IF @Found = 0 statement be @Found = 1?&nbsp; You want to delete only if you've found records.<br><br>2. Why bother checking to see if the records exists before deleting?&nbsp; The DELETE FROM statements do their own search/scan through the records.&nbsp; By searching/scanning yourself with IF EXISTS, you're actually doing 2 search/scans. Wouldn't this entire sproc be faster if it were just the 3 delete statements?<br><br>3. To optimize even further - your ArticleLanguage and ArticleInfo tables can be set with cascading delete referential integrity.&nbsp; Then the entire stored proc would consist of the single line<br><br>delete from Article where ARTL_ID = @ARTL_ID<br><br>Perhaps I'm misunderstanding something in what you're trying to accomplish...<br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>COBRASoft replied on Friday, August 15, 2008</h2><P>Hi,</P>
<P>The idea is to search for any related records, if at least 1 is found, no delete may happen becuase of concurrency.</P>
<P>The idea is this. You have a 'contact' table, a 'customer' table, a 'supplier' table, a 'user' table, a 'userrights' table, ... and so on. All of them have a&nbsp;1-1 relationship with&nbsp;'contact', 'userrights' has a 1-n relation with 'user'.&nbsp;What if I want to delete&nbsp;a customer? This customer could be a supplier or a user, but it is certainly a contact.&nbsp;With triggers this would already become more complex and you&nbsp;don't have much&nbsp;control what trigger would be fired first for the integrity check with those other tables. In my sproc you can safely check the smallest tables first (e.g. user). If found, no reason to search further, the delete of the 'contact'&nbsp;record must be canceled, so you gain speed, if nothing is found, the delete can be done.</P>
<P>Triggers can become a pain in th *ss. Specially when you have more than 300 tables in your database.</P>
<P>This sproc is not optimized completely, you could turn of the integrity checks, so the double scan won't happen.</P>
<P>Greetings,<BR>Sigurd</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
