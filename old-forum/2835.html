<html><header><title>Root object created from root object...</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Root object created from root object...</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2835.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>kbcb posted on Tuesday, May 08, 2007</h2><P>I have two root objects, Document and DocumentQueueItem.</P>
<P>When a new document is created, business requirements state that the document needs to be added to the document queue.</P>
<P>The problem I have is with where the&nbsp;DocumentQueueItem&nbsp;should be built and when it should be saved. It seems to me that with this being a business requirement/business logic, the DocumentQueueItem should be built and saved when the document is saved (which means the DataPortal_Insert method). My code would look like this:<BR><BR>class Document<BR>{<BR>&nbsp;&nbsp;&nbsp;void DataPortal_Insert( )<BR>&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using ( SqlConnection newConnection = new&nbsp;SqlConnection(...))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Call my database's procedure to insert&nbsp;my document object&nbsp;data</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocumentQueueItem newDQI = DocumentQueueItem.NewDocumentQueueItem(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newDQI.Save();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;}<BR>}</P>
<P>I did the above, and initially (at runtime) my program complained saying that MSDTC was not available. I figured out that this was because my DataPortal_Insert on Document creates and opens a new connection and that my DataPortal_Insert on DocumentQueueItem ALSO creates a new connection. MSDTC needed to be used because they are transacted methods. So,&nbsp;I started my "Distributed Transaction Coordinator" service and it worked just fine.</P>
<P>However, this doesn't seem right to me. I have heard that DTC is <EM>very</EM> slow, which, for such a commonly used part of my program, is not a good thing. </P>
<P>There has got to be a way for me to achieve this type of concept without overloading all my methods with a version that accepts a SqlConnection, and without testing whether or not my SqlConnection is in my LocalContext all the time.</P>
<P>Any help on the issue would be great. Thanks!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 08, 2007</h2><P>You must be using a TransactionScope? Otherwise the DTC wouldn't come into play.</P>
<P>First thing to consider: if you are only talking to one database, even multiple tables, you <EM>do not</EM> need the DTC. You can get transactional protection purely through ADO.NET transactions, or through TransactionScope local transactions.</P>
<P>What is happening to you is that you are being hit by a well-known oversight of TransactionScope. It turns out that TransactionScope enlists the DTC as soon as you open a second database connection - even if it is to the same database (which you'd think it shouldn't).</P>
<P>So what you need to do is open one database connection and reuse it across all your objects. This is the reason I added Csla.ApplicationContext.LocalContext - you can see examples of using it in my ebook.</P>
<P>However, in your case there's a twist, because your second root object would need to use the pre-opened connection, which is not normal. My suggestion though, is to just see if LocalContext has the connection, and only open a connection if you need it, otherwise just use the connection from LocalContext.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>kbcb replied on Tuesday, May 08, 2007</h2><P>Any idea why it is that the DTC is not smart enough to figure this out?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 08, 2007</h2>It is the transactionscope object's job to do this. I think this is an oversight in version 1 of the transactionscope feature.<br /><br />Rocky <br /><br /><br />-----Original Message-----<br />From: "kbcb" <br />To: "rocky@lhotka.net" <br />Sent: 5/8/2007 6:59 PM<br />Subject: Re: [CSLA .NET] Root object created from root object...<br /><br />Any idea why it is that the DTC is not smart enough to figure this out?<br /><br /></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
