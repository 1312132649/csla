<html><header><title>Responsibility driven design or database structure?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Responsibility driven design or database structure?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11983.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>c_manboy posted on Wednesday, May 15, 2013</h2><p style="margin:0in 0in 8pt;" class="MsoNormal"><span style="font-size:small;"><span style="font-family:Calibri;">My use case scenario has defined these objects: Employee, User, Client.<span style="mso-spacerun:yes;">&nbsp; </span>My database is structured similar to inheritance where the base table is named Entity (id, displayname) with a one to one relationship to Person(entityId, firstname, lastname) with a one to one to Employee/User/Client(entityId, &hellip;) tables each containing their unique fields. An Entity can be one or all three of the use case objects.</span></span></p>
<p style="margin:0in 0in 8pt;" class="MsoNormal"><span style="font-size:small;"><span style="font-family:Calibri;">I&rsquo;ve created working business objects using code generation which creates an Entity with child property of Person with child properties for Employee, User and Client.<span style="mso-spacerun:yes;">&nbsp; </span>Everything is fairly straightforward in that binding is done using dot notation like Entity.Person.Employee.HireDate.<span style="mso-spacerun:yes;">&nbsp; </span>I&rsquo;ve also created properties IsEmployee, IsClient, IsUser which checks for null on those properties.</span></span></p>
<p style="margin:0in 0in 8pt;" class="MsoNormal"><span style="font-size:small;"><span style="font-family:Calibri;">In Rocky&rsquo;s book he talks about responsibility driven design which seems to infer that my business objects should be redesigned like Employee(entityId, displayname, firstname, lastname, hiredate).<span style="mso-spacerun:yes;">&nbsp; </span>But this would create challenges when updating the database.<span style="mso-spacerun:yes;">&nbsp; </span>(I&rsquo;m using ado for data access).</span></span></p>
<p style="margin:0in 0in 8pt;" class="MsoNormal"><span style="font-size:small;"><span style="font-family:Calibri;">I haven&rsquo;t run into any real problems with my current business object design, but in my desire to understand best practices I am curious if I should redo my business objects, perhaps learning and implementing EF as a my data access?</span></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ColourHaze replied on Thursday, May 30, 2013</h2><p>Interesting case! I&#39;m using the exact same approach, where there is one central authority for issueing identities. I was (and still am) struggling with the design.</p>
<p>what rocky describes, as i believe, is more about behaviour (bdd) and use case driven modeling. This means focus is on loose coupling and little reuse when it comes to properties (data holders) however more on behaviour!</p>
<p>My advice: keep the entity table, a single person table containing the necesary fields and create the three classes. You will find it to be more easy to maintain i think.</p>
<p>please let me know what you mean with difficulties on using ado. I think ef is to blunt in general!</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 31, 2013</h2><p>The design approach I advocate is that your business objects should reflect your business requirements for the user scenario, not <em>necessarily</em> the shape of the database.</p>
<p>Sometimes the shape of the business scenario is the same as the shape of the database tables - that happens a lot in simple data maintenance scenarios and simpler apps.</p>
<p>Most apps do have more complex scenarios where the user must interact with numerous &quot;tables&quot; or &quot;entities&quot; - usually only in bits and pieces - to accomplish their task. It is in these user scenarios that an &quot;entity based&quot; or data-centric object model will really cause you a lot of pain, via performance problems and radically increased complexity in the app overall (especially in the presentation layer).</p>
<p>CSLA is designed to support behavior or responsibility based object design. Again, in some user scenarios the object behaviors require data that is pretty directly the same as tables, so the objects look like tables. But if you use CSLA to create data-centric objects for the more complex user scenario implementations of your app you can&#39;t blame me if your performance, scalability, or maintainability are poor, because that&#39;s the fault of a flawed object design.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 31, 2013</h2><p>One way to look at this too, is that if you need to use a viewmodel to reshape your CSLA objects to match the shape of your UI requirements, then your CSLA object model is not correctly designed.</p>
<p>In other words, using a viewmodel to reshape a CSLA business object is a clear anti-pattern.</p>
<p>(this is not to say that a viewmodel isn&#39;t a good idea, especially in a XAML world&nbsp;- but the viewmodel should be adding _actions_ or _verbs_ for UI purposes, not reshaping the properties of the business objects)</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
