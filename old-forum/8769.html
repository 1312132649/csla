<html><header><title>ASP.NET thread safety question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ASP.NET thread safety question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8769.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz posted on Monday, April 05, 2010</h2><p>Hi all</p>
<p>I&#39;m starting a new ASP.NET WebForms project. Using CSLA of course. Nearly all my CSLA work until now has been WinForms.</p>
<p>I&#39;d appreciate it if someone could confirm my understanding of basic thread safety. Sorry if this is a bit off topic. It&#39;s something I really should know well by now.</p>
<p>Static methods are bad, especially if they have local variables. Right?</p>
<p>In WinForms I often have a &quot;helper&quot; class with a few static methods to do common tasks but in WebForms I need to be careful of anything that would go wrong if the O/S interrupted it and code for another thread / user started the method from the beginning.</p>
<p>But instance methods are generally okay. Right?&nbsp; So with helper type methods, an easy solution is to make them instance methods. I would obviously need to instantiate the class before calling the method.</p>
<p>Then there is the common data stuff like a list of countries or states or whatever. In WinForms I tend to cache those in static variables and I have to admit that I&#39;ve never really worried too much about thread safety because my apps haven&#39;t been multi-threaded. I&#39;ve done the typical lazy loading / singleton type of thing. If the variable is null, load it from the db but any future access gets it straight from the static variable.&nbsp; For this sort of thing, should I continue like that but be careful about it or should I use the ASP.NET cache? Maybe there is not right or wrong answer there. I have seen articles and blog posts etc on how to do the static variable singleton properly in an efficient thread safe manner. eg http://www.yoda.arachsys.com/csharp/singleton.html</p>
<p>I&#39;m leaning towards the ASP.NET cache because I guess that&#39;s what it&#39;s there for.</p>
<p>Thanks</p>
<p>Ross</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>ajj3085 replied on Tuesday, April 06, 2010</h2><p>I think you have it backwards.&nbsp; Static methods are fine, so long as they don&#39;t modify the values of static fields / properties.&nbsp; If that&#39;s true, the method itself is thread safe.</p>
<p>For instance objects, unless you build in thread safety, there is none.&nbsp; So two threads &quot;using&quot; the same instance will get you into trouble, unless the instance is designed to be thread safe.&nbsp; Most instance classes are not.</p>
<p>If you implement the Singleton pattern, using&nbsp;a static backing field, you would need to do sycronization yourself.&nbsp; I think the Asp.Net cache is thread safe, but check the documentation.&nbsp; Even so you might still trip up.</p>
<p>Consider this code behind:</p>
<p>if ( Cache[ &quot;myKey&quot; ] == null ) {</p>
<p>&nbsp;&nbsp; Cache[ &quot;myKey&quot; ] = MyBoList.Get();</p>
<p>}</p>
<p>If you have two threads executing that code, thread 1 could pass the if test, then enter the block but be suspended.&nbsp; Thread 2 could pick up, execute the if and the Get portions and get suspended.. back to thread 1, which would execute Get a second time.</p>
<p>Now, that probably doesn&#39;t matter... you&#39;ve gone from a db hit every call to at most two, and then your results are cached.&nbsp; But you should be aware.</p>
<p>At least, that&#39;s my understanding, so I hope someone will correct me if I&quot;m wrong!</p>
<p>HTH</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, April 06, 2010</h2><p>Andy is correct.</p>
<p>static fields and properties are problematic, because they are shared across all threads in the appdomain (virtual root), and without locking or other techniques they are never safe.</p>
<p>static methods that don&#39;t use global data (atomic, stateless methods) are safe because each method call runs on a different thread with its own call stack so nothing is shared between invocations of the method.</p>
<p>Instances of objects are fine as long as each thread gets its own instance of the type. In other words, if you create an instance of an object and give it <i>exclusively</i> to a thread, that&#39;s safe because the data and behavior in that object aren&#39;t really multithreaded because they are being used by exactly one thread. This is what ASP.NET itself does when it creates your page object - it hands it to your primary thread and no other thread touches it from that point forward.</p>
<p>Instances of objects that are used by more than one thread is back into multi-threading land, and there is absolutely nothing that makes this automatically safe. It is entirely up to you. Also you must remember that the vast majority of .NET is not threadsafe, including things like ADO.NET. Making this work is really, really hard and should generally be avoided.</p>
<p>Caching object instances in a static field then, combines the two most complex concepts (shared data, shared object instance) and should generally be avoided.</p>
<p>Caching object instances in System.Web.Caching must be done with care too, because the cache maintains references to objects. It doesn&#39;t serialize or clone the objects - so it is quite possible for more than one thread to end up interacting with the object instance.</p>
<p>Caching read-only objects is generally fine, because you don&#39;t run into concurrency issues. If no thread changes the data, then there&#39;s no chance for conflict. </p>
<p>However, caching read-only CSLA objects can be a little tricky because the authorization rules in a ReadOnlyBase object drive off the current principal. As the object switches from thread to thread, the principal changes (each thread has a different HttpContext). Like most of .NET, CSLA isn&#39;t threadsafe and you&#39;ll get unpredictable results from your authz rules in this scenario. In other words, you can cache a read-only CSLA object as long as it doesn&#39;t contain authz rules.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz replied on Tuesday, April 06, 2010</h2><p>Thanks Rocky and Andy. That&#39;s clarified a few things.&nbsp; I didn&#39;t realize that with static methods, each thread gets its own local variables.</p>
<p>I&#39;m mostly concerned with read-only data so the ASP.NET cache is probably my best way to go for most things. The data can be set to expire which is useful.</p>
<p>If seems that you&#39;re right, Andy in that the typical use of the cache is to check for the data and then query and insert if it&#39;s not there. You don&#39;t need to do anything special but, as you say, the db might be hit more than once if several threads want the same data at almost the same time.</p>
<p>Cheers<br />Ross</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>CBL replied on Saturday, July 30, 2011</h2><p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">Please forgive the newbie questions, but I thought I had taken the safe and easy route... and now I have discovered my application locks up my server under heavy load.</span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">I have an ASP.NET (Wed Forms) application that uses CSLA and business objects generated by CodeSmith.</span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">Everything seems to work fine, but when under a load I get errors in BusinessBase (CanReadProperty)&nbsp;that from many threads all seem to point to code as not being thread-safe.</span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">Here I know just enough to be dangerous.<span style="mso-spacerun:yes;">&nbsp; </span>I have used code before that spins up threads.<span style="mso-spacerun:yes;">&nbsp; </span>But, here I&rsquo;m just building a vanilla ASP.NET application, no threading in code.</span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">So my question is in general: <span style="mso-spacerun:yes;">&nbsp;</span>what on earth am I doing wrong?<span style="mso-spacerun:yes;">&nbsp; </span>(Besides using this framework and code generator that are over my head.)<span style="mso-spacerun:yes;">&nbsp; </span>Do I need to do something special in ASP.NET to use CSLA?<span style="mso-spacerun:yes;">&nbsp; </span></span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">I do have 2005 and 2008 books&hellip; but I&rsquo;m using the latest CodeSmith templates and CSLA 4.1.<span style="mso-spacerun:yes;">&nbsp; </span>I&rsquo;m down the road on my project (and now in panic mode), so anything you can do to point me in the right direction would be appreciated.</span></span></p>
<p class="MsoNormal" style="MARGIN:0in 0in auto;"><span style="font-size:small;"><span style="font-family:Calibri;">Thank you.</span></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, July 30, 2011</h2><p>Are you somehow sharing an object instance across threads? This can happen if you use a static field to store an object reference, or if you are using in-proc state and use the Application object. In some cases it can happen with in-proc state and the Session object if a user/browser causes mutliple overlapping calls to the server (usually when the client is using AJAX).</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
