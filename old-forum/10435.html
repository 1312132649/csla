<html><header><title>Silverlight - BeginCreate vs CreateChild</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Silverlight - BeginCreate vs CreateChild</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10435.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH posted on Monday, June 13, 2011</h2><p>Why is DataPortal.CreateChild() synchronous while DataPortal.BeginCreate() is asynchronous.&nbsp; What is the thought behind that design decision?</p>
<p>It&#39;s a bit confusing from a UI consumption standpoint.&nbsp; For example, if I create a root, I expose a New method that returns void, but accepts a callback:</p>
<p>Root.<strong>NewRoot</strong>((s, e) =&gt; { _myRoot = e.Object}</p>
<p>However, when adding a child to the root, it&#39;s different, as creating a child via DataPortal.CreateChild():</p>
<p>Child child = Child.<strong>NewChild</strong>();&nbsp; // Invokes DataPortal.CreateChild()</p>
<p>_myRoot.Children.Add(child);</p>
<p>This is very confusing.&nbsp; Is there a better, more intuitive way to implement this?</p>
<p>Thanks!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 13, 2011</h2><p>The data portal has two &quot;modes&quot;: root and child.</p>
<p>Create, BeginCreate, Fetch, BeginFetch, Update, BeginUpdate, Delete, BeginDelete, Execute, and BeginExecute are all root methods - they operate on root objects.</p>
<p>The XyzChild methods are child methods - they operate on child objects.</p>
<p>Only root objects can be directly created, retrieved, updated, or deleted. Child objects are always created, retrieved, updated, or deleted by their parent - and that&#39;s ultimately controlled by the root.</p>
<p>This is described in the <em>Using CSLA 4</em> ebook series, and the older <em>Expert Business Objects</em> books. The concept of a root vs a child object is central to the data portal and data access models supported by CSLA .NET.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 13, 2011</h2><p>I suppose to more directly answer your question, I should point out that, in Silverlight, the data portal can be used in local or remote mode.</p>
<p>The reason the XyzChild methods exist in Silverlight is purely to support the local mode - where the root object of the object graph is being created/retrieved on the client (presumably by calling a service), and it then uses the results of the service call to populate itself and its child objects with data.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH replied on Monday, June 13, 2011</h2><p>Hi Rocky, this still doesn&#39;t explain why DataPortal.FetchChild() is implemented as a synchronous method within the Silverlight CSLA implementation.</p>
<p>Again, this is confusing behavior, as creating a new root object requires a callback function, and creating a new child object does not (because it&#39;s synchronous).&nbsp; This leads to very different implementations behind the scenes, too.&nbsp; For example:&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">public</span>&nbsp;<span style="COLOR:blue;">partial</span>&nbsp;<span style="COLOR:blue;">class</span>&nbsp;<span style="COLOR:#2b91af;">Root</span><br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">public</span>&nbsp;<span style="COLOR:blue;">static</span>&nbsp;<span style="COLOR:blue;">void</span>&nbsp;NewRoot(<span style="COLOR:#2b91af;">EventHandler</span>&lt;<span style="COLOR:#2b91af;">DataPortalResult</span>&lt;<span style="COLOR:#2b91af;">Root</span>&gt;&gt;&nbsp;handler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:green;">//&nbsp;Create&nbsp;a&nbsp;new&nbsp;object,&nbsp;invoke&nbsp;business/auth&nbsp;rules,&nbsp;set&nbsp;default&nbsp;values,&nbsp;and&nbsp;return&nbsp;the&nbsp;new&nbsp;instance&nbsp;via&nbsp;callback</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:#2b91af;">DataPortal</span>.BeginCreate(handler,&nbsp;<span style="COLOR:#2b91af;">DataPortal</span>.<span style="COLOR:#2b91af;">ProxyModes</span>.LocalOnly);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"><pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"><pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"><pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"> &nbsp;<span style="COLOR:blue;">public</span>&nbsp;<span style="COLOR:blue;">partial</span>&nbsp;<span style="COLOR:blue;">class</span>&nbsp;<span style="COLOR:#2b91af;">Child</span></pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"><span style="COLOR:#2b91af;"></span>&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">public</span>&nbsp;<span style="COLOR:blue;">static</span>&nbsp;<span style="COLOR:#2b91af;"><span style="COLOR:#2b91af;">Child </span></span>NewChild()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:green;">//&nbsp;Create&nbsp;a&nbsp;new&nbsp;object,&nbsp;mark&nbsp;it&nbsp;as&nbsp;a&nbsp;child,&nbsp;invoke&nbsp;business/auth&nbsp;rules,&nbsp;set&nbsp;default&nbsp;values,&nbsp;and&nbsp;return&nbsp;the&nbsp;new&nbsp;instance</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">return</span>&nbsp;<span style="COLOR:#2b91af;">DataPortal</span>.CreateChild&lt;<span style="COLOR:#2b91af;"><span style="COLOR:#2b91af;">Child</span></span>&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;}</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">&nbsp;</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"></pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">As you can see, the implementations of both are VERY different, as are the way they are consumed by the UI.  </pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"></pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">Wondering:</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"></pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">1.) What the reasoning behind exposing CreateChild() as a synchronous method is</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">2.) Is there a better way to keep implementations and consumption patterns more consistent, </pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">but still gain the benefits of creating a root vs. child appropriately</pre>
</pre>
</pre>
</pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, June 13, 2011</h2><p>I guess I could have phrased that better.</p>
<p>Only the root data portal moves the call from the logical client to the logical server. The child data portal <em>never crosses a layer/tier boundary</em>.</p>
<p>That&#39;s true in .NET, and it is true in SL.</p>
<p>So your BeginCreate call moves from the logical client to the logical server. Starting at your DataPortal_Create method, all code is &quot;server-side code&quot;.</p>
<p>All server-side code is synchronous - within the context of the server. Again, true on .NET and true on SL. The entire object graph must be created, populated, and fully established in memory before the server-side call (DataPortal_Create) completes.</p>
<p>Just think how much &quot;fun&quot; you&#39;d have if the child data portal was async. You&#39;d have to manually write threading code to ensure that the DataPortal_Create method didn&#39;t complete until all your async operations were done. And you&#39;d have to do this without blocking the UI thread and locking the browser.</p>
<p>In .NET v.next this will be easier (with the new async/await features). But those new async features probably won&#39;t get to SL until SL6.</p>
<p>Ultimately, to avoid the nightmarish fallout of forcing everyone to write complex threading code to populate their object graphs when using the local data portal in SL - I made the SL child data portal work exactly like the .NET one.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
