<html><header><title>CSLA Memory Management</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Memory Management</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8590.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bharat0204 posted on Monday, March 01, 2010</h2><p>we&nbsp;built an extensive application upon the CSLA framework with about 50+ business objects.None of my BO&#39;s are implementing IDisposable. I also started running some memory tracing/profiling applications (ANTS) on the site.&nbsp; I&#39;ve noticed several things here.&nbsp; Many (in fact, most) of my BO&#39;s are kept in memory up to age 15 or 18 sometimes. I expected that they would have been taken care of by GC long before age 18 or even age 10 for that matter.&nbsp;</p>
<p>So a few questions...</p>
<ol>
<li>Does CSLA classes implementing Idispose() or destructor or do i need to implement my own for all CSLA Classes.</li>
<li>Application is taking 5-10 seconds to fetch the records on page while SP is optimized and taking no time in exection.</li>
<li>how to free memory or clean up in CLSA to high or upgrade&nbsp;performnace.</li>
<li>it recomended to use destructor in class but as i am using csla framework so need to assure whether to use or not in classes.</li>
<li>there is very less or no use of unmanaged code as application is mainly to fetch records from database and add/update/delete operation.</li>
</ol>
<p>Can anyone help provide some advice on how to track down or how to increase the performance of Application.</p>
<p>please help.<br /><br />Thanks for your help.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, March 01, 2010</h2><p>IDisposable is useful only if your objects hold references to (typically unmanaged) resources that should be freed as early as possible. If your objects only hold references to other managed objects, IDisposable is essentially useless. The only exceptions come in when you hold a reference to a large object (like a big image) or have hooked a static event or an event from some other object that is never reclaimed (like a singleton).</p>
<p>In an n-tier deployment, IDisposable is virtually impossible to actually use. An object can implement it, but since the object is cloned back and forth across the network it becomes nearly impossible to actually dispose all the clones of all the objects. Even without that problem, we&#39;re talking about object graphs here - entirely families of objects - and looping through an entire object graph to call Dispose() on each of them is non-trivial.</p>
<p>Which is why normal managed objects don&#39;t implement IDisposable - CSLA or not - it is just impractical to build your own reference tracking mechanism to make these calls - especially when they provide no value in most cases.</p>
<p>It is actually <em>not</em> recommended to implement a finalizer in managed types. That forces the GC to go through extra work to get rid of the object. In fact, it is a best practice to use IDisposable to explicitly tell the GC to ignore the finalizer, because otherwise the object remains in memory longer than anyone would like. Though you are right - if you implement IDisposable, you should implement a finalizer - <em>if your object holds a reference to a non-managed type</em> like a database connection or file handle. This is because, in the case that the app has a bug and doesn&#39;t call Dispose(), you still do need to properly close the unmanaged resource. But that is a last-ditch effort to overcome the fact that somebody messed up and didn&#39;t call Dipose() like they were supposed to.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, March 01, 2010</h2><p>If you are using a profiler, then you should be able to determine where the application is spending its time in loading the data.</p>
<p>You say you already know it isn&#39;t the sproc - so that&#39;s good. Is it in your DAL, where the objects are loaded with data? Is it in serialization as the objects are moved from the app server to the web server (if you are in 3-tier deployment)? Is it in the UI layer where the UI is bound to the objects and the data is used to render the HTML?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bharat0204 replied on Tuesday, March 02, 2010</h2><p>thanks Andy for your suggestion and idea.</p>
<p>so my point is do i implement destructor in classes ..is it good or bad or helpful.</p>
<p>as my application is just UI and CSLA lib. means somethg two tier application.</p>
<p>and i need to do memory cleanup in application.</p>
<p>please suggest.</p>
<p>&nbsp;</p>
<p>thanks and waiting for your reply.</p>
<p>bharat</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, March 02, 2010</h2><p>Well as Rocky said you really DON&#39;T want to implement a Finalizer (there are no destructors in .Net), unless you have unmanaged resources, which if you&#39;re doing standard Csla stuff you likely won&#39;t.</p>
<p>I would really check your code where you wire up event handlers, especially if you&#39;re doing events to static / Singleton objects.&nbsp; The event handlers can cause objects to be kept in memory, so you really should be unhooking them when you&#39;re done with the objects.&nbsp; That&#39;s usually the culprit.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>richardb replied on Wednesday, March 03, 2010</h2><p>I&#39;ve found that the CSLA and business objects I write rarely give me performance issues.&nbsp; If they do, it&#39;s because I&#39;ve done something stupid like bring back too many rows or written some inefficient SQL statements.</p>
<p>Where I have had performance issues is in binding objects to WPF controls, and as the previous post said I&#39;ve also had objects hang around in memory due to not unhooking the event handlers.&nbsp; The Red Gate tools helped me out there showing the memory tree and what was holding on to my objects (oddly it was the Infragistic control keeping the control alive, the form it was on and hence the objects that were created.&nbsp; </p>
<p>So again, that&#39;s either me not unhooking things, a control &quot;issue&quot; and/or WPF controls&nbsp;not being as quick as&nbsp;they could be.</p>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
