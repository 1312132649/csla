<html><header><title>2.1.4: Multi-threading issues with ReadOnlyBase.CanReadProperty</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>2.1.4: Multi-threading issues with ReadOnlyBase.CanReadProperty</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4530.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream posted on Thursday, March 20, 2008</h2><P>We have a class that inherits from ReadOnlyBase&lt;T&gt; (CSLA.NET version 2.1.4).&nbsp; In our ASP.NET web application only a single instance of this class exists, which is being cached.&nbsp; Therefore, it's a Singleton instance.</P>
<P>Under heavy load conditions, we're noticing an exception that gets thrown periodically when the CanReadProperty method is called on certain properties.&nbsp; The exception is:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT face="Courier New" size=2>System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary</FONT></P></BLOCKQUOTE>
<P>And it occurs at the red line shown below within this CanReadProperty method overload in the ReadOnlyBase&lt;T&gt; class:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT face="Courier New" size=2>public virtual bool CanReadProperty(string propertyName)<BR>{<BR>&nbsp; bool result = true;</FONT></P>
<P><FONT face="Courier New" size=2>&nbsp; VerifyAuthorizationCache();</FONT></P>
<P><FONT face="Courier New" size=2>&nbsp; if (_readResultCache.ContainsKey(propertyName))<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; // cache contains value - get cached value<BR>&nbsp;&nbsp;&nbsp; <FONT><FONT color=#ff0000>result = _readResultCache[propertyName];</FONT><BR></FONT>&nbsp; }<BR>&nbsp; else<BR>&nbsp; {</FONT></P></BLOCKQUOTE>
<P>This seems like a threading issue and after doing some digging into the CSLA.NET source code I see that the _readResultCache private field (of type Dictionary&lt;string,bool&gt;) is used by ReadOnlyBase&lt;T&gt; to cache authorization rule results by property name.&nbsp; However, that dictionary object is being cleared by the VerifyAuthorizationCache method whenever the current user (IPrincipal) changes.&nbsp; In a multi-threaded web environment where each request potentially has a different IPrincipal instance, this clearing of the readResultCache object is happenning quite frequently.&nbsp; And if one thread clears it just before another thread executes the above line of code, I can see where the KeyNotFoundException would occur.</P>
<P>I know Rocky did some bug-fixing in the SharedAuthorizationRules class (which gets called if a property authorization result is not in the _readResultCache) which fixed some race conditions related to multi-threaded environments.&nbsp; We've actually patched our CLSA.NET 2.1.4 codebase with this fix, which fixed a past issue we had.</P>
<P>However, this problem&nbsp;is a different issue.&nbsp; Is there a known work-around or perhaps another bug fix?&nbsp; I looked into the SVN repository for the ReadOnlyBase&lt;T&gt; and didn't see anything too promising in the revisions after the 2.1.4 release.&nbsp; If you go past the CSLA.NET 3.0 revisions, Rocky has completely rewritten the property infrastructure altogether.</P>
<P>If I can't effectively patch our version of CSLA.NET based on existing code in the SVN repository, I'm considering the following options:</P>
<OL>
<LI>Not call the CanReadProperty from the property-getters of this class (and therefore loosing the benefits of CSLA authorization rules) 
<LI>Add synchronization code (i.e. a lock block) around the logic in the CanReadProperty method.&nbsp; Given the high number of accessing threads.&nbsp; This could turn into a performance bottleneck. 
<LI>Code in&nbsp;a mechanism in the ReadOnlyBase that optionally short-curcuits the readResultCache cache to avoid the multi-threading issue.&nbsp; In the case with this class, I don't think we're gaining much from the caching anyway.&nbsp; This third approach is currently my best candidate.</LI></OL>
<P>Thoughts?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, March 23, 2008</h2><P>CSLA objects are not threadsafe. That's not a design goal either, so it isn't likely to change.</P>
<P>Like with .NET itself I try to make sure the static/Shared methods are threadsafe, but instance methods/properties are absolutely not threadsafe.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, March 23, 2008</h2><P>I'll offer another alternative though:</P>
<P>4. Since this is a singleton, make sure all threads access it through a singleton accessor, and use locking in that accessor to ensure that only one thread can use the singleton object at a time - thus meeting the threading constraints of CSLA. This should make it work - but I suppose will still eliminate the benefit of the authorization results caching that would otherwise occur.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Monday, March 24, 2008</h2><P>You have a good point and I think the alternative you've suggested is what I will do.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Monday, March 24, 2008</h2><P>Hold on.&nbsp; I take that back.&nbsp; Putting lock code around the Singleton accessor will not solve the problem since that will only ensure that the <EM>retrieval</EM> of the object is thread-safe.&nbsp; But once the caller has the object instance, calling read-only properties on that object will still not be thread-safe.&nbsp; </P>
<P>Putting lock statements around each property getter in your business object doesn't do the trick either since thread 1 could be calling PropertyA and thread 2 could be calling PropretyB and clear the authorization results cache just before thread 1 hits the line shown in red in the original post and we'll get the KeyNotFoundException again.</P>
<P>Locking needs to be done around the instance itself and all interactions with that instance.&nbsp; The problem is the only place that could be done would be in the caller's code.&nbsp; Providing the caller with a nice Singleton read-only business object, but then requiring them to put locking code around it whenever it's used is a bit pointless.</P>
<P>So this takes me back to my option #3 where a mechanism needs to be provided by the ReadOnlyBase&lt;T&gt; class that makes it thread-safe when calls to the CanReadProperty are made in a multi-threaded environment.&nbsp; My idea was to provide a virtual property called RequireThreadSafety that defaults to false and, when overriden by a subclass and returned true, would bypass the authorization results caching altogether, eliminating the multi-threading issue.&nbsp; The authorization results cache doesn't give you much value anyway in a multi-threaded environment where the current principal is potentially different with each thread.</P>
<P>If what I'm saying is correct (and I'm not saying it is), this might represent a design issue with the ReadOnlyBase&lt;T&gt; class since it currently provides no way for the business object developer to make his/her Singleton business object class thread-safe.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, March 24, 2008</h2>Well you could have a single object upon which you lock, and every property read would need to lock for the entire read.&nbsp; This will create a bottleneck, but you have no choice if the access must be done by a single thread only.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Monday, March 24, 2008</h2><P>You're absolutely right.&nbsp; For some reason I was thinking that this approach would only provide thread safety if another thread was accessing the same property.&nbsp; However, a lock object (similar to the SyncRoot object found on most collections) would do the trick.&nbsp; We could just have a private field of type object like this:</P>
<P><FONT face="Courier New" size=2>private readonly object instanceLock = new object();</FONT></P>
<P>And then lock on it like this:</P>
<P><FONT face="Courier New" size=2>public string PropertyA<BR>{<BR>&nbsp; lock (this.instanceLock)<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; this.CanReadProperty(true);<BR>&nbsp;&nbsp;&nbsp; return this.propertyA;</FONT><FONT face="Courier New" size=2><BR>&nbsp; }</FONT><FONT face="Courier New" size=2><BR>}</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
