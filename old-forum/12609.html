<html><header><title>HttpContext.Current is null in server-side DataPortal methods?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>HttpContext.Current is null in server-side DataPortal methods?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12609.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>PeteK posted on Monday, May 05, 2014</h2><p>Hi,<br /><br />I&#39;m gradually introducing CSLA into our existing application. It&#39;s a MVC / Silverlight app using WCF services hosted in IIS.<br /><br />For each&nbsp;WCF&nbsp;call, the existing code creates and stores an&nbsp;EF DbContext&nbsp;in HttpContext that is then used for the duration of that call (the DbContext is created / destroyed in the&nbsp;HttpApplication&#39;s BeginRequest / EndRequest event handlers).<br /><br />As I&#39;m gradually adding CSLA business objects into the mix, I&#39;ve come across an issue where the HttpContext.Current ends being null within the DataPortal XYZ methods. I need access to HttpContext so that my CSLA business objects (from their server-side DataPortal XYZ methods) can calls some of the pre-existing code that relies on HttpContext containing the EF DbContext used for managing database access.<br /><br />Below is an example of the code I&#39;m using:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; public async static Task&lt;ReportQuery&gt; ExecuteAsync(ReportCriteria criteria)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var cmd = new ReportQuery { ReportCriteria = criteria };<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cmd = await DataPortal.ExecuteAsync&lt;ReportQuery&gt;(cmd);<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return cmd;<br /> &nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p><span></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;protected async override void DataPortal_Execute()<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// This is where System.Web.HttpContext.Current is NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br />I added breakpoints to the&nbsp;HttpApplication&#39;s BeginRequest and EndRequest event handlers (that are wrapped around the call to my CSLA DataPortal XYZ methods), and was able to confirm that&nbsp;HttpContext.Current did contain a &#39;real&#39; value. Unfortunately, this&nbsp;HttpContext does not make its way further down the chain to the&nbsp;CSLA DataPortal XYZ methods.<br /><br />I&#39;ve tried quite a few things,but no luck yet. I made sure to include the following in Web.config, to ensure that HttpContext is accessible within WCF:<br /><br />&lt;serviceHostingEnvironment aspNetCompatibilityEnabled=&quot;true&quot; /&gt;<br /><br />Any ideas?<br /><br />Thanks,<br />Pete&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>ajj3085 replied on Monday, May 05, 2014</h2><p>I think the async dataportal method is causing you execute code to run in a new thread, which would not have access to the http context.&nbsp; You can verify this by looking at the Thread.CurrentThread.ManagedThreadId property where you have the http context and you don&#39;t.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>PeteK replied on Tuesday, May 06, 2014</h2><p>Hi Andy,</p>
<p>Yep, you&#39;re right. Stepping through the code, I noticed that the HttpContext.Current was getting &#39;lost&#39; when the CSLA WcfPortal makes the call to (and awaits) the BO&#39;s async DataPortal_XYZ() methods:</p>
<p>In WcfPortal.cs:<br /><br />&nbsp; &nbsp; public async Task&lt;WcfResponse&gt; Fetch(CriteriaRequest request)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; &nbsp; &nbsp; // HttpContext.Current contains a VALUE.<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;var fetchResponse = await processor.Fetch(fetchRequest).ConfigureAwait(false);<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; &nbsp; &nbsp; // HttpContext.Current is now NULL.<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; }</p>
<p>The above line of code calls my business object&#39;s&nbsp;DataPortal_Fetch() method:<br /><br />&nbsp; &nbsp; private void DataPortal_Fetch(Criteria criteria)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; &nbsp; &nbsp; // HttpContext.Current is now NULL.<br />&nbsp; &nbsp; &nbsp; &nbsp; .......................................<br />&nbsp; &nbsp; }&nbsp;<br /><br />Is there any way to get the HttpContext to propagate through? I&#39;ve tried a few things, even creating my own proxies and factories, but still no success.<br /><br />Thanks,<br />Pete&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Tuesday, May 06, 2014</h2><p>You need to revisit your design.</p>
<p><b><i>When you start an asynchronous operation you have no control on how long the async operation will be running and the actual HttpRequest thread may be gone and the EF DbContext may already be Disposed while your async method is running.</i></b></p>
<p>So you must either</p>
<p>
<ul>
<li>Redssign your code to use other means of controlling the lifetime of the EF DbContext than HttpContext</li>
<li>Or only use synchronous methods on to DataPortal.</li>
</ul>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>PeteK replied on Tuesday, May 06, 2014</h2><p>Hi there,<br /><br />Thanks for your replies.<br /><br />Johhny, I might have to go with your first suggestion. I don&#39;t think your second suggestion will work for us as we&#39;re dealing with a Silverlight app, which I believe forces us to use asynchronous DataPortal calls.<br /><br />Regarding the issue of HttpContext becoming null, I found this page which seems to describe the situation:<br /><br />&nbsp; &nbsp; http://blog.alextercete.com/keep-your-context-around/<br /><br />It appears that calling&nbsp;.ConfigureAwait(false) causes HttpContext to become null, and this actually is done throughout the CSLA DataPortal code.<br /><br />Cheers,<br />Pete&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
