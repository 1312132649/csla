<html><header><title>Dealing with differences between Object Model and Data Model</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Dealing with differences between Object Model and Data Model</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12864.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jasonabi posted on Friday, April 17, 2015</h2><p>Generally our CSLA business objects correspond 1-to-1 with our database tables.&nbsp; </p>
<p><br />MamaWidget is persisted to mamawidget_table</p>
<p>and </p>
<p>BabyWidget is persisted to babywidget_table</p>
<p>Problem is MamaWidget is so fat....I said MamaWidget is SO FAT...How fat is she?<br /><br />MamaWidget is SO FAT her property list looks like the list of ingredients in a twinkie.</p>
<p><br />Alright, excuse the poor attempt at humor.&nbsp; Point is the parent object has gotten too bloated and I would like to decompose some of it into a few child objects, but this should not effect the persistance, which saves all editable property values to a single table.</p>
<p>This deviates from the way we tend to wire up our CSLA objects, but seems like the right thing to do.&nbsp; I don&#39;t want to change the database schema, just the object hierarchy.&nbsp; <br /><br />Is there an example of persisting a business object with children into a flattened schema?<br /><br />Thanks.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 17, 2015</h2><p>Your Csla objects should model the use case the user is working from.&nbsp; Your database should be the normalized storage for the data entered.&nbsp; While for simple cases they may match up closely, its actually quite normal for your Csla objects to have a different shape than the db tables, which means they might be denormalized, only contain a subset of data from a table, etc. </p>
<p>So I&#39;d say by decomposing things you&#39;re actually fixing a design issue you currently have.&nbsp; Just decompose them according to the use case for the user, which typically will be closely related to what&#39;s on the users screen.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jasonabi replied on Friday, April 17, 2015</h2><p>Yes, the decomposition is to address the &quot;god object&quot; code smell and break the big object into a few smaller more narrowly focused objects - but in terms of persistence, the newly created child objects really just represent clusters of tightly related properties of the parent object.&nbsp; The decomposition will increase the readability and maintainability of the type(s).&nbsp; Yet, all of the props on parent and child are really describing a single denormalized entity in the db schema.&nbsp; </p>
<p>For example, let&#39;s say I have a type called &quot;body&quot; and it contains properties that describe all the limbs and organs, etc. I want to decompose it into a parent object &quot;Body&quot; with many children such as &quot;Hand&quot;, &quot;Heart&quot;, &quot;Brain&quot;, etc. each with their own attributes, but it will all still be persisted in the body table in a completely flat schema.</p>
<p>So, what is the difference in terms of DataPortal method implementation?&nbsp; If I want to save a parent and child simultaneously in the same operation, what do I do?<br /><br />I&#39;m used to saving child objects along with a parent, but in their own Csla DataPortal_Create (or whatever) method. If I want both to be persisted in the parent object save, how is that wired up? Am I making sense? <br /><br />Thanks.</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, April 20, 2015</h2><p>I&#39;d probably just have the save logic in the children, and only the save logic which the parent owns should be in the parent.&nbsp; So the properties that Body has will be saved in its DP_I/U and the rest will be handled by the children.&nbsp; That means you&#39;ll probably have multiple updates to the same table, unless you&#39;re using something like EF, where you&#39;d probably want to pull the data object from your context in each object and manipulate just the fields which are &quot;owned&quot; by the object, letting only your root class actually call SaveChanges.&nbsp; </p>
<p>However if your child objects are always going to be children (not switchables) then you could just have your save logic only in the parent; it could check the children to see if they really changed and not bother with those or you could always just gather all the data and update the row.&nbsp; Your child objects should just contain Child_Insert / Child_Update methods with no logic so you can still call FieldManager.UpdateChildren so CSLA will properly set their metadata states (such as IsDirty).</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
