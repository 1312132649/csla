<html><header><title>WPF - Multiple Async CslaDataProvider + ObjectFactory</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>WPF - Multiple Async CslaDataProvider + ObjectFactory</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8001.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough posted on Monday, November 16, 2009</h2><span>Hi All,</span><br><br><span>This problem refs </span><a HREF="/forums/2/26963/ShowThread.aspx">ObjectFactory</a><span> (last post) and </span><a HREF="/forums/thread/38150.aspx">Multiple Async CslaDataProviders</a><span>.</span><br><br><span>We are seeing very strange behaviour here where the ObjectFactory is involved.&nbsp; We have two BO's in test (Item &amp; ShelfLifeLookup) both are being retrieved async using separate CslaDataProviders.&nbsp; I also re-created prob by debugging a test by firing off two simultaneous calls to the Get methods of each BO.</span><br><br><span>When we try and parse the factoryName in our GenericFactoryLoader and create the instance of the factory, it seems as if the parser contains different values (when it throws an Exception) to the factoryName parameter of the method, (it parses in the first line of this method), i.e. the other BO's parsed factoryName.</span><br><br><span>Synch calls work ok for these BO's.&nbsp; Below is a Debug output from the Loader which show calls in call order before the Exception which is in GetFactory.</span><br><span>Also GetFactoryType is called excessively for some reason.<br><br><font size="1">OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=INameValueListFactory;List=OurApp.Domain.ShelfLifeLookup,OurApp.Domain;Key=System.Guid;Value=System.String)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=OurApp.Data.Factories.ItemFactory,OurApp.Data;Item=OurApp.Domain.Item,OurApp.Domain)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=OurApp.Data.Factories.ItemFactory,OurApp.Data;Item=OurApp.Domain.Item,OurApp.Domain)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=OurApp.Data.Factories.ItemFactory,OurApp.Data;Item=OurApp.Domain.Item,OurApp.Domain)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=OurApp.Data.Factories.ItemFactory,OurApp.Data;Item=OurApp.Domain.Item,OurApp.Domain)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactoryType(Factory=INameValueListFactory;List=OurApp.Domain.ShelfLifeLookup,OurApp.Domain;Key=System.Guid;Value=System.String)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactory(Factory=OurApp.Data.Factories.ItemFactory,OurApp.Data;Item=OurApp.Domain.Item,OurApp.Domain)<br>OurApp.Data.Factories.Loader.GenericFactoryLoader - GetFactory(Factory=INameValueListFactory;List=OurApp.Domain.ShelfLifeLookup,OurApp.Domain;Key=System.Guid;Value=System.String)</font><br><br><br>Hope someone can shed some light.<br><br>TIA<br>Kevin<br><br><br><br></span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 16, 2009</h2><P>The data portal creates <EM>exactly one</EM> factory loader instance, and reuses that instance for all calls. So if you create a custom factory loader you must make it totally threadsafe (no instance level fields without locking, etc).</P>
<P>The data portal does get the factory type several times, because it needs to look for the RunLocal and Transactional attributes, etc. Because the data portal uses a pipeline model, each step in the pipeline is independent of any other step, and so there's basically no global state.</P>
<P>In 4.0 I might rework the data portal to use more of a container model - still a basic pipeline, but with an overarching contextual model too.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Tuesday, November 17, 2009</h2>Ok that explains it.&nbsp; I should really make my GenericFactoryLoader a static class then for clarity but then I can't implement IObjectFactoryLoader.<br><br>Now the pain! Any good docs/links around for doing this?<br><br>Thanks Rocky<br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Tuesday, November 17, 2009</h2>Hi Rocky<br><br>I have come up with this, seems to work but not sure about it (I'm still pretty wet behind the ears with C#)<br><br><font size="2" face="Courier New">public class GenericFactoryLoader : IObjectFactoryLoader<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static readonly GenericFactoryLoader instance = new GenericFactoryLoader();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static GenericFactoryLoader()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StructureMap.ObjectFactory.Initialize(x =&gt; x.AddRegistry(new GenericFactoryRegistry()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static GenericFactoryLoader Instance<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return instance; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #region IObjectFactoryLoader Members<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public object GetFactory(string factoryName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance.GetFactorySafely(factoryName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Type GetFactoryType(string factoryName)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return instance.GetFactoryTypeSafely(factoryName);&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endregion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;&nbsp;&nbsp; #region Privates<br>&nbsp;&nbsp;&nbsp; Methods GetFactoryTypeSafely,GetFactorySafely that instantiate local parser.&nbsp; <br>&nbsp;&nbsp;&nbsp; Also use Activator.CreateInstance (ThreadSafe I think)<br>&nbsp;&nbsp;&nbsp; MethodCaller.CallPropertySetter (Is this threadsafe?)&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; #endregion<br>}</font><br><br>So,&nbsp; Is a call to MethodCaller.CallPropertySetter thread-safe?<br><br>Thanks<br>Kevin<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, November 21, 2009</h2><P>CallPropertySetter() is absolutely not threadsafe.</P>
<P>.NET really has no threadsafe way to call a property setter. The only way to do such a thing would be to have a syncroot on your object, and to make sure all code everywhere uses that syncroot to lock the object before setting a property - a virtual impossibility in normal coding.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Monday, November 23, 2009</h2>Thanks Rocky<br><br>I'll remove this call,&nbsp; I was using this to set a specific repository type for my factory.<br>I guess this should be StructureMap's responsibility or the factory itself.<br><br>I wonder how dependency injection works when setting properties?<br><br>Kevin<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 23, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>This is less a DI issue than a multi-threaded issue with
singleton objects.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>The factory loader is a singleton &#8211; it is a single instance used
by multiple threads &#8211; and so it really shouldn&#8217;t have properties or fields &#8211;
just two stateless methods.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I think you are trying to use the same instance of <i>your
object</i> as well, which means it too must be written to be threadsafe &#8211; generally
meaning no properties or fields, and only stateless methods. If you must have
properties and fields, you must remember that they are shared across all
threads &#8211; setting a property changes it for all threads. Therefore you must
implement appropriate locking around all access to that object&#8217;s
properties/fields.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>A potentially better solution &#8211; certainly simpler &#8211; is to create
a different object instance for each thread. Then the object can have
properties/fields with no issue, because only one thread will interact with
that particular object instance at a time.<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Kevin Fairclough replied on Monday, November 23, 2009</h2>My GenericFactoryLoader doesn't have any fields or props I removed them so that is ok.&nbsp; <br><br>In the GetFactorySafely method I create an instance of the factory object that will be used to create the BO.&nbsp; I was originally calling MethodCaller.CallPropertySetter(newFactoryObject,"Repository",newReposObject ) inside the stateless method, therefore I think my original code was ok, assuming I've understood.<br><br>Thanks<br>Kevin<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
