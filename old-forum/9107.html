<html><header><title>Async Csla.Rules.BusinessRule Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Async Csla.Rules.BusinessRule Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9107.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geoff_Manning posted on Friday, June 18, 2010</h2><p>This is a two part question:&nbsp;</p>
<p>First,&nbsp;can anyone explain why it&#39;s necessary for the Csla.Rules.RuleContext to set the Target to null? This is throwing a wrench in my plans because I wanted to access the object&#39;s BrokenRules collection to only run this possibly time-intensive rule if one of the other rules on this property are not already broken. Specifically, it is safe to assume that if the primary key is not in a valid state already, that it obviously isn&#39;t already assigned in the table, so it just seems like a big waste of time to check regardless.</p>
<p>So the second part is, assuming that there is no way for me to get a reference to the context.Target since it is null, does anyone have any ideas how to figure out if any rules on this property are already broken? I&#39;ve considered the possibility of rewriting all the logic of all the other rules in this rule as well, but that is obviously very unclean.&nbsp; Any help would be greatly appreciated.</p>
<p>Along the same lines, perhaps rule chaining would be helpful here? I don&#39;t understand it too well yet, so I&#39;m not sure if I could make something like this work with rule chaining or not, but I&#39;d assume at the very least that if I do that I wouldn&#39;t be able to use the DataAnnotation rules and commonrules on this property, since those are the rules that I assume would have to fire off this rule if they don&#39;t fail.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, June 18, 2010</h2><p>The issue is that CSLA, like most of .NET, is not threadsafe. Therefore, allowing multiple threads to interact with one object causes problems. Problems which are virtually impossible to overcome (since they tie into things like data binding, which is also not threadsafe).</p>
<p>To prevent people from making what would be a common and horrible mistake by having a background thread on an async rule interact with the business object, the Target property is always set to null for async rules. The alternative would be chaos. Horrible, horrible chaos.</p>
<p>Instead what happens, is that you get to specify the list of input properties your rule requires, and those values are copied and the copies are provided to your rule. That way the rule can&#39;t accidentally alter a property value mid-stream on a background thread, thus triggering all the nasty cross-thread data binding troubles.</p>
<p>Anything your rule needs to change should be put in the output property dictionary, so after control returns to the UI thread, those property values can be safely updated - again without triggering the cross-thread nastiness.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geoff_Manning replied on Friday, June 18, 2010</h2><p>Ok, I can accept that, but not everything in an async rule necessarily needs to be in a backroundworker, correct? </p>
<p>Perhaps I can explain my case a bit better: I have an object where the primary key is a modifiable field. Because of this I store an&nbsp;original persisted id&nbsp;that comes from the database (or empty string if new object) and the current id that the consumer of the object can change. The purpose of the async rule is ensure that the current id does not exist in the database, because it must be unique.</p>
<p>For efficiency and functionality, before I start a background worker I want to see if it&#39;s even useful to do this check&nbsp;by 1. seeing if there are any rules broken on this property already (which is forcing me to make redundant checks since I can&#39;t access the BrokenRules collection) and 2. seeing if this property currently equals the &quot;original&quot; property in the database, upon which it obviously does exist in the database and SHOULD because it is in fact one and the same row.</p>
<p>Now for #2 I can obviously pass in both the current id&nbsp;and original id properties and that takes care of that, but for #1, what I REALLY need is a way to check if any of the rules on the current id are broken, upon which it also wouldn&#39;t exist in the db because bad data would never make it to the database (I&#39;m thinking positive here, although most of it is duplicated with db check constraints, so is a pretty good assumption).</p>
<p>Because the only think I can pass in to the async rule is IPropertyInfo, I can&#39;t see any other way than using the context.Target, which is null so i can&#39;t use it.</p>
<p>So, if I modified the Csla source to NOT set&nbsp;the target&nbsp;to null, and left it up to me to not use the reference to the Target inside of the BackgroundWorker, would that theoretically work?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>Marjon1 replied on Friday, June 18, 2010</h2><p>Geoff,</p>
<p>I&#39;ll probably come back and edit this post later this afternoon, but what I think you are trying to do can be done with the priority mechanism that is already there on CSLA rules. You assign a priority number to a rule at the time of adding it and if any of the rules prior to that priority level are broken that rule will not run, therefore your rule does not need to be aware of what else is broken. We use this to great affect for doing a similar thing (i.e. only checking the DB for duplicates if the value has a string, isn&#39;t too long and matches a regular expression), only after all those rules at priority 0 are passed are the rules at our higher level (in our case 10) run. You would still want to do option #2 in your rule, but this will take care of issue #1.</p>
<p>This is&nbsp;demonstrated&nbsp;in one of the CSLA videos and I&#39;m sure it is in the book as well (can&#39;t recall chapter right now).</p>
<p>I would strongly recommend changing something so fundamental to the CSLA experience, especially when it comes to threading.</p>
<p>Marjon</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geoff_Manning replied on Friday, June 18, 2010</h2><p>Thank you so much to both of you.&nbsp; </p>
<p><strong>@ Rocky:</strong> Your explanation helped me a lot.&nbsp;</p>
<p><strong>@ Marjon:</strong> That solution worked perfectly for me.</p>
<p>Not a high priority to get answered, and I don&#39;t plan to change anything in the CSLA source now that I can get it to do what I need, but I&#39;m still curious about one thing to improve my understanding of how it&#39;s affected by threading:&nbsp;Theoretically, if context.Target in the Execute() override&nbsp;had the reference to the object when IsAsync is set to true, would it not cause an issue to use the reference in the actual Execute method outside of any BackgroundWorker delegate?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, June 19, 2010</h2><p>That&#39;s true Goeff, it would be safe to use Target outside the async parts of the rule. But just because you understand that, and I understand that, doesn&#39;t stop the hard, cold reality that people would continually use Target inside their async code - especially given lambdas, where it isn&#39;t really apparent that one chunk of your Execute method is on a background thread.</p>
<p>I&#39;m open to suggestions on how to loosen the restriction, but in some way that doesn&#39;t cause a continual and forever support burden for me. Perhaps some property you set to true like: </p>
<p>IFullyUnderstandTheConsequencesOfUsingTargetInAnAsyncRuleAndWillNotBotherRockyWhenIDoTheWrongThing</p>
<p><img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geoff_Manning replied on Wednesday, June 23, 2010</h2><p>Haha, that&#39;s hilarious. I can definitely see your reasoning, but designing a framework to prevent it from being misused is a thin line and in this case it crosses the line since there is a way to use the target without causing an issue.&nbsp; Regardless, I&#39;m finding that writing async code and understanding it is a battle regardless of this specific problem that could occur if done incorrectly.&nbsp; </p>
<p>In this case I already have a solution so I&#39;m not especially concerned about using Context when it is marked as Async at the moment, but perhaps a variation of what you just said could be taken seriously:</p>
<p>Maybe instead of calling it context.Target, it could be context.NonAsyncSafeTarget, and you could&nbsp;include notes about the usage of Target in the XML documentation that shows up in the intellisense, and to make it even harder for someone who doesn&#39;t know what they are doing to screw up, make then modify a property in the constructor, lets call it AllowNonAsyncSafeTarget that defaults to false unless they specifically change this.</p>
<p>I personally think that just the XML documentation and the AllowNonAsyncSafeTarget property would be enough for anyone, but renaming Target to NonAsyncSafeTarget would make it to where if ANYONE EVER tried to get your support on this due to not understanding why they are getting threading issues, they should be executed immediately. ;)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, June 23, 2010</h2><p>Alright, you&#39;ve convinced me. I&#39;m adding this to IBusinessRule:</p>
<p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Gets a value indicating that the Target property should<br />&nbsp;&nbsp;&nbsp; /// be set even for an async rule (note that using Target<br />&nbsp;&nbsp;&nbsp; /// from a background thread will cause major problems).<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; bool ProvideTargetWhenAsync { get; }<br /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Geoff_Manning replied on Wednesday, June 23, 2010</h2><p>Great! Thanks, Rocky!&nbsp;<img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, June 24, 2010</h2><p>May I also suggest that Rocky setup an email filter which forwards any emails with &quot;async rule&quot; and &quot;target&quot; to you. :-)</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
