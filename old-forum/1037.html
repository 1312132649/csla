<html><header><title>Data retrieval with multiple-level hierarchy</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Data retrieval with multiple-level hierarchy</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1037.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Vertigo1 posted on Saturday, August 26, 2006</h2><P>Ok, having read through the book I understand how the data retrieval operates with the SQL stored procedures in the case of parent and child objects.&nbsp; Basically a single stored procedure retrieves the details for the specified parent object followed by a second resultset containing the details of all the child object.&nbsp; The parent object's DataPortal_Fetch function populates its own fields and then passes the (Safe)DataReader to the factory method of the child class in order that it may construct the child objects.</P>
<P>My question is how do you organise things in the case of a multi-level hierarchy?&nbsp; If you have a Parent/Child/Grandchild situation such that the Child object is both a child and a parent, what's the best way to retrieve the data?&nbsp; You could have a stored procedure to retrieve the details of a specific Parent object which, as described above, would return a second resultset containing a row for each Child object but how would you retrieve the data for each Grandchild object?&nbsp; You can't simply add a third resultset as this would contain all Grandchildren of the Parent in one big "lump" rather than discrete resultsets of Grandchildren for each Child.</P>
<P>Not sure if I'm making myself clear here but if someone can explain the best way of doing this I'd be eternally grateful&nbsp;:)</P>
<P>Toby.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz replied on Saturday, August 26, 2006</h2>Toby,<br><br>The usual way to do this is with a DataSet. I think I've been down to great grand children. I&nbsp; still use an sproc with multiple queries that I read with a DataReader but I instanciate a DataSet and load the data below the child level into DataTables within the DataSet. Create relationships within the DataSet and use the GetChildren() is whatever the method is called. I think I passed a DataTable to my lower collections in much the same way as we usually pass a DataReader in CSLA. The Fetch method in the collections loop though the DataRows.<br><br>Ross<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>akabak replied on Monday, August 28, 2006</h2>Ross, do you have any sample code for this? I was just logging on to ask the same question ... I've got a root object that has child contacts, and each child contact has children addresses and children phone numbers related to it.<br><br><br>amanda<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz replied on Tuesday, August 29, 2006</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>akabak:</strong></div><div>Ross, do you have any sample code for this? I was just logging on to ask the same question ... I've got a root object that has child contacts, and each child contact has children addresses and children phone numbers related to it.<br>amanda<br></div></BLOCKQUOTE><br><br>Sorry, I don't have working code I can easily publish but its basically like this:<br><br>In your stored procedure do something like this. Assuming, just for example, all tables have Id and Name.<br><br>SELECT Id, Name FROM Parent WHERE Id = @Id<br><br>SELECT Id, Name FROM Child WHERE ParentId = @Id<br><br>SELECT Id, Name FROM GrandChild INNER JOIN Child ON GrandChild.ParentId = Child.Id<br>WHERE Child.ParentId = @Id<br><br>In the root object's DataPortal_Fetch, call your sproc in the usual way. Now assuming your sproc call has returned a DataReader dr<br><br>Read the root's data into its instance variables.<br><br>dr.NextResult()<br><br>Now you could do the children in the normal CSLA way by passing it the dr but I found that if there were grandchildren then it was cleaner (although not as efficient) to leap into the DataSet. I'm dealing with small collections. At the very least you need to put the Id of the children into a DataTable so you can create the relationship with the grandchildren. So ... continuing how I did it.<br><br>DataSet ds = new DataSet();<br>DataRow row;<br><br>// Children<br>DataTable dtChildren = ds.Tables.Add("Children");<br>DataColumnCollection cols = dtChildren.Columns;<br>cols.Add("Id", typeof(Int32));<br>cols.Add("Name", typeof(String));<br>// plus other fields<br><br>while (dr.Read())<br>{<br>&nbsp;&nbsp;&nbsp; row = dtChildren.NewRow();<br>&nbsp;&nbsp;&nbsp; row["Id"] = dr.GetInt32("Id");<br>&nbsp;&nbsp;&nbsp; row["Name"] = dr.GetString("Name");<br>&nbsp;&nbsp;&nbsp; // plus other fields<br>
&nbsp;&nbsp;&nbsp; dtChildren.Rows.Add(row);<br>}<br><br>dr.NextResult()<br><br>// Grandchildren<br>
DataTable dtGrandChildren = ds.Tables.Add("GrandChildren");<br>
DataColumnCollection cols = dtGrandChildren.Columns;<br>
cols.Add("Id", typeof(Int32));<br>
cols.Add("Name", typeof(String));<br>
// plus other fields<br>
<br>
while (dr.Read())<br>
{<br>
&nbsp;&nbsp;&nbsp; row = dtGrandChildren.NewRow();<br>
&nbsp;&nbsp;&nbsp; row["Id"] = dr.GetInt32("Id");<br>
&nbsp;&nbsp;&nbsp; row["Name"] = dr.GetString("Name");<br>&nbsp;&nbsp;&nbsp; // plus other fields<br>

&nbsp;&nbsp;&nbsp; dtGrandChildren.Rows.Add(row);<br>
}<br>
<br>// create the relationship<br>ds.Relations.Add("CtoG", dtChildren.Columns["Id"], dtGrandChildren.Columns["ParentId"]);<br><br>Now to load the data into the children and grandchild. Looking at it now, the way I did it was slightly untidy because of some other issues. I think the following is how it should be done: Its really just a matter of substituting the DataReader in the normal CSLA templates with a DataTable and its rows.<br><br>ChildList is an EditableChildList. Its static "Get" method accepts a DataRow. The root object's Fetch() has something like:<br><br>_childList = ChildList.GetChildList(dtChildren);<br><br>In ChildList you have a Fetch() method (called from the constructor) that takes a DataTable something like this:<br><br>private void Fetch(DataTable dt)<br>{<br>&nbsp;&nbsp;&nbsp; RaiseListChangedEvents = false;<br>&nbsp;&nbsp;&nbsp; foreach (DataRow row in dt.Rows)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(Child.GetChild(row));<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; RaiseListChangedEvents = true;<br>}<br><br>In the Child class, again you pretty much just substitute a DataRow for the DataReader but at the end of its Fetch() you'll have something like:<br><br>_grandChildList = GrandChildList.GetGrandChildList(row.GetChildRows("CToG"));<br><br>Note that row.GetChildRows("CToG") returns an array of DataRows (not a filtered DataTable) so therefore GrandChildList is different in that it needs to accept an array of DataRows instead of a DataTable like ChildList does but whether you're loading the collection from repeatedly dr.Read(), or rows in a DataTable or an array of DataRows, its all much the same.<br><br>Well ...&nbsp; hope that helps.<br><br>Cheers<br>Ross<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Sunday, August 27, 2006</h2><P>I think it would depend. :)</P>
<P>If you have thousands of parent records in a collection, and you are unlikely to want to look at all of the grandchildren, grabbing all the grandchildren for each parent all at once would be wasteful.</P>
<P>But, if you *are* going to be rooting thru most of the grandchildren in your object, then asking for the data one child at a time would be wasteful.</P>
<P>Hope that helps!</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
