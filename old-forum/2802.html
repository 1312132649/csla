<html><header><title>csla and deepdata for inserts and updates</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>csla and deepdata for inserts and updates</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2802.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>CSLA_Rocks posted on Monday, April 30, 2007</h2>I am using Codesmith Templates to generate CSLA Business layer. However I am also making modifications in the templates so as to create a separate Data Access layer. This is inspired by the DeepData Sample. The DeepData sample explains well for Fetch command and transperancy is easily achieved between the 2 layers. However I am not able to do the same with Insert and Update commands where I will have to fill in SQL parameters from the object itself. Also if I have child objects associated then I will need to maintain transactions. How can I achieve separating the Business and Data layers in these cases?<br><br>Thanks <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 01, 2007</h2><P>Insert/update/delete are far easier than Fetch.</P>
<P>The same techniques used in my books work for insert/update. Your child collections/objects will all accept a reference to the root (and any other foreign-key-containing parent) as parameters to their internal/Friend Insert() and Update() methods. Each child is responsible for inserting/updating/deleting itself.</P>
<P>In other words, the root object calls an internal/Friend Update() method on each child collection in the DataPortal_Insert/Update methods:</P>
<P>&nbsp; _childCollection.Update(Me)</P>
<P>Notice that a reference to the root object is passed to the child collection. The child collection loops through its children (and DeletedList) calling the appropriate internal/Friend Insert/Update/DeleteSelf methods on each child:</P>
<P>Friend Sub Update(ByVal parent As MyRoot)<BR>&nbsp; For Each child As MyChild In Me<BR>&nbsp;&nbsp;&nbsp; If child.IsNew Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; child.Insert(parent)<BR>&nbsp;&nbsp;&nbsp; Else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; child.Update(parent)<BR>&nbsp;&nbsp;&nbsp; End If<BR>&nbsp; Next<BR>&nbsp; '...<BR>End Sub</P>
<P>Each child object inserts or updates (or deletes - remember to loop through DeletedList and call child.DeleteSelf()) - itself, and then cascades the call to its child collection:</P>
<P>&nbsp; _grandchildCollection.Update(parent, Me)</P>
<P>Notice how it passes both the root parent and itself as a parameter. I'm assuming that both objects now provide foreign key values to the grandchildren. The grandchild collection and grandchildren themselves merely use the same pattern as I've already shown.</P>
<P>As far as transactions, there are two scenarios:</P>
<OL>
<LI>You are using EnterpriseServices, so you can just open/close the db connection in each object and the transactions are handled by COM+ - you don't need to worry about them as long as you throw an exception if you want to fail.</LI>
<LI>You are using TransactionScope or Manual, in which case you should use the technique shown in the <EM>CSLA .NET Version 2.1 Handbook</EM> that uses the new ApplicationContext.LocalContext to put either the db connection or transaction object in a globally available location for use by all your child objects.</LI></OL>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
