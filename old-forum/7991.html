<html><header><title>MobileFormatter not deserializing collection of objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>MobileFormatter not deserializing collection of objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7991.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>miker55_2 posted on Friday, November 13, 2009</h2>I have a collection of detail tables attached to each business object to handle master/detail scenarios.&nbsp; It is declared in BusinessBase like so:<br><br>&nbsp;&nbsp;&nbsp; private List&lt;IEditableCollection&gt; _detailTables;<br><br>&nbsp;&nbsp;&nbsp; public List&lt;IEditableCollection&gt; DetailTables<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return _detailTables; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { _detailTables = value; }<br>&nbsp;&nbsp;&nbsp; }<br><br>In the DataPortal_Fetch method of the master table I fill that collection.&nbsp; I've stepped through the code and on the server everything is fine.&nbsp; As soon as I get back to the client however, the collection is gone.<br><br>Is there anything special I need to do to get this to deserialize correctly in Silverlight?&nbsp; This exact code worked fine in CSLA 2.5 for WinForms.<br><br>TIA,<br><br>Mike<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, November 13, 2009</h2><P>The MobileFormatter can only deal with types that implement IMobileObject. List&lt;T&gt; doesn't implement that interface.</P>
<P>However, CSLA .NET includes several base classes for objects, lists and dictionaries that do implement the correct functionality. Though I don't know for sure that we handle a list of lists - you'll have to try and see.</P>
<P>Check out the "MobileXyz" types in Csla.Core&nbsp;- what you want is MobileList&lt;T&gt;.</P>
<P>The reason this is necessary is because private reflection isn't possible in Silverlight. Serializers normally rely on reflection to do their job. Without private reflection you can't write a normal serializer (which is why there's no BinaryFormatter or NDCS on Silverlight).</P>
<P>The MobileFormatter avoids the reflection issue by requiring that the objects to be serialized participate in the process. Basically it just asks each object to serialize/deserialize its own state, thus avoiding private reflection. MobileFormatter does know how to handle primitive types all by itself.</P>
<P>The drawback, of course, is that it can't serialize types that don't participate...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Thursday, January 19, 2012</h2><p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b></p>
<p>The reason this is necessary is because private reflection isn&#39;t possible in Silverlight. Serializers normally rely on reflection to do their job. Without private reflection you can&#39;t write a normal serializer (which is why there&#39;s no BinaryFormatter or NDCS on Silverlight).</p>
<p></div></p>
<p>&nbsp;</p>
<p>Is this still the case for WinRT? If WinRT will supports private reflection then are we going back to whatever serializers ship with WinRT?</p>
<p>&nbsp;</p>
<p>I realize that WinRT is still a work in progress and that nothing is for sure but I can&#39;t help wondering if WinRT is heading into being just as&nbsp;powerful&nbsp;as WPF or if its going to be yet another&nbsp;framework or full of limitations like Silverlight.</p>
<p>&nbsp;</p>
<p>Thanks.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 19, 2012</h2><p>Based on everything we know at this time, WinRT is at least restrictive as Silverlight.</p>
<p>This means the value of improving MobileFormatter is higher than ever, because it will probably become the primary serializer for a lot of applications, and eventually nearly all applications.</p>
<p>The problem with full .NET is that people can use it to create malware. Same with full Win32.</p>
<p>WinRT attempts to solve this by ensuring that all apps run in a sandbox, and that obvious dangerous&nbsp;things (like unrestricted private reflection) aren&#39;t available.</p>
<p>I don&#39;t think twice about downloading an app on my Windows Phone. People don&#39;t think twice on an iPhone either. Sane people think several times before downloading an app on their Android device, or onto their PC. And for good reason - those platforms aren&#39;t inherently safe, and the apps being downloaded haven&#39;t been screened.</p>
<p>As developers, geeks, and hackers we might find these constraints annoying. But as a consumer I rather look forward to the idea that my worst fear is that an app is stupid or useless, not that the app is going to be malware that takes hours of work to eliminate from my computer.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
