<html><header><title>Transactions</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Transactions</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9148.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ballistic posted on Tuesday, June 29, 2010</h2><p>I&#39;ve used CSLA in several web sites, but have never done transactions, until now.<br /><br />Based on the videos Rocky created for 3.8, I have started decorating all of my DataPortal calls with [Transactional(TransactionalTypes.TransactionScope)]. In addition, I am now using the Repository pattern and within each repository method, I am using the Csla.Data.ConnectionManager to reuse database connections.<br /><br />I have been able to get transactions working, but not sure I am doing it the best way.&nbsp; <br /><br />In my case, I have a Conversation (BusinessBase) with a list (BusinessListBase) of messages.<br /><br />Within a &quot;Service&quot; class I create transaction:<br />connectionTransaction = TransactionManager&lt;SqlConnection,SqlTransaction&gt;.GetManager(&quot;FavsDB&quot;).Transaction;<br /><br />Add the messages to the list and save the Conversation.<br /><br />In order to get the transactions to work, I had to change the Transactional attribute of Conversation DataPortal methods to Manual:<br />[Transactional(TransactionalTypes.Manual)]<br />protected override void DataPortal_Insert()<br /><br />Finally, in the Repository, I changed it so it uses the transactionManger instead of the regular ConnectionManager&lt;SqlConnection&gt;.GetManager(&quot;&quot;)<br />using (var tm = TransactionManager&lt;SqlConnection, SqlTransaction&gt;.GetManager(&quot;FavsDB&quot;))<br /><br /><br />Again, this all works, but now when I go to add a &quot;reply&quot; message, which doesn&#39;t need to be in a transaction, the newly created record doesn&#39;t get committed to the database, because the DataPortal and Repository Insert method expect to be in a transaction, which I am hoping to avoid.<br /><br /><br />Is there a way to simply create a transaction, have the DataPortal keep the TransactionalTypes.TransactionScope and have the repository methods use the ConnectionManager so they do not know/care if they are in a transaction? I would like for the &quot;Service&quot; to be the one that determines if the db calls need to be in transaction, and not have the DataPortal or Repository methods know this.<br /><br />Again, first time using transaction, so not sure if what I am asking is possible.<br /><br />Thank you,<br /><br />&nbsp;- Andy</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Tuesday, June 29, 2010</h2><p>You should read up on what System.Transactions.TransactionScope does for you - that&#39;s what CSLA is using.</p>
<p>There is no need to create an explicit transaction when using TransactionScope - it is automatic (within some limits).</p>
<p>Basically, if you decorate your root DataPortal_XYZ or object factory method with [Transactional] you are automatically protected.</p>
<p>The ConnectionManager (and similar) types are important to avoid accidentally using the DTC, which will be a perf hit and increases deployment complexity.</p>
<p>Chapter 18 is a good thing to read too - lots of good info about data access in that chapter.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mesh replied on Wednesday, June 30, 2010</h2><p>I think transactions should be handled in your data layer and/or separate infrastructure project. I&#39;m trying to prototype CSLA solution with separate NHiberante data layer. I&#39;m using unit of work and repository pattern while accessing NH layer. I think the most important thing is that BO layer stays as much &quot;clean&quot; of any db related code. <br /><br />For implementing UoW and repository pattern I&#39;m using something very similar to this:<br />http://davybrion.com/blog/2009/12/using-nhibernate-in-your-service-layer/<br /><br />So, typical DataPortal method might look something like this:</p>
<p><br />using (IUnitOfWork _UnitOfWork = EnsureDependency(Ioc.Container.Resolve&lt;IUnitOfWork&gt;()))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var context = EnsureDependency(_repository);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dto = new SomeDto();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // filling empty dto object<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Update(dto);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // or some others calls to children update<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _UnitOfWork.Flush();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p>
<p>Everything in using statement is &quot;protected&quot;, because only if Flush is executed, transaction will be committed. Btw, I can open explicit transaction if I wish.</p>
<p>I&#39;m still evaluating this solution and searching for best implementation...</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
