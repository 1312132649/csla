<html><header><title>Dummy static initialization</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Dummy static initialization</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6391.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>emathias posted on Tuesday, February 10, 2009</h2>Regarding the use of the _forceInit variable for proper static initialization...<br /><br />Would the same initialization be forced by merely adding the line<br /><br />private static int _forceInit = 1;<br /><br />as opposed to coding a static constructor?<br /><br />Thanks!</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, February 10, 2009</h2><P>No, because that static field won't be initialized until it is triggered - just like the static fields you are declaring for your property metadata.</P>
<P>The whole point here, is that .NET has specific rules about when static fields (like the one you show) are initialized, and it is often too late for what we need.</P>
<P>Static fields are initialized <EM>for a specific class</EM>&nbsp;(not subclass, not base class, <EM>just this class</EM>) when</P>
<P>a) a static field is accessed from that class </P>
<P>b) a static constructor is declared in that class, and any class member is accessed</P>
<P>Unfortunately, in Silverlight we ran into issues where (b) was not always correct, so only (a) appears totally reliable.</P>
<P>What you are showing is a field declaration - which is fine - but you still need some code to access that field to trigger the initialization. This must occur in two cases</P>
<P>a) when the object is created through a constructor</P>
<P>b) when the object is created through serialization (which doesn't invoke a constructor)</P>
<P>However, in CSLA .NET 3.6.1 I solved this problem and you don't need to worry about it any more (on .NET anyway). CSLA .NET now forcibly accesses at least one static field on each class in an inheritance hierarchy before allowing any property access, thus guaranteeing that the fields are initialized.</P>
<P>The same is true on Silverlight, but your static fields must be public in scope for it to work.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>emathias replied on Tuesday, February 10, 2009</h2>Then I've read some baaaaad info about static initialization.  Wouldn't be the first time.<br /><br />Thanks Rocky, and again for that 3.6.1 update.  </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, February 10, 2009</h2>The only reliable info I have found is Brad Abram's blog post from months<br />ago. He spelled this out rather thoroughly, and the rules he lays out in<br />that post match my findings.<br /><br />I suspect that most people have a set of assumptions about this (I sure did)<br />that aren't violated under normal circumstances, so we all assume the<br />assumptions are correct. <br /><br />But as soon as you start to _rely_ on static field initialization,<br />especially in non-static methods, you quickly find out that those<br />assumptions are wrong...<br /><br />This was my experience anyway :)<br /><br />Rocky</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
