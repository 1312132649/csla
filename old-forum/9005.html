<html><header><title>RelationshipTypes.PrivateField - how to use it?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>RelationshipTypes.PrivateField - how to use it?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9005.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago posted on Friday, May 28, 2010</h2><p>Hi Rocky,</p>
<p>Referring to Beta 2 4.0.0-100524 Change Log</p>
<p>PrivateField relationship type (100519)<br /><a href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=756">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=756</a><br />Add new PrivateField relationship type to IPropertyInfo so property metadata can know<br />that a property has a private backing field. This change includes making ReadProperty()<br />and LoadProperty() automatically get/set these values using reflection.</p>
<p><br />I suppose this should be used like this</p>
<p>private static PropertyInfo&lt;int&gt; DocTypeIDProperty = RegisterProperty&lt;int&gt;(p =&gt; p.DocTypeID, &quot;Doc Type ID&quot;, RelationshipTypes.PrivateField);<br />public int DocTypeID<br />{<br />&nbsp;&nbsp;&nbsp; get { return GetProperty(DocTypeIDProperty); }<br />&nbsp;&nbsp;&nbsp; set { SetProperty(DocTypeIDProperty, value); }<br />}</p>
<p>Note the syntax I used up to this change was</p>
<p>public int DocTypeID<br />{<br />&nbsp;&nbsp;&nbsp; get { return GetProperty(DocTypeIDProperty<strong>, _docTypeID</strong>); }<br />&nbsp;&nbsp;&nbsp; set { SetProperty(DocTypeIDProperty<strong>, ref _docTypeID</strong>, value); }<br />}</p>
<p>I&#39;m wrong and I don&#39;t understand how to use this new feature.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, May 28, 2010</h2><p>The PrivateField flag is intended to tell CSLA that you are using a private field. So you do need to use the private field syntax in your property declaration - and now you can tell CSLA that this is what you are doing.</p>
<p>That is important, because it means that the non-generic ReadProperty and LoadProperty methods then know that they should use BypassPropertyChecks and reflection to interact with the property, rather than using the field manager.</p>
<p>In other words, we needed some way (specifically in new business rule system) to be able to get/set properties regardless of whether the property used a managed or private backing field. Managed was easy - this is what managed properties are all about. </p>
<p>But private backing fields are hard, because there&#39;s no guaranteed way for CSLA to know how to interact with the field (and in Silverlight it is essentially impossible). If you tell CSLA that you are using a private backing field however, then ReadProperty/LoadProperty can know that the only way to get/set the value is to use BypassPropertyChecks to disable rule processing, and then use reflection to interact with the public property itself.</p>
<p>Now ReadProperty and LoadProperty are still virtual (another CSLA 4 change), so if you want to avoid the use of reflection you can always override the methods and use a switch block or something based on the requested property name to directly get/set the field value. That&#39;ll be faster, but obviously less maintainable. That was my original solution to this problem, until Jonny suggested the PrivateField approach as a more maintainable (if somewhat slower) alternative.</p>
<p>So now you really have two choices for solving this problem. The most important thing is to use one of the two, because otherwise you can&#39;t really leverage the new rules system when using private backing fields.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Friday, May 28, 2010</h2><p>Thanks for your reply. I guess the &quot;PrivateField&quot; is useless on Unmanaged properties with type conversion...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 28, 2010</h2><p>Why do you say that? Certainly it will impose some limitations, but it will work fine.</p>
<p>If you have a private backing field, the non-generic ReadProperty/LoadProperty methods will use the <em>property</em> to set the value, not the <em>field</em>. So it will use whatever type conversion is in the property (like SetPropertyConvert) automatically.</p>
<p>If you don&#39;t want that to occur, then you&#39;d need to override LoadProperty so you can write your own code to directly set the private field.</p>
<p>In other words, you can let CSLA set the property - and use whatever type conversion is already in place - or you can override the methods to set the field directly, presumably to avoid type conversion.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
