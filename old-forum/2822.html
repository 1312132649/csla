<html><header><title>Refactoring DataPortal Fetching</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Refactoring DataPortal Fetching</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2822.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>EliteTraining posted on Friday, May 04, 2007</h2><P>It seems you can refactor the fetching process to hide complexity, please let me know the drawbacks of what I suggest:</P>
<P>ATM to fetch a listbase using custom criteria the developer must create a custom myCriteria object, create a '.Get(myCriteria criteria)' for the object, and override DataPortal_Fetch. Why the complexity? </P>
<P>As far as I can see, all criteria boil down to a stored procedure name and a parameter list, so you can make one criteria object called for example <FONT size=2><FONT color=#2b91af>FilterCriteria </FONT></FONT>(with properties FetchSP and Parameters).&nbsp;Instead of polymorphically dispatching on it in&nbsp;<FONT size=2>Get(</FONT>...<FONT size=2>)</FONT>, make a generic signature: '<FONT color=#0000ff size=2>public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>static</FONT><FONT size=2> T Get(</FONT><FONT color=#2b91af size=2>FilterCriteria</FONT><FONT size=2> criteria)</FONT>'. This invokes '<FONT color=#0000ff size=2>return</FONT><FONT size=2> </FONT><FONT color=#2b91af size=2>DataPortal</FONT><FONT size=2>.Fetch&lt;T&gt;(criteria);'</FONT>. In the callback '<FONT color=#0000ff size=2>private</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>void</FONT><FONT size=2> DataPortal_Fetch(</FONT><FONT color=#2b91af size=2>FilterCriteria</FONT><FONT size=2> criteria)<FONT size=3>', the stored procedure is set this way:</FONT></FONT></P><FONT size=2><FONT size=2>
<P>cm.CommandText = criteria.FetchSP;</P>
<P></FONT><FONT color=#0000ff size=2>if</FONT><FONT size=2> (criteria.Parameters != </FONT><FONT color=#0000ff size=2>null</FONT><FONT size=2>)</FONT></P>
<P><FONT size=2>&nbsp;&nbsp;&nbsp;cm.Parameters.AddRange(criteria.Parameters);</FONT></P>
<P><FONT size=2><FONT size=3>Since the fetch can generically operate on any .Get off any filter criteria, it can be moved up the inheritance chain and completely hidden from the developer, saving a ton of duplication. Is there something wrong with this approach?</FONT></P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RRorije replied on Friday, May 04, 2007</h2><P>We do this in exactly the same way, which works very fine IMO.</P>
<P>A refinement can be that you do not want to expose the FilterCriteria to the UI. When this is the case you can create different static functions that use the filterCriteria. For instance</P>
<P>pubic static Order GetOrderByName(string name)<BR>{ Get(new FilterCriteria("GetOrderByName", new IDbDataParameter("name",name) ; }</P>
<P>public static Order GetOrderById(GUID id)<BR>{ Get(new FilterCriteria("GetOrderById", new IDbDataParameter("id",id) ; }</P>
<P>Of course this code will not execute, but I think the idea is clear.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 04, 2007</h2><P>The data portal is designed to impose as few restrictions on your code as possible. I use it one way in the books, but it is really quite flexible.</P>
<P>If you get right down to it, in fact, the data portal is largely independant of the rest of CSLA. In fact, you can get/update <EM>any</EM> object through the data portal, as long as that object implements DataPortal_Fetch() and DataPortal_Update() methods.&nbsp; And, of course, you are able to pass some criteria object through to the DP_Fetch() method.</P>
<P>So coming up with ways to simplify code that fits into your overall environment and architecture is a wonderful thing, and is one of the reasons why I've kept the data portal as inobtrusive as possible.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
