<html><header><title>CSLA 4 Cascading Rules</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA 4 Cascading Rules</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9255.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pneurohr posted on Thursday, July 22, 2010</h2><p>I am getting what I think is an interesting behavior and wanted to get some clarification.&nbsp; I have two properties A and B and two rules X and Z.&nbsp; Both rules are async.&nbsp; Rules X sets property A , rule Z sets property B and rule Z is attached to property A.&nbsp; When I look at the value of property A it appears to be an event behind.&nbsp; So if A goes from 5 to 10 when I know it is 10 the value is 5 when using the context.InputProperties.&nbsp; If I look at context.Target it is 10.&nbsp; </p>
<p>I hope this makes sense and what is the best way to get the value I want (10) in rule Z?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, July 22, 2010</h2><p>context.InputProperties is a snapshot of the values <em>at the time the rule was invoked</em>.</p>
<p>There is no threadsafe way to get at the object&#39;s property values while the async rule is running on the background thread. This is why (by default) Target isn&#39;t available to an async rule - if you use Target in an async rule you better know exactly what you are doing or you&#39;ll find yourself in deep trouble.</p>
<p>To avoid that trouble, InputProperties gets a copy of the specified property values when the rule is invoked, so the rule has something to work with that is safe (if not necessarily current).</p>
<p>This is all by design.</p>
<p>If you really need access to current object values while the async rule is running, you will need to use Target - and you will need to invent and implement your own threadsafe way to access the Target object properties.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pneurohr replied on Thursday, July 22, 2010</h2><p>I understand that the InputProperties is a snapshot at the time the rule was invoked.&nbsp; I guess my question is&nbsp;why would the rule be invoked before the property was updated and the snapshot taken?&nbsp; I though the out values were updated when context.Complete is called which should be on the UI thread.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 22, 2010</h2><p>You have a dependent property scenario too I assume?</p>
<p>When the rule completes, the out values are used to update the object&#39;s properties, true. But that&#39;s done using LoadProperty(), which doesn&#39;t trigger any rules to run (because that would rapidly lead to infinitely running async rules - just think of the chaos!).</p>
<p>In other words, your rules are both being <i>started</i> (I suspect) at about the same time. The completion of either rule wouldn&#39;t trigger the running of more rules, because the out values are &quot;passively&quot; updating the property values.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pneurohr replied on Thursday, July 22, 2010</h2><p>That makes sense but then&nbsp;why execute the rules on the affected properties at all if their values may very well change during the &quot;first&quot; rule to run thereby making the results of the affected properties rules incorrect?&nbsp; My understanding was to assure that they were still valid after any changes made in the rule.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 22, 2010</h2><p>The overall assumption here is that async rules are the exception, not the norm. The only real reason to have an async rule is if the rule needs to talk to the server, or perhaps if it executes some long-running task (but I&#39;m not sure that&#39;s a great scenario for rules).</p>
<p>I knew from the start that overlapping async rules would be problematic. But short of creating an entirely threadsafe model - which would mean starting from scratch with a completely different architectural model for CSLA - there&#39;s no realistic way to make overlapping async rules really work either.</p>
<p>I guess what I&#39;m saying is, that for better or worse, you have the dubious honor of being the first person to hit a scenario that I knew would be hit <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pneurohr replied on Monday, July 26, 2010</h2><p>I appreciate the response but I have another question now.&nbsp; In the process of converting my rules back to run synchronously it appears as though my UI is no longer being updated.&nbsp; Instead of calling context.AddOutValue I have to assign it by casting the target and setting the property or raising the OnPropertyChanged event myself.&nbsp; The&nbsp;bindings have IdentityConverters on them.&nbsp; Any idea why this might be?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, July 26, 2010</h2><p>The UI updates because of PropertyChanged, so <i>something</i> needs to ensure that PropertyChanged is raised when a property is changed.</p>
<p>You should be able to continue to use AddOutValue() if you&#39;d like - that works in both sync and async rules (the whole idea was that the basic structure of a rule is unaffected by being sync or async - at least at that level of coding).</p>
<p>But in a sync rule that isn&#39;t in a rule library (isn&#39;t reusable across object types), it is perfectly fine to cast Target to your object type and set properties - as long as you avoid infinite loop issues (like don&#39;t set the value of the primary property unless you have a way to short-circuit the resulting re-run of the rules).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pneurohr replied on Monday, July 26, 2010</h2><p>But why does AddOutValue not seem to call property changed?&nbsp; If I cast the target then I presume I am calling SetProperty instead of LoadProperty and could potentially run into some authorization issues.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, July 26, 2010</h2><p>AddOutValue ultimately does use LoadProperty(), that&#39;s true. </p>
<p>But to add an out value for a property you have to also make that property an AffectedProperty of the rule, and so a PropertyChanged event will be raised for that property.</p>
<p>For example:</p>
<p>using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br />using Csla;<br /><br />namespace ConsoleApplication1<br />{<br />&nbsp; class Program<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; static void Main(string[] args)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = new Test();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.PropertyChanged += (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(&quot;PropertyChanged {0}&quot;, e.PropertyName);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj.Value1 = &quot;hi&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine(obj.Value2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadLine();<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br /><br />&nbsp; [Serializable]<br />&nbsp; public class Test : BusinessBase&lt;Test&gt;<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;string&gt; Value1Property = RegisterProperty&lt;string&gt;(c =&gt; c.Value1);<br />&nbsp;&nbsp;&nbsp; public string Value1<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(Value1Property); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { SetProperty(Value1Property, value); }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; public static readonly PropertyInfo&lt;string&gt; Value2Property = RegisterProperty&lt;string&gt;(c =&gt; c.Value2);<br />&nbsp;&nbsp;&nbsp; public string Value2<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return GetProperty(Value2Property); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { SetProperty(Value2Property, value); }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; protected override void AddBusinessRules()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.AddBusinessRules();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BusinessRules.AddRule(new MyRule { PrimaryProperty = Value1Property });<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; private class MyRule : Csla.Rules.BusinessRule<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MyRule()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AffectedProperties.Add(Value2Property);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override void Execute(Csla.Rules.RuleContext context)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.AddOutValue(Value2Property, &quot;abc&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />}<br /></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
