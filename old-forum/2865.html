<html><header><title>Memory Tampering Security Risk?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Memory Tampering Security Risk?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2865.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>AllenG posted on Monday, May 14, 2007</h2><P>We are developing a CSLA 2.1 app that will have a Windows Forms UI with remoting to an application server.&nbsp; The app will have one database with users from different organizations, so we want to be diligent about security and, in particular, making sure our CRUD operations are userID-specific.</P>
<P>I've seen these gamers using a memory editing tool to modify memory values to cheat games, and I am wondering if a similar technique could be used by a malicious user (behind the scenes) to:</P>
<P>1) Change the value of an object's private variable, thus bypassing authorization and rules checking in the property set statements.</P>
<P>2) Change the "Name" value on their CSLA.ApplicationContext.User.Name (if that is where we choose to store the UserID (GUID)</P>
<P>3) Change a GlobalContext name-value pair in CSLA.ApplicationContext.GlobalContext... if that is where we choose to store the USerID.</P>
<P>4) Modify a role name in Csla.ApplicationContext.User.IsInRole (list)</P>
<P>Does anyone have any insight in type of memory tampering?</P>
<P>Thank you.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Monday, May 14, 2007</h2><P><FONT face=Tahoma>I actually emailed Rocky about a similar question a few years ago.&nbsp; I had found that, using CSLA custom authentication and&nbsp;reflection, I could change the username on the custom identity object to whatever user I wished.&nbsp; The remoting server would accept my "rogue" identity object as gospel.&nbsp; All I needed was the business object assembly (usually publicly available if you are using Netrun or Click-once), and I could create a rogue client that would successfully impersonate any user I liked.</FONT></P>
<P><FONT face=Tahoma>Rocky's answer was basically that once you can't trust both endpoints, CSLA remoting isn't a good choice.&nbsp; If you can't trust the client computer to be under your control, it can send whatever data it wants to your services, so you can't implicitly trust it.&nbsp; Instead, you should take more of an SOA approach where you verify every bit of input and trust nothing.</FONT></P>
<P><FONT face=Tahoma>What I still don't like about this answer, though, is this:&nbsp; I, as a competent developer could theoretically find out that one of my company's custom systems is using CSLA remoting and custom authentication.&nbsp; I could then use the same tactics I did a few years ago to create a rogue client that references the public business library assemblies and easily elevate my permissions in the app!</FONT></P>
<P><FONT face=Tahoma></FONT>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 14, 2007</h2><P>That was basically my response, yes.</P>
<P>And it remains true, though not just with CSLA. If you can't trust both endpoints, then you can't build client/server systems. Period.</P>
<P>The reason is that n-tier client/server architectures assume the client is inside the trust boundary. But you are describing a situation where the client is <EM>outside</EM> the trust boundary (not just security, but trust - a broader concept).</P>
<P>So this means you must always assume that code running on the client has been compromised. You must also assume that the data stream has been compromised, and that you may be subject to replay attacks and various other protocol and network-level attacks.</P>
<P>The basic answer is to implement an SO solution, which is message-based, but moreover employs concepts like isomorphic messaging (meaning each message is absolutely unique, so the service can include code to prevent replay attacks), and the service is <EM>entirely</EM> self-contained (meaning it does full validation, calculation, etc. on any inbound data).</P>
<P>Obviously even in such an SO setting, the client app (because it isn't a tier now) must provide a good user experience, and so it too will implement much or all of the validation, calculation, etc. That allows the UI to be responsive and nice for the "good" users, but the service never trusts that input and re-applies <EM>all</EM> logic so as to prevent being compromised by "bad" users.</P>
<P>The original post mentioned gamers. As an amateur MMORPG designer, I can tell you that these games all employ the techniques I'm talking about here. While the game clients do extravegant and exciting things, the server never trusts client input, and includes guards against replay attacks, etc.</P>
<P>Obviously this can get quite expensive. You should do a realistic threat analysis to determine your speicfic needs and how you want to respond to them. This stuff all boils down to a business decision based on cost/benefit and likelihood of compromise. No sense building Pentagon level security to protect mundane data, but similarly, you can't ignore common-but-low-impact issues or uncommon-but-fatal issues.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>joshpainter replied on Monday, May 14, 2007</h2><P><FONT face=Verdana>And I should clarify...it's not that I didn't like&nbsp;your answer, it's that it didn't make me feel any "safer" on the project I was working on at the time.&nbsp; But you were absolutely right - in the end we decided that the likelyhood of a user exploiting these attack vectors and the security level of our data&nbsp;was not worth the effort of going to extremes to stop it.</FONT></P>
<P><FONT face=Verdana>However, I did do one simple modification that made me feel a little better.&nbsp; I added a private field to the identity object that held an encrypted string.&nbsp; When the user logged in, the server authenticated him and&nbsp;sent back an identity object with that private field&nbsp;set to&nbsp;the username encrypted with a private key (stored in web.config).&nbsp; On each client request, when the client sent its identity object,&nbsp;the server would first decrypt the identity's private field&nbsp;and then compare it with the identity's username.&nbsp; If they matched, the server knew that it is the only one that could have "issued" that identity object, and therefore the user had been previously authenticated.&nbsp; This method, coupled with SSL to prevent snooping and therefore replay attacks, made me feel much better with a minimal investment.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AllenG replied on Tuesday, May 15, 2007</h2><P>Thank you Josh and Rocky for the responses.&nbsp; I understand that I'll need to do some rethinking.&nbsp; I don't have much experience with SO and web services, so I think I'll start by re-reading chapter 11, but I think the short term solution is going to be to move the client to a web forms app.&nbsp; My hope was to leverage Click Once and remoting to offer a richer UI.</P>
<P>I think the complexity of developing the "good user experience" SO client will make ASP.NET a better (faster, cheaper?) choice for now, but maybe using code generation tools, I could whip up a class library (of&nbsp;stripped-down BOs) that offers validation, calculation,&nbsp;authorization, etc.</P>
<P>OT - Rocky, I've been a "disciple" since 2002 with your VB6 BO book.&nbsp; Thank you for all you've done.&nbsp; I heard an interview once on the web where you explained why you chose to share the framework in this way...very admirable.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Tuesday, May 15, 2007</h2>If you re-authorize the user in every remote dataportal call would that help.&nbsp; Or on the DataPortal server if you simply re-created the businessprinciple for&nbsp;server&nbsp;use?</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
