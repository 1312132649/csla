<html><header><title>3 monkeys (Utilities.CallByName vs Methodcaller.CallPropertyGetter)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>3 monkeys (Utilities.CallByName vs Methodcaller.CallPropertyGetter)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6741.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong posted on Saturday, April 04, 2009</h2>As addition to my question a story of 3 monkeys in the following:<br /><a href="http://www.codeproject.com/KB/database/DynamicMethod_ILGenerator.aspx?fid=435990&amp;df=90&amp;mpp=25&amp;noise=3&amp;sort=Position&amp;view=Quick&amp;fr=76&amp;select=2130593" target="_blank" title="http://www.codeproject.com/KB/database/DynamicMethod_ILGenerator.aspx?fid=435990&amp;df=90&amp;mpp=25&amp;noise=3&amp;sort=Position&amp;view=Quick&amp;fr=76&amp;select=2130593">http://www.codeproject.com/KB/database/DynamicMethod_ILGenerator.aspx?fid=435990&amp;df=90&amp;mpp=25&amp;noise=3&amp;sort=Position&amp;view=Quick&amp;fr=76&amp;select=2130593</a><br /><br />It seems that CSLA is using both monkey 2 (slow reflection) and monkey 3 (fast dynamicmethod) code.<br /><br />However, most of the code is using the Utilities class which uses reflection alot. The Methodcaller generates dynamic methods in memory.<br /><br />Am i looking at this wrong?<br /><br />Is Methodcaller really faster like the monkey 3 in the story.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, April 04, 2009</h2><P>CSLA predates the dynamic method concept, and so had to use some reflection early on.</P>
<P>The parts of CSLA where performance matters most (n-level undo and the data portal) were converted to use dynamic methods in 3.5 thanks to a lot of help from Ricky Supit.</P>
<P>Eventually the other parts may get converted too, but honestly it is a cost/benefit issue. There's been more benefit in supporting WPF, Silverlight and so forth than in optimizing the use of reflection in areas where it has little real impact.</P>
<P>Premature optimization is an anti-pattern. We had to optimize the data portal to support some of the 3.5 concepts or they wouldn't have been practical. And it was necessary to optimize n-level undo to handle larger object graphs in complex UI scenarios. It may be necessary to optimize other areas at some point, and I'll do so if necessary.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Sunday, April 05, 2009</h2>Ok,in time perhaps.<br />I'm not trying to 'flame' CSLA ofcourse.<br /><br />Just wanted to know if i should use MethodCaller.CallPropertyGetter or Utilities.CallByName.<br /><br />Perhaps i'll create a small application to test both methods, if that doesn't put me in the anti-pattern hehe.<br /><br />Thanks for the reply.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, April 05, 2009</h2>What I was hoping to get at, is that you need to understand the situation<br />where you are using the call.<br /><br />If you are going to make relatively few calls, and/or the calls occur<br />relatively infrequently, then reflection is probably fine, and requires few<br />resources.<br /><br />If you are going to make a lot of calls, and/or the calls occur frequently,<br />then it is probably worth the overhead of establishing and caching the<br />dynamic method information to make the calls faster.<br /><br />The data portal, prior to 3.5, fit into the category of relatively few<br />calls, and so reflection was (imo) fine. The cost of talking to the database<br />was many, many, many times higher than the cost of reflection, so the use of<br />reflection (or not) made no practical (timable) difference in any real<br />application.<br /><br />The 3.5 data portal, with its support for child objects, changed the<br />equation. With the change, the data portal does a lot more invocation of<br />your objects. Due to this, the use of reflection did make a measurable<br />difference in performance for many common scenarios. This made it worth the<br />overhead of creating and caching dynamic method delegates.<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Sunday, April 05, 2009</h2>I'm using the datamapper in my factory base classes where a custom mapping definition is being analysed and parsed. It maps an DTO by using the datamapper.map with a dictionary as destionation.<br />Next the dictionary is being iterated and it does a LoadProperty with the correct propertyinfo. The propertyinfo is marked as internal and the factory methods are in a friend assembly.<br /><br />Iinserting it's slightly a differend story. By the DTO generated identifiers have to be read and set in the BO and ofcourse my internal "updatechildren" lookalike must give any identification to the BO's children factory's.<br /><br />Works great, but im a bit afraid that all the extra mapping might turn the application into a cpu &amp; memory eating monster. Anti pattern in place?<br /><br />We'll see..<br /><br />Greetings,<br />Raymond</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, April 05, 2009</h2>The DataMapper support for an IDictionary originates with ASP.NET Web Forms,<br />because that data binding model provides postback form data in the form of<br />an IDictionary. The use of reflection in that scenario is incidental,<br />because data binding is already so reflection-intensive that DataMapper<br />makes no difference (and the amount of data in a postback is necessarily<br />limited).<br /><br />I can't say I anticipated the idea of using an IDictionary as a DTO for a<br />DAL. You'd be forced to use a loosely typed dictionary, and so would incur a<br />lot of boxing/unboxing costs, and probably a lot of casting costs. It<br />doesn't seem like a particularly great model overall, DataMapper aside.<br /><br />But if performance is adequate and you don't run into maintenance issues<br />with such a loosy-goosy DTO model then all is well :)<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Sunday, April 05, 2009</h2>We have our DTO objects generated, they aren't real DTO objects. But the ORM fills them and in case of a fetch operation it can even be anonymous objects.<br /><br />No loosy goosy DTO, just generated from the datamodel :)<br /><br />What i do for fetch:<br /><br />1) Get DTO (can be with Linq to ORM)<br />Repository.GetPersistent(..)<br /><br />2) DTO to a new dictionary();<br /><br />3) Dictionary to BO<br />With LoadProperty() doing type coersion.<br /><br />Update &amp; Insert:<br /><br />1) BO to dictionary<br />2) Dictionary to DTO<br />3) Persist DTO<br />4) Foreach identity in DTO do a loadproperty() against the BO<br />5) call child factory..<br /><br />I thought that the DataMapper will help speed things up, since the GetValue and SetValue are being delegated into an dynamicmethod.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, April 05, 2009</h2>Why the dictionary in the middle?<br /><br />You go from a strong-typed model to a weak-typed model back to a<br />strong-typed model. If this is all code-genned on both sides, I agree that<br />there's no maintenance issue. But there's still a perf issue due to all this<br />data copying and type coercion and boxing and casting.<br /><br />Rocky</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Monday, April 06, 2009</h2><P>Cause of the DataMapper wanting a dictionary with field names, but double thinking about it i could just call MethodCaller directly going from DTO to BO. I didn't see that much of a problem with using Dictionary.</P>
<P>I didn't think that going from strong to weak and from weak to strong again isn't that much of a perf hit.<BR>I see that DataMapper.Map(fromObject, toDictionary)&nbsp;doesn't do type coercion.<BR>For sure type coercion in LoadProperty, but i don't see any other way then doing that.</P>
<P>The dictionary between has one major improvement for us, the propertynames can be case-insensitive :)<BR>The developer doesn't have to think about casing, in the mapping definition.<BR>Because our developers will only have to define a mapping,<BR>but most will be the already cased correctly because using lambda expressions for the propertynames. Only property alias names are handly coded.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Monday, April 06, 2009</h2><P>hmm.. the property value is already weak when called?<BR>I might be wrong, but it seems that there isn't any boxing and unboxing?</P>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2>object</FONT></FONT><FONT size=2> value = </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MethodCaller</FONT></FONT><FONT size=2>.CallPropertyGetter(dto, propertyName);</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, April 06, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>You are aware that DataMapper will map from object to object
right?<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Again, the dictionary&lt;-&gt;object support is there for
ASP.NET. But there&#8217;s object&lt;-&gt;object support for working with DTOs.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

</div>



</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
