<html><header><title>IE 9 Giving Error &quot;Unable to find assembly Csla&quot; When Running as a Full-Trust XBAP </title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>IE 9 Giving Error &quot;Unable to find assembly Csla&quot; When Running as a Full-Trust XBAP </h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10656.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>cchaney_64 posted on Tuesday, August 30, 2011</h2><p>I have developed a&nbsp;full-trust WPF XBAP application using the Csla.Net framework that runs fine in IE6, IE7, and IE8. However, when I attempt to use IE 9 I get the following error:</p>
<p style="padding-left:30px;">System.Runtime.Serialization.SerializationException: Unable to find assembly &#39;Csla, Version=4.1.0.0, Culture=neutral, PublicKeyToken=93be5fdc093e4c30&#39;.<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo.GetAssembly()<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.ObjectReader.GetType(BinaryAssemblyInfo assemblyInfo, String name)<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.ObjectMap..ctor(String objectName, String[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, Object[] typeInformationA, Int32[] memberAssemIds, ObjectReader objectReader, Int32 objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable)<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.__BinaryParser.ReadObjectWithMapTyped(BinaryObjectWithMapTyped record)<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.__BinaryParser.ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum)<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.__BinaryParser.Run()<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.ObjectReader.Deserialize(HeaderHandler handler, __BinaryParser serParser, Boolean fCheck, Boolean isCrossAppDomain, IMethodCallMessage methodCallMessage)<br />&nbsp;&nbsp; at System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize(Stream serializationStream, HeaderHandler handler, Boolean fCheck, Boolean isCrossAppDomain, IMethodCallMessage methodCallMessage)<br />&nbsp;&nbsp; at System.Runtime.Remoting.Channels.CrossAppDomainSerializer.DeserializeObject(MemoryStream stm)<br />&nbsp;&nbsp; at System.AppDomain.Deserialize(Byte[] blob)<br />&nbsp;&nbsp; at System.AppDomain.UnmarshalObject(Byte[] blob)</p>
<p>I&#39;ve made sure the security certificate is imported into the Trusted Publishers and Trusted Root Certificates stores, the site has been added as a trusted site, and the &quot;XAML browser applications&quot; IE security option is enabled. I&#39;ve also verified I can run XBAP applications in IE 9 that don&#39;t contain Csla.Net. </p>
<p>Is there something specific I need to do for CSLA.Net to work within a full-trust WPF XBAP in IE9?</p>
<p>Thanks,</p>
<p>Chris</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Wednesday, August 31, 2011</h2><p>XBAPs are just a PITA. Total PITA. They tried to emulate the worst aspects of the web with that technology - yuck!</p>
<p>If you insist on using an XBAP (where I think you should really use Silverlight - which works much better), you need to understand what the XBAP framework is doing to you (not really <em>for you</em>, but to you).</p>
<p>Each time you do a page transition, the XBAP works very hard to ensure that nothing remains in memory from the previous page. It appears they do this by creating a new AppDomain for each page - or they clean the AppDomain to a degree I&#39;ve never seen before. This takes what would be a smart client technology and dumbs it down to being at least as bad as the stateless web.</p>
<p>Also, XBAPs are hosted in IE, and so aren&#39;t hosted by a normal, native .NET environment. This messes with the .NET serialization model. The same effect occurs in IE, COM+, and other non-managed hosts.</p>
<p>Specifically, any types from dynamically loaded assemblies (assemblies loaded via reflection instead of static binding), are not found during deserialization like they should be. Many years ago I tried to argue that this was a bug. But even if it is a bug, the issue is at such a low level, near the core of the .NET runtime itself, that changing it now is unrealistic I&#39;m sure.</p>
<p>To overcome this serialization issue, you need to establish a hook at the AppDomain level to &quot;help&quot; the .NET serialization model work properly. Basically, you set up an event handler that is invoked when the runtime can&#39;t find a type. In your event handler, you look through the list of known types, and return the one that the runtime couldn&#39;t find.</p>
<p>Behind the scenes it turns out that .NET maintains (iirc) 4 different lists of known types. The one you can get from the AppDomain object is a consolidated list - so we see just one list. But there are really 4. And for some reason the dynamically loaded list isn&#39;t used when .NET is running within a non-managed host.</p>
<p>The Enterprise Service data portal channel has this code - look at older versions of CSLA .NET. Or look at CSLA .NET 1.0, specifically at a utility I included back then to run .NET apps from a network shared drive. That also includes this code.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cchaney_64 replied on Thursday, September 01, 2011</h2><p>Rocky,</p>
<p>Firstly, thanks for the response. It turns out this was a stupid permission problem with the user account and the backend database. That&#39;s totally my bad. </p>
<p>In general though it has been a pain to work out all the security aspects of the XBAP. The main reason we went with full-trust XBAP was so it could access local resources on the user&#39;s PC. We need to save files to their local hard-drive for data export features, etc. Though certainly no expert, I thought Silverlight was a sand-boxed architecture using WPF and would always run in a partial-trust mode in the browser. Can I access local resources with Silverlight? Would I just make the silverlight component full trust or something similiar?</p>
<p>Thanks,</p>
<p>Chris</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, September 02, 2011</h2><p>There are several options:</p>
<ol>
<li>WPF app deployed/updated with ClickOnce</li>
<li>WPF XBAP app deployed/updated via browser (and with all the XBAP limits)</li>
<li>WPF app deployed the &quot;old fashioned&quot; ways (like msi)</li>
<li>Silverlight app</li>
</ol>
<p>Silverlight 3 can run out-of-browser. Silverlight 4 allows COM interop. Silverlight 5 has p/invoke (they just put out the release candidate for SL5).</p>
<p>Personally, my speculation is that WPF has a limited life, because Silverlight is moving so much faster, and is core to Windows Phone and Windows clients. But that&#39;s editorial thinking on my part :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jbinder replied on Thursday, October 27, 2011</h2><p>I am having a similar issue to what this thread is describing. After reading your reply, I am very much hopeful that there may be a solution, but I was wondering if you could give me a little more direction. My issue is as follows:</p>
<p>I have a Win Form control that I want to host in internet explorer. I have the assembly for this control marked as com visible and all the proper attributes and decoration for com&nbsp;visibility. When I install the control on a client (via msi), it renders perfectly in internet explorer. The control gathers data by making WCF calls to a server. The calls&nbsp;succeede&nbsp;(I can verify the requests are&nbsp;received&nbsp;at the server), but when the results come back, the result objects are not able to be deserialized by the IE process (even though the&nbsp;assemblies&nbsp;for the corresponding classes are loaded into memory).</p>
<p>This sounds very similar to what you&#39;re describing in this post regarding the running process not knowing what to do about deserialization. I would like to try your approach regarding &quot;Helping the framework figure out what to do&quot; but I&#39;m not sure of the approach. I&#39;m not sure if I can catch the&nbsp;unhandled&nbsp;app domain exceptions as my code is only a .NET control, and I don&#39;t have much control over the IE process. Any&nbsp;direction&nbsp;you could provide would be much appreciated.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, October 27, 2011</h2><p>One example of the code is here:</p>
<p><a href="http://www.lhotka.net/cslacvs/viewvc.cgi/csla1-x/trunk/cslacs10/NetRun/Launcher.cs?view=markup">http://www.lhotka.net/cslacvs/viewvc.cgi/csla1-x/trunk/cslacs10/NetRun/Launcher.cs?view=markup</a></p>
<p>Search for &quot;workaround&quot; and you&#39;ll see the code bits necessary.</p>
<p>The serialization workaround is an ancient issue&nbsp;- svn shows the date as 2003 or 2004, but I&#39;m pretty sure I actually wrote this originally in 2001 or something :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jbinder replied on Thursday, October 27, 2011</h2><p>That worked!!! Thank you so much!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
