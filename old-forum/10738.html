<html><header><title>Csla.Xaml.InvokeMethod exception handling</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Csla.Xaml.InvokeMethod exception handling</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10738.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>BrianPerry posted on Wednesday, October 05, 2011</h2><p>This is the scenario:</p>
<ul>
<li>WPF-MVVM-CSLA 4.1 application</li>
<li>The views trigger the view model methods via Csla.Xaml.InvokeMethod</li>
<li>There is an AppDomain-level exception handler in App.xaml.cs for logging any&nbsp;random, app-killing&nbsp;exceptions for analysis and troubleshooting</li>
</ul>
<p>The problem is that InvokeMethod.CallMethod has a catch block that rethrows exceptions thrown by view model code, which resets the exception call stack. The result is uninformative&nbsp;logged exceptions like the one below.</p>
<p>System.NullReferenceException: Object reference not set to an instance of an object.<br />&nbsp;&nbsp; at Csla.Xaml.InvokeMethod.CallMethod(Object sender, EventArgs e)&nbsp;<br />&nbsp;&nbsp; at blah blah blah</p>
<p>One solution is to simply&nbsp;eliminate the try-catch&nbsp;in InvokeMethod.CallMethod. Do I lose anything essential by doing that? Is there a better solution?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Wednesday, October 05, 2011</h2><p>InvokeMethod is deprecated and will be removed in a future version. </p>
<p>You should consider using TriggerAction instead. It is more flexible, more powerful, and provides better debugging overall.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>BrianPerry replied on Wednesday, October 05, 2011</h2><p>Switching to TriggerAction may be a good idea for other reasons, but it has the same try-catch logic as InvokeMethod, with the same effect on the exception call stack.</p>
<p>System.NullReferenceException: Object reference not set to an instance of an object.<br />&nbsp;&nbsp; at Csla.Xaml.TriggerAction.CallMethod(Object sender, EventArgs e)</p>
<p>So to rephrase the question, what, if anything, do I lose by&nbsp;eliminating the try-catch from TriggerAction.CallMethod, and letting the original exception, with its original call stack,&nbsp;flow naturally up to the global exception handler as the inner exception to the TargetInvocationException? The resulting log entry is longer as a result, but unlike the above entry it provides useful information.</p>
<p>System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.NullReferenceException: Object reference not set to an instance of an object.<br />&nbsp;&nbsp; at ViewModels.ViewModel.Calculate() in etc.<br />&nbsp;&nbsp; --- End of inner exception stack trace ---<br />&nbsp;&nbsp; at System.RuntimeMethodHandle._InvokeMethodFast(IRuntimeMethodInfo method, Object target, Object[] arguments, SignatureStruct&amp; sig, MethodAttributes methodAttributes, RuntimeType typeOwner)<br />&nbsp;&nbsp; at System.RuntimeMethodHandle.InvokeMethodFast(IRuntimeMethodInfo method, Object target, Object[] arguments, Signature sig, MethodAttributes methodAttributes, RuntimeType typeOwner)<br />&nbsp;&nbsp; at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)<br />&nbsp;&nbsp; at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)<br />at Csla.Xaml.TriggerAction.CallMethod(Object sender, EventArgs e)</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, October 06, 2011</h2><p>I don&#39;t know that there&#39;s any real drawback to what you propose.</p>
<p>The reason we swallow TargetInvocationException is that it is the only exception that really occurs, and it obscures the underlying inner exception (the one you really care about). So we were trying to be helpful :)</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>BrianPerry replied on Thursday, October 06, 2011</h2><p>Helpful is good. Unfortunately,&nbsp;System.Exception offers two less than ideal options: expose the irrelevant exception or lose the stack trace.&nbsp;The following link suggests that there might be a better option in the future.</p>
<p><a href="https://connect.microsoft.com/VisualStudio/feedback/details/633822/allow-preserving-stack-traces-when-rethrowing-exceptions">https://connect.microsoft.com/VisualStudio/feedback/details/633822/allow-preserving-stack-traces-when-rethrowing-exceptions</a></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
