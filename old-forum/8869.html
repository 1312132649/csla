<html><header><title>Recommended way to load child properties or work with collections in Silverlight</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Recommended way to load child properties or work with collections in Silverlight</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8869.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>wjcomeaux posted on Monday, May 03, 2010</h2><p>Due to the async requirement of Silverlight we have had to figure out a way to load child properties in Silverlight. What we are currently doing is basically loading the child properties asynchronously but making the call to the property behave in a synchronous manner. This works but I am not happy with the solution.<br /><br />Another issue we struggle with is working with collections in an async manner. If you have a foreach loop on an editable collection how do you handle this? We are basically doing pretty much the same as when loading the property in the code below (making the foreach act synchronous in that nothing else gets processed on the thread until the foreach is done). This completely removes any async benefits we would have, and again, I&#39;m not hapy with it.<br /><br />Can you all share ideas of how you are handling these scenarios? We definitely want to keep the object graph as is so loading other root objects asynchronously is not an option for us.<br /><br />Thanks, Will<br /><br /><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">//Our Current Property Loading Code<br />private</span></span><span style="font-size:x-small;"> </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">bool</span></span><span style="font-size:x-small;"> _privilegeAsyncPropertyIsLoading = </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">false</span></span><span style="font-size:x-small;">;<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">private</span></span><span style="font-size:x-small;"> </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">static</span></span><span style="font-size:x-small;"> </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">readonly</span></span><span style="font-size:x-small;"> </span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">PropertyInfo</span></span><span style="font-size:x-small;">&lt; </span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">Privilege</span></span><span style="font-size:x-small;"> &gt; _privilegeAsyncProperty = RegisterProperty&lt; </span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">Privilege</span></span><span style="font-size:x-small;"> &gt;(p =&gt; p.PrivilegeAsync, Csla.</span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">RelationshipTypes</span></span><span style="font-size:x-small;">.Child);<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">public</span></span><span style="font-size:x-small;"> </span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">Privilege</span></span><span style="font-size:x-small;"> PrivilegeAsync<br />{<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">&nbsp; get<br /></span></span><span style="font-size:x-small;">&nbsp; {<br />&nbsp;&nbsp;&nbsp; System.Threading.</span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">AutoResetEvent</span></span><span style="font-size:x-small;"> waitEvent = </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">new</span></span><span style="font-size:x-small;"> System.Threading.</span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">AutoResetEvent</span></span><span style="font-size:x-small;">(</span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">false</span></span><span style="font-size:x-small;">);<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">&nbsp; &nbsp; if</span></span><span style="font-size:x-small;"> (!_privilegeAsyncPropertyIsLoading &amp;&amp; !FieldManager.FieldExists(_privilegeAsyncProperty))<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp;&nbsp;&nbsp; _privilegeAsyncPropertyIsLoading = </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">true</span></span><span style="font-size:x-small;">;<br /></span><span style="color:#2b91af;font-size:x-small;"><span style="color:#2b91af;font-size:x-small;">&nbsp;&nbsp;&nbsp; &nbsp; Privilege</span></span><span style="font-size:x-small;">.GetPrivilegeAsync(PrivilegeID, (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(_privilegeAsyncProperty, e.Object);<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OnPropertyChanged(_privilegeAsyncProperty.Name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; _privilegeAsyncPropertyIsLoading = </span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">false</span></span><span style="font-size:x-small;">;<br />&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; waitEvent.Set();<br />&nbsp;&nbsp;&nbsp; &nbsp; });<br />&nbsp; &nbsp; }<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">&nbsp; &nbsp; else<br /></span></span><span style="font-size:x-small;">&nbsp; &nbsp; {<br />&nbsp; &nbsp;&nbsp;&nbsp; waitEvent.Set();<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; waitEvent.WaitOne();<br /></span><span style="color:#0000ff;font-size:x-small;"><span style="color:#0000ff;font-size:x-small;">&nbsp; &nbsp; return</span></span><span style="font-size:x-small;"> GetProperty(_privilegeAsyncProperty);<br />&nbsp; }<br />}</span></p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p>I would suggest stepping back from the problem and looking at it anew.</p>
<p>Silverlight server communication is async. This has a very real impact on how applications should be constructed. In many cases there are different ways to approach the overall problem that recognize the async reality and make use of it rather than fighting it.</p>
<p>What you are doing right now is fighting the async model, and while you might win the fight you probably won&#39;t be real happy in the end.</p>
<p>The nature of async is that you need to shift work from a synchronous flow into an async flow. Usually this means doing much of the actual work in a callback instead of in-line.</p>
<p>For UI-centric scenarios this is easy, because the UI is already event-driven and CSLA will make things &quot;just work&quot;. Lazy load a property, and the data will just appear in the UI when it is available. That&#39;s automatic, thanks to CSLA interacting correctly with data binding to make it happen.</p>
<p>For algorithmic processing (like your foreach loop) you are really faced with a choice - remain linear and fight the async reality, or rethink your algorithm to exploit the async model - which means breaking apart the &quot;start the process&quot; from the &quot;do the work&quot; parts of your algorithm.</p>
<p>You should also (I think) question the use of lazy loading as a general rule, especially if you have algorithmic code that relies on the data. Why would you lazy load it if you know you need it? Lazy loading is intrinsically less efficient, and should only be used if the data is rarely actually loaded.</p>
<p>But even if you say that the algorithmic operation is rarely invoked, so lazy loading &quot;makes sense&quot;, I would suggest that you consider this operation to be a separate use case - at least think through that possibility. Because if it is a separate use case, then you could just load the data using a different root object. You still need the algorithm to be modeled as async, but it is simpler to put the foreach loop in the FetchCompleted handler of the data portal than what you are doing now.</p>
<p>Finally, if you say none of this works - you really do need lazy loading of a property of an existing root object. OK, that&#39;s fine. Then what you need is an event that is raised when the property has actually been loaded. You can use PropertyChanged, but it might be simpler to declare your own property and raise it when the async load is complete.</p>
<p>That allows the calling code (where your foreach is now) to trigger the property load, and then you&#39;d put the foreach loop itself into a handler of that lazy-load-complete event.</p>
<p>In the final analysis, you need to look at breaking your algorithm up to be async-aware, and trigger the foreach part based on the completion of the async load.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>wjcomeaux replied on Monday, May 03, 2010</h2><p>We have two reasons why we are using Lazy Loading.<br />1) Our object graphs can be fairly complex with some items only being used some of the time. <br />For instance, using a typical (very simple)&nbsp;User/Role scenario:<br />User<br />&nbsp;&nbsp; RoleList<br />&nbsp;&nbsp;&nbsp;&nbsp; PrivilegeList<br />We&nbsp;have&nbsp;various use cases like (User Edit,&nbsp;User RoleList Edit, User PrivilegeList Edit) and all of these are under the context of the user.<br />Given that we have ONLY one User object&nbsp;(we are&nbsp;using CodeSmith and generating with a customized version of their latest CSLA templates), I don&#39;t have just a User object that doesn&#39;t know about RoleList (as would be the proper case that I think you would recommend).&nbsp;So, we are kind of forced into a lazy-load scenario because when all we want to do is edit a&nbsp;User we don&#39;t want to wait for Roles and Privileges to load.</p>
<p>2) Our choice of code generation&nbsp;templates comes with it&#39;s own set of limitations. Generating the above code means our User object&nbsp;has a RoleList collection exposed as&nbsp;a public property AND our RoleList exposes a public property of User. We had to do some customizations to the templates to prevent infinite load loops because we ran into this scenario quite often:&nbsp; Load User -&gt; Load RoleList -&gt; Load UserList for each Role in RoleList&nbsp;-&gt; &quot;to infinity and beyond&quot;. This customization basicaly came in the form of lazy loading so that&nbsp;Many-to-one and Many-to-many properties only get loaded when they are called the first time and on update (to prevent saving an out of date version). We have overridden the IsValid check to&nbsp;basically do (if RoleList == null || RoleList.IsValid) to allow for the lazy load. The rationale is that if the child object is null then accept it as valid because it wasn&#39;t employed for the current use&nbsp;case. This is all exposed by our customized code generation templates.<br />&nbsp;&nbsp; <br />On the topic of asynchronously loading properties, how do you accomplish this? Our sample that I gave in my initial post forces the async property to behave synchronously from the POV of the calling code. This was adopted because you can&#39;t provide a callback to a Property. Would you recommend exposing an PropertyXYZLoaded event be exposed on the business object that would get raised from inside of the property and have the calling code listen for the event? Or would it be better to expose LoadPropertyXYZ(callback) functions for each property and then have the property simply act as as accessor that can and will be null if the LoadPropertyXYZ hasn&#39;t been called yet?<br /><br />Any solution we decide on has to be something that can be rolled into the code generation templates, which isn&#39;t usually an issue, just something to keep in mind.</p>
<p>Thanks for all of your help!<br />Will</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>wjcomeaux<br></b></p>
<p>On the topic of asynchronously loading properties, how do you accomplish this? Our sample that I gave in my initial post forces the async property to behave synchronously from the POV of the calling code. This was adopted because you can&#39;t provide a callback to a Property. Would you recommend exposing an PropertyXYZLoaded event be exposed on the business object that would get raised from inside of the property and have the calling code listen for the event? Or would it be better to expose LoadPropertyXYZ(callback) functions for each property and then have the property simply act as as accessor that can and will be null if the LoadPropertyXYZ hasn&#39;t been called yet?</p>
<p></div></p>
<p>As I mentioned, if the lazy loading is done within the context of a bound UI, you don&#39;t need to worry about making the property appear to be synchronous. The UI will bind to the default null value, and then will update to show the real data when it arrives. This is automatic, and is a good solution for most UI binding scenarios.</p>
<p>The worst thing you might need to do is use a ValueConverter or viewmodel property to allow the UI to disable the area where the child object&#39;s data will appear until the value is something other than null. But that&#39;s not hard, and is really a UI concern more than a business layer concern. The point is that CSLA objects already expose everything necessary to make this work.</p>
<p>If you want, almost as a bonus, you can add calls to set the IsBusy property of the parent in your async lazy load code. In most of my UIs this would cause a busy animation to run, and would block out the UI from user interaction during the async process - which may or may not be desired.</p>
<p>In any case, using blocking techniques like you have in your code <i>should be avoided</i>. This is because blocking the SL UI thread locks the browser. The whole browser. The user won&#39;t be able to switch tabs, resize, move, etc. In short, you&#39;ll really irritate your users - I know that sort of experience would make me very unhappy. This is, in fact, why SL defaults to async server access - because the alternative is simply unacceptable for normal web apps, and if Microsoft had made sync possible/easy then everyone would hate Silverlight (they wouldn&#39;t blame your app - they&#39;d just blame Silverlight...)</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
