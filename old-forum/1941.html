<html><header><title>Authorization rules on methods</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Authorization rules on methods</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1941.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>edika2000 posted on Monday, December 11, 2006</h2>Hi all,<br><br>I would like to specify wich roles are enabled to use or not each public methods (that execute CommandBase) on my classes.<br>Someone can suggest me a way to do it without&nbsp; the use of the authorization rules of the properties?<br>Thanks.<br><br>Edika<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2>Usually you check the prinical's role and throw a securityexception if teh user doesn't have the proper role(s).<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, December 11, 2006</h2><P>We added a "CanExecuteMethod" method to our base class(es) that behaves just like the CanReadProperty and CanWriteProperty methods.&nbsp; We added AllowExecute and DenyExecute methods along with IsExecuteAllowed and IsExecuteDenied properties to the AuthorizationRules collection.&nbsp; This allowed us to implement these checks in a consistent manner as with the properties.&nbsp; They behave in the same way using the method name instead of the property name as an argument for the various method and property calls.</P>
<P>HTH</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>edika2000 replied on Monday, December 11, 2006</h2>Thanks, this is what I'd wonder to do but can you post an example of how you've implmented this?<br><br>Edika<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2>That's actually a great idea. <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ChristianPena replied on Monday, December 11, 2006</h2>That's a nice clean solution. It's a good example of where inheriting from your own base classes really brings benefit as well. </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2>I hope Pirate posts and gives more insight.&nbsp; I started adding this and although it so far seems easy to do, I went and added some extensions to AuthRulesManager, AuthRules and ValidationRules via partial classes.&nbsp; Basically role lists are totally seperate between proprties and methods (and obviously you have ExecuteDeny or grant only, not four different combinations).<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, December 11, 2006</h2><P>It actually was as easy at it sounds - at least they way I did it.&nbsp; I did not separate properties from methods internally because the name already makes then unique within each object, so I didn't think this was necessary.&nbsp; This allowed me to simply patterns another set of methods around what was already there for properties.</P>
<P>For strictly sematical reasons, I renamed the RolesForProperty class to RolesForMember and changed all applicable code referring to it (actually, the built-in refactoring on rename did it for me!).&nbsp; Inside that class, I added private variables with the same form and syntax as the existing four for _executeAllowed and _executeDenied along with corresponding properties and IsExecuteAllowed and IsExecuteDenied methods.&nbsp; So the end result looked like this (I'll spare you the comments):</P>
<P><CODE>/// &lt;summary&gt;<BR>/// Maintains a list of allowed and denied user roles for a specific class member.<BR>/// &lt;/summary&gt;<BR>[Serializable()]<BR>internal class RolesForMember<BR>{<BR>&nbsp; &nbsp; private List&lt;string&gt; _executeAllowed = new List&lt;string&gt;();<BR>&nbsp; &nbsp; private List&lt;string&gt; _executeDenied = new List&lt;string&gt;();<BR>&nbsp; &nbsp; private List&lt;string&gt; _readAllowed = new List&lt;string&gt;();<BR>&nbsp; &nbsp; private List&lt;string&gt; _readDenied = new List&lt;string&gt;();<BR>&nbsp; &nbsp; private List&lt;string&gt; _writeAllowed = new List&lt;string&gt;();<BR>&nbsp; &nbsp; private List&lt;string&gt; _writeDenied = new List&lt;string&gt;();<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; ExecuteAllowed<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _executeAllowed; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; ExecuteDenied<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _executeDenied; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; ReadAllowed<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _readAllowed; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; ReadDenied<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _readDenied; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; WriteAllowed<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _writeAllowed; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public List&lt;string&gt; WriteDenied<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get { return _writeDenied; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsExecuteAllowed(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in ExecuteAllowed)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsExecuteDenied(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in ExecuteDenied)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsReadAllowed(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in ReadAllowed)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsReadDenied(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in ReadDenied)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsWriteAllowed(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in WriteAllowed)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public bool IsWriteDenied(IPrincipal principal)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; foreach (string role in WriteDenied)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (principal.IsInRole(role))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; return false;<BR>&nbsp; &nbsp; }<BR>}<BR></CODE></P>
<P>In AuthorizationRules, rather than change GetRolesForProperty to GetRolesForMember, I decided to leave the distinction here because I didn't think it was appropriate to add ExecuteAllowed and ExecuteDenied to the AccessType enumeration.&nbsp;I didn't want to make it seem possible to query GetRolesForProperty(validPropertyName, AccessType.ExecuteAllowed).&nbsp;So, I chose not to extend the AccessType enumeration.</P>
<P>Instead, I added the following method to the AuthorizationRules class:</P>
<P><CODE>private RolesForMember GetRolesForMethod(string methodName)<BR>{<BR>&nbsp; &nbsp; RolesForMember currentRoles = null;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; if (!Rules.ContainsKey(methodName))<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; currentRoles = new RolesForMember();<BR>&nbsp; &nbsp; &nbsp; &nbsp; Rules.Add(methodName, currentRoles);<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; else<BR>&nbsp; &nbsp; &nbsp; &nbsp; currentRoles = Rules[methodName];<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return currentRoles;<BR>}<BR></CODE></P>
<P>Next, I added the following&nbsp;to the AuthorizationRules class to allow rule setting and checking:</P>
<P><CODE>public void AllowExecute(string methodName, params string[] roles)<BR>{<BR>&nbsp; &nbsp; RolesForMember currentRoles = GetRolesForMethod(methodName);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; foreach (string item in roles)<BR>&nbsp; &nbsp; &nbsp; &nbsp; currentRoles.ExecuteAllowed.Add(item);<BR>}<BR>&nbsp;<BR>public void DenyExecute(string methodName, params string[] roles)<BR>{<BR>&nbsp; &nbsp; RolesForMember currentRoles = GetRolesForMethod(methodName);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; foreach (string item in roles)<BR>&nbsp; &nbsp; &nbsp; &nbsp; currentRoles.ExecuteDenied.Add(item);<BR>}<BR>&nbsp;<BR>public bool HasExecuteAllowedRoles(string methodName)<BR>{<BR>&nbsp; &nbsp; return (GetRolesForMethod(methodName).ExecuteAllowed.Count &gt; 0);<BR>}<BR>&nbsp;<BR>public bool IsExecuteAllowed(string methodName)<BR>{<BR>&nbsp; &nbsp; return GetRolesForMethod(methodName).IsExecuteAllowed(ApplicationContext.User);<BR>}<BR>&nbsp;<BR>public bool HasExecuteDeniedRoles(string methodName)<BR>{<BR>&nbsp; &nbsp; return (GetRolesForMethod(methodName).ExecuteDenied.Count &gt; 0);<BR>}<BR>&nbsp;<BR>public bool IsExecuteDenied(string methodName)<BR>{<BR>&nbsp; &nbsp; return GetRolesForMethod(methodName).IsExecuteDenied(ApplicationContext.User);<BR>}<BR></CODE></P>
<P>Finally, the following were added to BusinessBase:</P>
<P><CODE>public bool CanExecuteMethod(bool throwOnFalse)<BR>{<BR>&nbsp; &nbsp; string methodName = new System.Diagnostics.StackTrace().GetFrame(1).GetMethod().Name.Substring(4);<BR>&nbsp; &nbsp; bool result = CanExecuteMethod(methodName);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; if (throwOnFalse &amp;&amp; result == false)<BR>&nbsp; &nbsp; &nbsp; &nbsp; throw new System.Security.SecurityException(String.Format("{0} ({1})", Resources.MethodExecuteNotAllowed, methodName));<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return result;<BR>}<BR>&nbsp; &nbsp; <BR>public bool CanExecuteMethod(string methodName, bool throwOnFalse)<BR>{<BR>&nbsp; &nbsp; bool result = CanExecuteMethod(methodName);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; if (throwOnFalse &amp;&amp; result == false)<BR>&nbsp; &nbsp; &nbsp; &nbsp; throw new System.Security.SecurityException(String.Format("{0} ({1})", Resources.MethodExecuteNotAllowed, methodName));<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return result;<BR>}<BR>&nbsp; &nbsp; <BR>public bool CanExecuteMethod()<BR>{<BR>&nbsp; &nbsp; string methodName = new System.Diagnostics.StackTrace().GetFrame(1).GetMethod().Name.Substring(4);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return CanExecuteMethod(methodName);<BR>}<BR>&nbsp; &nbsp; <BR>public virtual bool CanExecuteMethod(string methodName)<BR>{<BR>&nbsp; &nbsp; bool result = true;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; if (AuthorizationRules.HasExecuteAllowedRoles(methodName))<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; // some users are explicitly granted execute rights<BR>&nbsp; &nbsp; &nbsp; &nbsp; // in which case all other users are denied.<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (!AuthorizationRules.IsExecuteAllowed(methodName))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; else if (AuthorizationRules.HasExecuteDeniedRoles(methodName))<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; // some users are explicitly denied execute rights<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (AuthorizationRules.IsExecuteDenied(methodName))<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = false;<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; return result;<BR>}</CODE></P>
<P>I'm pretty sure that's it.&nbsp; Hope that answers your questions...</P>
<P>Oh, create the rules in AddAuthorizationRules just like properties and&nbsp;at the start of each applicable method, just call CanExecuteMethod just like CanReadProperty and CanWriteProperty.&nbsp; That simple.</P>
<P>HTH</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 11, 2006</h2>Pirate,<br><br>Thanks for the code.&nbsp; I went the seperate route so that you couldn't have Executeallowed / Denied on properties, and allow / deny / read / write for methods.<br><br>Also, it helped keep my changes in seperate code files, so that I don't have alot of work on each upgrade (just have to add back the partial keyword).<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>willfarnaby replied on Monday, December 11, 2006</h2><strong>ajj3085, can you please post your C# code files (either inline as text, or in an attached RAR or ZIP file if this board supports and allows attachments) for your modified authorization implementation?<br><br>Thanks.<br><br></strong></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 12, 2006</h2>Not sure if my company would like that.&nbsp; Its pretty simple though.&nbsp; All I did was copy the methods / properties for Reading a property into another file (which is the other part of the partial class) and change Read to Execute.&nbsp; The files are AuthorizationRules.cs, AuthorizationRulesManager.cs.&nbsp; I also created a copy of RoleForProperty and named it RoleForMethod, making appropriate changes.&nbsp; Finally I added to the enumeration... you'll be able to find the name.<br><br>Then in your business subclass you can add CanExecuteMethod, again pretty much copying and pasting the code for CanReadProperty and making appropriate changes.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, December 11, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Pirate,<BR><BR>Thanks for the code.&nbsp; I went the seperate route so that you couldn't have Executeallowed / Denied on properties, and allow / deny / read / write for methods.<BR><BR>Also, it helped keep my changes in seperate code files, so that I don't have alot of work on each upgrade (just have to add back the partial keyword).<BR><BR>Andy<BR></div></BLOCKQUOTE></P>
<P>I opted to have separate methods and not add to the AccessType enumeration to accomplish this.&nbsp; Realistically, because these methods are all accepting strings, there really isn't a safeguard in place to validate the name being passed.&nbsp; I've considered making a simply call using Reflection to verify the property and method names are valid.&nbsp; That would ensure that no properties were passed to the Allow/DenyExecute method and visa versa.</P>
<P>In fact, now that I am thinking about it again, I am going to do just that.&nbsp; Our framework is being rolled out for team development including an off-shore team, so I'd better bullet-proof it where ever I can!</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 12, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I opted to have separate methods and not add to the AccessType enumeration to accomplish this.&nbsp; Realistically, because these methods are all accepting strings, there really isn't a safeguard in place to validate the name being passed.&nbsp; </div></BLOCKQUOTE><br><br>Right, I actually did add to the enumeration though, but it sounds like we have more or less the same code.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>SonOfPirate:</strong></div><div>I've considered making a simply call using Reflection to verify the property and method names are valid.&nbsp; That would ensure that no properties were passed to the Allow/DenyExecute method and visa versa.

<p>In fact, now that I am thinking about it again, I am going to do just that.&nbsp; Our framework is being rolled out for team development including an off-shore team, so I'd better bullet-proof it where ever I can!</div></BLOCKQUOTE></p>Sounds like an excellent idea, especially if you're having a bunch of new people using Csla.&nbsp; Good luck!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>edika2000 replied on Tuesday, December 12, 2006</h2>That's great SonOfPirate, very smart solution. It could be a good idea for Rocky to add it in the next release of the CSLA.<br>Many thanks<br><br>Edika<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Monday, December 11, 2006</h2>Please compare notes and come up with a "best of both approaches" set of code.&nbsp; Then contact Rocky to get permission to post it to the CSLA Contrib project.&nbsp;&nbsp; It sounds like a great extension to the product, and maybe we'll get him to incorporate it into the base product.&nbsp; (Particularly if someone ports it to the other language!)</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
