<html><header><title>The type 'Csla.Core.MobileObject' cannot be deserialized</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>The type 'Csla.Core.MobileObject' cannot be deserialized</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10389.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH posted on Friday, May 20, 2011</h2><p>I&#39;m trying to use enterprise library for Silverlight caching block.&nbsp; Using the IsolatedStorage container, I&#39;m able to successfully serialize a ReadOnlyList to my IsolatedStorage.&nbsp; However, on deserialization, I get the following exception:</p>
<p>The type &#39;Csla.Core.MobileObject&#39; cannot be deserialized because it does not have a public parameterless constructor. Alternatively, you can make it internal, and use the InternalsVisibleToAttribute attribute on your assembly in order to enable serialization of internal members - see documentation for more details. Be aware that doing so has certain security implications.</p>
<p>I have verified that my ReadOnlyList and each ReadOnlyInfo child contain public paramaterless constructors, but I still receive this exception.<br /><br />Any thoughts?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, May 20, 2011</h2><p>I&#39;m not familiar with this application block. But it is possible that they are using the DataContractSerializer (DCS) to directly serialize the object graph - and that won&#39;t work.</p>
<p><a href="http://www.lhotka.net/cslanet/faq/XmlServicesFaq.ashx">http://www.lhotka.net/cslanet/faq/XmlServicesFaq.ashx</a></p>
<p>The problem is that Silverlight has no BinaryFormatter or NetDataContractSerializer (like .NET), and so the more common solution to cloning an object graph isn&#39;t available on Silverlight. For CSLA we implemented our own serializer (MobileFormatter) to overcome this limitation - but of course this Silverlight caching block wouldn&#39;t know about such a thing, and is probably restricted to the more limited/primitive DCS...</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>AaronH replied on Friday, May 20, 2011</h2><p>They are actually using the DataContractJsonSerializer, belonging to the System.Runtime.Serialization.Json namespace of the System.ServiceModel.Web assembly.</p>
<p>In any event, I have come up with a work around.&nbsp; When using the Ent Library Caching block, you interact with a CacheItem, which exposes a Value property.&nbsp; The Value property is the object you want cached.</p>
<p>So before setting the Value of the CacheItem, I perform the following (note that the CompressionUtility is part of the SharpZipLib project):</p>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">var</span>&nbsp;data&nbsp;=&nbsp;Csla.Serialization.Mobile.<span style="COLOR:#2b91af;">MobileFormatter</span>.Serialize(result.Object);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;<span style="COLOR:#2b91af;">CompressionUtility</span>.Compress(data);</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;"><pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">               cacheContainer.Add(cacheKey,&nbsp;data,&nbsp;<span style="COLOR:#2b91af;">DateTimeOffset</span>.MaxValue);
</pre>
</pre>
<p>First, result.Object is representing a ReadOnlyList of objects.&nbsp; Notice that I&#39;m first serializing the object graph with the Csla MobileFormatter, then further compressing the results.&nbsp;<span style="text-decoration:underline;"> This is important</span>.&nbsp; To put things into perspective, here are some size differentials with different configurations:</p>
<p>Given a ReadOnlyList that contains five ReadOnly instances, each one containing and ID and Name property (not alot of data here)</p>
<p>1.) Using Ent Lib Cache serialization default: <strong>2K </strong>(remember that objects cannot be deserialized by Ent Lib after they&#39;ve been serialized in iso storage)</p>
<p>2.) Serialize using MobileFormatter: <strong>31K </strong>(remember, this is 31K for FIVE objects containing only ID and Name property values)</p>
<p>3.) Serialize using MobileFormatter, then compress using CompressionUtility: <strong>4K</strong></p>
<p>As you can see, option 3 is twice the size of option option 1.&nbsp; But this allows you to continue to use your ReadOnlyInfoLists in conjunction with the Ent Lib Caching Block (Isolated Storage, not a problem with In Memory).&nbsp; Option 2 speaks for itself.</p>
<p>So after successful serialization to Iso Storage, here is how I get it back:&nbsp;</p>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">var</span>&nbsp;data&nbsp;=&nbsp;<span style="COLOR:#2b91af;">CompressionUtility</span>.Decompress(item.Value&nbsp;<span style="COLOR:blue;">as</span>&nbsp;<span style="COLOR:blue;">byte</span>[]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="COLOR:blue;">object</span>&nbsp;values&nbsp;=&nbsp;Csla.Serialization.Mobile.<span style="COLOR:#2b91af;">MobileFormatter</span>.Deserialize(data);</pre>
<pre style="FONT-FAMILY:Consolas;BACKGROUND:white;COLOR:black;FONT-SIZE:13px;">                return values as whateverTheTypeIsThatYouSerialized;</pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 20, 2011</h2><p>The reason number 2 is large (and why compression works so well) is that the .NET type data is included in the serialization data. To a large degree, the same type names are repeated numerous times in the stream - so compression works <em>great</em>, but the initial size is large.</p>
<p>I evaluated techniques to optimize the stream by creating a dictionary of type names. And that would work fine, but is really duplicate processing effort over compression. Or to put it another way, compression was still valuable, and if you are going to compress anyway it is cheaper to just let it do all the work than to have the MobileFormatter consolidate the type names.</p>
<p>For some future version of CSLA I&#39;m considering completely abandoning Microsoft&#39;s serialization schemes to create one unique to CSLA. Given the intrinsic knowledge CSLA has about its own types, I could serialize the object graphs in a much more efficient manner than Microsoft does with reflection, and could generate a data stream more like JSON than the highly verbose NDCS XML results (which is similar to what MobileFormatter generates).</p>
<p>In any case, I&#39;m rambling - I&#39;m glad you have a solution!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronH replied on Friday, May 20, 2011</h2><p>That would be fantastic.&nbsp; Would you use this serialization scheme when marshalling objects between servers as well?&nbsp; Anything to reduce that bloat would be gold.</p>
<p>I&#39;m noticing that just sending ReadOnly objects to my SL clients (even with compression) is pretty huge.&nbsp; 4X more than serializing POCO objects containing the same properties and runtime values.</p>
<p>I realize the weight is because you&#39;re serializing the entire objects, and not just the data, but I&#39;m wondering if there&#39;s a way around that, especially when dealing with ReadOnly objects.</p>
<p>Although, I&#39;m suspecting you&#39;d run into trouble with this approach as you can&#39;t reflect against private members in SL. (assuming your ReadOnly property setters were private)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, May 20, 2011</h2><p>This is purely a guess, but I would think that Rocky&#39;s custom solution would utilize either the managed backing fields (which are very strongly encouraged&nbsp;in SL) or the custom serialization hook methods (which are required if you aren&#39;t using managed backing fields).&nbsp; That&#39;s&nbsp;the easiest way to get&nbsp;around the reflection issues.&nbsp; I would also guess that any custom solution built would be used everywhere.&nbsp; After all, the DataPortal is basically the same regardless of the client tech...</p>
<p>What I find somewhat amusing is that if this&nbsp;does get implemented, the likely solution is one that some have been clamoring for, which is to only send a &quot;raw data stream&quot; over the wire.&nbsp; Where this gets interesting is that doing so potentially obviates the need for cloning the business object, thus giving some folks the &quot;in-place update&quot; they seem to think is so incredibly important.&nbsp; That obviously introduces a whole new set of rules, and perhaps that is still a bridge too far to implement in a way that doesn&#39;t break existing functionality.&nbsp; I do realize the &quot;returns a new object&quot; concept has its issues, and maybe I&#39;m just so used to the CSLA architecture that it doesn&#39;t bother me.&nbsp; But for some people, that seems to be a concept akin to eating your own young... <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 20, 2011</h2><p>Scott is correct, if I do this it would rely on the same infrastructure I put in place for MobileFormatter, and so would have the same limitations in terms of what could be serialized.</p>
<p>The MobileFormatter (MF) uses the IMobileObject interface to politely ask each object in the object graph for its field data, and then a list of its child objects. The MF then goes through the list of child objects, politely asking each child for its field data, and a list of <em>its</em> child objects. And so on.</p>
<p>As each object&#39;s data is collected, the data is placed into a DTO that can be serialized by the DataContractSerializer (DCS). </p>
<p><img height="171" width="174" src="http://www.lhotka.net/weblog/content/binary/WindowsLiveWriter/CSLALightobjectserialization_12749/image_2.png" alt="" /></p>
<p>&nbsp;</p>
<p>The end result is a DTO object graph that mirrors the business object graph. Except this DTO object graph only contains DCS serializable properties. Each DTO contains all the information necessary to create a clone of the original business object - including the object&#39;s type, and the type of each data field. The type names are assembly qualified type names, so they aren&#39;t compact. As you can imagine, for a simple object, the size of the <em>type information</em> may be larger than the actual object data.</p>
<p>The DCS is then used to serialize the DTO graph into (by default) BinaryXML, and that&#39;s what sent across the network.</p>
<p>OK, given that background, you can probably imagine how a &quot;CslaFormatter&quot; might exist that would do much the same thing, but would rely on intrinsic knowledge of the business object graph shape to do the deserialization. More like JSON, less like SOAP/BinaryFormatter/NDCS.</p>
<p>The key here is that the field manager <em>has the required intrinsic knowledge</em>. Even the field names can probably be dropped from the data stream, because each property has an int index value that is consistently known by the field manager on both sides of the wire.</p>
<p>If I went that far (not sending field names) then this new formatter <em>would only work for properties that have an IPropertyInfo descriptor</em>. Personally I think that&#39;s an acceptible requirement, but it is certainly a topic for discussion.</p>
<p>I also suspect that this new formatter would still serialize into a DTO graph, and would still use the DCS to do the final wire serialization. But even that&#39;s not a given. I think I have some old Module II code from my Amiga days, where I implemented the Kermit protocol, and that is more compact than JSON or XML :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, May 20, 2011</h2><p>I should also say that the in-place serialization vs new-copy serialization used today is (in my view) out of scope for the serialization discussion.</p>
<p>That could also happen someday, but the pressing need (in my view) is to solve the more immediate issues around network bandwidth and related performance.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
