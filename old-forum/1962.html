<html><header><title>Fetch Status Messages</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Fetch Status Messages</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1962.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lotrij posted on Wednesday, December 13, 2006</h2><P>Hey,</P>
<P>In the application that I'm working on the fetches consist of executing a bunch of SQL statements.&nbsp; Some of these can take a while to run, so we were thinking that providing the user with an overall status of&nbsp;each fetch would be a nice feature (something like a message just before and just after each statement runs).</P>
<P>I was wondering if anyone has considered this before?&nbsp; Is there a way to get a message&nbsp;from the server version of the business object back to the client application midfetch?</P>
<P>&nbsp;</P>
<P>Thanks,</P>
<P>Jonathan</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>twistedstream replied on Wednesday, December 13, 2006</h2><P>Jonathan,</P>
<P>This really is more of a UI design issue than that of your business objects.&nbsp; Theoretically any operation that hits the database could be take a bit of time to execute.&nbsp; In the world of UI, anything that takes more than&nbsp;a second (especially in a WinForms UI) can annoy the user since it freezes up the main UI thread, making the application unresponsive.</P>
<P>A good approach would be to implement the <A href="http://msdn2.microsoft.com/en-us/library/ms228969.aspx">Asynchronous Programming Model</A> pattern in your UI code.&nbsp; It uses a delegate on the client-side to invoke any method on its own thread so you don't tie up the main UI thread.&nbsp; You can then display an hour glass or some kind of status bar.</P>
<P>Now this approach is easy to implement in a WinForms app (which I'm assuming is what you're building).&nbsp; If you're app is ASP.NET, then things get a little more complex.&nbsp; You can use APM but then you need some kind of callback mechanism from the browser to check the status of the request; Ajax works well here.&nbsp; Another approach is to use something like this <A href="http://blogs.crsw.com/mark/articles/642.aspx">HTML Busy Box</A>, which throws up a IFRAME with a "please wait" message while the long-running request executes.</P>
<P>~pete</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Wednesday, December 13, 2006</h2>I agree with twistedstream that it is easiest, and usually sufficient, to improve on your UI.<br><br>In most cases it is simply not worth the extra effort to implement advanced notification schemes. <br><br>Everyone who once copied a bunch of files in Windows Explorer knows how terribly unreliable progressbars can be even in multi-million dollar software product like MS Windows. The good news here is that they have set the standard and paved the way for us: users kind of 'expect' progressbars and the likes to be not too reliable. So in most cases it should be sufficient to avoid a UI-freeze as twistedstream suggests, and your users will be ok with it.<br><br><br>Bayu</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
