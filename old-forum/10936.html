<html><header><title>Custom Properties and _bypassPropertyChecks</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Custom Properties and _bypassPropertyChecks</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10936.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal posted on Thursday, December 01, 2011</h2><p>There is a problem when implementing a custom property, that doesn&#39;t really have it&#39;s own data, but instead consumes other properties for managing it&#39;s state. Example: 2 standard managed properties, StartValue, EndValue. 1 &quot;custom&quot; property&nbsp; that feeds on these two: DifferenceValue<br /><br /><br />&nbsp; Public Shared ReadOnly DifferenceValueProperty As PropertyInfo(Of Integer) = RegisterProperty(Of Integer)(Function(o) o.DifferenceValue, &quot;Difference&quot;, RelationshipTypes.PrivateField)<br />&nbsp; Public Property DifferenceValue As Integer<br />&nbsp;&nbsp;&nbsp; Get<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanReadProperty(DifferenceValueProperty, True)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return ReadProperty(EndValueProperty) - ReadProperty(StartValueProperty)<br />&nbsp;&nbsp;&nbsp; End Get<br />&nbsp;&nbsp;&nbsp; Set(value As Integer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanWriteProperty(DifferenceValueProperty, True)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(EndValueProperty, ReadProperty(StartValueProperty) + value)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyHasChanged(DifferenceValueProperty)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyHasChanged(EndValueProperty)<br />&nbsp;&nbsp;&nbsp; End Set<br />&nbsp; End Property<br /><br />There&#39;s no way to determine if there&#39;s currently a Bypass in place, so you can&#39;t prevent the calls for canread/write from throwing exceptions. This could be solved by either exposing the current value of _bypassPropertyChecks through a protected readonly property or checking it&#39;s value from within CanReadProperty / CanWriteProperty. The former seems better because you may still want to check during a bypass if the current user could write to a property.<br /><br />As a side note, it seems appropriate to use &quot;RelationshipTypes.PrivateField&quot; in this scenario, but there really is no private field.</p>
<p>&nbsp;</p>
<p>Andr&eacute;s</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, December 01, 2011</h2><p>To possibilites from me:</p>
<p>A: Change to be a property with a backing fiied and have rule that &quot;calculates&quot; the value based on the other two/three input values. InputProperties is automatically depencies in CSLA 4.2 so the value will be recalculated and OnPropertyChanged raisen when any of the input properties is changed. </p>
<p>B. In CSLA 4.2 we support nested BypassPropertyChecks (using reference counting just like &lt;database&gt;Context).</p>
<p>I&#39;d recommend option A- to just keep it as a simple property (maybe add an authorization rule to never allow edit of the field) and use a BusinessRule.</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 01, 2011</h2><p>Jonny&#39;s option A is preferred. The idea is that all business logic should be encapsulated in rule types.</p>
<p>This means a calculated value should be calculated by a rule, not in a getter. And that means that the calculated property should be a real property, and its value should be set by the rule.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, December 01, 2011</h2><p>Hi Jonny and Rocky, thanks for your replies.</p>
<p>I see how in theory option A is great, but in practice it&#39;s impractical and it implies performance hits across all tiers. I have scenarios with 10 or more calculated properties, most of them editable and affecting other properties values, some of them are strings that are returned based on a resource value and formatted with values from other properties as well, the resource to be used can vary depending on the value of yet another property. </p>
<p>In a collection with many objects, storing all these extra values has a huge impact:</p>
<p>-Loading the collection will take longer.</p>
<p>-Serializing the collection and moving it through the wire means more bandwidth and even more time.</p>
<p>-Client side and server side memory and cpu penalties.</p>
<p>There are cases when such collections are retrieved and those properties might not even be consumed. so you&#39;d be getting all that extra overhead for nothing.</p>
<p>I agree that this is in a sense a business rule. But this can also be looked at as behavior, something that could be done in a method to affect other properties. And it actually is implemented through 2 methods, the getter and the setter of a property, the property wrap just gives you the added bonus of data binding. If I were creating a method called &quot;void AdjustEndValueBy(int difference)&quot; I wouldn&#39;t want it&#39;s implementation inside a business rule and I believe this is the same scenario.</p>
<p>Either way, I don&#39;t see why this should be not allowed. And the fact remains that if you do implement a custom property there&#39;s no way for you to know if the BO is currently bypassing checks.</p>
<p>The GetProperty method does this &quot;if(_bypassPropertyChecks || CanWriteProperty(..))&quot;. You can&#39;t replicate that in the derived class because there is no protected property that exposes the current status of _bypassPropertyChecks. I knew about the nesting of BypassPropertyChecks but it is unrelated to this.</p>
<p>I think we need a protected bool IsBypassingPropertyChecks{ get { return _bypassPropertyChecks;}}</p>
<p>&nbsp;</p>
<p>Cheers</p>
<p>Andr&eacute;s</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Saturday, December 03, 2011</h2><p>One more option is to put the &quot;calculation&quot; code into a PropertyHasChanged override. </p>
<p>When BypassPropertyChecks is true then no PropertyHasChanged is called.<br />And you can also raise new OnPropertyChanged events for calulated properties.</p>
<p>I always prefer to keep the property declaration code as straight and simple as possible. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Sunday, December 04, 2011</h2><p>We will always agree on wanting the code to be simple and elegant. But the fact remains that this will add overhead and memory consumption. It&#39;s not a big problem in a single root object, but in large collections calculated properties are the way to go. Creating storage space for a calculated value will also create redundant data and increases the chances for having bugs.</p>
<p>Here&#39;s a really really common scenario: you have a lookup. The key type is byte, you have around 20 possible values and the descriptions can be rather long. I&#39;m loading the collection with 500 rows. Do I want to load 500 bytes or 20kb? What if you have more properties like that? The best answer is to use dictionaries in the properties to reduce load, memory and to have good response times when reading the properties.</p>
<p>All that is required to enable this scenario is to expose the current status of _bypassPropertyChecks through a property. It&#39;s just another status indicator, such as isvalid, isdirty and isbusy, although this one shouldn&#39;t be public.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, December 05, 2011</h2><p>I realize this is a little off the mark of where this post has gone, but I&#39;m still confused about something:</p>
<p>Why would you want your calculated property to have different security constraints than its dependent properties?&nbsp; Your main concern seems to be that the ability to detect whether you&#39;re in a bypass-security block is missing.&nbsp; Setting aside whether that&#39;s a good thing to know or not, I&#39;m wondering why it&#39;s important in this situation.&nbsp; Surely a user&#39;s ability to read/write a property whose value is dependent on other properties would be the same as those dependent properties, thus obviating the need to know whether a bypass block is active.&nbsp; So I must be missing something...</p>
<p>As to your performance questions, I will say that business rules are by type, not by instance, and thus are loaded only once.&nbsp; Yes, that is a bit more overhead than a straight calculated property, but it isn&#39;t that much.&nbsp; I&#39;m also not following your example too well; if you have a lookup, wouldn&#39;t you load the lookup values in a ROL (or an NVL) only once, and do the translation in your UI?&nbsp; There doesn&#39;t seem to be any overhead there - at least not any you can realistically get rid of.&nbsp; If you&#39;re talking about a read-only scenario, then I&#39;d just load the descriptions directly - also a situation where I don&#39;t see much overhead that can be removed.&nbsp; So again, I must be missing something.</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Monday, December 05, 2011</h2><p>Well, the calculated property could definitely have its own security constraints. Imagine you have a class that has a base value, let&#39;s call it weight, 3 different price categories, one for retailers, one for class &quot;a&quot; customers and one for regular customers, one general cost per weight multiplier (this is an extremely over simplified version of a company&#39;s requirement). <br />Weight and cost multiplier properties are regular properties. The prices are all calculated. A user may be able to see only one category of those prices. The independent multipliers for each category come from settings outside this class, not from properties in the class itself. So there you have a scenario where the base properties don&#39;t necessarily have a say on the access to a calculated property.<br />Now, a user could have access to viewing and editing prices to just one class, or 2 classes or all three. Changing a price would affect the base multiplier and if you have access to more than one pricing class, you could see how it affected the other classes as well. This would then go to a staging database where all the data collected and prices estimated by the end users would be analyzed to define the final prices to all categories. In this stage a user would have access to the same business object but instead of affecting the price multipliers per item, it would alter the category multiplier, affecting hundreds of objects at the same time.</p>
<p><br />Having all this in rules would mean long execution times, higher memory usage and redundancy. It would also affect serialization and transfer over the wire as well. Not because of the rule, I know they are only loaded once by type, but because of the properties themselves. Why even recalculate it if the user will never be able to see it? So that&#39;s why you use calculated properties. Some calculations may be more complex, taking longer time, like getting coordinates for an address or interacting with the file system, a web service, loading other child objects on demand. There are heaps of possibilities. For some of them I wouldn&#39;t consider using properties, for some of them I would.<br />The issue here is having the choice of using a calculated property or a storing a value. And right now if you want to create a calculated property you would have to choose not to enforce security on that property or maintain a modified copy of csla to enable that. It&#39;s not a huge deal for me, but I see it&#39;s something that other people will want to do. </p>
<p><br />On the other subject yes, sometimes you can take care of the lookup in the UI, but if the collections are used in different scenarios you&rsquo;d have to replicate that logic over and over. What if the lookup is not just a regular &ldquo;dropdown selection&rdquo; situation? Sometimes you have a calculation that depends on a lookup value. Do you want to replicate those calculations in the UI? Generally, the answer is no. As Rocky always says, UI code is the most expensive, and I agree 100%.<br />If you have an application that will be used by 10 users in a local network and will only be working with a simple root objects, then of course you wouldn&#39;t care and create an extra field, but if you need to create something for a large user base, that moves relatively large amounts of data then you need to think about these issues. If the difference becomes 20k to 200k in a dataportal operation then you have a problem. </p>
<p><br />I&rsquo;m currently migrating a very large application from windows forms to MVC.&nbsp; It was built with csla 2.1 and I&rsquo;m porting everything to the latest version because it&rsquo;s better suited for that purpose. The migration will take a very long time and in the meantime the windows forms client needs to be maintained, so the window forms client will have to work with the same library (and yes, I&rsquo;m using businessbindinglistbase).<br />There are many places where this application uses calculated properties. Sometimes calculated properties depend on other calculated properties and sometimes they are chained many times. Not only there is nothing wrong with this, I believe it is a good practice. I also believe that performing those calculations in rules and storing the results will make the code harder to understand and maintain, and will open the door for more bugs.</p>
<p>&nbsp;</p>
<p>Anyway, I hope that clarifies it.</p>
<p>&nbsp;</p>
<p>Cheers!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
