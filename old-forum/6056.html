<html><header><title>A proposed TDD-friendly CSLA solution</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>A proposed TDD-friendly CSLA solution</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6056.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris posted on Friday, December 26, 2008</h2><P>Hey everybody.&nbsp; I know that TDD&nbsp;with CSLA has been the topic for discussion in several threads&nbsp;within this forum.&nbsp; I've been playing around with a solution that tries to make them play together.&nbsp; I have started to write a series of blog posts on this.&nbsp; If you are interested, please check it out.</P>
<P><A href="http://leighalsteris.blogspot.com/2008/12/tdd-friendly-csla-solution.html">http://leighalsteris.blogspot.com/2008/12/tdd-friendly-csla-solution.html</A></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rhoeting replied on Friday, December 26, 2008</h2>Leigh,<br><br>I'd be interested in see more discussion about CSLA/TDD.&nbsp; Frankly, I'm not convinced that CSLA objects are not TDD friendly.&nbsp; The argument seems to be around the DataPortal's control over object construction.&nbsp; Decent DI frameworks like Spring support the "service locator" style of injection, which is intended for the scenarios where the developer has no control over object construction.&nbsp; Why not use that to inject different implementations of DAOs, specifically for NUnit tests?&nbsp; <br><br>Also, the new version of CSLA provides us with the ability to have the DataPortal contruct an object factory, rather than the object.&nbsp; It seems any approach will require us to write a lot more code. :(&nbsp; Any additional discussion would be great.<br><br>Rob<br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Saturday, December 27, 2008</h2><P>Hey Rob,</P>
<P>The DataPortal's control over construction is definitely at the core of the issue.&nbsp; I understand that a service locator can be used to call upon dependencies as required.&nbsp; This is a valid solution.&nbsp; There is nothing wrong with that at all.&nbsp; (Have you checked out the Common Service Locator on codeplex? <A href="http://www.codeplex.com/CommonServiceLocator">http://www.codeplex.com/CommonServiceLocator</A>)</P>
<P>My preference is to use constructor injection of dependencies and call upon the service locator in constructor overloads.&nbsp; In this scenario, the constructor forms a vital part of the class interface,&nbsp;and when combined with the properties and methods, fully&nbsp;specifies class dependencies.&nbsp; That just sits better with me.</P>
<P>Leigh</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rhoeting replied on Saturday, December 27, 2008</h2>Leigh, thanks for the reply.&nbsp; I was not aware of that project.&nbsp; Looks like a good idea.&nbsp; I'm very much interested in seeing other approaches to making the BOs injectable.&nbsp; I worked on a Java/Spring project for a year and it seemed the setter injection via applicationContext.xml was the method of choice.&nbsp; <br><br>Rob<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Monday, December 29, 2008</h2><P>For those interested, my latest post expands a little on the details of my design.</P>
<P><A href="http://leighalsteris.blogspot.com/2008/12/tdd-friendly-csla-solution-part-3.html">http://leighalsteris.blogspot.com/2008/12/tdd-friendly-csla-solution-part-3.html</A></P>
<P>My point for discussion is this – If we go to the trouble of abstracting out the data access by introducing a DTO, why don’t we send the DTO across the wire rather than the business object? The actual data access code will still run on a server, but we don’t send the business object across the wire.<BR><BR>Rather than make the DTO the mobile object, I suggest that we piggyback the serializable DTO on a mobile command object, since the DataPortal has infrastructure in place for a command object.<BR><BR>Note: Since the business object has methods to reconstruct itself from a DTO, we could always create the business object again on the server in order to check validation rules and authorization rules if necessary. If any logic run on the server results in a state change, the state is captured in the DTO and provided back to the business object on the client after the operation is complete. A new instance of the business object does not need to be created on the client, instead the existing instance will update it’s state from the returned DTO.</P>
<P>Check out the code on my blog for more details.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 29, 2008</h2>Well, I'm not sure I see the difference in sending a DTO vs. the actual business object.&nbsp; Both are just being serialized and sent over the wire.<br><br>I'm also not sure what you're trying to accomplish.&nbsp; Are you trying to prove the serializer works?&nbsp; That remoting or WCF calls work?&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Monday, December 29, 2008</h2><P>Hi, thanks for your reply.&nbsp; I'm definitely no expert, so please&nbsp;bear with me!&nbsp; I'm just trying to share my thoughts as I work my way through this exploratory process.&nbsp; </P>
<P>I've tried my best to convey what I am trying to accomplish in the second blog post.&nbsp; If I attempt to distill it down to what I really want&nbsp;... I want all of my business object&nbsp;dependencies to be explicit and I want to pass them in through a constructor.&nbsp; That's just my preference.&nbsp; I am aware that there are&nbsp;other&nbsp;ways to inject dependencies and to achieve most of what I am aiming for.&nbsp; However, I only want to inject these dependencies once throughout the lifetime of the object (unless of course there is a reason for changing them, then I would expose a setter).&nbsp; In addition,&nbsp;I only ever wish to&nbsp;work with one instance of the business object once it is constructed, rather than changing my references after each save (the DTO enables this).&nbsp;I also want to keep using everything else that CSLA has to offer ... I'm not attempting a re-design, or trying to prove?? serialization.&nbsp; So, I think I can achieve the above by sending a DTO accross the wire rather than the business object.&nbsp;(1) I'm not using the DataPortal Fetch or Create methods, so the power of construction is back in my hands, and (2) because the DTO effectively becomes the mobile object (piggybacking on a command object), there is no need to work with a new business object instance after the save, just the new DTO instance (which the same&nbsp;business object instance&nbsp;uses to update itself after a save).</P>
<P>I understand that the nature of the DataPortal is that it controls construction and that serialization brings me back a new copy of the business object.&nbsp; The purpose for sending the DTO accross the wire instead is so I can continue to work with the same instance of the business object on the client even after a save.&nbsp; As a side affect, I don't need to keep updating references and re-injecting dependencies.</P>
<P>Cheers</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rhoeting replied on Monday, December 29, 2008</h2>So if you want to<i> constructor inject </i>everything, rather than going the locator or setter route, does that not mean your constructor signature needs to change every time you add a new property/dependency into your class? <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, December 29, 2008</h2><P><FONT face=Tahoma size=2>Yes and no.&nbsp; Most halfway-decent DI frameworks I've seen do a fair amount of searching to find the constructor that matches the objects they need to inject.&nbsp; So if you need to inject something new, you can create a constructor overload with your new object, and the DI framework should pick it up just fine.&nbsp; It's a measure of backwards compatibility - though you could probably argue that the old code that tries to work with your object without the new dependency is very likely suspect, and should change.&nbsp; But you have to make a code change no matter what, so it's probably a six-of-one situation.</FONT></P>
<P><FONT face=Tahoma size=2>Unless your intent was to debate the merits of the overall approach... from where I sit, it appears that the OP is taking a "middle-ground step" between the pre-.NET versions of CSLA and the .NET version.&nbsp; Restrictions in VB 6 required a situation very similar to what's been proposed.&nbsp; One of the main issues with that design - and a big reason why Rocky chose the architecture he did - was that this method tended to break some encapsulation.&nbsp; While you could overcome these limitations in .NET with reflection, performance concerns become a real issue.&nbsp; So a new way of building objects was needed.&nbsp; Not exactly a new way - more like Rocky could finally do what he always wanted to do.</FONT></P>
<P><FONT face=Tahoma size=2>This kind of discussion has been going on around CSLA for quite some time now.&nbsp; I have not read the OP's blog entries, so I can't really speak to how "good" the solution is.&nbsp; If it works for his/her project, then we can very likely call it "good".&nbsp; That's ultimately the standard upon which the solution needs to be judged, IMO.</FONT></P>
<P><FONT face=Tahoma size=2>Having said that, even with the hooks that Rocky has provided in 3.5/3.6, there's still a fair amount of work that had to be done to get to the "TDD friendly" approach.&nbsp; And much of that work involves&nbsp;modifying the framework code itself.&nbsp; I won't say that Rocky's&nbsp;codebase is the "pure, one-and-only" version of CSLA.&nbsp; Many folks have created modifications to suit their needs.&nbsp; But the more you modify, the more you have to maintain as new versions come out.&nbsp; And I suspect that a fair amount of modification to the framework&nbsp;was required.&nbsp; Given that the current version of CSLA represents several man-months of work spread across multiple developers, providing support for four different UI technologies and multiple communication protocols...</FONT></P>
<P><FONT face=Tahoma size=2>Even if you got it working (which it appears the OP did), you could probably still call it CSLA, but that might be pretty confusing to anyone else who has any CSLA experience.&nbsp; A lot of what CSLA does for you has to be side-stepped/refactored/hacked/enter-your-choice-of-phrase-here in order to get this working.&nbsp; And it just seems that the T/M/DDD group of folks have a fundamentally different view of the world.&nbsp; That's great, since it works for them.&nbsp; I'm not debating the merits of either approach, mostly because I hate religious arguments.&nbsp; But I don't think any solution that tries to meld CSLA and TDD is going to work out very well.&nbsp; They simply approach the world from a different perspective, and I don't see a happy meeting of the minds between the two.</FONT></P>
<P><FONT face=Tahoma size=2>This&nbsp;ultimately means that the ideas presented here probably cannot be coherently and effectively merged into the existing CSLA codebase that Rocky and his Magenic team manage.&nbsp; So it's not very long before you end up having to decide whether you're going to break with CSLA and its update cycles... and then it's not CSLA anymore.</FONT></P>
<P><FONT face=Tahoma size=2>Again, I'm not mocking the OP's work.&nbsp; If it serves his purpose, then it's done the job.&nbsp; I just don't think he's going to get a lot of love from either side of the fence.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Monday, December 29, 2008</h2><P>Hey Scott,</P>
<P>Yes, I agree completely with everything you say.&nbsp; TDD/DDD is definitely a different view of the world.&nbsp; I guess you just pick the view that helps you sleep at night <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /> ... I also hate religious arguments!&nbsp; Most of the people on this forum have already decided what side of the fence they sit on, however, I am still deciding.</P>
<P>And yes, the solution does require some code changes ... so like most solutions to anything, there's a lot of trade-offs.&nbsp; E.g., does the benefit of the refactorings, hacks, etc, outweight the fact that I may need to make more modifications as newer versions of CSLA are released.&nbsp; Mmmm, I don't know.&nbsp; Time will tell.&nbsp; But it's fun playing around. If it all gets too hard, I'll just use CSLA as is - it does most of what I want out-of-the-box anyway.&nbsp; However, if my tinkerings lead to a solution that some people may also get some benefit from, then it's all good.</P>
<P>Leigh</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Monday, December 29, 2008</h2><P>Rob,</P>
<P>While the class is still being developed and I have control of the source code, the constructor will evolve as dependencies are fleshed out.</P>
<P>I guess I am largely influenced by Martin Fowler's discussion on dependency injection (See the "Deciding which option use" section):</P>
<P><U><FONT color=#800080><A href="http://martinfowler.com/articles/injection.html#DecidingWhichOptionToUse">http://martinfowler.com/articles/injection.html#DecidingWhichOptionToUse</A></FONT></U><A href="http://martinfowler.com/articles/injection.html"></A></P>
<P>Fowler discusses Service Locator, Constructor injection, and Setter injection.&nbsp; My aim, like Fowler, is to at least aim for purely constructor injection - </P>
<P><EM>"My long running default with objects is as much as possible, to create valid objects at construction time ... Constructors with parameters give you a clear statement of what it means to create a valid object in an obvious place. If there's more than one way to do it, create multiple constructors that show the different combinations ... Despite the disadvantages my preference is to start with constructor injection, but be ready to switch to setter injection as soon as the problems I've outlined above start to become a problem" - Fowler.</EM></P>
<P>You see, I write classes and modules that may be reusable in a number of applications. Other developers that use my libraries for other applications may not have access, or not allowed access,&nbsp;to the source code, so the dependencies need to be evident in the class interface - </P>
<P><EM>"With dependency injector you can just look at the injection mechanism, such as the constructor, and see the dependencies. With the service locator you have to search the source code for calls to the locator" - Fowler.</EM></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rhoeting replied on Tuesday, December 30, 2008</h2>I agree with you guys.&nbsp; I believe we do waste quite a bit of time arguing about religion :).&nbsp; I say if you get the job done, that that's 80% of the game.&nbsp; Others will argue right past the deadline.&nbsp; I'd like to see how this turns out, Leigh.<br><br>Rob<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>daniel_higgins replied on Tuesday, December 30, 2008</h2>As per ajj, Csla 3.6 business objects already have most of the dirty/new/deleted logic that leigh has put in his third blog post. So to answer the question: "why not send the dtos across the wire on a command object?" --&gt; because csla&nbsp;already sends the bos across the data portal. No need for additional dirty/new/deleted&nbsp;logic in dtos, bos, or gateway&nbsp;code.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Tuesday, December 30, 2008</h2><P>Hi Daniel,</P>
<P>Thanks for your reply.&nbsp; Most of the guts of the dirty management and tracking logic is still taken care of by the CSLA framework.&nbsp; I am using the DTO to take a snap shot of the dirty state so I can send this to my data access layer, so that the data access code can determine what it needs to insert, update, delete, etc.&nbsp; The primary reason for this, is that it allows separation of my data access layer ...&nbsp;I think you'll find that something similar would need to be done if one choses to use the ObjectFactory to separate out the data access, since Rocky only provides extension points for&nbsp;root level fetch, insert, update, and delete.&nbsp; So, it's really a result of fleshing out the data access.</P>
<P>Leigh</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>daniel_higgins replied on Wednesday, December 31, 2008</h2><P>Hi Leigh, </P>
<P>It is not neccessary to duplicate the dirty/new/deleted logic when using DTOs and a DAL. </P>
<P>Daniel</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lalsteris replied on Thursday, January 01, 2009</h2><P>Thanks Daniel.&nbsp;&nbsp;Thanks for your patience. &nbsp;I'd appreciate it if you - or anyone else - can provide an example of deleting an editable child through the ObjectFactory?&nbsp; If I am using DTOs to separate out my&nbsp;DAL - specifically using the ObjectFactory (ie., the data access code is not privy to my protected or private fields) - how does the DAL know when to delete a child if I don't send the IsDeleted flag in the DTO (since the DeletedList is a protected member)?&nbsp; </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>daniel_higgins replied on Thursday, January 01, 2009</h2><P>My apologies. I know nothing about the ObjectFactory. </P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
