<html><header><title>Stored procedure discussion</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Stored procedure discussion</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2018.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams posted on Thursday, December 21, 2006</h2><P>I pulled this out of the "multiple views..." thread since it's really its own topic.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>xAvailx:</strong></div><div>I am not looking for a neverending debate. As I previously posted, I was looking for specific verifiable and reliable resources so I can research further. <BR><BR>Again, pretty much all of my previous research and experience says otherwise (performance, security, maintenability, etc...) about using dynamic sql from a client application and I am not looking for a debate, just some reliable resources I can research further for which "specific" scenarios client dynamic sql is "better" than a stored proc. <BR><BR>If you have any specific links, I would appreciate if you would share. <BR><BR>Thx. <BR><BR><BR></div></BLOCKQUOTE></P>
<P>Well, you can start by looking in the SQL 2005 Books Online under Stored Procedures Basics.&nbsp; You'll note in the "benefits" section there isn't a mention of performance anywhere in sight.&nbsp; In contrast,&nbsp;in SQL 2000 Books Online there is a specific section implying (erroneously) that the compiling of stored procedures brings&nbsp;a performance benefit.&nbsp; So, the official Microsoft position is that performance is not a reason to choose sprocs - is anything more necessary?</P>
<P>The following is a rather infamous blog wherein the author later corrected himself and admitted that&nbsp;the pre-compile argument was complete myth.</P>
<P><A href="http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx">http://weblogs.asp.net/rhoward/archive/2003/11/17/38095.aspx</A></P>
<P>The following is a fairly well-known blog on the myths of stored procedure advantages.&nbsp; Frans is perhaps a little extreme himself in his disdain for sprocs, but it gives good arguments against the myths which have fueled the "always use stored procedures" position.</P>
<P><A href="http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx">http://weblogs.asp.net/fbouma/archive/2003/11/18/38178.aspx</A></P>
<P>The alleged security advantages of sprocs have been hit on in the other thread... views offer many of the same advantages, at least when you're talking about reading the data.&nbsp; As I said before, I do think sprocs offer some benefit for writing and I do my writing with sprocs exclusively.&nbsp; Among other things, they provide severe limitations on the amount of damage a wild insert/update/delete command can do.</P>
<P>There is the potential for some benefit from the reduction of network traffic, and the difference in the traffic TO the server can be quite drastic in some cases.</P>
<P>As far as maintainability, that's a matter of opinion of course.&nbsp; Even more significant, it's a matter of the particular talent pool you have at your disposal.&nbsp; Everyone writing business objects understands the language being used there, but they might not necessarily understand a sproc with temp tables or coalesce commands.</P>
<P>I &nbsp;don't have time to repeat all my research, but as for a specific case where dynamic SQL is more performant, see what you can find googling including "coalesce".&nbsp; That was one specific example I remember - the problem being basically that in a complex sproc with lots of conditional testing going on you ended up with two problems:</P>
<P>1 - a lot more code to run compared to the business layer that likely already knows exactly what it needs to do</P>
<P>2 - the final query that ends up being performed is so variable that you really have no cached execution plans and therefore no performance benefit over the specific ad-hoc dynamic calls</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 22, 2006</h2>Dan,<br><br>Thanks for finding those, I was having problems for some reason, although I have read those articles before.<br><br>I think the final answer to this question is "use whatever is most appropriate to solve the problem," just as it is anywhere else in this field.<br><br>I also use procs for data modification.&nbsp; The main reason is it allows me to add row level auditing at a moments notice.&nbsp; Creating an audit record I believe is a task best left to the db... otherwise you have your BOs worrying alot about how to create audits, and that's not really their responsiblity.&nbsp; Having another object worry about auditing would be complex as well.. at least in my experience.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 22, 2006</h2>[Answering Dave here]<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Gosh, we sure are not communicating well!&nbsp; :(
<p>No, absolutely not.&nbsp; I am not talking about allowing
unknown/untrusted applications to communicate with the database.&nbsp; I am
talking about someone writing a web page for their own application that
allows a user of that page to inject unwanted sql commands into it -
all because they dynamically constructed the sql statement by
truncating user-entered strings together.&nbsp; Are we mis-communicating
because you don't see how this is a problem?</div></BLOCKQUOTE></p>
<p>Why does dynamic sql become an exercise in tacking strings together
blindly?&nbsp; You have this problem calling a stored proc as well, if you
just build the Sql call by tacking strings together.&nbsp; The solution is
to parameterize your query (which you can do with any sql, not just
proc calls).&nbsp;&nbsp; I've never argued against parameterizing your query, quite the opposite.<br>
</p>

<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Again, we are not communicating.&nbsp; If
your business object accepts user-entered free-form text&nbsp;and constructs
the sql statement to be issued by concatenating the strings together, a
user of that web page&nbsp;has the capability to totally and completely
subvert the security the business object tries to add.&nbsp; </div></BLOCKQUOTE></p>
<p>Where did I ever say you just stick strings together?&nbsp; I said
dynamic sql is fine, and it is.&nbsp; The problems you describe are solved
by parametizing the query, but again you don't need a proc to
parametize a sql statement.<br>
</p>


<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>I agree that proper usage of database
roles is good practice - and I will continue to use it.&nbsp; It's a good,
basic level of security that's very cost effective.&nbsp; This technique is
a quick and&nbsp;inexpensive way to safely use dynamically created sql on a
query page.&nbsp; That's all.</div></BLOCKQUOTE></p>
<p>I wouldn't consider role based security basic... I would say its fundamental to proper security in a Sql server database.<br>
</p>


<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>It's not far-fetched.&nbsp; Happens in big business
all the time.&nbsp;&nbsp;Depending upon software&nbsp;licensing arrangements, using a
different database server and database instance might cost huge pots of
money in licensing fees.&nbsp; Plus extra hardware.&nbsp; And extra rent,
heating, cooling, hardware maintenance and repair fees, etc.&nbsp; Plus the
extra labor cost - even with code utilities to help out&nbsp;- of keeping
multiple installations synchronized.</div></BLOCKQUOTE></p>
<p>All those costs can easily be justified if the alternative is that your competitor even has a slight chance <br>
of harming your business because they store their data in the same
database.&nbsp; Also, in a hosted environment (which is likely how you'd end
up in such a scenario), the hosting fees for a dedicated server are
still much less than simply adding up all those expenses.&nbsp; But again,
dynamic sql is not a problem as long as you parameteize your query just
as you would with a stored procedure call.&nbsp; <br></p><p></p>Please, don't assume dynamic sql means blindly truncating strings together, nor does it mean you allow uses to type sql (that would defeat the purpose of the business layer after all).&nbsp; I think this is the cause of our miscommunication; dynamic sql can (and should be) parameterized.&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cds replied on Friday, December 22, 2006</h2><P><FONT face=Arial size=2>Hi Guys</FONT></P>
<P><FONT face=Arial size=2>This is an interesting discussion. The arguments for and against stored procedures are fairly well-known - they're all over the web as you've pointed out.</FONT></P>
<P><FONT face=Arial size=2>I'm wondering what most of the CSLA community use. I would suspect that sprocs are pretty much the rule, but there are those of us, such as myself that have built on top of ORMs. </FONT></P>
<P><FONT face=Arial size=2>I use LLBLGen which is interesting in itself as it purports to be a complete solution for n-tier development - basically you transport the objects generated from the database to your client and back again. I've been down that track and you get some awful compromises and exposure of the data model design to your UI. </FONT></P>
<P><FONT face=Arial size=2>Instead, I have a BO designer (that I built) that plugs into the LLBLGen Designer environment. It gives me access to all the LLBLGen-generated classes and I can construct my BOs from whatever entity objects I want - I can even get down to database views and sprocs if I want.</FONT></P>
<P><FONT face=Arial size=2>Anyway, I am wondering if the great divide around ORMs and dynamic SQL vs. SPROCs mainly comes down to who owns the DB, and whether you have the services of a DBA. I work for a small&nbsp;ISV and basically our applications "own" the database and so we're "in charge" of the DB and can basically use whatever technology is required to "do our stuff". The customer really doesn't care, as long as it does its job. </FONT></P>
<P><FONT face=Arial size=2>Perhaps in an enterprise environment, where DBAs "rule the roost" you're more constrained about what technology is allowed to be used.</FONT></P>
<P><FONT face=Arial size=2>Just some random thoughts on the subject. Hope everyone has a great Christmas (or whatever you happen to celebrate at this time of year!)</FONT></P>
<P><FONT face=Arial size=2>Craig</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 22, 2006</h2>Craig,<br><br>Well, its just me here, so I'm everything from business analyst to architech to engineer.&nbsp; Oh and deployment manager (thank you ClickOnce!).&nbsp; <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><br><br>I have basicaly the same setup as you do, with a custom DAL instead of LLBLGen (I wish they wouldn't market it as something for consumption directly by your UI.. I think that's a disservice).&nbsp; <br><br>I've worked in much larger firms before as well, and I think they all allowed views / dynamic sql as well.. although for the life of me I can't remember exactly now anymore.&nbsp; I know my first gig did, because we were always running user input strings through a MakeSQLString VBscript function to prevent bad sql (which is funny, because it was before injection attacks took off, and we were only doing it because someone's name had an apostrophy in it and was bombing our code).<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cds replied on Saturday, December 23, 2006</h2><P>Andy</P>
<P>I well remember the bad old days when I used VB3 and we connected to an Access database and also being surprised when our code bombed out with names with a single quote character in them. </P>
<P>So what are the advantages you see in your custom DAL over using Stored Procs or some other commercial or open source ORM?</P>
<P>Craig</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, December 27, 2006</h2>Well my DAL does call stored procedures for insert, update and delete operations.&nbsp; Its for selects that the DAL generates dynamic sql.&nbsp; <br><br>I'm not sure there are any advantages compared to an existing ORM, except that it was pretty easy for me to build the functionality I needed.<br><br>I guess the main advantage for me is that I have a VS add-in which I point at a database table or view and it creates the apprioriate view (for selects), stored procedures (for CUD) and C# class file.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Thursday, December 28, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>[Answering Dave here]<BR><BR><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Gosh, we sure are not communicating well!&nbsp; :( </P>
<P></div></BLOCKQUOTE></div></BLOCKQUOTE></P>
<P>Ok, now we are beginning to communicate!&nbsp; Our unshared assumptions are now understood. :)</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div></P>
<P>Why does dynamic sql become an exercise in tacking strings together blindly?&nbsp; You have this problem calling a stored proc as well, if you just build the Sql call by tacking strings together.&nbsp; The solution is to parameterize your query (which you can do with any sql, not just proc calls).&nbsp;&nbsp; I've never argued against parameterizing your query, quite the opposite.</P>
<P></div></BLOCKQUOTE></P>
<P>I'm all for parameterizing.&nbsp;&nbsp; Here's an&nbsp;example.&nbsp; <BR><BR>select p.* <BR>from project p<BR>inner join table1 t1 on t1.id = p.t1_id<BR>inner join table2 t2 on t2.id = p.t2_id<BR>inner join table3 t3 on t3.id = p.t3_id<BR>inner join table4 t4 on t4.id = p.t4_id<BR>inner join table5 t5 on t5.id = p.t5_id<BR>inner join table6 t6 on t6.id = p.t6_id<BR>where t1.field1 like @field1<BR>&nbsp;&nbsp;&nbsp; and&nbsp;t1.field2&nbsp;like @field2<BR>&nbsp;&nbsp;&nbsp; and t2.field3&nbsp;like @field3<BR>&nbsp;&nbsp;&nbsp; and t2.field4&nbsp;like @field4<BR>&nbsp;&nbsp;&nbsp; and t3.field5&nbsp;like @field5<BR>&nbsp;&nbsp;&nbsp; and t3.field6&nbsp;like @field6<BR>&nbsp;&nbsp;&nbsp; and t4.field7&nbsp;like @field7<BR>&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; and t6.field99 like @field99<BR></P>
<P>Now, I agree that I could build a parameterized query in a business object or via a stored procedure that had 99 parameters, fields 1 thru 99.&nbsp; Those parameters could all default to "do not care, show me everything".&nbsp; It would be perfectly safe.<BR><BR>If that's what you mean by dynamic sql, then I agree with your points as you presented them.&nbsp; <BR><BR>But it's not what I mean by dynamic sql.<BR><BR>Let's suppose that joining to table table2 is really, really, really slow.&nbsp; And that the users do not want to do so 99% of the time.&nbsp;&nbsp;&nbsp; So, if the users left the on-screen parameters that map to table2 as a wild-card, I would prefer to construct my query at run time like this:</P>
<P>select p.* <BR>from project p<BR>inner join table1 t1 on t1.id = p.t1_id<BR>inner join table3 t3 on t3.id = p.t3_id<BR>inner join table4 t4 on t4.id = p.t4_id<BR>inner join table5 t5 on t5.id = p.t5_id<BR>inner join table6 t6 on t6.id = p.t6_id<BR>where t1.field1 like @field1<BR>&nbsp;&nbsp;&nbsp; and&nbsp;t1.field2&nbsp;like @field2<BR>&nbsp;&nbsp;&nbsp; and t3.field5&nbsp;like @field5<BR>&nbsp;&nbsp;&nbsp; and t3.field6&nbsp;like @field6<BR>&nbsp;&nbsp;&nbsp; and t4.field7&nbsp;like @field7<BR>&nbsp;&nbsp;&nbsp; ...<BR>&nbsp;&nbsp;&nbsp; and t6.field99 like @field99<BR></P>
<P>Note the complete absence of any reference to table2.&nbsp; The query should now run much faster.&nbsp; </P>
<P>That's what I mean by dynamic sql.<BR><BR>If you have a ready-made solution to parameterizing this so that entire references to tables, where clause lines, etc, can be included or not, I would like to know how!</P>
<P>And I'm not being a smart-aleck when I say that.&nbsp; I have lots to learn in this technology stack.</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Friday, December 29, 2006</h2><P>I apparently am still a poor communicator.&nbsp; ;)</P>
<P>I thought your previous objections to dynamic sql were that they were risky because they allowed end-users to pass strings into the SQL statement.&nbsp; The response we've made is that parameterizing the queries prevents that in dynamic sql just as it does in a stored procedure.</P>
<P>Now you seem to have switched completely to a discussion of the challenge of creating EFFICIENT dynamic sql.&nbsp; That's something entirely different, and even as difficult as it may turn out to be (I don't think it is), the fact that it's even possible is precisely the advantage dynamic sql brings to the table.</P>
<P>And for clarity of my position and previous statements, the logic of determining what the final most-efficient&nbsp;query that should run can be done dynamically in the business layer or indeed in the stored procedure itself, but in the latter case you don't really have a stored procedure at all in terms of performance because there won't be a consistent execution plan anyway.&nbsp; And I'd argue that the sum of the "code" isn't nearly as clean, unless your talent pool is heavily slanted towards dba types.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 29, 2006</h2>Dan,<br><br>I'm going to have to agree with your post.&nbsp; Dave, it does seem the focus has now switched from secure to performance.&nbsp; And a stored procedure (which has branches to omit the "poorly performing" table) vs. dynamic sql offers no performance benefits.&nbsp; As the articles you posted pointed out, no execution plan is built until the procedure is actually run.<br><br>A cleaner solution in my mind would be to create various views, and have the BO be intellegent enough to figure out which view to use for the query.&nbsp; In a real scenario though, its unlikely that you'd omit an entire table from a join for performance reasons based on what search criteria is used.&nbsp; Unless there are never any columns selected from the omitted table (in which case it would be odd that you'd join with the table to begin with) you'll have some data not returned to the client.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Friday, December 29, 2006</h2><P>No, I haven't switched the subject.&nbsp; As I recall, the original poster explained a need to allow a user to choose between many, many data filtering options.&nbsp; Dynamic sql was proposed as the solution because then only the sql needed would be executed.</P>
<P>Creating a sql statement on the fly is what I (and many others I've worked with) have called dynamic sql.&nbsp; I've seen the same terminology used in the MS documentation.</P>
<P>Parameterized queries are just static queries with parameters added. :)&nbsp; I don't consider them dynamic sql.&nbsp; It appears that you do.&nbsp; Maybe they are, maybe they aren't.&nbsp; But at&nbsp;least our individual terminology is now understood&nbsp;:)&nbsp; Maybe we could settle on these three terms:</P>
<UL>
<LI>Static Sql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - definitely static!</LI>
<LI>Parameterized&nbsp;Sql&nbsp;&nbsp;&nbsp;- sort of static, sort of dynamic!</LI>
<LI>Concatenated Sql&nbsp;&nbsp;&nbsp;- definitely dynamic!<BR></LI></UL>
<P>My objections to constructing a sql statement from user-supplied strings (concatenated sql)&nbsp;for security reasons&nbsp;remain.&nbsp; You apparently agree. :)</P>
<P>As for the reality of my example (of skipping entire tables in the query), here's an example of why someone would do that.&nbsp; This sample query screen returns a list of all projects that meet the user's selection criteria. It displays the project id, project name, customer, start and finish dates.</P>
<P>User Requests: </P>
<BLOCKQUOTE dir=ltr>
<P>"Find me all projects where Joe Shmoe was assigned to it, and in which the XYZ Machine was used."&nbsp;&nbsp; (The user is concerned about quality control issues with Joe on the XYZ Machine.)</P>
<P>"Find me all projects that had work performed in Upper Slobovia between 2004 CE and 2006 CE."&nbsp; (The user just discovered that Upper Slobovia passed a retroactive law that might affect us, and we need to investigate those projects in detail.)</P>
<P>"Find me all projects that are more than 10% over budget and more than 10% overdue.&nbsp; (The user wants to investigate those projects in detail to get them back on track.)</P></BLOCKQUOTE>
<P>Neither of the above criteria are fields actually shown in the list of projects.&nbsp; They are just used to determine which objects are returned.&nbsp; That's the difference between filter criteria and display information - they don't have to be the same thing.</P>
<P>This need for dynamically constructed, efficient sql is why I proposed the database solution I explained in the other thread.&nbsp; It is a simple way that allows you to construct a sql statement at runtime using user-supplied data and be completely safe from sql injection attacks.</P>
<P>As for whether database stored procedures are faster than queries issued from the object layer for static, parameterized queries, I don't have a clue.&nbsp; Haven't done the testing to prove it one way or the other.&nbsp;&nbsp; For the situation the original poster described, it's a moot point because the execution path should vary based upon user input.&nbsp; If it doesn't, it's going to be inefficient anyway, because it will be querying data the user doesn't care about. :)</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 29, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>No, I haven't switched the subject.&nbsp; As I recall, the original poster explained a need to allow a user to choose between many, many data filtering options.&nbsp; Dynamic sql was proposed as the solution because then only the sql needed would be executed.</div></BLOCKQUOTE><br><br>I suggested a non-stored procedure solution not because only the needed sql would be executed, but for maintenance reasons.&nbsp; That is, if a filter allows its operator to be set by the user ( &lt;, &gt; or != ), the stored procedure must have many branches to accomodate that... one for each type of operator.&nbsp; And that's just one field.<br><p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Creating a sql statement on the fly is what I (and many others I've worked with) have called dynamic sql.&nbsp; I've seen the same terminology used in the MS documentation.</p>
<p>Parameterized queries are just static queries with parameters added. :)&nbsp; I don't consider them dynamic sql.&nbsp; It appears that you do.&nbsp; Maybe they are, maybe they aren't.&nbsp; But at&nbsp;least our individual terminology is now understood&nbsp;:)&nbsp; Maybe we could settle on these three terms:</p>
<ul>
<li>Static Sql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - definitely static!</li>
<li>Parameterized&nbsp;Sql&nbsp;&nbsp;&nbsp;- sort of static, sort of dynamic!</li>
<li>Concatenated Sql&nbsp;&nbsp;&nbsp;- definitely dynamic!<br></li></ul>
<p>My objections to constructing a sql statement from user-supplied strings (concatenated sql)&nbsp;for security reasons&nbsp;remain.&nbsp; You apparently agree. :)</div></BLOCKQUOTE></p><p>Parameterized sql is not necessarly static or dynamic.&nbsp; My data searcher dynamically builds the where clause and order by clause based on the list of SelectionCriteria and OrderCriteria it receives.&nbsp; Even though its built dyanmically, its still parameterized.&nbsp;&nbsp; The select and from clauses by their nature will typically not change within a single business object.. after all if it does, you'll have properties which cannot be populated.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>As for the reality of my example (of skipping entire tables in the query), here's an example of why someone would do that.&nbsp; This sample query screen returns a list of all projects that meet the user's selection criteria. It displays the project id, project name, customer, start and finish dates.</p>
<p>User Requests: </p>
<blockquote dir="ltr">
<p>"Find me all projects where Joe Shmoe was assigned to it, and in which the XYZ Machine was used."&nbsp;&nbsp; (The user is concerned about quality control issues with Joe on the XYZ Machine.)</p>
<p>"Find me all projects that had work performed in Upper Slobovia between 2004 CE and 2006 CE."&nbsp; (The user just discovered that Upper Slobovia passed a retroactive law that might affect us, and we need to investigate those projects in detail.)</p>
<p>"Find me all projects that are more than 10% over budget and more than 10% overdue.&nbsp; (The user wants to investigate those projects in detail to get them back on track.)</p></blockquote>
<p>Neither of the above criteria are fields actually shown in the list of projects.&nbsp; They are just used to determine which objects are returned.&nbsp; That's the difference between filter criteria and display information - they don't have to be the same thing.</div></BLOCKQUOTE></p><p>Fair enough, but I would say its better to have the BO 'know' which view to select from to perform the search.<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>This need for dynamically constructed, efficient sql is why I proposed the database solution I explained in the other thread.&nbsp; It is a simple way that allows you to construct a sql statement at runtime using user-supplied data and be completely safe from sql injection attacks.</div></BLOCKQUOTE></p><p>I would still argue a better (simpler, and more maintanable) solution would be to construct various views and have the BO choose which view to select from, dynamically building the where and possibly order clauses (while parameterizing the sql).<br></p>
<p><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>As for whether database stored procedures are faster than queries issued from the object layer for static, parameterized queries, I don't have a clue.&nbsp; Haven't done the testing to prove it one way or the other.&nbsp;&nbsp; For the situation the original poster described, it's a moot point because the execution path should vary based upon user input.&nbsp; If it doesn't, it's going to be inefficient anyway, because it will be querying data the user doesn't care about. :)</div></BLOCKQUOTE></p>If you haven't read the links from DansDreams, I suggest you do so.&nbsp; The query (whether dynamic or from a stored procedure) is cached the same way, starting with Sql server 2000.&nbsp; <br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>david.wendelken replied on Friday, December 29, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Parameterized sql is not necessarly static or dynamic.&nbsp; My data searcher dynamically builds the where clause and order by clause based on the list of SelectionCriteria and OrderCriteria it receives.&nbsp; Even though its built dyanmically, its still parameterized.&nbsp;&nbsp; </div></BLOCKQUOTE></P>
<P dir=ltr>So, the $64,000 question is this:</P>
<BLOCKQUOTE dir=ltr>
<P>"How are you building a query that dynamically changes what commands are in the where clause without concatenating those where clause code fragments into the sql statement?"</P></BLOCKQUOTE>
<P>If you've got a spiffy technique for doing that, I would really like to learn it.&nbsp; </P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>The select and from clauses by their nature will typically not change within a single business object.. after all if it does, you'll have properties which cannot be populated.<BR></div></BLOCKQUOTE></P>
<P>Agree with you on the select clause, not on the from clause.&nbsp; The select clause is to define the data elements returned, the from clause defines what data is searched.&nbsp; A from clause can reference lots of data that is never, ever, in the select clause.&nbsp; For a (hopefully) humorous example...</P>
<BLOCKQUOTE dir=ltr>
<P>"Show me a list of names and addresses for every sales prospect that has neon colored&nbsp;paisley-print facial tattoos and over 50 body piercings on their head, plus dreadlocks - any hair color will do."</P></BLOCKQUOTE>
<P dir=ltr>I don't want to look at them (so no image data in the select clause!), I just want their addresses so I can send them a sales brochure. :)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, December 29, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>"How are you building a query that dynamically changes what commands
are in the where clause without concatenating those where clause code
fragments into the sql statement?"</div></BLOCKQUOTE><br><br>I never said I wasn't concatinating strings.&nbsp; I said I was doing it in a way that gives me a parameterized dynamic sql statement.<br><br><font color="#008000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;Adds the selection criteria<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// to the find request.&lt;/summary&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="selection"&gt;The &lt;see cref="SelectionCriteria"/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// to filter with.&lt;/param&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="sql"&gt;The sql statement built so far.&lt;/param&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name="cmd"&gt;The &lt;see cref="SqlCommand"/&gt; object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// to modify.&lt;/param&gt;<br></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">private static void</font> AppendWhereCriteria&lt;T&gt;(<font color="#008000"> IList</font>&lt;<font color="#008000">SelectionCriteria</font>&gt; selection,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">StringBuilder </font>sql, <font color="#008000">SqlCommand </font>cmd ) <font color="#0000ff">where </font>T : <font color="#008000">DataEntity </font>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">string </font>paramName1, paramName2, colName;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">string </font>op;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">SqlParameter </font>param;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">Type </font>entType;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entType = <font color="#0000ff">typeof</font>( T );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">if </font>( selection.Count &gt; 0 ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.Append( <font color="#ff0000">" WHERE "</font> );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">foreach </font>( <font color="#008000">SelectionCriteria </font>sel <font color="#0000ff">in </font>selection ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colName = <font color="#008000">EntityReflector</font>.GetColumnName( entType, sel.PropertyName );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.Append(<font color="#ff0000"> "( "</font> );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">switch </font>( sel.Operator ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">case </font><font color="#008000">Operators</font>.Between:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.AppendFormat( <font color="#ff0000">"[{0}] "</font>, colName );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paramName1 = string.Format( <font color="#ff0000">"@B1{0}"</font>, rand.Next( 0, <font color="#0000ff">int</font>.MaxValue ) );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paramName2 = string.Format( <font color="#ff0000">"@B2{0}"</font>, rand.Next( 0, <font color="#0000ff">int</font>.MaxValue ) );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.AppendFormat( <font color="#ff0000">" BETWEEN {0} AND {1}"</font>, paramName1, paramName2 );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param = cmd.CreateParameter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Direction = <font color="#008000">ParameterDirection</font>.Input;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Value = sel.Values[ 0 ];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.ParameterName = paramName1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd.Parameters.Add( param );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param = cmd.CreateParameter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Direction = <font color="#008000">ParameterDirection</font>.Input;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Value = sel.Values[ 1 ];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.ParameterName = paramName2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd.Parameters.Add( param );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">break</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">case </font><font color="#008000">Operators</font>.Equals:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">case </font><font color="#008000">Operators</font>.Like:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">foreach </font>( <font color="#0000ff">object </font>val <font color="#0000ff">in </font>sel.Values ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paramName1 = <font color="#0000ff">string</font>.Format( <font color="#ff0000">"@EL{0}"</font>, rand.Next( 0, <font color="#0000ff">int</font>.MaxValue ) );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">if </font>( val == <font color="#0000ff">null </font>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.AppendFormat( <font color="#ff0000">" [{0}] IS NULL OR "</font>, colName );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.AppendFormat( <font color="#ff0000">" [{0}] {1} {2} OR "</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; colName,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sel.Operator == <font color="#008000">Operators</font>.Equals ? <font color="#ff0000">"="</font> : <font color="#ff0000">"LIKE"</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; paramName1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param = cmd.CreateParameter();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.ParameterName = paramName1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Direction = <font color="#008000">ParameterDirection.</font>Input;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; param.Value = sel.Operator ==<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">Operators</font>.Like ? val.ToString().Replace( <font color="#ff0000">"*"</font>, <font color="#ff0000">"%"</font> ) : val;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd.Parameters.Add( param );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.Length -= <font color="#ff0000">" OR "</font>.Length;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#0000ff">break</font>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#008000">// Other operators here</font><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.Append( <font color="#ff0000">") AND "</font> );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sql.Length -= <font color="#ff0000">" AND "</font>.Length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>david.wendelken:</strong></div><div>Agree with you on the select clause, not on the from clause.&nbsp; The
select clause is to define the data elements returned, the from clause
defines what data is searched.&nbsp; A from clause can reference lots of
data that is never, ever, in the select clause.&nbsp; For a (hopefully)
humorous example...
<blockquote dir="ltr">
<p>"Show me a list of names and addresses for every sales prospect that
has neon colored&nbsp;paisley-print facial tattoos and over 50 body
piercings on their head, plus dreadlocks - any hair color will do."</div></BLOCKQUOTE></p></blockquote><p>Again, that's better handled by changing which view to select against.</p><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Friday, December 29, 2006</h2><P>David, I'm not even sure what we're disagreeing about at this point.</P>
<P>We seem to all agree that letting&nbsp;any user hand us some sql to send to the database is an idiotic idea.&nbsp; Stored procedures or not is a moot point in that regard.</P>
<P>I think everyone who's contributed is using sprocs for updates, which means that no user has update permissions on <EM>any</EM> table.&nbsp; There's no need to discuss malicious updates, from sql injection or otherwise.&nbsp; Many, if not most, of your arguments seem to be centered around that.</P>
<P>You have also&nbsp;broght up&nbsp;row-level security.&nbsp; I went back and read the proposed solution in the other thread.&nbsp; In the first example ("simplest version") you conclude with explaining how it protects from sql injection, which wasn't the problem you were trying to solve.&nbsp; It doesn't even address the row-level security problem, so it's just a waste.</P>
<P>Your second solution is to have separate views that are row-level specific to each user.&nbsp; This has nothing to do with using stored procedures or not, of course.</P>
<P>Your third example of one sproc calling another also does not seem to address the row-level security issue at all, but is also apparently trying to address the sql injection risk.</P>
<P>So, for the sake of my thick skull, could you try once again to explain why you think stored procedures are superior to ad-hoc (non-sproc) queries for reasons other than injection protection, and explain why?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Saturday, December 30, 2006</h2>&nbsp; 
<P>I do not use dynamic SQL or sp's.&nbsp;Well I do but there is no trace of this anywhere in the BO's.</P>
<P>I use what I call Data Requests.&nbsp; Basically they are xml files that define how to retrieve data. They extend the database interfaces in .NET. </P>
<P>For db access Data Requests are generally a block of sql.&nbsp; Parameters can be added and removed as needed.&nbsp; Each Data Request has a select, update, insert and delete request.&nbsp; Each is optional so a single Data Request may only allow Select.&nbsp; Or allow Select and Update but not delete or insert.&nbsp; depend upon the needs. (There is an option to allow insert, update and delete to be created from the Select part. Don't use it much but it is there.)&nbsp; </P>
<P>So my criteria classes take two things.&nbsp; A Data Request name and a ParameterList class.&nbsp; The Parameter class can handle Like, Between, IN and&nbsp;looking for NULLs. (The IN and Between parameters is the whole reason I created this thing in the first place.&nbsp;SP's parameters can't handle anything like an array and I need that functionality allot. But I will not tolerate sql in my middle tier classes.)</P>
<P>The thing is the Data Request can be changed from using straight SQL statements to a stored proc or UDF by simply changing the stuff in the xml.&nbsp;(The straight SQL is converted to parameterized SQL queries.&nbsp; It supports all the .NET data providers that come with the framework.&nbsp; Adding new ones doesn't take that much work.)</P>
<P>Now the BO doesn't know any thing about these requests except that they are named something and that they take parameters.&nbsp; The DAL controls this and&nbsp;knows if the data&nbsp;is on a local network (direct access to the db and it returns a datareader for performance) or if it is remoted (the DAL uses a remoted component and passes&nbsp;data&nbsp;tables and&nbsp;DataRequests back and forth.)&nbsp; The&nbsp;BO's&nbsp;are able to&nbsp;handle either the datatables or datareaders.&nbsp;It&nbsp;just looks at what type is handed to it and the populates the private fields.</P>
<P>One of the nice things is that the Data Requests&nbsp;can also handle getting info from text, xml or&nbsp;a couple of more types&nbsp;of files.&nbsp;I can also&nbsp;'query' a web service.&nbsp;&nbsp;For&nbsp;xml it usually&nbsp;uses the WilsonXML provider.&nbsp; It can use simple XPATH queries but it does choke&nbsp;on complex ones.&nbsp;(I am no xml expert.)</P>
<P>I can also 'build' these&nbsp;Data Requests dynamically&nbsp;because&nbsp;they really&nbsp;are just&nbsp;CSLA (1.x) derived classes with all the cool things that brings.&nbsp; Internally I check and fail&nbsp;for the&nbsp;'bad' sql words&nbsp;meaning no DDL statements are allowed and comments are stripped out.&nbsp; It also validates that a date really is a date etc.</P>
<P>Because the DAL handles the data retrieval I can use several data sources because each Data Request also defines the connectionStringName. The actual connection information is handled by another class and server.</P>
<P>The whole reason I bring this up is because the SP vs "Built" SQL debate is limiting in itself.&nbsp; You have to look beyond the debate and see what else can be done to make the debate moot.&nbsp; I rarely use SP's mainly because I have hundreds of DBs to maintain.&nbsp; If I could have all my DB's use a central SP server I might do it.&nbsp; But we only have two developers and a manager that also do all the maintenance.&nbsp; It is much easier to change a xml file on the server and have all the applications for all our customers use the latest and greatest. This includes the ClickOnce, Webapps and traditional windows forms.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, January 11, 2007</h2><P>I may be a little late to the thread, but here's one more thing to throw in that has not been mentioned in this or the previous thread: abstraction.</P>
<P>Craig hit the nail right on the head asking if the issue had to do with the availability of DBA's, etc. effecting the viable options.&nbsp; As in Andy's case, many of us are one man shows while others are working in more rigid corporate environments and this does affect the approaches we use.&nbsp; When in a one-man-show, we don't have to worry about satisfying the needs or working within the limitations of other developers or deal with corporate standards and/or restrictions, etc.&nbsp; However, and this is just me, because of my varied background I find myself developing as if in a team environment even when not.</P>
<P>Anyway, the point I wanted to raise has to do with the fact that stored procedures also provide an additional point of abstraction for your application.&nbsp; Sprocs abstract the underlying table structure from our BO's and is one of the biggest reasons I've continued to use them as all of the former benefits have slowly fallen by the wayside - whether myths or simply a result of improvements in other areas.</P>
<P>For example, if I have an application that displays a read-only list of contacts with columns for&nbsp;the contact's name, address, phone, fax and e-mail address, I would simply call the GetContactList sproc.&nbsp; Initially this sproc could be retrieving records from the flat Contacts table with columns of the same names.&nbsp; Later, either myself or a DBA or whatever sees the DB bloating and decides to normalize address data by creating a lookup table so that multiple contacts sharing the same address point to the same record.&nbsp; This results in a change to the Contacts table whereby the Address nvarchar(x) column is replaced with a foreign key to the new Addresses table.&nbsp; Subsequently, my GetContactList query much change to implement the join required to flatten the data.</P>
<P>Granted, this same thing can be accomplished using a view (and between you &amp; I, I typically do use views as the basis for any stock queries that require joins, etc. to create a...view... of the underlying data).&nbsp; So, in my case, GetContactList would actually be something like:</P>
<P><CODE>SELECT * FROM ContactList ORDER BY Name</CODE></P>
<P>And yes, this means that our BO could simply execute the exact same statement and make use of the view bypassing the sproc and that is certainly legitimate.&nbsp; But, as I strive for consistency, and there are times when calling a sproc is required because of additional logic or processing required, I have elected to standardize my BO data access to call sprocs.&nbsp; For dynamic searches, I use an approach similar to what Andy has described with his DataSearcher approach.</P>
<P>(And yes, I am ignoring the fact that such a change to the Contacts table would undoubtedly affect our read/write object for the same data - it's just an example to illustrate my point.)</P>
<P>Anyway, in a discussion that has seemingly revolved around performance and security, I thought it appropriate to point out how sprocs add another layer of abstraction for our apps.&nbsp; Those of us working in team environments with or without DBA's can appreciate the fact that the changes I described above can be implemented without a single change to the application code.&nbsp; For those of us working in one-man-shows, my parting thought is that everything changes and just because you are a one-man show today doesn't mean you'll be one tomorrow.</P>
<P>I was designing an application recently that I anticipated being the sole developer on; but, as the development phase drew nearer, some of the company's off-shore resources became available and I was "directed" to find a way to use them.&nbsp; Having a clearly defined "API" of sorts for the database as provided by the set of sprocs I had designed allowed me to easily turn over the chore of creating the myriad of Reporting Services reports that were required for the app.&nbsp; All I had to do was indicate which sprocs were required for each.&nbsp; As the application took shape and the design invariable changed as I went along, none of the reports that had already been completed had to change because they all relied on the sproc - not the underlying schema or elements.&nbsp; This saved us a tremendous amount of time in a number of areas.</P>
<P>Just my two cents...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Thursday, January 11, 2007</h2><P>Those are good thoughts, and in the "food for thought" context I'll comment.&nbsp; Really, just adding to your comments...</P>
<P>The value or cost of that abstraction must be determined for each environment.&nbsp; For reading, views have the significant difference of being more easily discoverable in ways more commonly understood.&nbsp; You can even link to them directly from Access 2000.&nbsp; That is a good or bad thing depending on your particular point of view and corporate atmosphere.</P>
<P>So, the choice of views vs. sprocs for reading to some degree depends simply on the "philosophical" decision of where you build the bridge between the normalized relational database and the user-friendly access.&nbsp; And in a large development team those "users" could be defined as the business layer developers (users of the DBA's work) who I believe still benefit from more discoverable nature of views.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, January 11, 2007</h2><P>Keep in mind that your "more discoverable ways", I am assuming, consist of a set of system procedures that may be used to obtain a list of schema elements.&nbsp; This requires knowledge of those procedures which I cannot assume that the developer knows.&nbsp; However, he certainly knows how to expand the nodes in Server Explorer or SQL Server Management Studio at which point expanding the Stored Procedures node becomes just as easy and accessible as the Views node.</P>
<P>IMO, and the point I was vague about, is that sproc allow you to define an API much in the same way we define an API/interface to our BOs for our UI designers (e.g. ContactList.GetContactList()).&nbsp; So, just like we abstract how our BO's are implemented and do their job from the UI designer, the GetContactList sproc provides an API/interface that abstracts how the underlying structure and schema of the database is implemented from our business layer developer.&nbsp; And, yes, it will require the same steps/efforts to convey the nature of the API to the applicable developers just as with our BO's - documentation!!&nbsp; <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /></P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
