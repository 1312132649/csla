<html><header><title>Async Validation Fires multiple times using CheckRules() overload</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Async Validation Fires multiple times using CheckRules() overload</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8870.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion posted on Monday, May 03, 2010</h2><p>So, I think I have discovered a bug in CSLA 3.8.2 (and it looks like the issue still exists in 3.8.3)</p>
<p>Basically, if we have a long running asyc rule and the paramaterless CheckRules() is executed (I.E. from DataPoral.Create&lt;t&gt;), the long running async rule will be executed multiple times (see bugfix comment below).</p>
<p>Also, I believe the meaning of &#39;validation complete&#39; is different depending on who is invoking it (see &#39;regarding the OnValidationComplete method\event&#39; comments below)</p>
<p>For now I am implementing these changes in our version of CSLA.&nbsp; Is this a good fix?&nbsp; Will this be addressed in a new release of 3.8.x?</p>
<p>&nbsp;</p>
<p>&nbsp;/// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Invokes all rule methods for all properties<br />&nbsp;&nbsp;&nbsp; /// in the object.<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; public void CheckRules()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_suppressRuleChecking)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRulesManager rules = RulesToCheck;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rules != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (KeyValuePair&lt;string, RulesList&gt; de in rules.RulesDictionary)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckRules(de.Value.GetList(true));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Given a list<br />&nbsp;&nbsp;&nbsp; /// containing IRuleMethod objects, this<br />&nbsp;&nbsp;&nbsp; /// method executes all those rule methods.<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; private void CheckRules(List&lt;IRuleMethod&gt; list)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool previousRuleBroken = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool shortCircuited = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //bugfix: added asyncRulesToInvoke so that we don&#39;t invoke all ValidatingRules.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we don&#39;t want to invoke all of them because when we are called <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from CheckRules (checking rules for all properties), some async validation <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rules may still be in ValidatingRules by the time we are checking the next <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; property&#39;s rules.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; So, when we invoke the rules below, if we invoke all the rules in <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidatingRules, we will invoke the privious properties&#39; rules for each <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule set in the RulesDictionary, until they complete and are remove from the <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidatingRules).<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var asyncRulesToInvoke = new ObservableCollection&lt;IAsyncRuleMethod&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Lock the rules here to ensure that all rules are run before allowing<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // async rules to notify that they have completed.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; list.Count; index++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRuleMethod rule = list[index];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // see if short-circuiting should kick in<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!shortCircuited &amp;&amp; (previousRuleBroken &amp;&amp; rule.Priority &gt; _processThroughPriority))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortCircuited = true;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (shortCircuited)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // we&#39;re short-circuited, so just remove<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all remaining broken rule entries<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Remove(rule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // we&#39;re not short-circuited, so check rule<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool ruleResult;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IAsyncRuleMethod asyncRule = rule as IAsyncRuleMethod;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (asyncRule != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidatingRules.Add(asyncRule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncRulesToInvoke.Add(asyncRule);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Remove(rule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ruleResult = rule.Invoke(_target);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //// force a broken rule<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ruleResult = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //rule.RuleArgs.Severity = RuleSeverity.Error;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //rule.RuleArgs.Description = <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; string.Format(Properties.Resources.ValidationRuleException &amp; &quot;{{2}}&quot;, rule.RuleArgs.PropertyName, rule.RuleName, ex.Message);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // throw a more detailed exception<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ValidationException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string.Format(Properties.Resources.ValidationRulesException, rule.RuleArgs.PropertyName, rule.RuleName), ex);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ruleResult)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rule is not broken<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Remove(rule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the rule is broken<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Add(rule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rule.RuleArgs.Severity == RuleSeverity.Error)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; previousRuleBroken = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rule.RuleArgs.StopProcessing)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shortCircuited = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // reset the value for next time<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule.RuleArgs.StopProcessing = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //using asyncRulesToInvoke instead:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //IAsyncRuleMethod[] asyncRules = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; asyncRules = ValidatingRules.ToArray();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...any reason to ToArray() asyncRulesToInvoke?<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // They must all be added to the ValidatingRules list before you can invoke them.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Otherwise you have a race condition, where if a rule completes before the next one is invoked<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // then you may have the ValidationComplete event fire multiple times invalidly.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach(IAsyncRuleMethod rule in asyncRulesToInvoke)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule.Invoke(_target, asyncRule_Complete);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // throw a more detailed exception<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ValidationException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string.Format(Properties.Resources.ValidationRulesException, rule.RuleArgs.PropertyName, rule.RuleName), ex);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //regarding the OnValidationComplete method\event.&nbsp; It appears to have two meanings.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //when the CheckRules(List&lt;IRuleMethod&gt; list) method calls target.OnValidationComplete <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //it means &#39;the rule set passed in is done being validated.&#39;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //when target.OnValidationCopmlete is called from <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //target.ValidatingRules_CollectionChanged it means &#39;all async<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //rules have completed&#39;.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //so we should have the following scenerio with the current code<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //TEST: When we have no asyncRules (or an extremly fast one?) and <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // CheckRules() is executed, we should get OnValidationComplete invoked<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //for each property that has a rule attached (invoked from the code below)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //TEST: When we have a reasonably long running async rule and CheckRules() is fired<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //we should get only one OnValidationComplete invoked (from the last <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ValidatingRules_CollectionChanged)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...is this desirable?&nbsp; In my mind we should have it one way or the other but not both.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //this used to check the length of the ValidatingRules Array (I.E. &#39;all invoked async Rules&#39;) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //now it is using asyncRulesToInvoke (I.E. &#39;all invoked async rules in the current rule list&#39;), <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //I believe both to be incorrect based on the above code comment.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(asyncRulesToInvoke.Count == 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var target = _target as Csla.Core.BusinessBase;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(target != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; target.OnValidationComplete();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p>This will not be addressed in a future version of 3.8.x. It is a known side-effect of async rules that they can be executed multiple times with overlapping results. Generally my recommendation is to use the UI to block the user from interacting with the object in ways that would allow such overlapping behaviors.</p>
<p>At this point version 3.8.3 is on track to be finalized this week, and other than minor bug fixes the 3.8 branch will not be changing substantially in the future. All development focus is now on CSLA 4.</p>
<p>So the good news is that your changes to the framework code won&#39;t be affected by numerous future releases, because hopefully there won&#39;t be any <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>cool, no sweat.&nbsp; I will make the changes outlined above to our version of 3.8.2 and re-implement in 3.8.3 when we upgrade.&nbsp; Do you see any problems with my implementation? (I.E. only invoke the async rules for the current &#39;rule set&#39; being checked instead of invoking all the ValidatingRules over and over again for each &#39;rule set&#39; being passed in by the parameterless CheckRules()?)</p>
<p>To Be Clear:&nbsp; I don&#39;t think that the UI developer has any control over the problem.&nbsp; This problem occurs when ever the parameterless CheckRules is executed.&nbsp; This happens when DataPortal BeginCreate is invoked so the UI developer has little control over preventing the async rules from firing multiple times.</p>
<p>Also, What do you think of the &#39;OnValidateComplete&#39; question?&nbsp; (when exectuded from the BusinessBase.ValidatingRules_CollectionChanged callback, it means &#39;all async rules completed&#39;.&nbsp; When executed from the CheckRules(List&lt;IRuleMethod&gt; list) overload it means &#39;all rules for the &#39;list&#39; being validated have comleted).</p>
<p>I haven&#39;t checked 4.0 to see if it has a similar problem (I will do so &#39;soon&#39;). &nbsp; Given that the entire subsystem has been re-vamped, chances are this goes away in 4.0.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p>Is the problem that you&#39;ve attached the rule to multiple properties, so it runs for each property? That&#39;s actually by design - it is entirely legal to attach a rule to multiple properties, and in that case the expectation is that it will run once for each property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>No, this is not the issue (I actually thought the same thing when the developer came to me with this problem).<br /><br /><br />The problem is when CheckRules() is fired we roll through each property that has a list of rules attached and invoke those rules by executing the CheckRules(List&lt;IRuleMethod&gt; list) overload:<br /><br />&nbsp;&nbsp;&nbsp; public void CheckRules()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_suppressRuleChecking)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRulesManager rules = RulesToCheck;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rules != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (KeyValuePair&lt;string, RulesList&gt; de in rules.RulesDictionary)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CheckRules(de.Value.GetList(true));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br /><br /><br />Inside of the CheckRules(List&lt;IRuleMethod&gt; list) overload we add to the validating rules for each rule that implements IAsyncRuleMethod:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IAsyncRuleMethod asyncRule = rule as IAsyncRuleMethod;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int index = 0; index &lt; list.Count; index++)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //irrelevant code not shown<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (asyncRule != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidatingRules.Add(asyncRule);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BrokenRulesList.Remove(rule);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //irrelevant code not shown<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br />after we have rolled through all the rules we invoke all the ValidatingRules:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IAsyncRuleMethod[] asyncRules = null;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lock (SyncRoot)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asyncRules = ValidatingRules.ToArray();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // They must all be added to the ValidatingRules list before you can invoke them.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Otherwise you have a race condition, where if a rule completes before the next one is invoked<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // then you may have the ValidationComplete event fire multiple times invalidly.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach(IAsyncRuleMethod rule in asyncRules)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule.Invoke(_target, asyncRule_Complete);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (Exception ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // throw a more detailed exception<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ValidationException(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string.Format(Properties.Resources.ValidationRulesException, rule.RuleArgs.PropertyName, rule.RuleName), ex);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />this is where the problem is.&nbsp; When we are only validating rules through the CheckRules(string propertyName) overload, we are ok since the only async rules in ValidatingRules are the rules we have found in the for loop above.&nbsp; <br /><br />However, when we are executing this through the CheckRules() overload, we may still have ValidatingRules from the previous execution of CheckRules(de.value.GetList(true)) (EDIT:&nbsp; because the async rule is a &#39;long running&#39; rule) in the&nbsp; foreach (KeyValuePair&lt;string, RulesList&gt; de in rules.RulesDictionary) loop.&nbsp; These rules were already invoked (from that previous execution) and are now invoked again (unless they have completed and are removed from the ValidatingRules list).<br /><br />Am I making sense?</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p>Hmm, this sounds more like a bug and less like any sort of expected behavior. I&#39;ll add it to the bug list.</p>
<p>Regarding the ValidationComplete event - the intent is that this event is raised at the point where validation for a property ends, and there are no outstanding async rules running. A consumer should be able to handle this event, and know that when it is raised it is because the rules are done running. It isn&#39;t necessarily linked to a specific CheckRules() invocation - but rather to the fact that we&#39;ve hit a point where we know there were rules running, and now there aren&#39;t.</p>
<p>The behavior of ValidationComplete changes a little in CSLA 4, but this is the philosophy on which the event is implemented. The primary goal is to allow a UI (or viewmodel) author to handle the event so they can do processing knowing that 1 or more rules have run, and that there are no rules currently running when the event is being handled.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>Cool, I will implement this fix in our 3.8.2.x.<br /><br /><br />Regarding ValidationCompete:<br />This makes sense.&nbsp; The only time we don&#39;t know when validation rules are complete are when at least one Async rule is running.<br /><br />So given the philosophy:<br />allow an observer to handle the event such that they can do processing knowing that 1 or more rules have run, and that there are no rules currently running when the event is being handled.<br /><br />and given:<br />when using CheckRules() we may end up with multiple &#39;batches&#39; of rules processing, each taking upon itself to decide that all async rules have completed. <br /><br />would it be safe to say I can modify the 3.8.2.x base such that CheckRules() can ask the CheckRules(List&lt;IRuleMethod&gt; list) not to bother with the async completed check:<br />private void CheckRules(List&lt;IRuleMethod&gt; list, bool checkAsyncCompleted)<br /><br />so that CheckRules() can do it on his own?</p>
<p>Edit:</p>
<p>Oh yeah, and regarding:<br />&quot;At this point version 3.8.3 is on track to be finalized this week, and other than minor bug fixes the 3.8 branch will not be changing substantially in the future. All development focus is now on CSLA 4.<br /><br />So the good news is that your changes to the framework code won&#39;t be affected by numerous future releases, because hopefully there won&#39;t be any :-)&quot;</p>
<p>It does kind of feel good to have the ability of being able to modify the code base without fear of being impacted by future releases.&nbsp; However, I will trade that in a heartbeat for the new rules subsystem. <img src="http://forums.lhotka.net/emoticons/emotion-9.gif" alt="Crying" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, May 03, 2010</h2><p>You want to raise ValidationComplete while there is an outstanding async rule still running? I guess that is up to you, but it is not the intended purpose of the event. Obviously validation is <i>not</i> complete, because there&#39;s still a rule running.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>Sorry, the point being that while CheckRules() (paramaterless overload) is running (<b>I.E.</b> calling CheckRules(List&lt;IRuleMethod&gt; list) multiple times) I consider &#39;rules to still be running&#39;</p>
<p>Since the CheckRules(List&lt;IRuleMethod&gt; list) is raising validation complete and I see CheckRules() as not completing (&#39;rules still running&#39;) until it exits; I take issue with CheckRules(List&lt;IRuleMethod&gt; list)&#39;s behavior.</p>
<p>My thought is to allow CheckRules()&nbsp; (paramaterless overload) to ask CheckRules(List&lt;IRuleMethod&gt; list) overload to not check for async complete so that CheckRules()  (paramaterless overload) can instead.</p>
<p>If I remember correctly there is something I would need to do with the&nbsp; CheckRules(string propertyName) overload as well.&nbsp; I would have to make it such that when the &#39;propertyName rule set&#39; and the &#39;dependent properties rule set&#39; are processed we would only get one ValidationCompleted Event. </p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>I suppose if ValidationCompleted were to have the propertyName along with it, I could have CheckRules() raise that with an empty propertyName and CheckRules(List&lt;IRuleMethod&gt; list) raise it with the &#39;property being validated&#39; that may satisfy my requirement.</p>
<p>EDIT: following Microsofts lead with INotifyPropertyChanged.&nbsp; For instance ValidationComplete with:</p>
<ul>
<li> !string.IsEmptyOrNull(propertyName) == validation is complete for the specified property.&nbsp;&nbsp;</li>
<li>string.IsEmptyOrNull(propertyName) == validation is complete for all properties (only fired if CheckRules() is run).</li>
</ul></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Monday, May 03, 2010</h2><p>&nbsp;</p>
<p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>. A consumer should be able to handle this event, and know that when it is raised it is because the rules are done running. <b>It isn&#39;t necessarily linked to a specific CheckRules() invocation </b>- but rather to the fact that we&#39;ve hit a point where we know there were rules running, and now there aren&#39;t.</div></p>
<p>EDIT: (my apologize if this is rambling, I wanted to change my thoughts 
on this before I go to bed and it is kind of late)</p>
<p>hmmm... I see where we don&#39;t meet eye to eye.&nbsp; I view rules to &#39;still be running&#39; while CheckRules() is running.&nbsp; You do not.&nbsp; I could easily accept the alternative view but I guess I have a few concerns regarding the current behavior:</p>
<p>the first is:<br />&nbsp;&nbsp; if our public facing CheckRules don&#39;t translate one to one with ValidationComplete (or at least there is no way of knowing when &#39;<b>*all*</b> rules have been run&#39;) we are forcing our UI to react on every single event instead of just one (after all, isn&#39;t it a more common scenrio to want all the rules run before acting?)... &nbsp;<br /><br />when our CheckRules() (paramaterless overload) is being executed we could be firing ValidationComplete a bunch of times if we have a lot of properties with rules (and some properties have dependent properties).<br /><br />the second is :<br />&nbsp;&nbsp; I get a &#39;bad feeling&#39; about the fact that it is in-determinant how many validation completes I will get per execution of CherckRules... but that is just a &#39;bad feeling&#39;, I have no basis I can articulate at this time for it...</p>
<p>I also have no way of knowing which properties are going to fire first... so if I wanted to front load my async validations (assuming I have some properties that don&#39;t have async validation) such that I get as few ValidationCompleted events as possible, I can&#39;t do that either.</p>
<p><div style='padding-left: 50px;background-color:silver'><b>RockfordLhotka<br></b>The behavior of ValidationComplete changes a little in CSLA 4, but this is the philosophy on which the event is implemented. The primary goal is to allow a UI (or viewmodel) author to handle the event so they can do processing knowing that 1 or more rules have run, and that there are no rules currently running when the event is being handled.</div></p>
<p>If the purpose of the ValidationCompleted event is truly to know that 1 or more <b>*async*</b> rules have run and that there are no <b>*async*</b> rules currently running, then we should only have raised the ValidationCompleted from CheckRules(List&lt;IRuleMethod&gt; list) if we actually did invoke rules in this &#39;go round&#39; of the call to the method.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 04, 2010</h2><p>CSLA 4 raises ValidationComplete one time per CheckRules() call, when all rules complete (sync and async) - assuming non-overlapping CheckRules() calls. If you have overlapping CheckRules() calls and async rules you could get less than one ValidationComplete per CheckRules() call.</p>
<p>I do not plan to change the 3.8 behavior. There are apps that rely on the existing behavior (I know, because just a few months ago I altered the behavior to meet their need to get ValidationComplete for sync as well as async rule completion). If ValidationComplete is raised too often, it at least follows the specific definition I provided earlier in the thread - which is that a batch of rules is complete, and there are no currently executing rules (sync or async) when the event is raised.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>am_fusion replied on Tuesday, May 04, 2010</h2><p>groovy.&nbsp; Thanks for bearing with me through that <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p>
<p>I will think about this a little more and figure out what we want our behavior to be in our 3.8.3.x version.&nbsp; I suspect we will move in the direction 4.0 is moving (one checkRules, one validationComplete).</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
