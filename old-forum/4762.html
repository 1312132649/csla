<html><header><title>Challenge! Good at CSLA? Try to solve this design pattern: Abstract Factory or Factory of Factories.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Challenge! Good at CSLA? Try to solve this design pattern: Abstract Factory or Factory of Factories.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4762.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rrahlf2 posted on Monday, April 28, 2008</h2><P>I've found myself in a bit of a predicament, but maybe you are the CSLA genious that can help!&nbsp; Offer a solution to this design problem and you can win the respect of your peers and an unlimited supply of bragging rights!&nbsp; Worth 42 points* (*points not available in all areas or in any areas at all.&nbsp; Points cannot be exchanged or returned.&nbsp; Actual monetary value of points: $0.00.&nbsp; Void where prohibited.&nbsp; Prohibited in current void.)</P>
<P>OK, so I admit that was a bit of a trick to get you to read my thread, but it's all true and you did find it at least a little amusing.&nbsp; Honestly, I'm excited to get everyone's feedback; here's the situation:</P>
<P>I'm working with a list of objects that we'll call "ActionFigures".&nbsp; This thread is not intended to discuss the merits of ActionFigures, only their implementation.</P>
<P>In the system there are different types of ActionFigures.&nbsp; ActionFigures do many common properties, but each disctinct type also has it's own distinct properties and behaviors as well.&nbsp; ActionFigures are stored in one table in the database to provide a unique ID, but periphery tables join to the root ActionFigure table to hold any data that is unique to an ActionFigure type or classification.&nbsp; This is just to avoid a sparce table. What I need to do is be able to determine if a user has a given ActionFigure based on given parameters - we'll call this an ActionFigure Query.</P>
<P>This lends itself to two implementations in my mind, but can you suggest another?&nbsp; First, I see retreiving all the user's ActionFigures from the database and using them locally (on the web server) to perform ActionFigure Querries.&nbsp; The second may be simply using a CSLA Command object to check against the database directly but I'm concerned that may be too "chatty" - perhaps caching the result of a particular&nbsp;ActionFigure Query&nbsp;would help.</P>
<P>For the first implementation - retrieving the whole list and querying locally - I'm thinking about a ActionFigureManager class.&nbsp; Provide the ActionFigureManager with the user information and it will retrieve all of the different ActionFigures for that user.&nbsp; Provide the loaded ActionFigureManager with information on an ActionFigure to look for (an "ActionFigure Query"), and it will tell you if it exists in the collection or not.&nbsp; </P>
<P>Remember though, that each ActionFigure type is a little different and has to retrieve different data from the DB from different table joins.&nbsp; This leads me to think that a single CSLA parent collection of child ActionFigure objects won't quite do it since different stored procs may need to be called to load and manage different ActionFigure data based on ActionFigure type (which is also stored in the DB).&nbsp; The data management behavior is different by type, however the other behavior should be the same: check against an ActionFigure Query.&nbsp; I'd love to make this ActionFigureManager a single collection with child-type ActionFigure from a normalization-of-behavior standpoint, but the data management behavior varries too much by ActionFigure type, I think, and when I get to validation it's different again (assuming I use the same classes for ActionFigure management).&nbsp;&nbsp; Even if it were one table or view, choosing which column from which to load data would vary by ActionFigure type, so its not really a database issue (do you agree?).</P>
<P>At any rate, one of my key goals for this approach would be that the ActionFigureManager should not need to be modified when we add a new ActionFigure type to the system; we should only need to implement the newest ActionFigure type class since that class would be responsible for loading and saving itself to its tables as well as replying to any ActionFigure Query.&nbsp; One approach I thought of to achieve this goal was in the ActionFigureManager to store a collection of type-specific, ActionFigureCollection-derived, editable-root-collection CSLA objects; polymorphism at work.&nbsp; The ActionFigureManager internally maintains a collection of ActionFigureCollections, but each entry is a different collection type for each type of ActionFigure, and each collection does its thing in its own way while deriving from a base ActionFigureCollection - or perhaps they all implement a certain IActionFigureCollection interface.&nbsp; Going back to the goal of not modifying the ActionFigureManager when a new ActionFigure type is added to the system: I'd like to avoid a switch statement in the ActionFigureManager over the ActionFigure type which would hard-code the ActionFigure type code from the DB (or a string or type name) to a specific collection class type and it's constructor.&nbsp; Reflection, I'm looking at you... It's somewhat akward, but along with the ActionFigure type identifier in the database (probably an int), I could add the associated strong class name and have the ActionFigureManager load the appropriate collection type via reflection, then work on it once its cast to the base ActionFigureCollection type.&nbsp; In other words, ActionFigureManager is a Factory that creates ActionFigureCollection-derived Factories for ActionFigure objects - or as Number 2 in Austin Powers put it: "A factory that&nbsp;manufactures miniature replicas of factories".&nbsp; Shark.FrickinLaserBeam.Fire().</P>
<P>Seems clever...maybe too clever.&nbsp; It does meet my criteria though: ActionFigureManager doesn't need to know about the different types of ActionFigureCollections, but can still retreive ActionFigure data and respond to ActionFigure Queries.&nbsp; I do know that generics (and hence CSLA objects) in C# are not polymorphic, but I believe setting up a root ActionFigures collection&nbsp;class from a CSLA template and implementing an "OnQuery", "OnFetch" methodology to provide hooks for derived classes should do the trick. Nyet?&nbsp; </P>
<P>The second, and less thouroughly thought out implementation, would be to use a UserHasActionFigureCommand CSLA Command object to simple query the database directly.&nbsp; This however puts the responsibility of firguring out which tables to join&nbsp;to on&nbsp;the SQL statement or stored procedure.&nbsp; I think it also only delays the problem, since this only addresses the ActionFigure Query, and not any data management tasks like modifying the user's ActionFigure collection info.</P>
<P>So, have any of you CSLA framework experts done anything similar to this?&nbsp; How have you handled the situation?&nbsp; How am I doing with my attempts?&nbsp; What suggestions do you have?&nbsp; </P>
<P>Thanks in advance, I'm looking forward to hearing your suggestions!</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, April 28, 2008</h2>First, I'll admit up front I may have skimmed some of the details of your post.&nbsp; Sorry, just can't spent too much time here.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br>So, you need to find what kind of figure someone has based on certain criteria?&nbsp; Is this criteria limited only to the shared set of properties any figure may have, or can someone specify in their search criteria specific to certain kinds of figures?<br><br>If it's the former, probably your best bet is to add a column that simply stores the kind of figure to the base table.&nbsp; You get an immediate answer very easily.&nbsp; If it's the latter, you'll probably still need said column, but you may also need to have meta data in your database that you can use to figure out what extra attributes certain types of figures have.&nbsp; For example FigA and FigB will share all the FigBase properties, but possibly a few properties unique to either of those figures.&nbsp; So maybe FigA has A, B and Z and FigB has X, Y, and Z.&nbsp; Z being something that figures may or may not have.&nbsp; The meta data would help you narrow your query.<br><br>As far as avoiding a switch statment goes, that may be unavoilable if you eventually need to get to the final derived class.&nbsp; That's not necessarly bad though.. it just means that will likely be the entire responsiblity of one class.<br><br>Just my thoughts.. <br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SomeGuy replied on Monday, April 28, 2008</h2><P>Hmm, looks like you have a Pattern in search of a problem.</P>
<P>I am assuming your object model is something like:<BR>&nbsp;&nbsp;&nbsp;Action Figure: Id, Name, Manufacturer(Id), Release date, etc.</P>
<P>&nbsp;&nbsp;&nbsp;Action Figure Types: Star Wars, Star Trek, Battlestar Galactica, Transformers, Smirfs, etc.</P>
<P>&nbsp;&nbsp;&nbsp;Each type has additional properties specific to it, like Movie(Id), Season(Id), etc.</P>
<P>To me, it calls for a Composition Pattern with a static class like Assignment in PTracker with concrete classes for each type. You may have a ActionFigureList which has the common properties, but will also have Lists for each type to get a list based on the type specific properties (StarWarsActionFigureList.GetListByMovie('Episode I'))</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Monday, April 28, 2008</h2><p>You, in part, said: <br></p><p><br><font color="#000000">I'm working with a list of objects that we'll call "ActionFigures".&nbsp;
This thread is not intended to discuss the merits of ActionFigures,
only their implementation.</font></p>
<p><font color="#000000">In the system there are different types of ActionFigures.&nbsp;
ActionFigures do many common properties, but each disctinct type also
has it's own distinct properties and behaviors as well.&nbsp; ActionFigures
are stored in one table in the database to provide a unique ID, but
periphery tables join to the root ActionFigure table to hold any data
that is unique to an ActionFigure type or classification.&nbsp; This is just
to avoid a sparce table. What I need to do is be able to determine if a
user has a given ActionFigure based on given parameters - we'll call
this an ActionFigure Query.</font></p><p><font color="#000000">-------<br></font></p><p>My preference in these discussions is to make sure I understand the use cases.&nbsp; I think that I detect at least two very distinct use cases: First, for a given user, determine if a particular type of action figure is associated with that user.&nbsp; The result of the inquiry is a boolean yes or no.&nbsp; Second, again for a given user, retrieve the data for a spedific action figure, if such an action figure is associated with that user.&nbsp; <br></p><p>For the first use case, I would probably create a command class that was smart enough to switch the query SQL based upon the action figure type.&nbsp; This is chatty but is probably more maintainable (and I worship regularly at the Shrine for Maintainability).&nbsp; One variation on this approach would be to pass the action type to a stored procedure that would handle the switch.&nbsp; Another variation on this approach would be to store the queries for each action figure type in a configuration file (or something similar); look for the action figure code in the list, use the associated query.&nbsp; At the extreme you could build a series of plug in assemblies that contained the code to perform the queries.&nbsp; Unless you have hard requirements that dictate that you be able to add a new action figure in a matter of minutes, I would stick with the initial command class.&nbsp; Rule of thumb: avoid cleverness unless the situation requires it (and really question if the situation really does require it). <br></p><p>I suspect that you are engaged in premature optimazation.&nbsp; I would argue that you should make sure that your design is decoupled as much as is reasonable.&nbsp; Only when you have hard data that shows that you have a performance problem would I consider such tactics as caching data.&nbsp; If I did cashe data, I would probably create a very minimal data structure: user identification and the identification codes of the action figure types associated with that user.&nbsp; This would be a read-only&nbsp; list/item setup.&nbsp; It has one purpose: to answer the question: is this user  associated with s specified action figure type?</p><p>Now for the second use case: I would probably use the same command class approach with the difference that I would either hand back an instance of an action figure class or nothing/null.&nbsp; The same arguments for delaying the caching decision would apply here.</p><p>Your references to polymorphism suggests that there might be a third use case that would deal with a set of use cases.&nbsp; There is not enough material in your post to do anything with this use case.&nbsp; <br></p><p>There are probably several other use cases.&nbsp; One of the hallmarks of CSLA is that, in the absence of compelling reasons to the contrary, there ought to be a separate set of objects that handle each use case.&nbsp; My experience is that separation is the optimum approach: as the use cases change (and they do change), you gradually carve up the classes that you combined to "save coding" into separate classes that, in effect, build firewalls between the use cases.</p><p>HTH</p>Jon Stonecash<br><p><br></p><p><br></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rrahlf2 replied on Thursday, June 19, 2008</h2><P>Great suggestions guys!&nbsp; I really appreciate the input!&nbsp; Also, I appologize for the late reply, it seems the reply notification emails from the forum&nbsp;may be blocked by my email filter.</P>
<P>I defninitely agree that there needs to be a "type" column in the&nbsp;root ActionFigure table.&nbsp; The type can indicate which secondary table we need to address in our Sql join.&nbsp; One other approach we're looking at is adding a XML blob column to the root ActionFigure table for extended properties and eliminating the secondary tables by type...this should work since we aren't putting any foreign keys or other constraints on the values in the XML (that aren't going to be handled by the business objects).</P>
<P>SomeGuy, I'll definitely familiarize myself with the Composition Pattern and see how I can apply this to my ActionFigure problem.</P>
<P>As I've continued to work with this issue, I've really boiled the problem down to "How do I perform a search across non-homogeneous data using CSLA and SQL in an extensible way?"&nbsp; To answer your question, Jon, there is a requirement for being able to add ActionFigures quickly and easily - although not manually by the user's themselves at this point (ActionFigure is just a metephor, not our real objects).&nbsp; I can expand on it a bit though:</P>
<P>To extend the example, the ActionFigure is put into the product catalog by our staff, but it's added to the user's collection via shopping-cart,&nbsp;so we need to search a user's collection for an ActionFigure with unknown extended properties which have been defined by our staff.&nbsp; New definitions can be added at any time, and we'd like to not have to rewrite the search when the staff defines a new figure with new extended properties.&nbsp; To be clear, the extended properties which we are searching for will be known as part of the search, but we'd like the searching mechanism to support the extended properties genericly without actually having to understand their definition...sort of like SQL fulltext searching;&nbsp; it doesn't need to understand the spoken language of the text data, it only needs to understand Unicode.</P>
<P>As I'm writing this, and thanks to all your suggestions, I'm wondering if the XML blob column might be even more helpful than we thought.&nbsp; Going with a single Command object to return a boolean "Exists" result of a search, and combining that with Jon's suggestion of putting specific queries in the config file, perhaps I can write the portion of the SQL search that checks the extended properties as XPath and place that in the config.&nbsp; Then the system can look up the XPath by ActionFigure type and pass that parameter to the SQL via the Command object.&nbsp; With any luck, I may even be able to auto generate the XPath from the initial definition of the ActionFigure properties.</P>
<P>Any other thoughts or suggestions?&nbsp; Has anyone tried this approach?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SomeGuy replied on Thursday, June 19, 2008</h2><P>You could implement the Extended Properties as a child collection of the Action Figures. ie:</P>
<P>SELECT id, name, description, manufacturer, ....<BR>FROM ActionFigures af<BR>LEFT JOIN ExtendedProperties ep ON ep.actionFigureId = af.id<BR>WHERE ep.name = @extendedPropertyName AND ep.value = @extendedPropertyValue</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rrahlf2 replied on Thursday, June 19, 2008</h2><P>That's a good suggestion as well, altough I've never been a fan of vertical property tables.&nbsp; I think that would be a great way to build the CSLA business objects though, if there are no validation rules associated with the extended properties.&nbsp; </P>
<P>Thanks for the suggestion!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SomeGuy replied on Thursday, June 19, 2008</h2><P>Vertical property tables do have their drawbacks, but it seems like a clean way to implement your Extended Properties. You wouldn't have any code changes or even fancy search coding to do.</P>
<P>I am not a fan of dynamic SQL, or passing complex WHERE clauses at text or XML.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
