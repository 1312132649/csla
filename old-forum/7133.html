<html><header><title>Memory Leak with ReadOnlyBase derived object inside BusinessBase derived object</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Memory Leak with ReadOnlyBase derived object inside BusinessBase derived object</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7133.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Cable posted on Thursday, June 18, 2009</h2>This is a follow up to a discussion I had with Rocky at VSLive! Las Vegas last week.<br /><br />I have BusinessBase derived objects that have ReadOnlyBase derived objects in them.  When importing data from an access db and saving it to the new SQL DB, I received an OutOfMemoryException.<br /><br />The leak disappears if I change the BusinessBase OnAddEventHooks to not subscribe to the BusyChanged, UnhandledAsyncException, and PropertyChanged events for IReadOnly objects or if I don't use managed backing fields and Load/Set/Get/Read Property methods in my business objects.  Here's what I did to the OnAddEventHooks method in BusinessBase:<br /><br />protected virtual void OnAddEventHooks(IBusinessObject child) <br />{  <br />  bool isReadOnly = child is IReadOnlyObject;  <br />  INotifyBusy busy = child as INotifyBusy; <br />  if (busy != null &amp;&amp; !isReadOnly) <br />    busy.BusyChanged += new BusyChangedEventHandler(Child_BusyChanged);  <br /><br />  INotifyUnhandledAsyncException unhandled = child as INotifyUnhandledAsyncException; <br />  if (unhandled != null &amp;&amp; !isReadOnly) <br />    unhandled.UnhandledAsyncException += new EventHandler(Child_UnhandledAsyncException);  <br /><br />  INotifyPropertyChanged pc = child as INotifyPropertyChanged; <br />  if (pc != null &amp;&amp; !isReadOnly) <br />    pc.PropertyChanged += new PropertyChangedEventHandler(Child_PropertyChanged);  <br /><br />  IBindingList bl = child as IBindingList; <br />  if (bl != null) <br />    bl.ListChanged += new ListChangedEventHandler(Child_ListChanged);  <br /><br />  INotifyChildChanged cc = child as INotifyChildChanged; <br />  if (cc != null)  <br />    cc.ChildChanged += new EventHandler(Child_Changed); <br />}<br /><br />I've posted more detail and screen shots from Ants on my blog http://lovetocode.net<br />Let me know if you need any more details.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, June 20, 2009</h2>Thanks for following up on this - I'll add it to the list of things to look at.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>t.kehl replied on Tuesday, May 24, 2011</h2><p>Hi Rocky</p>
<p>Any update about this? - I use CSLA 4.1.0 and had similar problems.</p>
<p>Best Regards, Thomas</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 25, 2011</h2><p>We haven&#39;t looked at this yet, no.</p>
<p><a href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=423">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=423</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Miroslav Galajda replied on Friday, January 10, 2014</h2><p>Hi,&nbsp;</p>
<p>I have observed the same leak. Even in the latest version Csla 4.5.500 the problem isn&#39;t resolved. The bug is closed but not resolved.</p>
<p> Do you think that the proposed solution (here in the first post) is OK?</p>
<p>Thank you</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 16, 2014</h2><p>I&#39;ve added an issue to GitHub regarding this bug</p>
<p><a href="https://github.com/MarimerLLC/csla/issues/250">https://github.com/MarimerLLC/csla/issues/250</a></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
