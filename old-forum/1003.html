<html><header><title>Generic CSLA Factory methods...</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Generic CSLA Factory methods...</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1003.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul posted on Thursday, August 24, 2006</h2><P><SPAN>I'm still having trouble getting my head round Generics particularly when using the CSLA, I could remove the generic element from structure altogether but I don't want to lose the strong typing that the CSLA provides through the Save() method etc.</SPAN><o:p></o:p></P>
<P><SPAN>I have an abstract base class...</SPAN><o:p></o:p></P>
<P><SPAN>public</SPAN><SPAN> <SPAN>abstract</SPAN> <SPAN>class</SPAN> <SPAN>AbstractBase</SPAN>&lt;T&gt; : <SPAN>BusinessBase</SPAN>&lt;T&gt; <SPAN>where</SPAN> T : <SPAN>Base</SPAN>&lt;T&gt;</SPAN><o:p></o:p></P>
<P><SPAN>There is a chain of inheritance that looks like this</SPAN><o:p></o:p></P>
<UL>
<LI class=MsoNormal><SPAN>&nbsp;AbstractBase</SPAN> <o:p></o:p></LI>
<UL>
<LI class=MsoNormal><SPAN>Object1 (inherits base)</SPAN> <o:p></o:p></LI>
<UL>
<LI class=MsoNormal><SPAN>Object2 (inherts object 1)</SPAN><o:p></o:p></LI></UL></UL></UL>
<P><SPAN>Now since I don't&nbsp;know the type of object until I hit a database I have created an object factory which is basically a CommandBase object that hits the DB determines the type object and passes the datareader to the relevant concrete class which then creates the object. These object can all be maniulated as type AbstractBase so the concrete type doesn't really matter</SPAN><o:p></o:p></P>
<P><SPAN>The factory returns the item of type object since I could return it as type AbstractBase&lt;T&gt; since I didn't know the type T until the factory has done it's work</SPAN><o:p></o:p></P>
<P><SPAN>Ideally&nbsp;I would have been a static method on AbstractBase like...</SPAN><o:p></o:p></P>
<P><SPAN>public</SPAN><SPAN> <SPAN>static</SPAN> <SPAN>AbstractBase</SPAN>&lt;T&gt; GetAbstractBase(<SPAN>int</SPAN> Id)<BR>{<BR>&nbsp;&nbsp;&nbsp;<SPAN>AbstractFactory</SPAN> factory;<BR>&nbsp;&nbsp;&nbsp;factory = <SPAN>DataPortal</SPAN>.Execute&lt;<SPAN>AbstractFactory</SPAN><SPAN> </SPAN>&gt;(<SPAN>new</SPAN> <SPAN>AbstractFactory</SPAN>(Id));</SPAN><SPAN><o:p></o:p></SPAN></P>
<P><SPAN>&nbsp;&nbsp;&nbsp;return (<SPAN>AbstractBase</SPAN>&lt;T&gt;)factory.ConcreteObject;<BR>}</SPAN><SPAN><o:p></o:p></SPAN></P>
<P><SPAN>but again I wouldn't know the value of T so wouldn't be able to call the method. So I could have the Factory itself return the object but I can't convert it to AbstractBase because I don't know T. Well I do really becuase I can get the type of objct returned by the factory but this won't compile..</SPAN><o:p></o:p></P>
<P><SPAN>AbstractFactory</SPAN><SPAN> factory;<BR>factory = <SPAN>DataPortal</SPAN>.Execute&lt;<SPAN>AbstractFactory</SPAN><SPAN> </SPAN>&gt;(<SPAN>new</SPAN> <SPAN>AbstractFactory</SPAN>(Id));</SPAN><SPAN><o:p></o:p></SPAN></P>
<P><SPAN>return <BR>(<SPAN>AbstractBase</SPAN>&lt;factory.ConcreteObject.GetType()&gt;)factory.ConcreteObject;</SPAN><SPAN><o:p></o:p></SPAN></P>
<P><SPAN>Surely there is a better way of doing this I just don't know what it is! Can anyone assist?<o:p></o:p></SPAN></P>
<P><SPAN><BR>&nbsp;<o:p></o:p></SPAN></P>
<P class=MsoNormal><o:p>&nbsp;</o:p></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, August 24, 2006</h2>There's really no way of having strong typing that way. You could make the object implement an interface, and return that. But that way the problem is not really solved, you'll have to probe for the actual type.<br><br>The question is: How do you get to load this data? Usually you will have a readonly list that contains info about the object you're going to retrieve. The user picks something from that list and you retrieve the bo based on that ID. In that scenario, why not also include information about the type? That way, you can know the type before loading, and you could call the appropiate methods. Your readonly object could even abstract those calls for you, but you will definitely need to do some conditional evaluation to match either the method you're going to call or the type of the object that was returned.<br><br>What's important is to realise that it is not a problem that relates to generics at all...<br>Try to do the same thing without generics. What would be the type returned by your factory? Again: an interface or Object.<br>Generics provide type safety at compile time, and what you're trying to accomplish takes place at runtime.<br><br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul replied on Thursday, August 24, 2006</h2><P><FONT face=Arial size=2>Thanks for the reply</FONT></P>
<P><FONT face=Arial size=2>Without generics it become easy I could just say</FONT></P>
<P><FONT face="Courier New" size=2>ObjectBase object = ObjectFactory.GetObject(id);</FONT></P>
<P><FONT face=Arial size=2>I don't need to know anything about ObjectBase before making the call whereas the Generic method would have to be</FONT></P>
<P><FONT face="Courier New" size=2>ObjectBase&lt;T&gt; object = ObjectFactory.GetObject(id);</FONT></P>
<P><FONT face=Arial size=2>At which point I don't know the type of T. This essentially means that what I'm trying to achieve won't work. Since the caller doesn't need to know T and I don't really want them to if they need to convert to the concrete type then that was up to the caller.</FONT></P>
<P><FONT face=Arial size=2>I would like to avoid having pass the type into the method/factory as this would over complicate the method call and would require type knowledge and I won't always necessarily be creating the object from like you say a readonly list.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, August 24, 2006</h2>If that is all you want, then again, go with the interface approach:<br><br>IObjectBase object = ObjectFactory.GetObject(id);<br><br>What you want to do involves polimorphism and generics are not polimorphic. Implementing an interface is the only way around that.<br><br>The reason is simple, suppose you have a class like:<br><br>public class MyClass&lt;T&gt;<br>{<br>void DoSomething&lt;T&gt;(T value) {...}<br>}<br><br>If you pass different types to T, the method signature will not be the same. So, two objects that have different types for T will have different interfaces.<br><br><br><br>Andrés<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul replied on Thursday, August 24, 2006</h2><P><FONT face=Arial size=2>I had thought about the Interface approach but then dismissed it for some reason but what you've said makes sense.</FONT></P>
<P><FONT face=Arial size=2>Thanks for that.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, August 24, 2006</h2>I &lt;think&gt; that in c# you can right click on a class and select "Extract interface". That way the interface is created automatically and you'll save a couple of minutes. Again, I &lt;think&gt;, but I'm not certain.<br><br><br>Andrés</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 24, 2006</h2>You'd be correct.&nbsp; Its as simple as that.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul replied on Thursday, August 24, 2006</h2><P><FONT face=Arial size=2>Yeah unfortunately it doesn't take any methods from the base class (such as BusinessBase.Save()) but it's not a massive job to add them in.</FONT></P>
<P><FONT face=Arial size=2>Cheers for your advice on this.....and interface has proven successful :-)</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, August 24, 2006</h2>Why would you want methods from the BusinessBase class?<br><br>At any rate, interfaces can inherit other interfaces.. just declare it to inherit Core.IEditiableBusinessObject, and possibly ISavable (I think... but that's only if you're using 2.1 beta).<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>geordiepaul replied on Friday, August 25, 2006</h2><P><FONT face=Arial size=2>I want access to Save() through the interface but I'm not quite sure yet.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, August 25, 2006</h2>Well if you declare your interface like this:<br><br>public interface IMyInterface : Csla.Core.ISavable { <br>// Interface defintion here<br>}<br><br>Then you can access Save via your IMyInterface.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
