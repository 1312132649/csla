<html><header><title>3.5 question: PropertyInfo(Of T) and custom attributes</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>3.5 question: PropertyInfo(Of T) and custom attributes</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4483.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan posted on Sunday, March 09, 2008</h2>Hi Rocky,<br><br>I want to integrate an auditing mechanism in my base class using the new&nbsp; FieldManager.GetRegisteredProperties(), which returns a List(Of IPropertyInfo).<br><br>I know that this way I only can control members that were declared like this:<br><br><font face="Arial">&nbsp;&nbsp;&nbsp; Private Shared NameProperty As PropertyInfo(Of String) = _<br>&nbsp;&nbsp;&nbsp; RegisterProperty(Of String)(GetType(TestAuditableBase), New PropertyInfo(Of String)("Name", "friendly name of property", String.Empty))<br><br><font face="Times New Roman">I just pull out a new List(Of Object) using ReadProperty(info) for each registered member <br>each time I need to make a snapshot of the current values.<br>My tests seem to work.<br><br>Now I want to use a custom attribute 'NotAuditedAttribute' to indicate that certain members <br>should be ignored in the auditing process. Just like with NotUndoable.<br><br>How can I use custom attributes together with the new way of registering the members?<br>Am I then forced to use a local backing field, or is there another possible way?<br><br>Stefan<br></font><br></font><br>&nbsp;</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, March 09, 2008</h2><P>I think there are a couple options.</P>
<P>One is to put the custom attribute on the Shared PropertyInfo declaration. Another is to put the custom attribute on the property itself. Either way you need to use reflection to see if the attribute is present - it is just a matter of choosing what to reflect against.</P>
<P>A way that would avoid reflection is to extend PropertyInfo&lt;T&gt;. The purpose of PropertyInfo&lt;T&gt; is to provide metadata about each property, and you can subclass PropertyInfo&lt;T&gt; and extend it with extra metadata. So rather than using a custom attribute, you could just have an extra property in your custom extension that indicates whether the property is audited.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Monday, March 10, 2008</h2>Thank you for your advice. <br>I will as well have to extend PropertyInfo&lt;T&gt; for my custom authorization to work. Formerly I had attributes on each property indicating the appropriate permission entry in my auth table. <br>Now I will be able to maintain these infos using the framework's infrastructure. That's pretty cool!<br><br>Thanks,<br><br>Stefan<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Sunday, March 09, 2008</h2><P>This doesn't specifically address your question of attributes, but it seems to me that if you use attributes your auditing fields would be determined at compile time (unless you are using ICustomTypeDescriptor, which has its own warts). </P>
<P>Our application also supports field level auditing, but our users get to decide what fields get audited, so I don't know until runtime which fields will be audited.&nbsp;I implemented it with a static dictionary that maintains a list of the fields audited for each object, and load the dictionary on the first database connection. It seems to work well and is also reasonably fast. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>stefan replied on Monday, March 10, 2008</h2>You are right - deciding which properties are audited should be the user's choice.<br>How did you determine the first database connection - or do you fill the dictionary with the entire information that's available for all types on the first login?<br><br>Stefan<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Monday, March 10, 2008</h2><P>In our case, we have a set of bridge classes that sit between CSLA and the ORM we use for database access, so it provides a natural place for doing initialization of this type. (Getting the plumbing set up properly for this was a serious "chicken versus the egg" problem, but I finally got it sorted out... ;) </P>
<P>I think your idea of doing it on the first login would also work fine and is basically equivalent. </P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
