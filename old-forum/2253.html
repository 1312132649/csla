<html><header><title>ChildCollections fed by LLBLGen EntityClass</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>ChildCollections fed by LLBLGen EntityClass</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2253.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>swegele posted on Wednesday, January 31, 2007</h2><P>Hey all,</P>
<P>I am designing a BL with 2.1.2 around the latest LLBLGen DAL.&nbsp; Man it looks like this is going to be a match made in heaven!&nbsp; Seems to be fitting together nicely minus one thing that is stumping me.</P>
<P>The problem I am having is deciding how to architect the ChildCollections in the BL with CSLA.&nbsp; The EntityClass from LLBLGen actually holds all the data that was fetched and relations too.&nbsp; EX:</P>
<P><FONT color=#0000ff>Class EmployeeEditableRoot<BR>&nbsp; Inherits BusinessBase<BR><BR>&nbsp;&nbsp;&nbsp; Private mDALEmployee as EntityClasses.EmployeeEntity<BR><BR>&nbsp;&nbsp;&nbsp; Public ReadOnly Property ID&nbsp;As String<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return mDALEmployee.ID<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Get<BR>&nbsp;&nbsp;&nbsp; End Property</FONT></P>
<P>&nbsp; So what makes sense here as far as wrapping the DAL entities ??</P>
<P>1.&nbsp; Have an editable root with a private LLBLEntityClass that feeds all properties and child collections.&nbsp; Child collections in BL would be NotUndoable and NonSerializable and just temporary wrappers for the child data that is in the DALEntityClass.&nbsp; The BL child collections would hydrate upon deserialization pulling the&nbsp;related collections out of the DALEntityClass and exposing them in the proper&nbsp;BLChild classes/collections.&nbsp; But when EditableRoot BL&nbsp;object serializes it in effect would drop all it's child collections and rehydrate them on the other side of the portal because the DALEntityClass came with.&nbsp; Like so:</P>
<P><FONT color=#0000ff>&lt;NotUndoable(), NonSerializable()&gt; Private mAddresses as EmployeeAddresses<BR><BR>Public ReadOnly Property AddressList as EmployeeAddresses<BR>&nbsp; Get<BR>&nbsp;&nbsp;&nbsp; If mAddresses&nbsp;Is Nothing&nbsp;Then<BR>&nbsp; &nbsp;&nbsp;&nbsp; <FONT color=#9acd32>'dynamically build Employee Addresses first fetch from DAL Object</FONT>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For&nbsp;i = 0 to mDALEmployee.EmpAddress.Count -1<BR>etc.<BR>&nbsp; </FONT></P>
<P>2.&nbsp; OR...Don't use the DALEntityClass to hold all the child data...instead design&nbsp;one to one where&nbsp;the BLChildCollections actually persist holding the BLChildren which have a private member of that related DALEntity.&nbsp; I could still use the fetch DALEntityClass to fetch all data at once (using prefetch paths) but then strip it out into the corresponding BLCollections and then clear the DALEntityClass child collections so they don't take up a ton of space during de/serialization.&nbsp; The child BL Collections would get populated on the initial fetch or on demand.</P>
<P><FONT color=#0000ff>Private mAddresses as EmployeeAddresses<BR><BR>Public ReadOnly Property EmpAddressList as EmployeeAddressList<BR>&nbsp; Get<BR>&nbsp;&nbsp;&nbsp; If mAddresses&nbsp;Is Nothing&nbsp;Then<BR>&nbsp; &nbsp;&nbsp;&nbsp; </FONT><FONT color=#9acd32>'get Employee Addresses first fetch from&nbsp;DB through portal</FONT><FONT color=#0000ff><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mAddresses = EmployeeAddressList.GetList(mDALEmployee.ID)<BR>etc.</FONT><BR></P>
<P>I was leaning towards 1 but I am not that far into it yet and I could go either way...wondering if 2 makes more sense in the end especially since LLBLGen doesn't keep track of IsDeleted like CSLA does.</P>
<P>Give me your thoughts</P>
<P>Sean Wegele</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
