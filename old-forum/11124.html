<html><header><title>Deep Hierarchy Child Delete Issue</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Deep Hierarchy Child Delete Issue</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11124.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo posted on Thursday, February 02, 2012</h2><p>
<p>Hello.</p>
<p>Given a hierarchy such as &ldquo;Parent -&gt; Children -&gt; Child -&gt; Grandchildren -&gt; Grandchild&rdquo;. If you delete a &quot;Child&quot; object using its parent collection &ldquo;Delete()&rdquo; method as in: &ldquo;theParent.Children.Delete(theChild)&rdquo; and then save the parent. The delete data portal will only be called on the &quot;Child&quot; object but on the &quot;Grandchild&quot;.</p>
<p>It&rsquo;s been a while but I think I remember reading on some old post that this is the way is supposed to work but I would like to make sure. If you ask me I would say that all delete data portals on all the children on all lower levels of the hierarchy should be fired but I have a feeling that is not the way it works and I would venture to say is all in the name of performance.</p>
<p>Can someone confirm if this is a bug or a feature?</p>
<p>Thanks.</p>
<div></div>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 02, 2012</h2><p>The data portal doesn&#39;t cascade any calls to child objects unless you write code in the parent to cause that to occur.</p>
<p>If you want to cascade the delete calls you could do so, but normally that isn&#39;t the way it is done. As you say, for performance. Normally the object that&#39;s deleted, if a parent, deletes all data below it in the database structure, and then just sets all its child references to null to effectively discard the now-unnecessary objects from the object graph.</p>
<p>Occassionally someone has the requirement to keep the object graph intact, but have all those now-deleted child objects marked as new. That&#39;s pretty rare (I&#39;ve only seen it one or two times ever), and in that case you do need to cascade the delete calls through all the child objects.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Friday, February 03, 2012</h2><p>&nbsp;</p>
<p>Thanks Rocky,</p>
<p>I guess my question is why can&rsquo;t the CSLA automatically cascaded the deletes anyway and let the developer decide whether he or she wants to handle all children deletes on the parent object (as you suggest) or if he or she prefers to call &ldquo;FieldManager.UpdateChildren()&rdquo; on the parent and let each child delete itself (as I suggest)?</p>
<p>I personally prefer to let each child delete itself, I find that to be a more encapsulated and consistent approach. Also in our case (and I would expect this to be the same for most apps) the deletes account for probably around 1% or less of the data portal transactions so we don&rsquo;t need that extra performance gain for such low volume. Also, the reality is that even if the children delete themselves (unless you have thousands of children) the children deletes occurs so incredible fast that the performance gains are just about 100% irrelevant.</p>
<p>I realize that I can cascade the deletes manually (that&rsquo;s what I am doing now) I just think that this type of work is best suited for the CSLA.</p>
<p>Am I missing something?</p>
<p>Thanks.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, February 03, 2012</h2><p>I think it could cascade automatically, though that&#39;s not as easy as it might seem at first. Right now <em>no child calls</em> cascade automatically.</p>
<p>Cascading automatically is easy enough in one sense, but in practice there are dependencies between sibling objects in some cases. So really making this work requires adding the ability for you to describe the data dependencies between all the objects in the graph, and then having this new CSLA functionality be smart enough to walk the graph in the correct order based on those dependencies.</p>
<p><em>That</em> gets dangerously close to ORM behaviors, and I&#39;m really not interested in CSLA becoming an ORM.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
