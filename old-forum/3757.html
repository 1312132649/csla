<html><header><title>Inheritance comment / question -- change visibility of Delete method</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Inheritance comment / question -- change visibility of Delete method</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3757.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>lazaropi posted on Monday, October 22, 2007</h2>Hi,<br><br>The BusinessBase class is great most of the time, but I have a couple of BO's for which I would like to "turn off" the delete method (these objects can be modified but they should never be deleted from the DB.<br><br>It turns out that C# is a lot more restrictive than C++ when it comes to inheritance (almost always with good cause). In this case, it is impossible to override a member with a different visibility.<br><br>At first I thought that the 'new' keyword would help by hiding the base member and declaring the new one with private modifier. That does not work. The 'new' only hides a member with the exact same signature so the base method is still accessible.<br><br>The best I can do so far is to override delete( ) with an empty definition so it does not do anything.<br><br>something like this:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void Delete( )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the only way to prevent the delete is to do nothing here<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // it is still possible to call<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // base.Delete( );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // to get the delete method of the BusinessObject class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // when this is done an exception is thrown because there is <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // no delete functionality implemented in the DB.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // we don't want these records to be deleted.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<font color="#000000"><br><br>Have any of you guys ever come up with this issue? If so, what would be a better way to deal with it?<br><br>thanks, <br><br>lazz pi<br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lazaropi replied on Monday, October 22, 2007</h2>Just to clarify the 'new' keyword part:<br><br>You can check that 'new' doesn't work here (despite what I found through a Google search)<br><br>&nbsp;&nbsp;&nbsp; public class BaseClass<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void MyMethod( )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine( "From Base" );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public class DerivedClass : BaseClass<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private new void MyMethod( )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine( "From Derived" );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void OtherMethod( )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine( "From Other" );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public class User<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static void WorkHere( )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DerivedClass dc = new DerivedClass( );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.MyMethod( ); //still calling base class method<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dc.OtherMethod( );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseClass bc = ( BaseClass ) dc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bc.MyMethod( );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, October 22, 2007</h2>Your best bet is to override Delete and throw a NotSupportedException.<br><br>You could also override Save and throw a NotSupportedException if IsDeleted is set to true as well.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lazaropi replied on Monday, October 22, 2007</h2>Thanks for your replay, I'd say that would do it but what I would really like is for the Delete method not to be available to the class user.<br><br>It is another case of trade offs in language design, I guess.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, October 22, 2007</h2>To make it unavailable, you'd have create something between what is in BusinessBase and BindableBase now in Csla.Core.&nbsp; Then you could have a NonDeletableBusiness base, and inherit from that.&nbsp; BusinessBase would also inhert this new class, and just add the deleting portion of code.<br><br>Well, at least that's an off the top of my head way to do it.&nbsp; <br><br>Along the suggestion from my first post, you could subclass Csla.BusinessBase to a NonDeletableBusinessBase and do the overrides there... that would save having to override Delete in every class in which you don't want to support deletions.<br><br>So if you really want it gone, you should be able to.. its just a matter of if you want to spend the time (now and later) coding that.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lazaropi replied on Monday, October 22, 2007</h2>Right, that's precisely what I'm talking about. It is just too much work to get so little. And that's why I sort of miss the more carefree (dangerous) approach of other pardigms.<br><br>Having said that, I really like the overall design choices of C# and .NET. It is my preferred language, environment (at least for now). <br><br>Thanks for your comments,<br><br>lazz pi<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Henrik replied on Tuesday, October 23, 2007</h2><P>Several times I've found myself in the same position where the businessbase offers a method, say delete or update, that the use case didn't need or should support.</P>
<P>I just as many cases I've found myself implementing the very same methods later on, when the business rules changes.</P>
<P>My point is, that it's better to have the Delete method in the business base and just throw a NotSupportedException, than building a separate base class without the method. If the business rules,&nbsp; later on suddenly requires the delete method you can just implement the method instead of inheriting from a new base class which can easily introduce&nbsp;bugs in other parts of the class.</P>
<P>You can also have the case where the user cannot execute the method but an admin can. However in these cases there is often talk about two different use cases and thus two different business object.</P>
<P>In the end you should remember that it's the application developers that can see the delete method and not the end user. It's way easier to teach&nbsp;application developers not to call the delete method by throwing an exception in their face than teaching an end user not to press the delete button ;-)</P>
<P>Hope this helps a bit.</P>
<P>Cheers<BR>/Henrik</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>lazaropi replied on Wednesday, October 24, 2007</h2>Well, your point makes a lot of sense. I think I'll do it with an exception. <br><br>BTW, there are other situations where the object has to sometimes allow some behavior and sometimes it can't (according to some criteria) but must of the time it can be handled with validation / authorization rules. But the logic can become quite complex and in the end one has to decide these things in a case by case basis.<br><br>Thanks!<br><br>lazz pi<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
