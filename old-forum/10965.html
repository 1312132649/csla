<html><header><title>Improvements for private backing fields</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Improvements for private backing fields</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10965.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal posted on Wednesday, December 07, 2011</h2><p>I created the attached class as a proof of concept. It&#39;s use is more specific for private fields but could be used for custom properties (or calculated properties as well).<br /><br />For my tests I just edited one of the overloads for RegisterProperty like so:<br /><br />&nbsp;&nbsp;&nbsp; protected static PropertyInfo&lt;P&gt; RegisterProperty&lt;P&gt;(Expression&lt;Func&lt;T, P&gt;&gt; propertyLambdaExpression, RelationshipTypes relationship)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return RegisterProperty(new ExtendedPropertyInfo&lt;T, P&gt;(propertyLambdaExpression, relationship));<br />&nbsp;&nbsp;&nbsp; }<br /><br />I then added this to ReadProperty&lt;P&gt;:<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((propertyInfo.RelationshipType &amp; RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var extPI = propertyInfo as Csla.IExtendedPropertInfo&lt;P&gt;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extPI != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return extPI.GetProperty(this);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />And similar for LoadProperty&lt;P&gt;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (((propertyInfo.RelationshipType &amp; RelationshipTypes.PrivateField) == RelationshipTypes.PrivateField))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var extPI = propertyInfo as Csla.IExtendedPropertInfo&lt;P&gt;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (extPI != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (BypassPropertyChecks)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extPI.SetProperty(this,newValue);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />The benefits are obvious, being able to interact with these property types through ReadProperty and WriteProperty without the big performance penalties of reflection is very good.<br /><br />Currently the generic versions of Read/Load Property don&#39;t even support interaction with properties that have private backing fields. The non generic versions do, but they use reflection and their performance is really slow.<br /><br />Most of the time, the properties are being registered using the lambda variant of RegisterProperty, so in this scenario, we could easily load this &quot;extended&quot; version of property info and benefit from the performance improvements. Even if the lambda variant wasn&#39;t used, the same behaviour could be achieved as well, with a little more effort. Of course I&#39;d be glad to extend this even further, but I just wanted to throw this proof of concept out there first and see what other people think.</p>
<p>&nbsp;</p>
<p>Cheers,</p>
<p>Andr&eacute;s</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, December 08, 2011</h2><p>Hi Andres, </p>
<p>I&#39;d rather remove the need for private backing fields than add ExtendedPropertyInfo to CSLA. Just my personal opinion.</p>
<p>In an ideal situation&nbsp;we would only ever use managed properties in CSLA that would automatically be serialized with MobileFormatter/CslaFormatter. </p>
<p>For now -&nbsp; we need private backing fields to support [NotUndoable] and [NonSerialized] and developers must add&nbsp;extra code in OnSerialize/OnDeserialize for private fields&nbsp;when using MobileFormatter (or the CslaFormatter in next version). </p>
<p>See: <a href="http://www.lhotka.net/cslabugs/edit_bug.aspx?id=30">http://www.lhotka.net/cslabugs/edit_bug.aspx?id=30</a>&nbsp; </p>
<p>The RegisterProperty methods that do not take a PropertyInfo parameter should always use the PropertyInfoFactory approach. This is an extension point for developers and is used f.ex in CustomFieldData (<a href="http://jasonbock.net/jb/Default.aspx?blog=entry.9cc70d85bef34e2b9a683ba82615f8a3">http://jasonbock.net/jb/Default.aspx?blog=entry.9cc70d85bef34e2b9a683ba82615f8a3</a>) </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>xal replied on Thursday, December 08, 2011</h2><p>Hi Jonny,</p>
<p>Yes, I realize that you&#39;re supposed to use PropertyInfoFactory, as I said, this was done just for testing purposes. </p>
<p>The extended class is a proof of concept, this functionality could be implemented directly in the current propertyinfo object without needing the extra extendedpropertyinfo object.</p>
<p>It doesn&#39;t apply only to private fields. Calculated properties would benefit from this as well. It amazes me that they were never factored in. I&#39;ll create a sample project to demonstrate why calculated properties are needed and extremely important, but that&#39;s for another topic.</p>
<p>&nbsp;</p>
<p>Andres</p>
<p>&nbsp;</p>
<p>PS: the original version of the setter did not work in windows phone. This version does:</p>
<p><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ExtendedPropertyInfo(Expression&lt;Func&lt;C, T&gt;&gt; prop, RelationshipTypes relationship)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : this(Csla.Reflection.Reflect&lt;C&gt;.GetProperty(prop), relationship)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getter = prop.Compile();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_propertyInfo.CanWrite)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var mi = _propertyInfo.GetSetMethod();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var obj = Expression.Parameter(typeof(C), &quot;o&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var param = Expression.Parameter(typeof(T), &quot;value&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var call = Expression.Call(obj, mi, param);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var set = Expression.Lambda&lt;Action&lt;C, T&gt;&gt;(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; obj, param);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setter = set.Compile();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, December 08, 2011</h2><p>In 4.5 I am considering abandoning Microsoft&#39;s serializers completely. If Sergey&#39;s new serialization enhancements in 4.3 work out as well as we hope, our serializer will be more efficient, and we have direct control over it.</p>
<p>That&#39;ll make it practical to implement &quot;non-serialized&quot; as a concept for managed backing fields with no overhead.</p>
<p>The problem with doing it currently, is that (to support the binaryformatter) we&#39;d need to maintain two separate lists of field data - one serialized, the other not - in memory for each business object. Certainly something we could do, but also something that incurs overhead.</p>
<p>If we directly control serialization, we can make this work without multiple lists in memory and that&#39;s better.</p>
<p>A lot depends on just how well the new serialization features work out in practice. Look for an alpha of 4.3 very soon so we can get some feedback on the changes.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
