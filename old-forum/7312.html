<html><header><title>CSLA and Workflow</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA and Workflow</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7312.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>pondosinat posted on Tuesday, July 21, 2009</h2><P>I want to say that after following the workflow guidance laid out in ch. 3 of the CSLA 3.0 e-book, I couldn't be happier with CSLA's workflow integration and Rocky's recommendations on using it with CSLA. I did come across a "gotcha" that I'm struggling with: when calling a WF from within the DataPortal_Update of&nbsp;my BOs, I have been getting a lot of SQL timeouts, caused by deadlocking of certain tables.</P>
<P>It turns out that because the&nbsp;CSLA update method wraps both the BO update and WF activity in the same transaction, it's very easy to&nbsp;have any Select statements in your WF workflow get blocked and, subsequently,&nbsp;timeout.&nbsp;I'm assuming that the reason is the WF project and my ASP.NET project are&nbsp;opening two different connections to the db, so SQL thinks I'm two different users and&nbsp;decides to block me. It took quite a bit of troubleshooting (and adding a lot of (NOLOCK) hints, which did no good)&nbsp;to arrive&nbsp;at this conclusion. </P>
<P>The solution is to&nbsp;wrap any update calls in your BO with a manual transaction, and THEN call your workflow. Unfortunately, I lose the ability to roll back my entire transaction. How to work around this? I suppose I could get around this by passing my connection object to the workflow? </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 21, 2009</h2><P>I don't think you can do this.</P>
<P>WF is designed to isolate the workflow from the caller, and to that end I think they prevent you from passing object references into or out of the workflow.</P>
<P>If you pass an object into a workflow through the arguments dictionary, WF will serialize the object and the workflow actually gets a clone of the original object. ADO.NET connection objects aren't serializable, so the serialization would fail.</P>
<P>A couple of my colleagues at Magenic mentioned, just a few days ago, that they thought .NET 3.5 SP1 with SQL Server 2008 had addressed the TransactionScope issue, so a connection reclaimed through connection pooling wouldn't trigger the DTC. I haven't had time to try and confirm this yet, but it might help?</P>
<P>Otherwise I don't know of any answer that would avoid the DTC and still get you complete transactional protection over the entire operation.</P>
<P>If you can do two transactions - one for your object, another for the workflow, that's easy, because you can create your own TransactionScope objects instead of using the CSLA Transactional attribute.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pondosinat replied on Tuesday, July 21, 2009</h2><P>Very interesting - I am in fact using .NET 3.5 SP1 and SQL Server 2008 SP1 but the DTC behavior you mentioned is not there as far as I can tell.</P>
<P>Using two transactions will have to be good enough then. That's not a big deal for me, though it's good to know that doing single transaction may be a possibility in the future.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
