<html><header><title>Is CSLA the right tool for a web-only environment?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Is CSLA the right tool for a web-only environment?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10492.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks posted on Tuesday, July 05, 2011</h2><p>I&#39;m a big proponent of CSLA and have used it a lot. However, I&#39;ve just moved company and I&#39;m asking myself whether it is the right tool for the job here.</p>
<p>In my old place the ability to build a business layer and then make use of it with multiple UIs was something I used a lot. I am still a firm believer in a Windows app because you can deliver really usable stuff really fast in that environment. I&#39;ve been told that at the new place everything must be delivered on the web.</p>
<p>Personally I think there is still a small case for using a WinForms or WPF UI for a subset of the functionality, but that&#39;s a debate for another day. For now, let&#39;s assume that we are web only.</p>
<p>In a web-only world, some of the stuff that CSLA offers is either not helpful, or less than ideal. Whoa! Bear with me here.</p>
<p>Here are (most of) the things that make CSLA beneficial (in general) in no particular order:</p>
<p>1. Teaches and encourages encapsulation and scope best practices (maximum encapsulation, minimum scope)<br />2. Data portal allows flexibility at time of deployment with only moderate architectural compromise<br />3. Rich validation engine for rich UIs<br />4. Strong data binding infrastructure<br />5. Authorisation supported/encouraged in business layer (more flexible/beneficial in CSLA 4.0?)<br />6. State tracking available with minimal code impact<br />7. N-level undo</p>
<p>In a web environment (WebForms or MVC - can&#39;t force use of browser plug-ins for our users, sadly), a number of these are much less useful. </p>
<p>1 is always good. No arguments there, but don&#39;t need CSLA to do this per-se.</p>
<p>2 remains useful, but does result in a compromise in the architecture.</p>
<p>1 and 2 make testing more difficult than it might be. In particular the use of shared methods doesn&#39;t sit well with abstracting to interfaces (because you can&#39;t abstract shared methods) and loose coupling. Testing is an area I very much struggle with; I want encapsulation of data access (so I don&#39;t like the factory data access methods stuff) but at the same time I want to be able to disconnect from the database for testing. </p>
<p>Having said that, the data access is for me the bit that is most likely to be wrong - I still prefer stored procs and changing the data layer and forgetting to change (or incorrectly changing) the data access in the objects is the most common mistake I make. Testing is probably easy enough with TypeMock, but it&#39;s expensive these days for a reasonable size team.</p>
<p>3 is much less useful on the web. Validation execution at the time of property update is less appropriate on the web because a page postback is effectively a batch operation. Therefore a one-time &quot;validate all&quot; approach might be better. At least some validation has to happen on the client and CSLA doesn&#39;t make reuse of validation rules easy. Use of Data Annotations or Enterprise Library Validation Application Block make this slightly easier as they support the idea of exposing rules externally; see <a href="http://www.codeproject.com/KB/validation/DataAnnotations.aspx">http://www.codeproject.com/KB/validation/DataAnnotations.aspx</a> for an example (not sure I recommend this, but anyway ...)</p>
<p>4 remains useful in WebForms, but less than other UIs. I personally don&#39;t make as much use of this as I would like in WebForms because I want to encode all output and sanitize all input and they are jobs for a layer above the business layer, in my opinion. No use at all in MVC - data binding is out of the window there as far as I can see.</p>
<p>5 is OK but it&#39;s not complex in old versions of CSLA, which isn&#39;t really doing much in and of itself in this respect. I know that authorisation has changed in 4.0 and that may make it more beneficial.</p>
<p>6 already exists in another framework that the new place uses (which is their own framework built from CSLA teachings methinks!)</p>
<p>7 is pretty much useless. No harm in it being there, but no help because of the way that people expect the UI to work on the web.</p>
<p>As you can see, I think the case for CSLA is somewhat weakened in a web-only environment. Don&#39;t get me wrong, there&#39;s not much here that STOPS you using CSLA. However, making use of a framework does have a price (such as keeping up with breaking changes, to name but one example) and you have to continually question what is the best thing to do to make sure you are doing the best you can in any situation.</p>
<p>What are other people&#39;s experiences in this respect? Do people continue to use CSLA despite these shortcomings (in the UI technologies?) How/where do people deal with encoding output and sanitizing input?</p>
<p>Cheers.</p>
<p>Andrew</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
