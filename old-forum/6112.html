<html><header><title>Dependent property question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Dependent property question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6112.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 posted on Friday, January 09, 2009</h2>I have questions regarding some dependant property rules for a data entry form where a person gets a form that's incompletely filled in and I'm requested to provide some way to get a best guess input for them based on the input.<br /><br />Using CSLS 3.0.4 I have three fields: Start, End and Duration which are of types DateTime, DateTime and TimeSpan respectively. The requirements I gleaned are:<br /><br />* If the user fills in Duration, the object can be saved.<br />* If the start and end are filled in, I can compute the duration and the object can be saved.<br />* If they've given me a start and duration, I can compute the end or vice versa, and the object can be saved.<br />* In any situation where the Duration is not available, it should be invalid and not saveable.<br /><br />How do I structure the rules to construct a valid object? Do I require Duration and be an error and the other two are warnings only using the property changed to compute the value?<br /><br />Is this something the BO layer should do or the UI (before save)?<br /><br />Thanks for any advice,<br />_E</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, January 09, 2009</h2><P>I've run into the same scenario in the past and I used nullable variables in the background to track which&nbsp;properties actually had manually entered values and which were derived (per my use case) and always returned a default value so there was never an issue with missing values.&nbsp; For example, my StartDate property appeared as:</P>
<P><CODE>public System.DateTime StartDate<BR>{<BR>&nbsp;&nbsp;&nbsp; get<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_startDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _startDate.Value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (_endDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _endDate.Value.Subtract(Duration);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return System.DateTime.Today; // Or something else<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; set<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _startDate = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _startDate = new System.Nullable&lt;System.DateTime&gt;(value);<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_endDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _duration = null; // forces duration to be derived<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>} </CODE></P>
<P>EndDate would be similar:</P>
<P><CODE>public System.DateTime EndDate<BR>{<BR>&nbsp;&nbsp;&nbsp; get<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_endDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _endDate.Value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return StartDate.Add(Duration);<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; set<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endDate = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endDate = new System.Nullable&lt;System.DateTime&gt;(value);<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_startDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _duration = null; // forces duration to be derived<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>} </CODE></P>
<P>And Duration&nbsp;would be:</P>
<P><CODE>public System.TimeSpan Duration<BR>{<BR>&nbsp;&nbsp;&nbsp; get<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_duration.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _duration.Value;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (_startDate.HasValue) &amp;&amp; (_endDate.HasValue)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _endDate.Value.Subtract(_startDate.Value);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return System.TimeSpan.Zero;<BR>&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; set<BR>&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (value == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _duration = null;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _duration = new System.Nullable&lt;System.TimeSpan&gt;(value);<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((_startDate.HasValue) &amp;&amp; (_endDate.HasValue))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _endDate = null; // forces&nbsp;endDate to be derived<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<BR>&nbsp;&nbsp;&nbsp; }<BR>} </CODE></P>
<P>This eliminated my need to do any validation except to make sure that the dates were within valid ranges and that the EndDate was always the same or later than the StartDate (and example of which is shown in the book and sample app).</P>
<P>Hope that helps.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, January 09, 2009</h2><P>You could also do the above with validation rules (including the computation of any two of the fields from the other two). Sometimes you don't have the luxury of tinkering inside the property setter (e.g. code is generated). </P>
<P>The trick in doing this is to avoid getting into some weird infinite loop since the 3 values are interdependent, and to handle the case where no property was changed but someone calls CheckRules() explicitly.&nbsp;Also, you might just have 3 discrete rules and not use the dependencies. </P>
<P>Also, rules don't have to be warnings -- you can have a rule that just does a transformation and always succeeds. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 replied on Friday, January 09, 2009</h2>Thank you, gentlemen. That gives me a great start. I'm porting some .NET 1.1 code and forget about nullable fields out of habit.<br /><br />I also think that the start and end field should always have an entry so the production down time can be analyzed with trends to see if production mysteriously ceases at the same time more than it should... say 10 min before end of shift.<br /><br />Now to do it...<br /><br />_E</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
