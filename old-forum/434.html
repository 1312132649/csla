<html><header><title>Class Design Question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Class Design Question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/434.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>dstarkey posted on Wednesday, June 21, 2006</h2><P>Like to pose this question to the public.&nbsp; Say you have a class (employee) that has hundreds of fields (properties).&nbsp; Most of these properties are rarely used or updated but are still necessary.&nbsp; Is it better to</P>
<P>&nbsp;1) Create&nbsp;two distinct employee classes.&nbsp;&nbsp;BaseEmployee, and&nbsp;Employee&nbsp;with the larger (BaseEmployee) inheriting the&nbsp;&nbsp;dynamic fields from the baseEmployee class.</P>
<P>2) Seperate the large entity into an Employee class that contains a lazy load collection of atypical properties.&nbsp; And load these when demanded??</P>
<P>Or any other solutions to this question???</P>
<P>Will definitely need access to all employee properties at time of insertion.</P>
<P>Thanks</P>
<P>Don</P>
<P>Thoughts are very much appreciated!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Wednesday, June 21, 2006</h2><P>Option #1 has been discussed here before as it seems to be the OO approach to the problem.&nbsp; Although I think composition would be more appropriate than inheritance.&nbsp; The main problem there seems to be working out the data access plumbing given that one of the classes would be loadable both independently and as part of the other class.</P>
<P>A third option would be to make the business object infrasture more robust/complex such that a particular BO would have "modes" that would control what data was loaded and&nbsp;which fields were not only loaded but also valid to get/set.&nbsp; In&nbsp;my consideration the appeal of having only one class containing all the code is buried beneath a) the violation of the "one responsibility" principle and b) the difficulty in using the class since there wouldn't be any good way of discerning which public properties were valid for the mode you planned to load.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Wednesday, June 21, 2006</h2>

<p class="MsoNormal">Whenever a class has hundreds of fields, it usually means it
is taking on too much responsibility.<span>&nbsp; </span>You
might want to think about breaking up that huge class into smaller classes if
it makes sense to do so.<span>&nbsp; </span>I personally can’t
imagine why an employee class would have hundreds of fields.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 replied on Wednesday, June 21, 2006</h2><P>I had such a problem in a project:&nbsp;the users needed to allow multiple means of processing a manufactured&nbsp;component. They needed a boolean field for each option (about 120 possibilities) and none of them could be disabled, just ordered into a sequence.</P>
<P>I ended up using bit wise processing on a muliti-bit field. It worked, but the public property code is just monstrous. Not a design issue either... at least this time. ;-]</P>
<P>_E</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>burmajam replied on Thursday, June 22, 2006</h2>Hi<br><br>This is the way I read the situation. Situation with need for lots of properties is Employee records. Employee has a bunch of properties. I wouldn't say it is too much resposibilities. It is just need for a lot of information about someone. What I did in this situation is composition. Break Employee apart in few classes grouped somehow (maybe the best grouping decision is which properties will be displayed in each tab if you use tabbed panel). So, you could fetch only basic information for the first fetch and then if you need more details you should fetch all composite classes. I hope that this opinion will be of some help.<br><br>Bu®majaM<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, June 22, 2006</h2>Well, I think the question to be asked is, does the use case actually have the user modifying most of those properties all at the same time.&nbsp; In all likely hood, you'd think that for any given operation, the user would only be modifying a subset of those properties...&nbsp; but maybe there is a real business need where all of them need to be modified at once.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DansDreams replied on Thursday, June 22, 2006</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Well, I think the question to be asked is, does the use case actually have the user modifying most of those properties all at the same time.&nbsp; In all likely hood, you'd think that for any given operation, the user would only be modifying a subset of those properties...&nbsp; but maybe there is a real business need where all of them need to be modified at once.<BR></div></BLOCKQUOTE></P>
<P>&nbsp;</P>
<P>That's true, but you're still left with the question of how to&nbsp;code the answer into classes.&nbsp; I think having 20 different Employee objects becomes a nightmare in itself both in using them and in the property creep that would undoubtedly happen between them.</P>
<P>I think it's useful to think of having a couple of (or maybe one) facade Employee classes that includes all of those details&nbsp;via composition.&nbsp; One aspect of that is to consider using some lazy loading on those aggregated objects such that the facade object only gets as "heavy" as necessary.</P>
<P>It would be interesting to develop a Patterns &amp; Practices document for solving these kinds of problems with CSLA wouldn't it?&nbsp; Part of the value of CSLA in selling it to executives is Rocky's stature (not physically, although he is a tall one) and this community.&nbsp; Having recommended standard guidelines for its use would increase that argument exponentially says me.&nbsp; :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, June 22, 2006</h2>

<p class="MsoNormal">I will assume that your employee class needs hundreds of
properties.<span>&nbsp; </span>If you are concerned about retrieving
all of that data then you will need to lazy load the properties that are not
used often.<span>&nbsp; </span>I am not sure if a façade is
appropriate if you have one large employee class.<span>&nbsp; </span>A façade is used to make a subsystem easier
to use.<span>&nbsp; </span>If you only have one large
employee class, it would not make sense to create a façade.<span>&nbsp; </span>However, if you decided to break your
employee class into many classes, you could use a façade to make the subsystem easier.
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DancesWithBamboo replied on Thursday, June 22, 2006</h2>So this really doesn't answer the question, but I have a couple of points to be considered.<br><br>I think you need to look at the data type of the properties in question.&nbsp; If the majority of fields are booleans or integers and such then I would think the round tripping costs of lazy-loading would decrease performance and increase complexity.&nbsp; In this case the subsequent requests for more data(including queries) would be much larger than all the data itself.&nbsp; Now if each of those 100 fields are 500 character strings then sure, you need to break it up.&nbsp; But I have found that on large objects most of the fields are foreign keys or boolean answers; not very large to store and transport.<br><br>Also, if this is an intranet application with just a few(whatever that is) users, data size won't be an issue anyway.&nbsp; The users' experience would be better if it was just all loaded up at the get go.&nbsp; And the development will be cheaper.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
