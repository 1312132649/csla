<html><header><title>When working with two data stores what's the recommended save operation?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>When working with two data stores what's the recommended save operation?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2381.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>boo posted on Monday, February 19, 2007</h2><P>I don't want to get into the awful design we inherited but what we'd like to do and what we can do are apples and oranges...so here's what we have:</P>
<P>We are implementing BO's and the BO needs to save both to SQL Server and another data store.&nbsp; Sometimes it will only save to SQL Server, sometimes it will save to both, it will never save just to the other data store.&nbsp; This is simple enough to accomplish by overloading the Save method.</P>
<P>Now we have a set of methods to save to the other data store in seperate library, but what we send needs to know what the original BO's values were in order to know what to update.&nbsp; In otherwords if nothing has changed, we don't want to update the secondary data store...and I won't get into why (bad design that we cannot alter), but we NEED to know whether the BO or it's children have changed prior to updating the second data store, if it hasn't we can't send to second data store.</P>
<P>Question that we're struggling with...do we make the BO smart enough to convert itself into the value objects that the the external set of methods used to update the&nbsp;second data store&nbsp;use and when completing a DataPortal update or create call the required methods in the external library or do we use a third library to control what gets called and how (ala Mediator pattern).&nbsp; We like the idea of using the pattern because know the BO's don't have to know about how data is saved to a secondary data store, but it introduces a whole new set of problems (in particular circular references and now history of object is lost or the mediator becomes knowledgable of how external manager works which takes the purpose of the pattern away).&nbsp; </P>
<P>There is also a part of me that strongly says...well if the BO's is suppose to be self containing why wouldn't it know how to convert itself and save to this secondary data store?&nbsp; I'm leaning heavily towards this...but some other people's advice - in particular anyone who has dealt specifically with this...would be much appreciated.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Monday, February 19, 2007</h2>The Dataportal_Update method doesn't actually get called if there are no changes to the data.&nbsp; The BO keeps track of whether it is "dirty" or not.&nbsp; I would just add a more database code to your dataportal methods to save the updates&nbsp; in the second database rather than trying to overload methods.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, February 19, 2007</h2>Hey boo,<br><br>First, I don't think you need to overload the Save.&nbsp; Using the standard DP_I or DP_U should be just fine.<br><br>Your last paragraph is correct; the BO should know that it needs to update this second datastore.&nbsp; How it does so can be encapsulated into another class... but ultimately the BO should decide whether or not to update this second datasource.<br><br>Out of curiosity, will you be using DTC to coordinate the transaction between both datasources?&nbsp; Seems like a good idea to do so... but I'm not sure if the second datastore needs to know about DTC to use it (or does DTC magically know how to 'rollback' changes to whatever you're updating?).<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>boo replied on Monday, February 19, 2007</h2><p>Thanks Andy...I misread your reply.&nbsp; The reason I need to overload save is in below post.<br></p>
<p>DTC is not an option...again, one of those inherited nightmares.&nbsp; I'll pass on your thoughts.&nbsp; I'm actually hoping Rocky will answer too with the same results.&nbsp; I'm in agreeance with you, but I might need his 'blessing' to seal the design.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>boo replied on Monday, February 19, 2007</h2>The reason why I need to overload Save is that during the workflow, which may be from hours to days, to weeks, the user will just be saving to SQL DB.&nbsp; At the end of the workflow they will need to take all this information and save it to the secondary data store.&nbsp; So the default Save will just save to SQL DB as normal...at the end of the workflow, and few select places during, the information will be saved to the secondary data store which may add/change information meaning I'll have to save that new/updated information to SQL DB afterwards.&nbsp; In these cases an overload of Save would be called which would then let the business object know to save to the extra location along with SQL DB.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, February 20, 2007</h2>Boo,<br><br>An overload of Save isn't the way to go for what you're trying to acomplish.&nbsp; If you go that route, you'll have the UI deciding on a business rule (when does the secondary datasource need to be updated) when really your business object is what must make the decision.&nbsp; If you were to reuse this business object in another UI, a web site or webservice or a Windows service, you'd have to duplicate that logic that decides which overload of Save to call.&nbsp; Its that duplication which is actually a business rule.<br><br>It may be that you need another seperate object who's purpose is to determine if the workflow is completed and take the necessary steps updating the second datasource and such.&nbsp; If not, any decision you make in Save could be made in the DP_U method, and that's where it should be.&nbsp; Remember, you need to keep&nbsp; your data access code in the DataPortal_ methods.&nbsp; Review the book for reasons why.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>boo replied on Tuesday, February 20, 2007</h2>You hit the nail on the head, and in an ideal world where we didn't inherit a monstrosity of an application that is so tightly coupled to the GUI and so many other things that are done wrong that need to be addressed that is what we would do...and that is what we are working towards.<br><br>However it's simply not a refactoring exercise that we have the time nor the budget for, so for the time being the GUI has to know more than it should...and thus the overloaded Save method.&nbsp; Believe me, it's not the ideal solution to the problem, it's a hack really until we have the time and budget to do what needs to be done.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Monday, February 19, 2007</h2>We're not dealing with multiple data stores, but we had a need to avoid saving existing objects unless a database field actually changed. The typical technique of calling MarkDirty did not work for us because changing a value from A to B, then back to A would be considered dirty, and we couldn't have that. Perhaps our solution will be helpful to you.<br><br>If you haven't already, create a "custom" business object base that will be the base object for all your business classes. Rocky recommends it, and I would strongly second that option.<br><br>We created "smart" data objects for each primary data type that we deal with, plus a few special case types (e.g. a 0-filled number/string hybrid). Each type tracks original and current values. These smart data types inherit from our base business object, so they inherit a lot of important functionality. There is no DataPortal code in these objects because their purpose is not to be saved to a database.<br><br>Our user-facing business objects maintain the "smart" data objects internally, but expose the business object properties as the primitive data types. This simplifies data binding. The DataPortal_Fetch methods instantiate a smart data object for each field that is being maintained. <br><br>Here is a typical property for us on an editable business object.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Public Property PurchaseUOM() As String<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanReadProperty(True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return mPurchaseUOM.Value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set(ByVal value As String)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CanWriteProperty(True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If value &lt;&gt; mPurchaseUOM.Value Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mPurchaseUOM.Value = value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PropertyHasChanged("PurchaseUOM")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Property<br><br>mPurchaseUOM is a "SmartString" in this example that is declared at the object level.<br><br>Each of our business objects has to override the IsDirty function. Here's an example IsDirty function from one of our business objects:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Public Overrides ReadOnly Property IsDirty() As Boolean<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return MyBase.IsDirty OrElse mVPC.IsDirty OrElse mPurchaseUOM.IsDirty _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrElse mPurchaseList.IsDirty OrElse mReplacementCostStartValue.IsDirty _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrElse mReplacementCostDiscountMethod.IsDirty OrElse mReplacementCostDiscountValue.IsDirty _<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OrElse mVendorItem.IsDirty<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Property<br><br>The SmartString's IsDirty method is simply "Return mValueOriginal &lt;&gt; mValueCurrent".<br><br>This allows us to detect when an object is "really" dirty. As an additional benefit for us, we use dynamically generated SQL in our business objects to update the database. To avoid updating columns that didn't change, we are able to check the smart data object's IsDirty method and use the original and current values in constructing our dynamic SQL.<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
