<html><header><title>Getting OO, CSLA, MVC, Automation and WPF playing nicely together</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Getting OO, CSLA, MVC, Automation and WPF playing nicely together</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4100.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Saturday, December 29, 2007</h2><P>While not directly applicable to CSLA, because that part is actually the easiest to put together, I am trusting that the knowledge and experience of this forum's contributors will prove once again that this is the best place for me to post my issues/questions.&nbsp; I'll use a specific example to highlight my questions.&nbsp; But first, a little background...</P>
<P>I have been tasked with developing an application that will be deployed on multiple front-ends using either Windows Forms, WPF or ASP.NET.&nbsp; To ensure code-reuse and common behavior, we are trying to implement a multi-tier architecture following&nbsp;the MVC design pattern.&nbsp; In addition, to support extensibility, scripting, etc., we are looking at creating an Automation-style API.&nbsp; The Model is completely comprised of CSLA business objects and, as I said, is the most straigh-forward part of putting this all together.</P>
<P>That said, let's take a quick look at how I've thought about implementing&nbsp;the (simple) File-&gt;Close operation to discuss my issues/questions.</P>
<P>I've defined a CloseCommandItem class in my object model that the presentation layer (WinForm, WPF, ASP.NET, etc) binds to when rendering the command in the UI.&nbsp; This class, which derives from a CommandItem base class, exposes properties such as Caption and&nbsp;Enabled and a Click method that carries out the operation.&nbsp; A few notes about the class:</P>
<UL>
<LI>The Click method calls Application.Documents.Close which is part of the Automation API.&nbsp; This abstracts the exact behavior of the command item from the UI so that the same control can be used for all menu/toolbar items with no regard for what it represents or does.&nbsp; We are using, for instance, the Infragistics WebMenu for the ASP.NET presentation control.&nbsp; All it needs to know is to call the Click method on the CommandItem&nbsp;the selected menu item&nbsp;represents.<BR></LI>
<LI>The Caption property uses a resource file to localize/globalize the&nbsp;text that appears for the item.&nbsp; Here again, the rigors of globalization have been externalized from the presentation layer so that a single translation will be reflected in all client applications.&nbsp; One benefit is that a change to a menu item caption can be made in one place and take affect in all applications!<BR></LI>
<LI>The Enabled property is bound to the Application.Documents.Count property so that it will return true whenever Count &gt; 0 and false when Count = 0.&nbsp; Therefore, the Enabled property automatically updates itself based on the state of the application again taking the responsibility out of the UI.<BR></LI>
<LI>The class also exposes CaptionChanged and EnabledChanged events which are handled by the presentation layer to update the UI with the appropriate changes.&nbsp; For example, the enabled/disabled state of the control can be reset to match the new state of the CloseCommandItem.</LI></UL>
<P>As I've explained some of the benefits above, I am concerned that I am making a mountain out of a molehill and creating a ton of extra code, etc. by creating a separate class for each menu/toolbar item in this manner.&nbsp; However, it seems to me that this is good OOP given the business logic associated with each item's state management and behavior.</P>
<P>Furthermore, should I just raise a simple PropertyChanged event from the class or go with the individual events?&nbsp; I am not fluent in WinForms nor WPF data-binding but it seems to me that we should be able to bind the UI controls to the CloseCommandItem and specify that the Enabled property of the control is bound to the Enabled property of the command item.&nbsp;&nbsp;Am I correct that data-binding would handle refreshing the property if we raised a PropertyChanged event but won't know how to do so if we go with the EnabledChanged event instead.</P>
<P>Next, under the MVC pattern, I am a bit unclear who should be in charge of "building" the menus and toolbars.&nbsp; If we have all of these built-in command items, something needs to be responsible for assembling them into the Application.CommandBars collection that the presentation layer then binds to.&nbsp; Examples I've seen typically show the UI deciding which menu items to show and have then hard-coded through the form's designer.&nbsp; This seems to be contrary to what we are trying to do.&nbsp; My initial thought is to have another&nbsp;class that represents the File menu, instantiates all of the "built-in" child items and adds them to its ChildItems collection.&nbsp; In the same regards, any cascading item would be responsible for creating its child items.&nbsp; Then my CommandBars collection would simply know to create the top-level command items (File, Edit, View, etc.) and add them to itself.&nbsp; Make sense?</P>
<P>How does this work with or conflict with the new ICommand architecture in WPF (RoutedCommand, RoutedUICommand, etc.)?&nbsp; Obviously I want a solution that works across multiple front-end technologies so depending on WPF is not practical but I also don't want to reinvent the wheel nor eliminate capabilities provided by the framework.</P>
<P>Any other flaws in this approach?&nbsp; Anything I'm not thinking of or missing?&nbsp; I have much work ahead of me and don't want to wander too far down the wrong path, so your input is appreciated.</P>
<P>Thanks in advance.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>HappyJack replied on Wednesday, January 02, 2008</h2><P>I started to create an Automation API around my CLSA classes just for a winform application.&nbsp; So I'm not sure if this would work in a WPF application.&nbsp; I basically went the route of using the property notify change event instead of creating specific events and I'm starting to wish that I had specific events mainly for readibility.&nbsp; I also created a bunch of individual classes to represent menus and menu items that are independant of the infragistics menu control that I use.&nbsp; It is a lot of extra work but it does make coding the actual UI a little easier because all you have to do is respond to events to update the UI or use the automation api to change the application.&nbsp; I have a command window in my application that I can write .Net code snipptes that are dynamically compiled and the UI responds just as if the user did it.&nbsp; </P>
<P>As for the menus, I&nbsp;have an usercontrol which is a wrapper around the infragistics menu control that listens for events from the menu collections and menu item property change events.&nbsp; This user control is responsible for updating the UI either by adding or removing menu items or changing the enabled or visible property of individual menu items.&nbsp; Since the usercontrol is listening for menus getting added, I let each module add what ever menus each module needs.&nbsp; </P>
<P>I'm really intersted in the automation api style of creating applications and hopefully we can continue to bounce ideas around about this.</P>
<P>Happy Jack</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
