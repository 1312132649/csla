<html><header><title>Interface WithEvents of a BusinessBase throws serialization exception on Clone</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Interface WithEvents of a BusinessBase throws serialization exception on Clone</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9369.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>GPhillips posted on Thursday, August 12, 2010</h2><p>I have a problem with is now occuring since I rewrote my CSLA objects to use Lambda expresions and the &quot;(Of ...) syntax and had to add an Interface.&nbsp; My Object structure looks like this:</p>
<p>Class Entity(Of E As Entity(Of E))<br />&nbsp;&nbsp;&nbsp; Inherits BusinessBase(Of E)<br />&nbsp;&nbsp;&nbsp; Implements IEntity<br />&nbsp;&nbsp;&nbsp; Shadows Event PropertyChanged(ByVal sender As Object, ByVal e As System.ComponentModel.PropertyChangedEventArgs) Implements IEntity.PropertyChanged</p>
<p>&nbsp;&nbsp;&nbsp; Private Sub Entity2008_PropertyChanged(ByVal sender As Object, ByVal e As System.ComponentModel.PropertyChangedEventArgs) Handles MyBase.PropertyChanged<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent PropertyChanged(sender, e)<br /><br />&nbsp;&nbsp;&nbsp; End Sub<br /></p>
<p>Class CustomerBase<br />&nbsp;&nbsp;&nbsp; Inherits Entity(Of CustomerBase)</p>
<p>Class Customer<br />&nbsp;&nbsp;&nbsp; Inherits CustomerBase</p>
<p>The IEntity Interface is intended to operate on any object deriving from Entity in a generic fashion whithout having to know the type of object.&nbsp; My intent is to allow access to various functions provided by CSLA as well. It looks like this:</p>
<p>Interface IEntity<br />&nbsp;&nbsp;&nbsp; Property Name() As String<br />&nbsp;&nbsp;&nbsp; ...<br />&nbsp;&nbsp;&nbsp; ReadOnly Property IsDirty() as Boolean</p>
<p>&nbsp;&nbsp;&nbsp; Function Clone() as IEntity<br />&nbsp;&nbsp;&nbsp; Function Save() as IEntity<br />&nbsp;&nbsp;&nbsp; Event PropertyChanged(sender as object, e as System.ComponentModel.PropertyChangedEventArgs)<br />End Interface</p>
<p>Code in the Entity Class to Support this looks Like this:</p>
<p>&nbsp;&nbsp;&nbsp; Public Shadows Function Save() As IEntity Implements IEntity.Save<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return CType(MyBase.Save(), IEntity)<br /><br />&nbsp;&nbsp;&nbsp; End Function</p>
<p>&nbsp;&nbsp;&nbsp; Public Shadows Function Clone() As IEntity2008 Implements IEntity2008.Clone<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return CType(MyBase.Clone(), IEntity2008)<br /><br />&nbsp;&nbsp;&nbsp; End Function</p>
<p>So here&#39;s the problem: If I use a form to test this and have a Dim ob as Customer and retrieve, change and Save, everything works fine.&nbsp; If I do Dim ob as IEntity, everything works OK too.&nbsp; If I do Dim WithEvents of Customer or IEntity, everything works.&nbsp; BUT, if I add a PropertyChanged event handler (Private Sub PropertyChanged(sender as object, e as ...) Handles ob.PropertyChanged, to the form (and WithEvents to the Dim), the Save blows up with a Serialization Error when it tries to serialize the object.&nbsp; It says the FORM is not serializable.&nbsp; I need to get the PropertyChanged event when using IEntity.&nbsp; I walked through the CSLA code, but I cannot see why it would attempt to include the form in the BusinesObject&#39;s serialization.&nbsp; HELP!</p>
<p>It does not blow up with just the WithEvents, but blows up if the PropertyChanged event handler is defined.</p>
<p>Any help or thoughts would be greatly appreciated.</p>
<p>Gary</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, August 12, 2010</h2><p>Once you attach a method to an event handler, the object that contains the&nbsp;method becomes part of your event source&#39;s object graph.&nbsp; So once you attach a method on your form to your Customer object&#39;s PropertyChanged event (or the interface event, since they are the same thing), that adds a reference of the form to your Customer object.&nbsp; Since the event holds a reference to the form, when CSLA attempts to serialize your Customer object, it will try to&nbsp;serialize the form as well.&nbsp; And forms are not serializable.</p>
<p>Defining the object with the &quot;WithEvents&quot; keyword doesn&#39;t automatically hook the events to anything, which is why that doesn&#39;t cause the serialization exception.&nbsp; It just makes the VB.NET compiler aware that the object is capable of raising events (and allows you to hook to those events using the &quot;Handles&quot; clause.)</p>
<p>That&#39;s why, when you look through the CSLA source code, you see that the events are either marked with the NonSerialized attribute or use the alternate event-management syntax that allows you more control over event wireups.&nbsp; Since you&#39;re essentially replacing the default PropertyChanged event with your own, you&#39;ll need to implement the same scheme in your objects (including re-hooking your event handlers in the appropriate deserialize methods.)</p>
<p>Also, I might suggest that rather than re-implement PropertyChanged, you might just want to have your IEntity interface inherit from INotifyPropertyChanged.&nbsp; This is the .NET interface that defines the PropertyChanged event that enables data-binding.&nbsp;&nbsp;Doing so will make your interface a little cleaner, more intentional as to what you&#39;re trying to do, and possibly may let you leverage the existing CSLA code surrounding PropertyChanged management (which means you won&#39;t have to re-implement that code.)</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>GPhillips replied on Friday, August 13, 2010</h2><p>Thanks for your response, Scott.</p>
<p>It makes sense that the object would have to have a reference in order to call the event.&nbsp; But if I remove the event from the interface (and the supporting code from Customer), and Dim WithEvents ob as Customer, and handle the PropertyChanged event that BusinesBase provides, everything works fine.&nbsp; How can CSLA treat the event handler differently since it looks the same in the VB code?</p>
<p>What I&#39;m really trying to accomplish here is a generic ability to access common properties and events of any object that derives from Entity, without knowing what the object actually is.&nbsp; This worked fine when it was coded for CSLA 2.0 since my object model looked like BusinessBase -&gt; Entity -&gt; CustomerBase -&gt; Customer (without the &quot;(Of ...)&quot;).&nbsp; In that scenario I could do a Dim WithEvents ob as Entity and everything was happy.&nbsp; With the &quot;Of&quot; syntax, I have to specify the type (Dim WithEvents ob as Entity(Of CustomerBase))&nbsp; which defeats the whole purpose - unless there is some way to pass that in as a variable?&nbsp; I would rather not have to use the IEntity interface since that adds another level of complexity.</p>
<p>I tried to do it without the &quot;Of&quot;s:</p>
<p>Class Entity<br />&nbsp;&nbsp;&nbsp; Inherits BusinessBase(Of Entity)</p>
<p>Class CustomerBase<br />&nbsp;&nbsp;&nbsp; Inherits Entity</p>
<p>Class Customer<br />&nbsp;&nbsp;&nbsp; Inherits CustomerBase</p>
<p>but the RegisterProperty statements don&#39;t work (I kept getting Locked messages when the downstream objects tried to add their properties).</p>
<p>Is there some other way to accomplish this that I&#39;m missing?</p>
<p>Gary</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, August 13, 2010</h2><p>If you take a look at the BindableBase file in the CSLA source (and are comfortable reading C#), you&#39;ll see how Rocky gets around this problem.&nbsp; He uses an alternative event-wiring syntax that lets him write code to determine whether the object containing the method being hooked to the event is a serializable object.&nbsp; If it is, the method gets added to one event handler.&nbsp; If it isn&#39;t, the method gets added to a different event handler which is decorated with the NonSerialized attribute.&nbsp; That means that when CSLA serializes the object,&nbsp;the objects containing the methods hooked to that&nbsp;event handler don&#39;t get serialized.</p>
<p>The second part of this solution is that those non-serialized event handlers have to be re-hooked in the deserialization hook methods that are available in CSLA objects (the &quot;OnDeserialized&quot; methods).&nbsp; Since those&nbsp;event wirings&nbsp;are lost in the serialization process, CSLA&nbsp;can&#39;t handle that for you - you have to do it in your code.&nbsp; Which means you have to know when you hook a method contained in a non-serializable object, and deal with that in your business-object code.</p>
<p>In terms of your general problem, I would think that an interface (e.g. IEntity)&nbsp;that defines your common properties would be enough.&nbsp; It depends on what your &quot;common properties and events&quot; consist of, but most likely the interface doesn&#39;t have to be generic.&nbsp; You just create your interface and make sure that your business objects are marked as implementing that interface.&nbsp; The nature of interface implementation is such that normal business-object property coding can likely fulfill the needs of the interface.</p>
<p>The potential downside is that you have to implement all these common properties in every business object.&nbsp; But given what you&#39;re trying to do, plus the requirements of&nbsp;CSLA regarding the generic type (it must extend through the entire type hierarchy, otherwise you get the RegisterProperty errors you saw), that&#39;s probably a better idea anyway.&nbsp; Plus, one of the &quot;guiding principles&quot; that Rocky has espoused about object design is that inheritance is primarily for behavior reuse - and properties are <em>not</em> behavior.&nbsp; They are, for the most part, boilerplate plumbing code.</p>
<p>And as for passing the generic type in a variable, you&#39;re out of luck.&nbsp; Generics are not polymorphic - they expect a static type.&nbsp; That&#39;s usually the first disappointment people run into when they start working with generics... <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>Finally, If you need&nbsp;your interface to participate in events that CSLA objects raise, the key there is that pretty much every event that&#39;s potentially interesting in a CSLA object comes from some other interface (e.g. PropertyChanged comes from the INotifyPropertyChanged interface.)&nbsp; Some of them are .NET interfaces, while others are CSLA interfaces that Rocky created.&nbsp; Since interfaces can inherit from other interfaces, you can make your life simple by letting your IEntity interface inherit from these other interfaces containing the event(s) you need.&nbsp; Then your interface gets all those method signatures, plus the default CSLA implementations, for free.&nbsp; You might end up with more events in your IEntity interface than you really care about, but I don&#39;t consider that a big problem.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>GPhillips replied on Friday, August 13, 2010</h2><p>Scott,</p>
<p>&nbsp;</p>
<p>Thanks again for your time assisting with this.</p>
<p>As a VB programmer I&#39;m having a little trouble keeping up with this discussion, but my head is still above water.</p>
<p>First, I am intrigued by your last paragraph &quot;you can make your life simple by letting your IEntity interface inherit 
from these other interfaces containing the event(s) you need.&nbsp; Then your
 interface gets all those method signatures, plus the default CSLA 
implementations, for free&quot;.&nbsp; If I just add, for instance &quot;Inherits IUndoableObject&quot; in the Interface does that automatically hook up all the Undoable Objects Events?</p>
<p>I am trying to create an EntityChanged Event, which fires if a change is made to either the Entity itself (Customer, in this case) or a change is made to any of its children (Addresses, for example).&nbsp; Obviously if the first paragraph holds true, then I can just inherit the appropriate interfaces and check for both the PropertyChanged and Child_PropertyChanged events.&nbsp; However, I am attempting to do this as a new event within the Entity(Of T) class and the IEntity interface.</p>
<p>What I tried is as follows:</p>
<p>Add an Event to the IEntity interface:&nbsp;&nbsp; Event EntityChanged(sender as object, e as System.Eventargs)</p>
<p>Add the following code to the Entity(Of T) definition:</p>
<p>&nbsp;&nbsp;&nbsp; &lt;NonSerialized()&gt; _<br />&nbsp;&nbsp;&nbsp; Private _NonSerializableEntityChangedEventHandlers As EventHandler<br />&nbsp;&nbsp;&nbsp; Private _SerializableEntityChangedEventHandlers As EventHandler<br /><br />&nbsp;&nbsp;&nbsp; &#39; See pg 277-279 of &quot;Expert VB2008 Business Objects&quot; for a discussion of this<br />&nbsp;&nbsp;&nbsp; Public Custom Event EntityChanged As EventHandler Implements IEntity2008.EntityChanged<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler(ByVal value As EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If value.Method.IsPublic AndAlso (value.Method.DeclaringType.IsSerializable OrElse value.Method.IsStatic) Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _SerializableEntityChangedEventHandlers = DirectCast(System.Delegate.Combine(_SerializableEntityChangedEventHandlers, value), EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _NonSerializableEntityChangedEventHandlers = DirectCast(System.Delegate.Combine(_NonSerializableEntityChangedEventHandlers, value), EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End AddHandler<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveHandler(ByVal value As EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If value.Method.IsPublic AndAlso (value.Method.DeclaringType.IsSerializable OrElse value.Method.IsStatic) Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _SerializableEntityChangedEventHandlers = DirectCast(System.Delegate.Remove(_SerializableEntityChangedEventHandlers, value), EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _NonSerializableEntityChangedEventHandlers = DirectCast(System.Delegate.Remove(_NonSerializableEntityChangedEventHandlers, value), EventHandler)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End RemoveHandler<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent(ByVal sender As Object, ByVal e As System.EventArgs)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnEntityChanged()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End RaiseEvent<br />&nbsp;&nbsp;&nbsp; End Event<br /><br />&nbsp;&nbsp;&nbsp; Protected Overridable Sub OnEntityChanged()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If _NonSerializableEntityChangedEventHandlers IsNot Nothing Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _NonSerializableEntityChangedEventHandlers.Invoke(Me, New EventArgs)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If _SerializableEntityChangedEventHandlers IsNot Nothing Then<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _SerializableEntityChangedEventHandlers.Invoke(Me, New EventArgs)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br />&nbsp;&nbsp;&nbsp; End Sub</p>
<p>&nbsp;&nbsp;&nbsp; Private Sub Entity2008_ChildChanged(ByVal sender As Object, ByVal e As Csla.Core.ChildChangedEventArgs) Handles Me.ChildChanged<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent EntityChanged(sender, New EventArgs)<br /><br />&nbsp;&nbsp;&nbsp; End Sub<br /><br />&nbsp;&nbsp;&nbsp; Private Sub Entity2008_EntityChanged(ByVal sender As Object, ByVal e As System.ComponentModel.PropertyChangedEventArgs) Handles MyBase.PropertyChanged<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent EntityChanged(sender, New EventArgs)<br /><br />&nbsp;&nbsp;&nbsp; End Sub<br /><br />(I thought it would be helpful for anyone else going down this path to see the code)</p>
<p>Two things happened with this: </p>
<p>1. If the event were not in the IEntity and the Implements is removed, everything worked fine until the object was saved/cloned, then event stopped working (expected), since I have no idea how to accomplish rehooking the event after the object is deserialized and I can&#39;t find anything in Rocky&#39;s code that makes sense (to me) as an example [an assist would be helpful here]</p>
<p>2. When I added the Event definition to the interface, and the Implements to the event definition (above), I get a compiler error: Event &#39;EntityChanged&#39; cannot implement event &#39;EntityChanged&#39; on interface &#39;IEntity&#39; because their delegate types &#39;System.EventHandler&#39; and &#39;IEntity2008.EntityChangedEventHandler&#39; do not match.&nbsp; (Huh?)</p>
<p>So that is were I am, incredibly further than I would have been without your help.&nbsp; It looks like it just needs a little adjustment SOMEWHERE and it will work.</p>
<p>Thanks again for looking at this,</p>
<p>Gary</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Monday, August 16, 2010</h2><p>Sort of.&nbsp; If your IEntity interface inherits from IUndoableObject, then what happens is that interface contract becomes part of your IEntity contract.&nbsp; When you say that your Customer business object implements IEntity, you&#39;re required to implement all the members of IUndoableObject.&nbsp; However, the CSLA base class already does that.&nbsp; So, you don&#39;t have to write code for those members - and you get to utilize the code Rocky wrote in the base classes to manage hooking and unhooking from events (plus all the other code he wrote to implement the rest of the interface.)</p>
<p>So, for example, if your IEntity inherited from INotifyPropertyChanged, then when you apply IEntity to your business object, you get to utilize Rocky&#39;s implementation of the PropertyChanged event - which means you don&#39;t have to replicate the code he wrote to deal with nonserializable event sources.</p>
<p>However, if all you&#39;re using your IEntity interface for is a way to get some event noitifications in a generic way,&nbsp;I don&#39;t think you&#39;ll need it.&nbsp; PropertyChanged comes from the INotifyPropertyChanged interface, while the ChildChanged event comes from INotifyChildChanged.&nbsp; You should be able to cast any business object&nbsp;to&nbsp;either of those interfaces and deal with them that way.</p>
<p>Having said that, if you still want your IEntity interface, you should be able to get what you want with something like this:</p>
<p>Interface IEntity<br />&nbsp;&nbsp;&nbsp; Inherits INotifyPropertyChanged<br />&nbsp;&nbsp;&nbsp; Inherits INotifyChildChanged<br />End Interface</p>
<p>Then when you apply&nbsp;IEntity to your business objects, everything Rocky has written in BusinessBase should just get picked up for the PropertyChanged and ChildChanged events.</p>
<p>In terms of dealing with event hooks from things like forms, look for the OnDeserialized method in your business objects.&nbsp; It&#39;s a protected method that is called after the deserialization process is completed.&nbsp; That&#39;s where you would need to re-hook your event methods for your non-serializable sources (like your Windows form).</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>GPhillips replied on Monday, August 16, 2010</h2><p>I was able to get rid of the compiler error by changing the event definition in the Interface to <b>Event EntityChanged as System.EventHandler</b>, omitting the parameters (which made it too specific).</p>
<p>The last sticking point I have is rehooking the event after it has been deserialized.&nbsp; I found an example in the CSLA code as follows:</p>
<p>&nbsp;&nbsp;&nbsp; protected override void OnDeserialized()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (IEditableBusinessObject child in this)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; child.SetParent(this);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INotifyPropertyChanged c = child as INotifyPropertyChanged;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (c != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c.PropertyChanged += new PropertyChangedEventHandler(Child_PropertyChanged);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.OnDeserialized();<br />&nbsp;&nbsp;&nbsp; }</p>
<p>The sticking point is that this code won&#39;t convert to VB.NET.&nbsp; I tried duplicating this exact code inside a business object.&nbsp; The c.PropertyChanged reference does not compile and does not appear in intellisense,</p>
<p>The way I have added handlers in the past is to use the AddHandler method:</p>
<p><b>AddHandler obj,EntityChanged, AddressOf EntityChangedHandler</b></p>
<p>But that would only work if I knew the routine that had to be hooked (which is in the Form, not in the business object) thus I cannot figure out how the business object would restore the form&#39;s handler.&nbsp; When it deserializes, the entries in the private _NonSerializedEventHandlers are gone, so how is it possible to know what was there so that they can be rehooked??&nbsp; </p>
<p>Am I missing something here?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>GPhillips replied on Monday, August 16, 2010</h2><p>Ah, light bulb goes on (after another few hours of breakpoints and stepping code).</p>
<p>The problem is not that the <i>external</i> event handlers are unhooked when the business object is deserialized, but the object&#39;s <i>internal </i>event handlers are somehow unhooked.&nbsp; The Form adds its handlers back when the new, saved object is assigned to its local, WithEvents variable, but the event handlers in the business object stop firing.&nbsp; In this example, i was handling the PropertyChanged and the ChildChanged events within the business object so that either of them would fire my EntityChanged event.&nbsp; After deserialization, those two handlers stopped working and thus the EntityChanged Event stopped working even though it actually had been rehooked automatically.</p>
<p>The final piece of the puzzle is to add the following to the business object:</p>
<p>&nbsp;&nbsp;&nbsp; Protected Overrides Sub OnDeserialized(ByVal context As System.Runtime.Serialization.StreamingContext)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBase.OnDeserialized(context)<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler PropertyChanged, AddressOf Entity_PropertyChanged<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AddHandler ChildChanged, AddressOf Entity_ChildChanged<br /><br />&nbsp;&nbsp;&nbsp; End Sub</p>
<p>This reconnects the internal handlers for the PropertyChanged and ChildChanged Events which are as follows:</p>
<p>&nbsp;&nbsp;&nbsp; Private Sub Entity_ChildChanged(ByVal sender As Object, ByVal e As Csla.Core.ChildChangedEventArgs) Handles Me.ChildChanged<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent EntityChanged(sender, e)<br /><br />&nbsp;&nbsp;&nbsp; End Sub<br /><br />&nbsp;&nbsp;&nbsp; Private Sub Entity_PropertyChanged(ByVal sender As Object, ByVal e As System.ComponentModel.PropertyChangedEventArgs) Handles Me.PropertyChanged<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RaiseEvent EntityChanged(sender, e)<br /><br />&nbsp;&nbsp;&nbsp; End Sub</p>
<p>In retrospect, this may have worked earlier if I had overridden the OnPropertyChanged and OnChildChanged methods and did the RaiseEvents in those routines.&nbsp; The possible benefit of that method (other than not stumbling on the unhooking event problem) is that I could control the order the events were fired if I needed the ChildChanged event fired before or after my EntityChanged Event.&nbsp; The overrides method also does not require the events be rehooked since it does not use them.</p>
<p>Thanks for all your help on this, Scott.&nbsp; You are a real trooper.&nbsp; If anyone happens on this thread and would like a complete sample of the pieces, let me know.&nbsp; We actually processed a lot of different issues in the post including:</p>
<p>Form is not serializable error on Save or Clone<br />Creating an Interface with custom Events<br />Inheriting CSLA interfaces in custom interfaces<br />Rehooking events after deserialization due to Save or Clone</p>
<p>Whew!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>martinward replied on Friday, August 20, 2010</h2><p><span style="font-family:Arial;color:black;font-size:9pt;"><span style="font-family:Arial;color:black;font-size:9pt;">
<p><span style="font-family:Arial;color:black;font-size:9pt;">Hi Gary,</span></p>
<p><span style="font-family:Arial;color:black;font-size:9pt;">I have found this post very interesting and have learnt a lot form it. Scotts input was excellent, I would really appreciate a the copy of the code to play with.</span></p>
<p><span style="font-family:Arial;color:black;font-size:9pt;">It&rsquo;s nice to see VB being used</span></p>
<p><span style="font-family:Arial;color:black;font-size:9pt;">Many thanks</span></p>
<p><span style="font-family:Arial;color:black;font-size:9pt;">Martin</span></p>
<p>&nbsp;</p>
</span>
<p>&nbsp;</p>
</span></p>
<p>
<p>&nbsp;</p>
</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
