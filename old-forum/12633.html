<html><header><title>CSLA Behaviour with new unchanged entities</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Behaviour with new unchanged entities</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/12633.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>naskew posted on Thursday, May 15, 2014</h2><p>Hi,</p>
<p>I was writing some unit tests for code developed within the team and accidentally discovered that creating a new entity and calling save does not actually cause the new entity to be saved but instead returns a still new entity.</p>
<p>I was told that this is the expected behaviour of CSLA, that CSLA only saves an entity once it is dirty and not just because it is new. Is this correct?</p>
<p>Nick</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, May 15, 2014</h2><p>If your bo is new and dirty, save should end up calling your dataportal insert method.&nbsp; Save will return a new instance if successful , that is by design as its possible your dpi method throws an exception but some state may have changed leaving your object in a inconsistent state.&nbsp; since the copy was saved you can still use the original object to let the user continue to interact with it.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Thursday, May 15, 2014</h2><p>Just wanted to add that the return of the new entity is in large part because CSLA revolves around the ability&nbsp;to serialize objects between physical layers.&nbsp; Once you serialize an object to send it somewhere and deserialize it in another location, it&#39;s simply not the same &quot;handle&quot; or object in technical terms. </p>
<p>I only work in a scenario where serialization does occur, but I believe the local data portal doesn&#39;t end up serializing/deserializing the object and in this case there is a setting as to whether or not the original object is cloned or not... in the case where it is not cloned with the local data portal, I do believe the original object is the one that would theoretically be saved and even returned as the result of the save.</p>
<p>In general though, if you simply go under the notion of myObject.Save() returning a value containing the saved object, and that you have to use that in your UI context after the save, that&#39;s a paradigm you can just follow under all circumstances.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>naskew replied on Friday, May 16, 2014</h2><p>Thanks to the users who responded but I realised that I did not make myself clear in my first post. All our entities follow the same pattern, they have an Id (Guid) which is only assigned when the entity is persisted. All new entities are created by a call to a static method.</p>
<p>var order = Order.NewOrder()</p>
<p>Now order will be marked as IsNew == True and IsDirty == False and Id will be Guid.Empty so calling</p>
<p>var savedOrder = order.Save() </p>
<p>will not actually cause the entity to be Inserted and will return an Order that is still new and still clean and still has no unique Id assigned. Now I realise that one argument might be that without a change in any property, the order cannot contain any information. However behind the entities also share other common information including datemodified, a timestamp (for versioning) and a modifiedby containing the user name of the last inserter/updater. These properties are only filled by the underlying framework that wraps CSLA. So my point of view is that all these other managed properties also contribute to the conceptual state of the entity but &nbsp;as it stands they do not contribute to the IsDirty property because the values are only set when the Save method results in an insert or update.</p>
<p>I have a fictional but plausible scenario. Suppose that if an order is cancelled we store a cancellation as a child entity. The cancellation only needs to be linked to the order it is cancelling and all the other information is contained in the fact of the existence of the entity. In other words I know when it was cancelled and who cancelled it because that information is in datemodified and modifiedby fields. There is nothing I wish to add. My code for cancelling an order might look like this.</p>
<p>void cancelOrderById(Guid Id)</p>
<p>{</p>
<p>var order = Order.GetById(id);</p>
<p>order.Cancellation = OrderCancellation.NewOrderCancellation();</p>
<p>var updatedOrder = order.Save();</p>
<p>Assert.IsFalse(updatedOrder.Cancellation.IsNew);</p>
<p>}</p>
<p>The assertion will fail because currently when Save is called on the order cancellation it will not be marked dirty and will not save.</p>
<p>It was my hope that Save would always result in an insert if the entity is new even if it is not marked dirty and my question is simply is it right that CSLA requires that a new entity is dirty before it can be saved for the first time?</p>
<p>Sorry for being so verbose, I hope this explains things a little better.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, May 16, 2014</h2><p><div style='padding-left: 50px;background-color:silver'><b>skagen00<br></b>I believe the local data portal doesn&#39;t end up serializing/deserializing the object and in this case there is a setting as to whether or not the original object is cloned or not... in the case where it is not cloned with the local data portal, I do believe the original object is the one that would theoretically be saved and even returned as the result of the save.</div></p>
<p>I don&#39;t recall when, but at some point this was changed so that the Local dataportal does serialize.&nbsp; One benefit is that if you do switch on WCF data portal support, you won&#39;t suddenly find you&#39;re BOs don&#39;t serialized; that was the main reason for the change.&nbsp; Another nice side effect though is that if your DP_I starts changing the BO state and midway something goes wrong, without serialization your object is left in a potentially bad state; the fact that a copy is saved leaves your BO exactly as it was before you called save.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, May 16, 2014</h2><p>You must have code that creates the new order as not dirty.&nbsp; Dirty is an indication that your object has changed since it was loaded from the DB. By definition, the normal case is that something that has New is also always dirty.&nbsp; I&#39;m not sure why you&#39;d want a new order to NOT be dirty.</p>
<p>As far as order cancellation goes, I think your suggested design could be flawed; what reason would you have to not be able to save an OrderCancelation independently of an order?&nbsp; Certain the cancellation BO can reference an order; perhaps your code would be vary cancellation = OrderCancelation.Cancel(order) and then the cancellation BO can keep the id of the order as one if its properties (much like an FK), but it should be savable on its own I&#39;d think.</p>
<p>And you could still have the OrderCancelation property on the Order for convince if its needed; the getter would just be return OrderCancelation.Get(this).&nbsp; </p>
<p>Also, if you really did want a new Order to exist in the database, you COULD insert the data you want in your DataPortal_Create method.&nbsp; That might be unusual, but if its what your use case demands you&#39;ll get the behavior you&#39;re after.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>naskew replied on Friday, May 16, 2014</h2><p><div style='padding-left: 50px;background-color:silver'><b>Andy<br></b></p>
<p>You must have code that creates the new order as not dirty.&nbsp; Dirty is an indication that your object has changed since it was loaded from the DB. By definition, the normal case is that something that has New is also always dirty.&nbsp; I&#39;m not sure why you&#39;d want a new order to NOT be dirty.</p>
<p></div></p>
<p>Andy, I think you have hit the nail on the head. The code that generates new instances does so with the IsDirty set to False. This never made any sense to me but clearly if the default Save in CSLA only saves dirty objects and then uses IsNew to decide between insert and update then suddenly everything falls into place. Is this how others feel new instances should be created?</p>
<p> I&#39;ll take a look at the code that is used to create new entities. Most of our entity code is generated based on XML descriptions of the model but the code for creating a new instance is within a common base class that wraps CSLA base classes.</p>
<p>Thanks for your help. Being new around here am I expected to indicate that I accept your answer?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 16, 2014</h2><p>Hi,</p>
<p>You could simply calll MarkDirty on the object when it returns to the client.</p>
<p>The default behavior is that a new object is not dirty until a user has modified one ov the properties.&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>naskew replied on Saturday, May 17, 2014</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b></p>
<p>Hi,</p>
<p>You could simply calll MarkDirty on the object when it returns to the client.</p>
<p>The default behavior is that a new object is not dirty until a user has modified one ov the properties.&nbsp;</p>
<div style="clear:both;"></div>
<p></div></p>
<p>Hi Jonny,</p>
<p>I&#39;ve taken a look in the generated code for the classes and it seems that after initialising a new instance the code deliberately marks the instance as clean with a call to MarkClean(). I&#39;ll have a chat with the developers next week because currently they seem to be saying that the problem lies in CSLA when I think it is clear this is not the case.</p>
<p>Nick</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
