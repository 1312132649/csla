<html><header><title>MVVM with Winforms</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>MVVM with Winforms</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10782.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i posted on Tuesday, October 18, 2011</h2><p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Ok, I know this sounds like an odd question but I&#39;m wondering if anybody has tried to use the MVVM pattern with Winforms?</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">The reason I&#39;m&nbsp;pondering this is as a means of providing a migration path for very large Winform applications whereby we create modelviews and views for parts we can afford to migrate to wpf/sl but also perhaps slip the&nbsp;MVs&nbsp;in between our winform UIs and business objects as a means of getting <em><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;">nearly</span></em> there over time.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Obviously I haven&#39;t thought deeply about this so this question is just a tester for opinion really. </span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">In truth I would say 50/60% of our Winform UIs are single liners just calling a factory method on business objects(collections) so migration should be simple. The rest of the UI code is simple designer settings although these forms do rely on inheritance to encapsulate all the commonality of dealing with errors, saving, binding, etc.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">This leads me to another question &ndash; for such simple bind/save UI do you think the MVVM pattern adds value? I have to admit that for a long time I simply didn&#39;t <em><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;">get</span></em> what MVVM was all about. All I could see no matter who explained it to me was extra (duplicated) code and complexity for, what seemed to me, very little testability benefit. Even then most of the code I was shown blurred the boundaries so much that I couldn&#39;t even see how testability was improved (or even possible in some cases). I came to believe this was just herd mentality at its worst - everybody <em><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;">believed</span></em> this was the way to do things but nobody could give me a convincing argument as to why. Then I saw Rocky all over it and I seriously thought I&rsquo;m finally past it &ndash; my programming lifespan has been all used up. Finally, I found a post where Rocky mentions the anaemic and rich model versions and my sanity was restored.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Tuesday, October 18, 2011</h2><p>Concerning the first part: I can&#39;t exactly  remember the binding options you have in winforms. But as far as I remember, this has been quite a challange. </p>
<p>Concerning the second part: </p>
<p>The post you mentioned about the rich model nature of CSLA BOs is really important. I think the benefit of having a ViewModel shows up more sonner than expected: it&#39;s having a clear design!&nbsp; You start with one Property (your Target) and have a load and save mechanism. For your 50/60% simple UIs you to can provide a (generic) base ViewModel. And for these UIs this might be sufficent. </p>
<p>But user demand for entering support (auto completion, selection from availables). Having a ViewModel you clearly know, where to add this functionality (hmm, actually you sometimes still have the choice of ViewModel or a calculating CSLA BusinessRule...) </p>
<p><span style="font-size:x-small;">&nbsp;Stefan</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 19, 2011</h2><p>In concept it is possible. In practice, it depends on whether you can make two things work smoothly:</p>
<ol>
<li>Data binding to the Model property of the viewmodel</li>
<li>Event binding to bind UI events to methods of the viewmodel</li>
</ol>
<p>I haven&#39;t done Windows Forms in so long that I don&#39;t know how hard #1 will be. I suspect it can be done, but I&#39;m not sure about the work involved.</p>
<p>I know there&#39;s no such thing as event binding in Windows Forms, so #2 must be invented. Then again, there&#39;s not a <em>great</em> story for event binding in XAML either, and that&#39;s why CSLA has the TriggerAction control.</p>
<p>It might be possible to create something similar to TriggerAction for Windows Forms. But it might be easier to do the &quot;poor man&#39;s event binding&quot;, which is to use the event handler in the code-behind like normal, but in that event handler have exactly one line of code that invokes the appropriate method on the viewmodel. Simple delegation, and this works fine.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Wednesday, October 19, 2011</h2><p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">As always thanks for taking the time out to reply. The idea is fuzzy in my head but as/if I advance I will put some things to the test and see if there is any merit in trying an mvvm approach in winforms. </span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I was thinking on a very simplistic level though in that I would leave the existing winform ui&#39;s pretty much intact changing only the binding from direct to the business layer instead to the vm layer (created for upgrade to wpf/sl)&nbsp;and rewiring any method calls. Code-behind where it currently exists would remain.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I know this really wouldn&#39;t give any benefits to the winform app&nbsp;but might&nbsp;allow us to ensure continuing work on those would move us closer to a cheaper migration to wpf/sl. Our major difficulty, as I suspect with many folks out there, is very heavy investment in winform technology in the early 2000&#39;s. The money&#39;s all spent now but the products are still evolving and we are faced with a dilemma of trying to advance the technology yet have it live within the framework of existing systems. </span></p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>StefanCop replied on Wednesday, October 19, 2011</h2><p>Some years ago in a winforms project we had to provide a &quot;plug-in&quot; UI for serveral applications. Of course MVVM was not known then, nevertheless we took a similar approach (inspired from MVP). The view model (we called it presenter) coordinated the widgets on a UI and the model. <br />We took the same approach as you&#39;re planning (although we put some interfaces between, but this has only been reasonable due to the plugin requirement).</p>
<ul>
</ul>
<p><div style='padding-left: 50px;background-color:silver'><b>jh72i<br></b></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I
 was thinking on a very simplistic level though in that I would leave 
the existing winform ui&#39;s pretty much intact changing only the binding 
from direct to the business layer instead to the vm layer (created for 
upgrade to wpf/sl)&nbsp;and rewiring any method calls. Code-behind where it 
currently exists would remain.</span></p>
<p></div></p>
<p>I definitely want to encourage to introduce a view model &quot;layer&quot; as you planned. The design benefits while the extra work is small.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Saturday, May 26, 2012</h2><p>It happens I&#39;m on this subject.</p>
<p>I&#39;m doing a VisualWebGUI project. VWG is a WindowsForms like environemnt and reproduces System.Windows.Forms namespace as Gizmox.WebGUI.Forms. This means it has the same controls with the same behaviour (well... almost the same). It was easy to port Csla.Windoes to Csla.WebGUI.</p>
<p>VisualWebGUI compiles to web pages and is much easier to work with than ASP.NET with or without AJAX. I&#39;m writing the draft code in WindowsForms and then, form by form, port it to VWG.</p>
<p>I became used to MVVM and miss it. So I looked around and found three interesting things:</p>
<ul>
<li>Screen Activator Pattern for WindowsForms - you can find it <a rel="nofollow" href="http://caliburnmicro.codeplex.com/SourceControl/network/Forks/jagui/WinForms">here</a>, ported from <a rel="nofollow" href="http://caliburnmicro.codeplex.com">Caliburn.Micro</a> by jagui</li>
<li>Rich Bindings and TypeConverters - <a rel="nofollow" href="http://truss.codeplex.com">Truss</a>&nbsp;by Kent Boogaart, does it in an UI independent way</li>
<li>Commands - <a rel="nofollow" href="http://waf.codeplex.com/">WPF Application Framework (WAF)</a>&nbsp;has a WafWinFormsAdapter project that takes care of some MVVM stuff namely commands</li>
</ul>
<p>My next move is try to port Caliburn.Micro to WindowsForms. After it&#39;s done, I&#39;ll try to port Csla.Xaml to WinForms and WebGUI. By the end of the day we&#39;ll have a MVVM environment for WindowsForms and Web applications.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Wednesday, June 13, 2012</h2><p>At <a href="http://mvvmfx.codeplex.com/">http://mvvmfx.codeplex.com/</a> you will find some useful MVVM stuff for Windows Forms:<br />1) a databinding library with converters that can also bind an Action to a property change<br />2) a command binding library that can bind an Action to any input event of any UI component</p>
<p>&lt;edit&gt;</p>
<p>I&#39;m coordinating this project.</p>
<p>&lt;/edit&gt;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
