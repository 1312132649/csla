<html><header><title>Call to DataMapper resolves to generic method - even when no generics are specified!!!</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Call to DataMapper resolves to generic method - even when no generics are specified!!!</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7311.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, July 21, 2009</h2><P>I have my own version of&nbsp;the DataMapper class&nbsp;that includes generic methods such as:</P>
<P><CODE>public static void Map&lt;TSource, TTarget&gt;(TSource source, TTarget target) { ... }</CODE></P>
<P>In my web page, I am using an CslaDataSource and handling the UpdateObject event.&nbsp; I pass the e.Values property as the source to DataMapper.Map as follows:</P>
<P><CODE>DataMapper.Map(e.Value, myBO);</CODE></P>
<P>I would expect the call to resolve to the:</P>
<P><CODE>public static void Map(System.Collections.IDictionary source, System.Object target)</CODE></P>
<P>method but instead it goes to the generic method.&nbsp; Any ideas why this would be the case?&nbsp; I am not specifying the generic types in my call, so why would the compiler direct the call to the generic version?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, July 21, 2009</h2>I would guess that the compiler is using type inference and is finding that the generic method is a closer match based on the parameter types. Perhaps the compiler team gave preference to generic matches over looser matches with the assumption you'd want strong typing when possible?</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
