<html><header><title>BusinessListBase.Save() implementation</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>BusinessListBase.Save() implementation</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5771.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Andreas posted on Sunday, November 09, 2008</h2><FONT size=4>If a BusinessListBase collection instance holds many child business objects and one of its children was marked dirty due to user input changes (i. e. while editing a child instance property in a DataGridView), CSLA.NET BusinessListBase.IsDirty returns true because it returns true when only one of its children is marked as dirty. Next when BusinessListBase.Save() is called CSLA.NET Dataportal clones the whole collection incl. all its child objects on the client and then serializes them to the server where (after deserializing the collection incl. all its children) Dataportal_Update will be called. <BR>I think that this seems to generate a lot of overhead when only one database column needs to be updated? Why does BusinessListBase.Save() not check BusinessListBase.IsSelfDirty first and if it returns false iterate through the collection and calls Save only on the child objects which are marked dirty? <BR></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Sunday, November 09, 2008</h2>The simplest answer is that the logic on the server may do more than just write the data to the database.&nbsp; For example, it might sum a value from each child and update the parent based upon that calculation.&nbsp; CSLA.NET is very flexible and cannot know what the server-side logic might do.&nbsp; <br><br>In addition, unless you have a whole bunch of data, the amount of data in a single request is much less important than the number of requests.&nbsp; There is typically a fair amount of fixed overhead for each request and a fairly small incrementation cost for each addition kilobyte of data sent in the request.<br><br>Jon Stonecash<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Andreas replied on Sunday, November 09, 2008</h2><P><FONT face=Verdana>Ok, I understand. But I think as a general rule&nbsp;that the default implementation should always generate the smallest amount of overhead as possible. If you want more than the user should override Save() in a derived classes. I think that in more than 95% of the of&nbsp;use cases of CSLA.NET users simply use BusinessBaseList collection to manage or aggregate child business objects, without spending additional properties. A much cleaner and more obvious design approach in other cases is to derive from BusinessBase and spend a public property of type BusinessListBase&lt;childType&gt; that holds the child collection. </FONT></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vdhant replied on Sunday, November 09, 2008</h2>Hi guys <br>I tend to agree that it would be good if there was a way out of the box to only send over the wire the rows that need to be updated. Whether this is the default behaviour, I don't know. But if the BusinessListBase had a property that one could set to true or false, as to whether it send all the data or only the dirty rows. This new property could be something like - OptimiseSaveDataTransfer.<br>Cheers<br>Anthony<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Sunday, November 09, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Andreas:</strong></div><div> 
<P><FONT face=Verdana>Ok, I understand. But I think as a general rule&nbsp;that the default implementation should always generate the smallest amount of overhead as possible. ...</FONT></div></BLOCKQUOTE></P>
<P>It's&nbsp;"worse" than this actually. Say you have a moderately complex root object with several child lists. The root object is BusinessBase derived and the child lists derive from BusinessListBase. </P>
<P>If even a single field of the root is dirty and the child lists are clean, CSLA serializes the both the root and all child objects and&nbsp;sends it over the data portal to be saved server side.</P>
<P>This is the way CSLA works. I wouldn't worry about it. In practice I've found CSLA to be quite fast&nbsp;compared to the legacy technology it is replacing in our application.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Andreas replied on Sunday, November 09, 2008</h2><P><FONT face=Verdana>I fully agree with the scenario you are describing because&nbsp;the root object is used "for more" and "not only" as a collection or container&nbsp;of some more relevant child business objects. My point was that when BusinessListBase.IsSelfDirty returns false, BusinessListBase seems to serve only as a collection container and then I think it is suitable when CSLA&nbsp;serializes&nbsp;only dirty marked child objects.</FONT></P>
<P><FONT face=Verdana></FONT>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Monday, November 10, 2008</h2>Hi Andreas, <br><br>Please make sure to read this previous thread on the forum about the same issue you are raising:<br><a HREF="/forums/thread/25777.aspx">http://forums.lhotka.net/forums/thread/25777.aspx </a><br><br>Rockys answer pretty much sums it all up!<br><br>/jonnybee<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
