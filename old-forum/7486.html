<html><header><title>Bug in Csla to Linq?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Bug in Csla to Linq?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7486.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>BobK posted on Thursday, August 20, 2009</h2>I have created a "Dynamic Editable Collection" which contains a "Dynamic Editable Root" as described in the "CSLA .NET OBJECT TEMPLATES" section of the book (pp 199-203)<br /><br />I then bound the collection (through a BindingSource) to a listbox and edit controls. When an item in the listbox is selected, the edit controls update to the current record. If I edit the data and then move to another item in the list, the data is saved. All is well!<br /><br />However, I wanted to implement filtering in my list, so I changed the BindingSource to be bound to the result of a Linq query:<br /><code><br />var list = from item in col select item;<br /></code><br />Once I am bound to the Linq result, if I click back and forth (in other words, if I re-visit a previously selected item in the list - maybe twice) in the list, I get an unhandled "ArgumentOutOfRangeException" in the EditableRootListBase::SaveItem(int index) method on the line:<br /><code><br />item = this[index];<br /></code><br />because index is -1.<br />It appears that the save is causing the item in the collection to be replaced with a clone, and so the IndexOf method returns -1.<br /><br />However, when I'm bound to the base collection, this error does not occur.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, August 23, 2009</h2><P>What version of CSLA are you using? Some bugs have been fixed over time.</P>
<P>The thing to realize is that not all LINQ queries return a LinqBindingList as a result. We can only transform some queries into an LBL, other queries are rendered into an IEnumerable&lt;T&gt; like normal LINQ to Objects.</P>
<P>If you end up with an IEnumberable&lt;T&gt;, we can't keep the two lists in sync - and you need to realize that you really have two lists that point to some of the same objects, which is the core of the problem. This is the way LINQ works, and there's no easy solution.</P>
<P>If you are using a current version of CSLA (3.6.3 or higher), then you should make sure you are getting an LBL as a result of your query (use the debugger). If you are getting an LBL and are having this problem, then there may be a bug in LBL, and we'd appreciate a simple unit test style example that illustrates your failure condition.</P>
<P>Thank you!</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
