<html><header><title>LINQ Vs Stored Procedures</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>LINQ Vs Stored Procedures</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4674.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SouthSpawn posted on Friday, April 11, 2008</h2><DIV>I have been playing around with LINQ the last few days.</DIV>
<DIV><BR>I am so tempted to abandon the idea of using stored procedures when it comes to adding, deleting and updating data. I can see why using one for getting data still might be useful.</DIV>
<DIV>&nbsp;</DIV>
<DIV>But does LINQ make stored procs somewhat obsolete.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Or am I thinking this all wrong?<BR><BR>Thanks Guys,<BR>Mark</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mcnamara replied on Friday, April 11, 2008</h2>You can use LINQ with stored procedures.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DesNolan replied on Friday, April 11, 2008</h2><P>I've not used LINQ yet, but if I was to guess...a few might be...stored procedures can be optimized and their data plans cached on SQL Server, so they are more efficient to run on subsequent calls. Store procedures can be changed on the server to fix or enhance their efficiency without having to recompile the application. Having a layer of stored procedures decouples the application from the actual data structures in the database, so again the stored procedure can be modified to reflect data structure changes, but&nbsp;still&nbsp;maintain the same contract with an application.</P>
<P>Des</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronErickson replied on Friday, April 11, 2008</h2>Query plans since SQL 2k get cached whether they are in a sproc or not... being in a sproc has almost nothing to do with performance... run of the mill queries, once they are run more than once, get their plans cached.<br><br>As for changing sproc on the server... I have seen that done a lot in prod in emergency situations, and that normally is a big "oh !!@#" situation that usually should scare the holy hell out of anyone responsible for running a prod environment.&nbsp; Code in C#/VB usually has more of a change control and test mechanism than sql does, which tends to work better in said change controlled environs.<br><br>Sorry... pet peeve :) (sproc vs sql)<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DesNolan replied on Sunday, April 13, 2008</h2><P>Pet peeve acknowledged, and I really don't want to get into a lengthy exchange, especially as&nbsp;mine's probably the reverse, and one eventually needs to decide on how they like their code organized. So I'll close with just one additional post.<o:p></o:p></P>
<P>Personally, I find SQL code so much harder to read mixed in with regular code, and have encountered plenty of issues by many developers&nbsp;with setting parameter values where there are such things as spaces, commas, semi-colons, etc.&nbsp;in the value.&nbsp;<o:p></o:p></P>
<P>Also, I still do like the layer it provides which helps decouple the application from the structure of the database. In my case this is important, as there is a real chance I may need to support a second database down the road, and I want to retain the option to more easily use a different database. <o:p></o:p></P>
<P>On some&nbsp;minor notes, caching may work second time around, but for expensive SQL statements, (and I've known a few in my time), execution plan information will be retained with SP.<o:p></o:p></P>
<P>And I don't give anyone direct access to the tables of my database, everyone needs to go through SPs, which allows more security, and more flexibility in what happens when they do so.<o:p></o:p></P>
<P>At times this separation of code allows me to pass stored procedures to someone who's more knowledgeable about SQL then me to have him write a more efficient SP for me, and thus take advantage of specialized knowledge.<o:p></o:p></P>
<P>I guess, I feel the larger a system, or the more widely the application is likely to be used, the more likely the need is for having SPs.<o:p></o:p></P>
<P>Des Nolan<o:p></o:p></P>
<P>ABC Systems, Inc.<o:p></o:p></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MichaelBarnett replied on Monday, April 14, 2008</h2><P>"And I don't give anyone direct access to the tables of my database, " </P>
<P>...and therein lies my own pet peeve...DBA's who "own" the data rather that facilitating its use. I recently left a company after 9 years because a&nbsp;DBA kept locking down one permission after another until the .NET development team could not accomplish anything. </P>
<P>The company management was so scared of the DBA that they would not give direction so that the developers could actually do their jobs. </P>
<P>The environment had 3 databases, prod, staging, and dev with appropriate change control, When the developers were prevented from making table changes or writing procedures in DEV (forget prod or staging for the moment) and since a simple change to a stored procedure took a month to work through all the meetings and arguing that the DBA demanded in order to make a change...it just got too difficult to work at that company. In supporting the application for the users, I often had to do ad-hoc queries into the data in prod (read only). When I found my access to the tables had been terminated by the DBA I knew the party was over...it was time to find a company where the DBA had not been to DBA school and was not infected with these rediculous ideas. </P>
<P>Sorry to rant but this is a hot button....</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>MGervais replied on Monday, April 14, 2008</h2><P><FONT face=Tahoma size=2>Michael,</FONT></P>
<P><FONT face=Tahoma size=2>I feel your pain, however, I believe that some level of control must be provided for a production environment. When your DBA started controlling the development environment the same way, that is where he/she over-stepped their bounds.</FONT></P>
<P><FONT face=Tahoma size=2>Our environment (dev--&gt;prod) has some 20 client databases and the maintenance is getting increasingly more difficult. We do not have a DBA and so the developers are the ones making custom changes to data, stored procedures and structure within all environments...and this drives me crazy.</FONT></P>
<P><FONT face=Tahoma size=2>I suppose the bottom line is to have an environment somewhere in between where your were and we are.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Thursday, April 17, 2008</h2><P>One of the things that i think stored procedures are great&nbsp;for that is often overlooked (but might be of interest to this group) is their ability to support/encourage data access "patterns". We all love patterns in the UI and business layers but so often I see all that good work fall away when it comes to accessing the data. </P>
<P>I&nbsp;too "encourage" developers to access data via sprocs and not directly. I even go a step futther and encourage developers to access the data via "known" sprocs.&nbsp; There are a million bads and goods so I never dictate but do "encourage" - there will always been that one instance when something can be done better but these must be the exceptions. I want all my data to be accessed via known CRUD sprocs:<BR>Users-&gt;Search(search parameters)<BR>Users-&gt;Fetch(known to exist key)<BR>Users-&gt;Update(..)<BR>etc. - you get the point - and this is not OR mapping. And often I will use dynamic sql within the sproc if performance is an issue. But, often, I will admit I might return more fields than are needed - i don't believe in this day and age it is a serious problem to return 5 fields when you only need 3 and it makes maintenance much easier.</P>
<P>Too often I have seen projects where there are exponentially more sprocs/queries than tables - stuff like GetUserByName, GetUserById, GetUserByAge....leading to stuff like LoadUserByName....FetchUserByName.....etc.&nbsp; Especially on large projects in companies that don't traditionally "manage" software. I really have seen some utterly utterly crazy databases out there - especially if dev teams have high turnover - people want to be seen to produce something quickly and get overwhelmed with the existing db so roll their own Fetch/Get/Load/Find..With/By/Using exacerbating the problem (and probably leading to even higher dev turnover :)</P>
<P>Another nice thing about this approach is that with even the simplest data access 'block' we can port our business objects to work on multiple databases literally without any change to the c# code. I have done this with sqlserver, oracle and db2 so far. I even actually do use the naming convention above in sqlserver - makes it much closer to the packages concept in oracle and db2 and i just find it easier to find the sprocs that i might need to manipulate, say, a user.</P>
<P>Now, having said all that we can "pattern" any data access style - its just that I find the sproc way to be more intuitive and easier for developers to appreciate and get with.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Marjon1 replied on Thursday, April 17, 2008</h2><font size="3"><font face="Arial">Our own system was starting to experience the same problem that jh72i described, having 10 different stored procedures for each table; that is we did a massive review and got rid of any silly stored procedure that did nothing else other than "SELECT * FROM TABLE".<br><br>I must admit that I've not really had a chance to look at LINQ, however, the one thing that I do like about stored procs is the ability to assign permissions and especially in SQL 2005, the ability to escalate permissions within a stored procedure so that uses can do standard CRUD operations without the need for permissions to do them at a table level.&nbsp; That's the main reason I use stored procs, the cached plan benefits having been mostly negated these days by using parameter based queries.<br><br>Marjon<br></font></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, April 17, 2008</h2>Ya, I don't find SPs useful for selecting data.&nbsp; That's what views are for.&nbsp; <br><br>You're also spot on about the permissions... WITH EXECUTE AS OWNER can be useful if used properly.<br><br>Finally, there's one more thing I like about SPs.&nbsp; They help you find things you may have forgotten.&nbsp; I had an error in my application, and the error was that the proc was getting too many parameters specified.&nbsp; I had updated my code entity to add a new column, but I had forgotten to update the stored procs.&nbsp; I fixed the proc, and problem solved.<br><br>Now, my point is that it could have easily gone the other way.&nbsp; I update the table, but forget to update my code.&nbsp; If I was using an UPDATE query, the new column would have never be updated and it would have been a silent error.&nbsp; Who knows when I would have found that.&nbsp; But with a proc, I have to update the table and then the proc.. so if I updated just my proc and table, but forgot to update my code, I'll get an error as soon as that proc is called.&nbsp; <br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Friday, April 18, 2008</h2><P>I usually reserve my use of SPs to Inserts, Updates and Deletes...and even then I make sure there's no business logic there...just DB plumbing.</P>
<P>For selecting data (especially searching data)&nbsp;I find I need the versatility of dynamic SQL and now LINQ.&nbsp; This is most important in say a product searching scenario where you could be passing one, two or three or more keywords to search on, it's impractical to have 50 nullable parameters in your SP...what if my customer wants to search on 51 keywords.&nbsp; This is where LINQ shines IMHO.</P>
<P>Ryan</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jh72i replied on Monday, April 21, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>webjedi:</strong></div><div>
<P>it's impractical to have 50 nullable parameters in your SP...what if my customer wants to search on 51 keywords</P>
<P></div></BLOCKQUOTE></P>
<P>I am completely ingorant of LINQ but it looks like I really need to get with it. Your comment about the 50/51 parameters is very true - one of the things I don't like is that in that scenario i possibly have to&nbsp;1.&nbsp;change a sproc signature and details, 2.&nbsp;change the call to that sproc, 3. create a new Criteria constructor and 4. create a business object factory overload. This before considering the client call.</P>
<P>What I have toyed with in the past is......(dba's look away now).... passing the parameters to all sprocs in a single consistent manner - i.e. using xml!. The Criteria class is passed through a xml engine to construct the parameters (&lt;Parameters&gt;&lt;Parameter name='xxx'..../&gt;...)and having the sproc then deconstruct the search criteria into the appropriate query language.&nbsp; Also, I have toyed with the idea of not overloading the business object's factory method but rather exposing the inner criteria and allowing that to be the driver ('toyed' - i have not done this in production code...yet).<BR> <BR>This means that to add that extra parameter in a search I only need add it to the Criteria (and possibly create a new constructor) and have the client(UI) use it.&nbsp; Can go one step further and if the sproc parameters (now xml) are named closely to the fields they represent (@pUsername relating to Username) even the sproc may not need any updating if the parsing of the xml to build sql is clever enough(this is for faily simplistic queries though).</P>
<P>Now, besides sql injection etc, etc, what I did find when I did all this was.....that the performance hit of parsing the xml was noticeable.&nbsp; Milliseconds but still enough to put me off. But I as using SQL2000 then so maybe there is merit in the approach now with 2005. Can you imagine how beautifully simple it would make 60/70% of business objects/collections and, more importantly, easily mantainable!?</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, April 24, 2008</h2>Well, I would handle this by doing selects only from a view.<br><br>You can also build the query in Linq through code.. something like this:<br><br>var results = from contacts in db.Contacts select contacts;<br><br>if ( criteria.Lastname != "" ) {<br>&nbsp;&nbsp;&nbsp; results = results.Where( c =&gt; c.LastName == criteria.Lastname );<br>}<br>if ( criteria.Firstname != "" ) {<br>&nbsp;&nbsp;&nbsp; results = results.Where( c =&gt; c.FirstName == criteria.Firstname );<br>
}<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Monday, April 28, 2008</h2><P>I got curious about Linq performance so I wrote a little test app....trying to do an apples to apples comparison with LinqToSql vs T-SQL and a datareader that created a collection of POCO objects...I'm not certain it was a perfect test but I think it's closer.&nbsp; Interesting results...in larger datasets (50,000 records records) T-SQL was about 3x faster....with smaller sets (1,000 records) Linq was about 2.6x faster.</P>
<P>My full testing method is here: <A href="http://weblogs.asp.net/ryansmith/archive/2008/04/28/linq-to-sql-speed-test.aspx">http://weblogs.asp.net/ryansmith/archive/2008/04/28/linq-to-sql-speed-test.aspx</A></P>
<P>Let me know what you think about the test.&nbsp; It seems weird to me...</P>
<P>Ryan</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>andrewem replied on Thursday, May 08, 2008</h2><P>This is an interesting article. I too am new to LINQ. I read that it was designed to be able to query objects and collections and I completely see that,&nbsp;&nbsp;but I have some questions/concerns that arise when we start applying this to databases and&nbsp;hopefully others can address them.</P>
<P>1. Isn't putting your code inside of a compiled application worse than putting it into stored procedures? The fact that we can use stored procedures (or equivalents) in SQL Server and Oracle in our organization has proven very helpful to us from maintainability perspective. Eliminating them as some have suggested and putting them into compiled code would force us to create a new build of the entire application (or of at least an assembly) for each patch we have to release. We don't have a lot of bugs in our process, but we have a few pop up here and there and they are usually quick fixes.</P>
<P>2. Even if we were to keep the stored procedures and build&nbsp;LINQ on&nbsp;top of them (such as another suggested), what would be the point of that? Wouldn't that just mean now we have two layers of queries to contend with? I can understand going one way or the other, but why both?</P>
<P>3. What about performance? I read the two articles posted above. I know for our queries we run query analyzer on them afterwards with various sets of data to check that they run within a certain amount of time. If I just hand this off to LINQ, how do I know it's going to perform optimally? At least with stored procedures, I have a hand in performance.</P>
<P>4.&nbsp;Is LINQ intended as a replacement for ADO.NET data providers? If so, what about those data sources that do not have a way to be queried from LINQ?</P>
<P>I probably will have more. I'm greatful for your responses!</P>
<P>A</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Thursday, May 08, 2008</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>andrewem:</strong></div><div>
<P>1. Isn't putting your code inside of a compiled application worse than putting it into stored procedures? The fact that we can use stored procedures (or equivalents) in SQL Server and Oracle in our organization has proven very helpful to us from maintainability perspective. Eliminating them as some have suggested and putting them into compiled code would force us to create a new build of the entire application (or of at least an assembly) for each patch we have to release. We don't have a lot of bugs in our process, but we have a few pop up here and there and they are usually quick fixes.</P>
<P></div></BLOCKQUOTE></P>
<P>I think it depends on where you stand with regards to what role does your database have in the business application.&nbsp; If you (like me) believe that the database should (in best cases) be merely a highly performing repository, then all business logic (including data selection criteria) should reside within the domain of the business application.&nbsp; However if you are on the other side and the database IS a component of your business application then having that logic in the database is perfectly fine.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>andrewem:</strong></div><div></P>
<P>2. Even if we were to keep the stored procedures and build&nbsp;LINQ on&nbsp;top of them (such as another suggested), what would be the point of that? Wouldn't that just mean now we have two layers of queries to contend with? I can understand going one way or the other, but why both?</P>
<P></div></BLOCKQUOTE></P>
<P>The advantage is that it is strongly typed.&nbsp; I know at the coding level all the properties of the resulting collection of objects and can interact with it in a programatic way.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>andrewem:</strong></div><div></P>
<P>3. What about performance? I read the two articles posted above. I know for our queries we run query analyzer on them afterwards with various sets of data to check that they run within a certain amount of time. If I just hand this off to LINQ, how do I know it's going to perform optimally? At least with stored procedures, I have a hand in performance.</P>
<P></div></BLOCKQUOTE></P>
<P>If your application requires this kind of granular control over your queries then LINQ probably isn't for you.&nbsp; However (IMHO) if you are building a business application and a small performance variance (say of a quarter of a second difference) then it's not something to worry about.&nbsp; If you are building some sort of scientific application that requires every last nanosecond, then you wouldn't want to use LINQ...or .NET for that matter.&nbsp; You can inspect the queries that LINQ produces and paste them into Query Analyzer and I think you'd be fairly pleased with their performance.&nbsp; They won't be as aesthetically pleasing as your hand written queries but they will be really solid.&nbsp; And since the queries produced are parametized the query plan for them will be cached.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>andrewem:</strong></div><div></P>
<P>4.&nbsp;Is LINQ intended as a replacement for ADO.NET data providers? If so, what about those data sources that do not have a way to be queried from LINQ?</P>
<P></div></BLOCKQUOTE></P>
<P>It's not intended as an ADO replacement, rather an augmentation, it's using ADO under the hood.&nbsp; Basically it's an abstraction layer of sorts.&nbsp; There are a TON of LINQtoXYZ providers out there, and new ones are being built all the time.</P>
<P>There are some gotcha's for instance right now people are just getting a good grasp on using LINQ in an N-tier environment&nbsp;and best practices are not yet&nbsp;universally agreed upon.&nbsp; However that being said it won't be long.</P>
<P>Ryan</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Monday, April 14, 2008</h2><P>I love how this discussion goes in cycles...SP's good...then SP's bad.&nbsp; This is my favorite long running debate in development circles.&nbsp; IMHO SP's have a place for sure, but they do tie you to a database vendor.&nbsp; They also tie your hands a bit when it comes to flexibility.&nbsp; Have you ever tried to write a stored proc that had n-parameters?&nbsp; This is where LINQ beats SP's and even dynamic T-SQL.</P>
<P>SQL will automatically cache the query plan of an SP, and will TRY to cache the query plan of T-SQL if everything matches...however you can promote the resuse of the plan of T-SQL by using parametized queries...in that event there is no difference in performance between SP's and T-SQL.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>GeorgeG replied on Wednesday, April 16, 2008</h2><P>These are some links about ling performance </P><FONT face=Courier size=2>
<P><A href="http://blogs.msdn.com/ricom/archive/2007/07/16/dlinq-linq-to-sql-performance-part-5.aspx">http://blogs.msdn.com/ricom/archive/2007/07/16/dlinq-linq-to-sql-performance-part-5.aspx</A></P><FONT face=Courier size=2>
<P><A href="http://www.codeproject.com/KB/dotnet/LINQ_Performance_Test.aspx">http://www.codeproject.com/KB/dotnet/LINQ_Performance_Test.aspx</A></P>
<P>&nbsp;</P></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, April 16, 2008</h2>Well, I don't think the benefit in using Linq is performance, the benefit is the maintainablity it adds.&nbsp; Also, the first link mentions something the second doesn't... that Linq is doing other stuff, like making sure the data types match, indexing, etc. that flat Ado.Net code won't do.&nbsp; Also, it looks like those are both from CTP code, not RTM code..<br><br>If you need 100% performance, then maybe linq isn't for you.. but for most people, the other gains from using it outweight the performance costs.&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SouthSpawn replied on Friday, April 18, 2008</h2><DIV>Thanks for the discussion on this guys.</DIV>
<DIV><BR>Your responses have been very useful for me.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Thanks,<BR>Mark</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>smiley riley replied on Monday, May 12, 2008</h2>Stored Procedures should always be percieved as a good Abstraction from the database, Easier to update a Stored Procedure in a live environment than code.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Monday, May 12, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>smiley riley:</strong></div><div>Stored Procedures should always be percieved as a good Abstraction from the database, Easier to update a Stored Procedure in a live environment than code.</div></BLOCKQUOTE></P>
<P>I'm not sure about 'always'.&nbsp; And easier yes, but better?&nbsp; That's open to interpretation since one shouldn't be updating a live environment anyway.&nbsp; Having said that I certainly do use them but I also understand where their use is a leaky abstraction where in if I change db vendors I'll most likely have to tweak all the sprocs...using Linq or some other ORM I just acquire an approriate provider and rebuild my relational maps (in theory).&nbsp; I know replacing db vendors will require a little more work than that usually...but&nbsp;at least it's less work.</P>
<P>Admittedly, most of my hesitance to use sprocs everywhere comes from the days before I could source control my db.&nbsp; Now it's become very productive to be able to build&nbsp;a map of my tables a la Linq or other ORM and tighten down the db and have all my logic in one place.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
