<html><header><title>Timestamp Columns</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Timestamp Columns</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2319.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>d0tnetdude posted on Sunday, February 11, 2007</h2><P>We are getting ready to move to the current version of the CSLA framework, and after reading the book, I like how the stored procedures check for new versions of the data.&nbsp; All our tables incorporate both a ModifiedDate and CreatedDate column, of type datetime.&nbsp; </P>
<P>My question is is there any drawback to using just a datetime column as opposed to a timestamp column?&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>William replied on Sunday, February 11, 2007</h2><P>In SQL Server, you cannot explicitly update the TIMESTAMP column. Its value is automatically updated when there is any updates happened on the row.</P>
<P>I am having my update stored procedure looks like the following:</P>
<P><FONT face="Courier New" size=2>CREATE PROCEDURE dbo.UpdateCustomer<BR>&nbsp; @CustomerID BIGINT,<BR>&nbsp; @RowVersion TIMESTAMP,<BR>&nbsp; @CustomerName VARCHAR(100)<BR>AS<BR>&nbsp; UPDATE dbo.Customers SET CustomerName = @CustomerName<BR>&nbsp; WHERE CustomerID = @CustomerID AND [RowVersion] = @RowVersion<BR>GO</FONT></P>
<P>After invoking the stored procedure, the application code checks for number of rows affected.</P>
<P>Regards,<BR>William</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Lakusha replied on Sunday, February 11, 2007</h2><P>Also remember that datetime columns are imprecise&nbsp;(+- 3 ms)&nbsp;and get rounded by the server. That means that what you write is not what you will read back and that you will have hard to reproduce concurrency issues (lots of things can happen in 3ms on a server).</P>
<P>Timestamps do not have these problems but also have drawbacks. First, it is a meaningless binary that can't tell you when the update occured. Second, it it totally propriatary and your system will never be ported and can't play nicely with other systems.</P>
<P>We do audit on all tables with the usual UpdatedBy and UpdatedDateTime columns but for concurrency issues our record version is a simple integer. This means the data access layer does [...] UPDATE MyTable SET [...] RecordVersion = RecordVersion + 1 WHERE RecordVersion = @RecordVersion and <A href="mailto:PKEY=@PKEY">PKEY = @PKEY</A>.</P>
<P>You know how many versions of a row where audited without going into the audit tables and you can prevent unauthorized updates easily by rolling back all updates that do not increment RecordVersion.</P>
<P>Both timestamps and integer versionning methods work. Pick the one that matches your needs.</P>
<P>&nbsp;</P>
<P>L</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>d0tnetdude replied on Sunday, February 11, 2007</h2>Thanks guys!&nbsp; Appreciate the feedback ... definately gives me some good points to think about.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
