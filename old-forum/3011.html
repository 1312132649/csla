<html><header><title>Cancel creation of a child object</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Cancel creation of a child object</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3011.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Friday, June 08, 2007</h2><P>In our application, we allow the users to create new child objects by clicking a button which displays a form for them to enter/edit the child object's initial properties.&nbsp; The form allows the user to commit or cancel the "creation" of the child object.&nbsp; We saw two paths we could take with the UI form:</P>
<OL>
<LI>data-bind the form to the new child object 
<LI>no data-binding and manually populate the child object only when the user clicks the OK button.</LI></OL>
<P>We have gone down the path of option #1 but are now running into problems because of the actual implementation.</P>
<P>When the user clicks the button, the UI form calls the parent object's CreateChild() method which returns a new orphaned, empty, instance of our child object which is then bound to the form.&nbsp; When the user clicks the OK button, the bound child object is added into the parent object's ChildCollection.&nbsp; If they clicked Cancel, the orphaned object is simply disposed.</P>
<P>I mention the fact that the child object is orphaned because its Parent property is null until it is actually added into the collection.&nbsp; The reason this is causing problems is that some of the object's properties get their default values from their parent.&nbsp; So, we need to have the reference before we display the form.</P>
<P>This leads us to a third option which is to create the object, add it to the collection, bind to it and display the form.&nbsp; Then, if the user click OK, do nothing; otherwise, we remove the object from the collection.&nbsp; But, this Add/Remove seems like extra overhead and has raised some eyebrows.</P>
<P>What is the typical approach for this type of situation?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Friday, June 08, 2007</h2><p class="MsoNormal">I have been doing option 3 for awhile now.<span>&nbsp; </span>It seems to work best with CSLA.<span>&nbsp; </span>I changed CSLA to handle the automatic removal
of the new object. I added an extra property in BusinessBase called
IsBrandNew.<span>&nbsp; </span>An object is brand new when
it is new and ApplyEdit has not been called.<span>&nbsp;
</span>Once ApplyEdit has been called on a new object, it is no longer brand
new.<span>&nbsp; </span>If CancelEdit is called on an
object that is brand new, it notifies the collection to remove it from the
collection.<span>&nbsp; </span>The overhead is so minimal
that you should never notice it.<span> <br></span></p><p class="MsoNormal"><span><br> </span></p>

<p class="MsoNormal">If you donâ€™t add it to the collection when you create it,
you will need to pass the parent to the object when you create it. It might
need some information form the parent (as in your case) or it might need to raise
an event etc.</p><p class="MsoNormal"><br> </p>

<p class="MsoNormal">It can be beneficial to add the new object to the collection
when you create it. For example, what if a user wants to see the total on an
invoice before they press save on the current new line item?<span>&nbsp; </span>This is much easier if the new line item is
already added to the collection.<span>&nbsp; </span>I find
that adding a new object to the collection when it is created works best.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, June 08, 2007</h2>Make a factory method for the child object that allows you to pass the default values in to the new object.&nbsp; The collection or parent object could then supply a method that called the factory method on the child object and returned it.&nbsp; Then do what you are doing in option 1 with the databinding.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, June 11, 2007</h2>Pirate, the third option seems to be the one that Csla intends you to use.&nbsp; Yes, adding and removing the object incurs some overhead, but then again, so what?&nbsp; Unless you're doing this in some tight loop, the overhead doesn't really matter at all.&nbsp; The end user won't notice a thing.&nbsp; The object ultimately will be disposed of when the parent is Saved or discarded.&nbsp;&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Monday, June 11, 2007</h2><P>I actually "discovered" the System.ComponentModel.ICancelAddNew interface over the weekend and am looking at how to implement this into our classes as a way to possibly address this.</P>
<P>If my understanding is correct, when a new "row" is added to the collection by our UI grid (typically) via IBindingList.AddNew, calling ICancelAddNew.CancelNew as a result of the user pressing the Escape key (perhaps) instructs the collection to remove the item and discard it.&nbsp; If the user arrows off the row or presses the Enter key, the grid would call EndNew which would essentially commit the new row to the collection.</P>
<P>This interface&nbsp;is implemented by the System.ComponentModel.BindingList&lt;T&gt; class.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Monday, June 11, 2007</h2>The ObjectListView exposes a list of ObjectView which implements IEditableObject.&nbsp; This will give you
the same end result with the DataGridView (pressing ESC to cancel a new
row).&nbsp; It also means that the following works:<br>ObjectListView view = new ObjectListView(list);<br>object item = view.AddNew();<br><br>using (PopupForm form = new PopupForm())<br>{<br>&nbsp;&nbsp;&nbsp; form.Object = item.Object;<br>&nbsp;&nbsp;&nbsp; if (form.ShowDialog() == DialogResult.OK)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  item.EndEdit();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  item.CancelEdit();<br>&nbsp;&nbsp;&nbsp; }<br>}<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bowman74 replied on Monday, June 11, 2007</h2><P>It's been a while since I created a UI of this type and it was with a (much) earlier version of CSLA.&nbsp; At that time this was why there were nested levels of client side transactions.&nbsp; That is when the user pressed the Add button&nbsp;you start a nested BeginEdit on the parent object and then&nbsp;created the child object and brought it up in the edit screen.&nbsp; If the user pressed OK, ApplyEdit was called to commit the sub-transaction and all is good.&nbsp; If the user pressed Cancel then CancelEdit was called and the object was reset to where it was before the Add button was pressed but still preserving all the transactions made up to that point.&nbsp; </P>
<P>Very important if you can have parents that create children in edit screens that can in turn create grandchildren.&nbsp; Once you start getting to the grandchild level manually adding and removing is going to cause you headaches when compared to just using the nested CSLA transactions IMHO.</P>
<P>I assume this will still work in current versions of CSLA.&nbsp; IIRC it was a prime factor on why nested transactions are supported by the CSLA framework in the first place.</P>
<P>Thanks,</P>
<P>Kevin</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
