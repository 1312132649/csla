<html><header><title>Thoughts on expanding n-level undo</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Thoughts on expanding n-level undo</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3210.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM posted on Monday, July 16, 2007</h2><P>I've been thinking a lot about how to design my interfaces so they are easier to use.&nbsp; Most of my applications allow a user to search for an item (a customer, supplier, invoice, and so on) with a variety of different search parameters.&nbsp; When the results appear the user can sort them by any column and edit the item from the properties screen (accessed by double-clicking on the item).&nbsp;&nbsp; Nearly all of my property windows contain various text and combo boxes that a user can edit.&nbsp; The window also contains a 'Save' button, an 'Undo' button, and a 'Close' button.&nbsp; If the user changes a property and then clicks 'Close' without saving, I prompt them with a 'Are you sure want to discard changes?' dialog.&nbsp; Here lies the problem.&nbsp; If a user took the time to change something wouldn't they just expect it to be saved?&nbsp; It seems like forcing the user to constantly click 'Save' then 'Close' is a real hassle.&nbsp; Here is the model I want to go to.&nbsp; I want to remove the 'Save' button off of all my screens.&nbsp; When a user clicks 'Close' the changes will be&nbsp;automatically changed.&nbsp; Also, the 'Close' button should not be clickable if the user has made a change that has broken error rules.&nbsp; Now here comes the tricky part.&nbsp; I want the undo button to be able to undo let's say the last few sets of changes, but I wan't them to be undoable even if several hours or days have passed.&nbsp; I want them to be undoable even if the application has been closed.&nbsp; Basically, I want a way to keep the last few sets of changes to an object stored in the database.&nbsp; I'm not talking about a complete audit, I don't want to waste tons of space keeping track of everything that has ever happened just the last few changes.&nbsp; Then, when a user clicks undo I want the last set of changes to come back.&nbsp; I'm not sure how the undo interface should work, should it just update all the fields with last version or should I implement a common undo box that shows the differences and allows the user to pick which properties they want to revert?&nbsp; I'm reminded of the 'Previous Versions' tab in Windows Server 2003 and Vista that let's you easily recover old versions of documents.&nbsp; So basically I'm talking about extending n-level undo so that at least some of its data is saved into the database with the object and that it is retrieved again with the object.&nbsp;&nbsp; Does this sound doable? or just plain crazy?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, July 17, 2007</h2>Well, you can certainly do this, although I don't think it'd integrate with n-level undo, it would be a seperate mechenism.&nbsp; You need to consider though, do the users really want this, and do they expect your application to work like this?&nbsp; If they make a change by accident (it happens), but just want to close the window their changes will be saved.&nbsp; <br><br>Also, if the user comes back on a Monday morning, why would they hit Undo to undo the changes made from Thursday?&nbsp; Would they even remember what their last change to the record was?&nbsp; I doubt it.<br><br>I'd think your best be is to implement this as a kind of audit; that's basically what the Previous versions is.&nbsp; Every change is saved.&nbsp; In your case, you'd clear out some older records as changes are made, but you are talking about an audit (with the ability to restore the old version).&nbsp; <br><br>Added this to n-level undo would make Undoable base much more complicated and harder to maintain... plus you don't really need much except to have your insert or updates audited, and a bit of code to restore the previous version.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Tuesday, July 17, 2007</h2>After some more thought I think you are correct. Integrating this into n-level undo would really increase the complexity and maintainability.&nbsp; Not to mention it would make it hard to upgrade to new CSLA versions.&nbsp; I already have an audit system written in at the database level.&nbsp; So here is what I am thinking now.&nbsp; First, the various textboxes and comboboxes need to indicate that they have been changed since the form has been opened with a different font or background color.&nbsp; Second, I still want to eliminate the 'Save' button and have the Save functionality automatically run when they press the 'Close' button.&nbsp; Third, the 'Undo' button should just undo changes since they've open the form.&nbsp; Finally, the undo button should actually have another smaller button pushed right up against it, it should look like a down arrow or something.&nbsp; When the user presses this button a common dialog needs to pop up the shows a list of changes (sort of like the previous versions tab) as well as what has changed.&nbsp; Then the user should be able to select one of them and press Ok.&nbsp; The dialog should close and all of the old&nbsp;values should be loaded in place of the current values.&nbsp; Then the user can make any final changes and click Close (saving the changes).&nbsp;&nbsp; How does this sound?&nbsp; I really want to eliminate the 'Save' button.&nbsp; I want users to be able to bounce between screens without constantly having to be hassled with committing the data.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, July 17, 2007</h2>Sounds fine, although I don't think I'd get rid of the save button.&nbsp; You can remove the prompt on closing and autosave, nothing wrong with that.&nbsp; Just think about the user though that leaves the screen open, to go to a meeting perhaps, and then there's a power failure or crash.&nbsp; Changes lost.&nbsp; I would think most users are used to saving before leaving their desktop (I know I always save everything before walking away), and losing the ablitity to do that may upset them.<br><br>Just something to think about, I'm not trying to talk you out of this.&nbsp; Also, is this something your users have requested?&nbsp; If they like how its currently working, I think you'd be hard pressed to justify changing it.&nbsp; Again, just some food for thought.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Tuesday, July 17, 2007</h2><P>No. I have not received specific requests for this solution.&nbsp; However, while observing users I constantly see them forget to click Save.&nbsp; They are then confronted with an 'Are you sure?' box.&nbsp; In this specific application a user will open one window edit only a couple of fields.&nbsp; Then, close that window and do the same to another.&nbsp;&nbsp; It just occurred to me that if I could remove the save buttons and just implicitly save everything that it would really cut down the number of clicks required over the course of a work day.&nbsp; Then I started thinking about how a more advanced undo would be needed because my users make mistakes all the time.&nbsp;&nbsp;I don't like the idea of keeping the 'Save' button.&nbsp; I think that it may be difficult to&nbsp;get users to realize they don't need to hit it.&nbsp; Perhaps I should autosave changes on a regular interval just in-case they leave the window open and walk away for a while.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Tuesday, July 17, 2007</h2><P>Sounds like 3 distinct problems, here are some ideas based on similar issues we are dealing with:</P>
<P>1. Save and Close as two separate UI actions less effiecent than a single action. As a simple solution in our application we have a "Save &amp; Close" along with "Save" and "Cancel" (X being a "Cancel"). Users are trained and get used to Save&amp;Close pretty quickly and is thier primary choice.</P>
<P>2. Users saving but with errors that should be rolled back. We have this issue as well, and being legal in nature our next verison we are going to most likely move to a fully versioned data model, where by all updates are really copy-inserts and primary keys are an ID and a version number toghether. Yes this impacts space and performance, but for our needs this solves many issues, such as this one and things like concurrent edits and permanent records for linked entities.&nbsp;Think source control, we as developers can't live without it, well our users really need it for thier business data.</P>
<P>3. Possible data loss by leaving the client unattended and have some sort of system failure during that time. Again we have this issue and are looking at different options, perhaps saving a temp file like Word or&nbsp;VS does, and if you re-open the client it sees the temp file and says hey do you want to recover, or perhaps storing these "intermediate" versions in the db as well, similar to shelving it Team Foundation but automatic, yet not fully "checked-in".</P>
<P>&nbsp;</P>
<P>Justin</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tetranz replied on Tuesday, July 17, 2007</h2>For what its worth ... here's what I've done with form close etc.<br><br>My edit forms nearly all have four standard buttons.<br>OK which saves and closes.<br>Apply which saves but doesn't close.<br>Cancel which does a CancelEdit on the bindingSource (Undo seems like a better name)<br>Close which closes the form.<br><br>Button enables are set via the bindingsource CurrentItemChanged event.<br><br>The Close button simply does this.Close() and then everything else happens in the FormClosing event. That way the Close button and the little X at the top right behave the same.<br><br>If the form is closed while BO is dirty, the user gets one of two dialogs triggered by the FormClosing event.<br>If the BO is valid then it says "Save Changes?&nbsp; Yes, No Cancel" which does the (I think) obvious things. Yes saves and closes, No doesn't save but still closes, Cancel cancels the form close.<br><br>If the BO is not valid then its a bit more messy but says "Data not saved but cannot be saved without further editing. Return to Editing?&nbsp; Yes, No". Yes is effectively the same as Cancel above and No is the same as No above.<br><br>A refinement is that if the form is closed when the BO IsNew but no property has been changed then Close closes without prompt even if the BO is not valid. This assumes that if you hit the "Add New" button (which usually means a new and dirty BO) and immediately try to close then you've changed your mind and don't really want to create a new object. This logic uses a flag which is set false in the BO create new factory method and true on PropertyChanged.<br><br>All this adds up to what I see as similar to what MS Word and Excel do if you close a document without saving. Setting the form's CancelButton property to the Close button helps smooths things along too. Someone can open an edit form, hit Escape and then hit Enter which means Yes on the first dialog above. <br><br>Cheers<br>Ross<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Tuesday, July 17, 2007</h2><P>This is a somewhat philisophical point that has been debated and explored in the past with computer systems. Our current computing model is really based on Unix(processes with isolated memory, hirearchal file system, etc). There have been other models that use such things as orthogonal persistence. This is where you really don't have "save", that is the programmer or the user really need not be exposed to such physical constructs as committing data from ram to disk. There where systems that you could yank the plug, and when plugged back in came back to the exact state they were. No real need for a file system you just had&nbsp;objects&nbsp;that once created where persistent until destroyed, ram was just a cache to the real memory your hard disk. </P>
<P>Why should my grandmother have to remeber "save" her document why can't it just be created edited, rolledback, destroyed? But&nbsp;I digress.</P>
<P>With CSLA you will have to implement this orthogonal persistence yourself, such that every property set might have to trigger a update to a persistent store, or perhaps do this in batches on timed intervals&nbsp;if your not worried about each and every property change being committed in lieu of performance. This could be stored in a DB although if it's just short term non roaming then perhaps the local filesystem would be a better place to serialize the objects. </P>
<P>Bottom line current persistent storage is many orders of magnituded slower than ram, and making your objects commit every change to a persistent store can be difficult while still mantaining performance. </P>
<P>Justin</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
