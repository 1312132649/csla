<html><header><title>To merge, or just couple?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>To merge, or just couple?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1667.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Thursday, November 02, 2006</h2>Hi all,<br><br>I'm writing my contact management / sales / invoicing application.&nbsp; Contact management is pretty much feature complete, and I'm building the sales (quotes &amp; ordering) and invoicing part.&nbsp; <br><br>The contact management functionality is contained in a Contacts.Business assembly, and the sales is part of a Quoting.Business assembly.&nbsp; My UI refrences both.&nbsp; <br><br>There's also a flat Business assembly, which has an interface definition for Contact, Address and Phone business objects.&nbsp;&nbsp; I had created these so that the Quoting assembly doesn't need to reference the Contacts assembly.&nbsp; <br><br>I'm at a point now where the Quoting assembly needs to know more about what's in the Contacts assembly.&nbsp; Is it a good idea to continue what I've been doing, and just creating interfaces, keeping the Quoting assembly from needing a reference to the Contacts assembly?&nbsp; Or maybe it would be better to merge the assemblies so that they can operate as a cohesive unit?&nbsp; Or should I just have Quoting depend on Contacts directly?<br><br>Right now the testing assembly for Quoting depends on Contacts already... mainly though just so I can use it to put contact data into the database so that I can test the Quoting objects.&nbsp; I know, its probably not a good idea and lazy, I should probably reference the data assembly and pop the data in that way... but I digress.<br><br>So, what's the best way to proceed?&nbsp; I orginally though these assemblies could be used as is if we open up our ordering system directly to our customers via the web... but now I'm not so sure, which leads me to re-evaluate this.<br><br>So, of the options, which do you think is the best?<br><br>1.&nbsp; Keep quoting and contacts independant of each other, and use interfaces in the common business layer.<br><br>2.&nbsp; Let Quoting directly use contacts.&nbsp; This creates coupling... but anymore so than sharing interfaces? I've already had to change the interfaces, contacts and quoting to get something working the way I needed it..<br><br>3.&nbsp; Merge the assemblies into one.&nbsp; Are there good reasons to keep them seperate?&nbsp; Right now the users will be using both assemblies, but maybe if I keep them seperate I can give only contacts related functionality to other users as our application grows across the business.&nbsp; <br><br>Thoughts?<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Thursday, November 02, 2006</h2>You do not really explain which forces are causing you to reevaluate this.<br><br>- if Contacts are just readonly from the Quoting's perspective, then keep it separate<br><br>- if Contacts contain Quoting-related logic, then keep the Contacts assembly clean, add a reference to it from Quoting and implement Quoting-specific subclasses in Quoting<br><br>- if Quoting needs more than readonly access (perhaps the full scale of CRUD) to your Contacts, but your Contacts can remain inherently unspecific to their use by Quoting, then keep the separate but keep elaborating your interfaces as you currently do<br><br><br>Reuse is always preferred at the largest possible scale. In the imperative programming days it was on the functional level, with OO it reached the object-level, however: if you can enable reuse on the assembly-level you are king.<br><br>Independence (i.e. no reference, but plugin-style loading) is a nice addition. It eases deployment and maintenance. However, it requires you have well-established and fool-proofed interfaces. It seems you in the process of acquiring these. If you can manage to keep the interface generic, as opposed to specific to Quoting, then you are well on your way.<br><br>This is of course assuming that you have a potential future need for Contacts. But I guess this a reasonable assumption. <br><br>Bayu<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, November 02, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Bayu:</strong></div><div>
					You do not really explain which forces are causing you to reevaluate this.</div></BLOCKQUOTE><br><br>Ahh, fair enough.&nbsp; Basically its maintainability.&nbsp; I've found so far that if the Quoting assembly needs some information about a contact, I have to first change the interface in the shared business layer, then change the Contacts assembly.&nbsp; Finally, I can finished doing what I need to in my Quoting assembly.&nbsp; So I'm questioning if the most decoupled route is really the most maintainable.&nbsp; The UI knows about contacts, and knows how to look it up and pass it to the Quoting business objects.&nbsp; <br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Bayu:</strong></div><div>- if Contacts are just readonly from the Quoting's perspective, then keep it separate</div></BLOCKQUOTE><br><br>This is actually something I'm pondering.&nbsp; In my other thread, I talk about how to give the quote busienss objects the information it needs to deteremine if the 'source' data has changed, and raise a flag.&nbsp; The user then has the option to refresh the data.&nbsp; Well, the user also has the option to enter data directly onto the document contact, and push it back to the company or contact.&nbsp; <br><br>I can handle this two ways:&nbsp; One way is to have the quoting module 'know' how to update contact info.&nbsp; Not great, because contact data does have rules.&nbsp; The second way would be for the UI to intereprate the Save call, read the new info from the document contact, load up the appropariate Contact edtiable object, and use that to push the changes back into the quoting world.&nbsp; That's the way I think would be best, because I know that I can't accidently break contact business rules.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Bayu:</strong></div><div>- if Contacts contain Quoting-related logic, then keep the Contacts
assembly clean, add a reference to it from Quoting and implement
Quoting-specific subclasses in Quoting</div></BLOCKQUOTE><br><br>Contacts contain no quoting logic... they may contain data that affects quoting functionality, but its mainly defaults.&nbsp; For example, a contact may be assigned a default price list.&nbsp; Just a simple list, the user can pick any valid value.&nbsp; Of course if that price list is obsoleted by a new price list, the contacts default list should be changed.... this can be handled at the db level though.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Bayu:</strong></div><div>- if Quoting needs more than readonly access (perhaps the scale of
CRUD) to your Contacts, but your Contacts can remain inherently
unspecific to their use by Quoting, then keep the separate but keep
elaborating your interfaces as you currently do.</div></BLOCKQUOTE><br><br>Quotes probaby should directly be updating contact data, it should be kept to read only.&nbsp; The UI might use both to push data into a quote or into a contact based on user commands though.&nbsp; It sounds like keeping them seperate is a good idea and I should continue the interface route as you suggest.<br><br>Of course now that I have posted more info, maybe you'll give different advise.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br>Thanks <br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Thursday, November 02, 2006</h2><BLOCKQUOTE><div><img src="/Themes/alternate1/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div><br><br>Of course now that I have posted more info, maybe you'll give different advise.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br><br></div></BLOCKQUOTE><br><br>I was assuming you would prefer to keep them separate since that was your original approach. If the maintainability costs are going to cause too many delays, than merge them now and postpone improved designs until refactory time. <br><br>Usually when you have it all working and you start analyzing how you can refactor stuff you can hit the bull's eye in one throw; simply because you know all the details inside-out by now. However, when feasible I still always prefer as much separation as appropriate from the start, so my advice still stands. <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" /><br><br>Bayu<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, November 02, 2006</h2>I prefer whichever method will be more maintainable.&nbsp; It may be that coupling them will cause me more maintence work that I'm doing now.&nbsp; <br><br>I'm always trying to refactor my code, because it seems to be easier to do that sooner than later.&nbsp; I like keeping things seperate as well, I'm just not sure how much more or less work it will cause if I choose one path over another.<br><br>The system is always evolving, so I'm always trying to look for refactoring.<br><br>Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
