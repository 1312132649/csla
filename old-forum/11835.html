<html><header><title>Rules called multiple times after 4.5 upgrade</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Rules called multiple times after 4.5 upgrade</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11835.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>mparsin posted on Wednesday, February 13, 2013</h2><p>&nbsp;</p>
<p class="MsoNormal">Hi!</p>
<p class="MsoNormal">Our Silverlight 5 application&#39;s BOL has a couple of business objects with pretty deep hierarchy.</p>
<p class="MsoNormal">Such as</p>
<p class="MsoNormal">ProductEdit =&gt; SectionList =&gt; SectionEdit =&gt;
FieldList =&gt; StepList =&gt; StepEdit =&gt;SecuritySettingsList=&gt;etc.</p>
<p class="MsoNormal">Some validation rules defined on child level but other like &ldquo;NoDuplicateFieldName&rdquo;
defined on ProductEdit (EditableRoot) level.</p>
<p class="MsoNormal">Currently we call rule re-check of these rules from <span>OnChildChanged</span><span> </span>override.
</p>
<p class="MsoNormal">Is that the right strategy?&nbsp;
<br />
Our problem is that after upgrading to CSLA v4.5 we found that our ViewModel&rsquo;s ModelPropertyChanged
method is getting called hundreds of times when say one of the stepEdit objects
changed. &nbsp;I guess that caused by changes
in BusinessBase OnChildChanged (MetaPropertyHasChanged)</p>
<p class="MsoNormal">Our current solution to the problem is to override MetaPropertyHasChanged in our custom BusinesBase class:</p>
<p class="MsoNormal"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>protected</span><span> </span><span>override</span><span> </span><span>void</span><span> MetaPropertyHasChanged(</span><span>string</span><span> name)</span></p>
<p class="MsoNormal"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span></p>
<p class="MsoNormal"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>// </span><strong><span>TODO: find a better way to avoid multiple business rule
checks.</span></strong><span></span></p>
<p class="MsoNormal"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p>
<p class="MsoNormal">&nbsp;</p>
<p class="MsoNormal"><span>Thanks in advance,</span></p>
<p class="MsoNormal"><span>Maxim</span></p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, February 13, 2013</h2><p>OnChildChanged gets called many times for some of the IsDirty/etc properties of the child.&nbsp; Used to, it didn&#39;t.</p>
<p>We had to introduce logic to ignore some of those property changes in OnChildChanged (had the same issue as you I believe).</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Friday, February 15, 2013</h2><p>Your hierarchy is not that deep, compared to ours. There is a performance hit when you reach a certain dept in the hierarchy. Because of that our businessobject abstraction layer doesn&#39;t notify the parent of any metadata property change. It duplicates every dept and hundreds of times became a MILION!! times in our hierarchy (using ANTS performance profiler looking at ChildChanged when typing in a value in the lowest object in the chain)</p>
<p>We did something like this.</p>
<p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; private List&lt;string&gt; _metaProperties = new List&lt;string&gt;<span style="font-size:12px;">&nbsp;{&nbsp;</span><span style="font-size:12px;">&quot;IsNew&quot;, &quot;IsDeleted&quot;,&nbsp;</span><span style="font-size:12px;">&quot;IsBusy&quot;, &quot;IsSelfBusy&quot;,&nbsp;</span><span style="font-size:12px;">&quot;IsDirty&quot;, &quot;IsSelfDirty&quot;,&nbsp;</span><span style="font-size:12px;">&quot;IsSavable&quot;,&nbsp;</span><span style="font-size:12px;">&quot;IsValid&quot;, &quot;IsSelfValid&quot;</span><span style="font-size:12px;">&nbsp;};</span></p>
<p><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; protected virtual bool IsMetaProperty(string propertyName)<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; {<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return _metaProperties.Contains(propertyName);<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; }<br /></span><span style="font-size:12px;"><br />&nbsp; &nbsp; &nbsp; &nbsp; protected override void OnChildChanged(ChildChangedEventArgs e)<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; {<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e.PropertyChangedArgs == null || !IsMetaProperty(e.PropertyChangedArgs.PropertyName))<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base.OnChildChanged(e);<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>mparsin replied on Saturday, February 16, 2013</h2><p>skagen00, rfcdejong&nbsp;</p>
<p>Thank you very much for your answers. We&#39;re doing something very similar with our code.&nbsp;</p>
<p>Just wanted to make sure we&#39;re on the right track.&nbsp;</p>
<p>&nbsp;</p>
<p>Thank you,</p>
<p>Maxim</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, February 16, 2013</h2><p>Do you guys think this is a change that should be made to the core framework? That we should collectively come up with a set of rules regarding which child change events should and shouldn&#39;t propagate up through the object graph?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Sunday, February 17, 2013</h2><p>That suppressing code up there will not notify about meta property changes.</p>
<p>From my personal experience, there are usually two scenarios going on here. </p>
<p>One where you&#39;ve got pretty reasonable depth of graph and where you want to bind onto parent object&#39;s meta properties such as IsDirty or IsSavable. Here it&#39;s more than expected to have notifications behind those properties synced with the children.</p>
<p>However, with a lot of levels in the graph this synchronization can easily become perf issue, if there are slow handlers on the way. The sole invocation through the graph should be extremely fast. That being said, I would always recommend reconsidering every model with huge graph, even though I designed those as well on multiple occasions.</p>
<p>It would be probably wise to start looking at some opt-in/out subscription model or more intelligent notifications such as reducing redundant ones and so.</p>
<p>This is not an easy answer and it comes to the fact that CSLA strives to be very rich framework for modern interactive interfaces.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rfcdejong replied on Tuesday, March 12, 2013</h2><p>In a small graph it isn&#39;t really a problem.</p>
<p><span style="font-size:12px;">Anyway, most of the meta properties only have to be notified being changed just once right after the originating property self has changed.<br /><br />To make the IsBusy work again while eating up all meta property changes we&nbsp;</span><span style="font-size:12px;">have a workaround for IsBusy:<br />Whenever there is a OnPropertyChanging a custom class called &quot;PropertyManager&quot; then knows the property is busy and on the OnPropertyChanged it marks the property as not busy. The root BO can ask his own PropertyManager if any property is busy.&nbsp;</span></p>
<p><span>For more detail, lazy loaded properties are implemented this way:</span><br />
<p><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!IsPropertyLoading(SoortPandKeuzesProperty) &amp;&amp; !(IsPropertyLoaded(SoortPandKeuzesProperty)))<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MarkPropertyLoading(SoortPandKeuzesProperty);<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LookupList&lt;AandSoortPand?&gt;.GetList(LookupType.AandSoortPand, true, null, (s1, e1) =&gt;<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (e1.Error != null)<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e1.Error.ReThrow();<br /></span><span style="font-size:12px;"><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LoadProperty(SoortPandKeuzesProperty, e1.Object);<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MarkPropertyLoaded(SoortPandKeuzesProperty);<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OnPropertyChanged(SoortPandKeuzesProperty.Name);</span><span style="font-size:12px;"><br /></span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });</span><br /><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br /></span><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return GetProperty(SoortPandKeuzesProperty);</span></p>
</p>
<p><span>Instead of using FieldManager directly we have those IsPropertyLoading and IsPropertyLoaded methods.&nbsp;The MarkPropertyLoading and MarkPropertyLoaded are two custom methods for marking the property being loaded.<br />We also have a method to unload a property.</span></p>
<p><span>There has to be some sort of notification mechanism, you cannot simply eat up MetaDataProperty notifications in the OnChildChange. The BO&#39;s higher in the hierarchi won&#39;t notify a OnPropertyChanged of meta data properties.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ngm replied on Tuesday, March 12, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>rfcdejong<br></b>
<p><span>There has to be some sort of notification mechanism, you cannot simply eat up MetaDataProperty notifications in the OnChildChange. The BO&#39;s higher in the hierarchi won&#39;t notify a OnPropertyChanged of meta data properties.</span></p>
<div style="CLEAR:both;"></div>
</div></p>
<p>I agree. OnChildChange bubbling is very useful when syncing objects within a graph. CSLA does exactly this when&nbsp;maintaining compound properties such as IsDirty, IsSavable or IsValid.&nbsp;</p>
<p><div style='padding-left: 50px;background-color:silver'><b>rfcdejong<br></b> </p>
<p><span style="FONT-SIZE:12px;">Anyway, most of the meta properties only have to be notified being changed just once right after the originating property self has changed.</span></p>
<p></div></p>
<p>This is correct. If you take a loot at IsDirty, the moment first property changes it&#39;s going to be dirty and stay like that for any subsequent property changes (not taking into account n-level undo). </p>
<p>I don&#39;t have CSLA source in front of me right now, but if I remember correctly, IsDirty property&nbsp;change is raised only if the previous state wasn&#39;t dirty, preventing wasteful notifications. However,&nbsp;any time&nbsp;child changes any of its properties, it will raise parent&#39;s dirty change (indirectly through OnChildChanged) no matter if parent&#39;s IsDirty was already set. This is where huge waste occurs. It keeps multiplying if this parent is child as well, it will do the same thing up to the root with addition of notifying parent of both its IsDirty property change and plus ChildChanged because of its child that triggered all this.</p>
<p>- ngm</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Turntwo replied on Monday, August 12, 2013</h2><p>I&#39;m experiencing this too in one part of my application that can have decent sized child lists, with small lists of their own:</p>
<p>Root/ChildList/ChildList2</p>
<p>ChildList can have hundreds, maybe a couple thousand records although that is rare.&nbsp; The case I&#39;m encountering the most issues in the 200-500 range is relatively common for some clients.&nbsp; ChildList2 has 2-10 entries per ChildList entry.&nbsp; </p>
<p>Binding a Save button (WPF) to the Root.IsSavable (or IsValid)&nbsp;is causing issues as IsValid is getting called several hundred times per property change, and that number seems to grow as more properties are changed (haven&#39;t tracked down the cause of that yet, as I&#39;m more focused on avoiding the scenario entirely).&nbsp; </p>
<p>I think the real performance hit comes because each of those IsValid calls dynamically runs through the hierarchy checking for validity.&nbsp; </p>
<p>Rather than eat the propertychanged events and ignore them, it might be better to manage the IsValid, etc properties that propagate calls to all the child objects to somehow cache the last value, and use the notifications to check only the state of the object that changed - e.g. if IsValid for a child went from true to false, update the root IsValid to false, and if it went from false to true - check the graph until finding a single false value, or update to true if everything is valid.&nbsp; Then subsequent calls to the IsValid getter could use the cached value.&nbsp; Currently with a list of about 500 entries one property change triggered 48 million calls to FieldData.IsValid.&nbsp; </p>
<p>Haven&#39;t yet looked into how tricky that would be to manage - but given the notifications are going out and spreading through the object graph, it seems like the information needed might already be in place - just need to implement the logic to cache the values, instead of checking every field in the FieldManager for the entire graph every time.&nbsp; </p>
<p>My short term solution is just to bypass the binding and provide a slightly less user friendly experience for this particular view (which I really want to re-write to not be grid/list based anyway - as when we originally designed it the expectation was for lists of 10-50 children, and the ChildList2 didn&#39;t exist...&nbsp; but no time for that now).&nbsp; </p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
