<html><header><title>Calling Object's DataPortal methods with different Criteria</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Calling Object's DataPortal methods with different Criteria</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8434.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ballistic posted on Thursday, January 28, 2010</h2>I have a LoginHistory object where I need to call different fetch methods into the it's repository.<br><br>Previously, when my data access was included in my object, I had a private class for each of the criteria so that the DataPortal knew which method to call, based on the criteria type.<br><br>Now that I have a separate class handle the data access I need to define a public class for each of the criteria so that the DataPortal can again know which of the different Fetch methods to call.&nbsp; While this seems to be the correct way of doing this, it does expose details which previously were kept private.<br><br>In my object I have:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public class Item_MostRecent_byMemberId_Criteria<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int MemberId { get; private set; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Item_MostRecent_byMemberId_Criteria(int MemberId)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.MemberId = MemberId;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected void DataPortal_Fetch(DomainObjects.Members.LoginHistory.Item_MostRecent_byMemberId_Criteria criteria)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var dalManager = IoC.Resolve&lt;Repository.IDalManager&gt;())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dal = IoC.Resolve&lt;Repository.Members.ILoginHistoryRepository&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (var dr = new SafeDataReader(dal.Fetch(criteria)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( dr.Read())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetItems(dr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>In the repository I have:<br>public IDataReader Fetch(DomainObjects.Members.LoginHistory.Item_MostRecent_byMemberId_Criteria credentials)<br><br>And in the service layer I have:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public DomainObjects.Members.ILoginHistory FindMostRecentByMemberId(int MemberId)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (MemberId.IsId())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Fetch&lt;DomainObjects.Members.LoginHistory&gt;(new DomainObjects.Members.LoginHistory.Item_MostRecent_byMemberId_Criteria(MemberId));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return DataPortal.Create&lt;DomainObjects.Members.LoginHistory&gt;();&nbsp;&nbsp; //If parameter is not valid, return new instance of object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>This all works fine, and the correct methods are being called, I'm just not liking the public criteria class that I have defined in the object.&nbsp; Is this the "correct" way to do this? Are there any other ways to do this (using the service, object and repository)?<br><br>Thank you,<br><br>&nbsp;- Andres<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, January 29, 2010</h2><P>I don't think about it that way, and I think what you are suggesting breaks layer boundaries.</P>
<P>If you are going to have a separate DAL, then you need to have a clearly defined interface between the business layer and data layer. Types should not span that boundary, because that couples the two layers in a bad way.</P>
<P>The ideal solution from a decoupling and maintanability perspective is to have three assemblies (in concept):</P>
<OL>
<LI>Business assembly (contains your business objects, including criteria objects because they are part of your logical business domain)</LI>
<LI>Data access assembly (contains concrete implementation of the DAL contract/interface)</LI>
<LI>Data access contract assembly (contains interface definitions for DAL types, and DTO types for data interchange between the business layer and data layer)</LI></OL>
<P>The business assembly references the contract assembly. The data access assembly references the contract assembly. The business layer doesn't reference the data layer, and the data layer doesn't reference the business layer. They are decoupled and can now version independently.</P>
<P>The DAL is now pluggable (via repository or DI patterns) because it is completely interface based. The data flowing between the business and data layers always goes through the DTO types, which are the "data contract" between the two layers - again providing clean decoupling of the layers.</P>
<P>So your crtiera types flow through the business layer and data portal, but they shouldn't flow to the DAL, because the DAL shouldn't have access to those types.</P>
<P>You can see an example of what I'm talking about in the sample code from the <EM>CSLA .NET Core 3.8</EM> video series. I think&nbsp;I have two different examples that follow this model if I remember right.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ballistic replied on Friday, January 29, 2010</h2>Thinking about it again, it does look like I do not need the repository to know about the type. For some reason I thought the method in the repository had to be called "Fetch" but just have a different criteria parameters.&nbsp; However, looking at the examples, it looks like I can give it any name I want and from the business object's DataPortal_Fetch (which does take a criteria parameter) I can call the repository's fetch method and pass in each parameter (which doesn't need to be a criteria type).<br><br>Also, in order to keep the Criteria class only known to the business object, I will need a non-static method that makes a call to the DataPortal's fetch method. Previously, I had the service layer call the data portal's fetch method directly, which is what was requiring me to have to know the details about the criteria class.<br><br>Again, this is the first time I design my project using interfaces, so this is new to me.<br><br>Thank you,<br><br>&nbsp;- Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
