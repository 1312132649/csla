<html><header><title>Using Roles authentication in ASP</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Using Roles authentication in ASP</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/981.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jwooley posted on Tuesday, August 22, 2006</h2><P>I'm having difficulty using roles in my forms authentication in an ASP 2.0 application. I have set up my custom Principal and Identity objects and am persisting them into the CSLA.ApplicationContextUser in the global.asax. I have set the security on the main site with the following in Web.config:</P><FONT color=#0000ff size=2>
<P>&lt;</FONT><FONT color=#800000 size=2>authentication</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>mode</FONT><FONT color=#0000ff size=2>=</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>Forms</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>&gt;<BR>&nbsp; &lt;</FONT><FONT color=#800000 size=2>forms</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>loginUrl</FONT><FONT color=#0000ff size=2>=</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>Login.aspx</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>name</FONT><FONT color=#0000ff size=2>=</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>CorrespondentWeb</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>/&gt;<BR>&lt;/</FONT><FONT color=#800000 size=2>authentication</FONT><FONT color=#0000ff size=2>&gt;<BR>&lt;</FONT><FONT color=#800000 size=2>authorization</FONT><FONT color=#0000ff size=2>&gt;<BR>&nbsp; &lt;</FONT><FONT color=#800000 size=2>deny</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>users</FONT><FONT color=#0000ff size=2>=</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>?</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2> /&gt;<BR>&nbsp; &lt;</FONT><FONT color=#800000 size=2>allow</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>users</FONT><FONT color=#0000ff size=2>=</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2>*</FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2> /&gt;<BR>&lt;/</FONT><FONT color=#800000 size=2>authorization</FONT><FONT color=#0000ff size=2>&gt;</FONT></P>
<P><FONT color=#000000 size=2>In the child path, I have tightened the authentication to only allow "Admin" users to access that portion as follows:</FONT></P><FONT color=#0000ff size=2><FONT color=#0000ff size=2>
<P>&lt;</FONT><FONT color=#800000 size=2>authorization</FONT><FONT color=#0000ff size=2>&gt; <BR>&nbsp; </FONT><FONT color=#0000ff size=2>&lt;</FONT><FONT color=#800000 size=2>allow</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>roles</FONT><FONT color=#0000ff size=2>=</FONT><FONT color=#000000 size=2>"</FONT><FONT color=#0000ff size=2>Admin</FONT><FONT color=#000000 size=2>"</FONT><FONT color=#0000ff size=2>/&gt;<BR>&nbsp; &lt;</FONT><FONT color=#800000 size=2>deny</FONT><FONT color=#0000ff size=2> </FONT><FONT color=#ff0000 size=2>users</FONT><FONT color=#0000ff size=2>=</FONT><FONT color=#000000 size=2>"</FONT><FONT color=#0000ff size=2>*</FONT><FONT color=#000000 size=2>"</FONT><FONT color=#0000ff size=2>/&gt;<BR>&lt;/</FONT><FONT color=#800000 size=2>authorization</FONT><FONT color=#0000ff size=2>&gt;</FONT></P>
<P><FONT color=#000000 size=2>I set the SiteMap to use security trimming and that part appears to be working correctly. However, when a user who is in the "Admin" role tries to access one of the files in that directory, they are bumped back to the login page. I have checked the security and the .IsInRole is not being called on page access as I would expect. It is being called by the Menu to check the security trimming properly.</FONT></P>
<P><FONT color=#000000 size=2>In reading more about role management, I have tried to add a custom&nbsp;RoleProvider. The GetRolesForUser method is called (apparently by the forms authentication). Here is where the fun exists. Instead of just checking the .IsInRole or IsUserInRole method, it requires access to the entire string array of the roles which is not exposed by the Principal or Identity. Thus, I extended Principal and Identity to expose the mRoles as a string array publicly from the Principal and Friend from Identity (so that Principal could pass it on through). Here is what I came up with then for GetRolesForUser:</FONT></P><FONT color=#0000ff size=2><FONT size=2>
<P></FONT><FONT color=#0000ff size=2>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Overrides</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT><FONT size=2> GetRolesForUser(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> username </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String</FONT><FONT size=2>()<BR>&nbsp; </FONT><FONT color=#0000ff size=2>If</FONT><FONT size=2> CSLA.ApplicationContext.User.Identity.Name &lt;&gt; username </FONT><FONT color=#0000ff size=2>Then<BR>&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>Dim</FONT><FONT size=2> blank(0) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>String<BR>&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> blank<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Else<BR>&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>CType</FONT><FONT size=2>(CSLA.ApplicationContext.User, LarsBo.Security.BusinessPrincipal).Roles<BR>&nbsp; </FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>If<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Function</FONT></P>
<P><FONT color=#000000 size=2>The catch here, is the CSLA.ApplicationCondext.User which just exposes HttpContext.Current.User has a different underlying datatype than other references to the object. In this case it is holding a System.Web.Security.RolePrincipal containing a System.Web.Security.FormsIdentity object. Apparently, these are populated from a clone of the original Principal/Identity and replaced them at some point. Since they don't have a reference to the original Principal, I can't cast it to my custom BusinessPrincipal which exposed the Roles string array.</FONT></P>
<P><FONT color=#000000 size=2>I really don't want to have to run back to the database to pull information which is already in memory in order to get this functionality. I have spent the last couple days hitting my head into the wall and could use a little assistance. Please help me get rid of this headache.</FONT></P>
<P><FONT color=#0000ff size=2><FONT color=#000000>Jim Wooley</FONT><BR><A href="http://devauthority.com/blogs/jwooley">http://devauthority.com/blogs/jwooley</A></P></FONT></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Tuesday, August 22, 2006</h2><P>Jim,</P>
<P>I have not gone down that road but here are some comments.</P>
<P>1. Has the Admin already logged in once and *then* gets kicked back to the login page when trying to access forms in the child path? Or is the Admin expecting to access those forms without logging in? (I think the first behavior is expected, not the 2nd one.)</P>
<P>2. I have not built a custom Role Provider. But from what I have read, I do not recall ever hearing about the need for a string array of Roles. I would do more research and attempt to eliminate that requirement completely.</P>
<P>3. I am concerned about CSLA.ApplicationCondext.User containing a clone of the original Principal/Identity objects. If I can't cast to my custom Principal in CSLA 2.0&nbsp;then I am going to have some serious issues. (I am still in the planning stages for moving to 2.0.) I&nbsp;tried it out on a local data portal and it all worked as expected. No cloning occurred. Are you remoting? Is that when the cloning happened?</P>
<P>Good luck.</P>
<P>Joe</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jwooley replied on Tuesday, August 22, 2006</h2><P>Joe, </P>
<P>1: Yes. The admin has already logged in prior to trying to access the restricted page.</P>
<P>2: I'm with you and hope someone comes up with an alternative that I am overlooking.</P>
<P>3: Typically, I have no problems casting the CSLA.ApplicationContext.User to my custom principal. The problem only appears during the RoleProvider method.</P>
<P>FYI, I did check ProjectTracker, and it does not include an implementation of declarative Forms Authentication with role based permissions in the config file. There must be a way.</P>
<P>Jim</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Diz replied on Thursday, December 28, 2006</h2>Hi Jim, <br><br>Did you ever figure this out?&nbsp; I'm in the same boat.&nbsp; <br><br>Thanks!<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jwooley replied on Thursday, December 28, 2006</h2><P>No, I didn't come up with a good solution. I did blog the issue but didn't get much in terms of response there either. I ended up checking it on page load of the invalid page and doing a redirect. It would be nice if the security trimming would play nice with the custom principal, but it appears this is not the case.</P>
<P>Jim</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Diz replied on Thursday, December 28, 2006</h2>The strange thing to me is this works within a page:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.Context.User.IsInRole("Admin"))<br><br>but this in the config doesn't work:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;allow roles="Admin"/&gt;<br><br>I would have thought the two would result in the same call.&nbsp; 
<br><br>This also works:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;allow users="tdaurizi"/&gt;<br><br>Which to me proves that the config's auth tag can get to my Csla provided identity.&nbsp; So there must be a different call that 
<a href="http://asp.net/" target="_blank">asp.net</a> is making when it encounters that roles authorization tag... <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>jwooley replied on Thursday, December 28, 2006</h2><P>Indeed, the menu's security trimming uses the RoleProvider rather than the custom principal's MembershipProvider. I presume this is done to enable caching the roles&nbsp;as a delimited list on the client's cookie for faster evaluation rather than needing to access the MembershipProvider cached on the server in a session (in case session is disabled). I was able to trace this via Reflector to confirm the behavior. I wrote it up a while back at <A href="http://devauthority.com/blogs/jwooley/archive/2006/08/25/2207.aspx">http://devauthority.com/blogs/jwooley/archive/2006/08/25/2207.aspx</A>. Check the comments on that post for more info as well.</P>
<P>Jim Wooley</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JCannelos replied on Thursday, February 22, 2007</h2><P><FONT face=Arial size=2>Guys,</FONT></P>
<P><FONT face=Arial size=2>I guess I'll toss my two cents in here because I have been wrestling with this all morning. :( I have noticed in general that when using Forms Authentication - the AquireRequestState event is fired several times. Only the first time is Session State available (throws error otherwise).</FONT></P>
<P><FONT face=Arial size=2>On the first call, I test for valid Session State and test for my Csla principal object in Session. If found, I restore it to Csla.ApplicationContext.User&nbsp;and I'm done. If my Csla principal object is NOT in Session, I then test for the FormsAuthenticationTicket in cookie and can log the user in that way (userName only log in). I discovered this neat trick from other posts in this forum.</FONT></P>
<P><FONT face=Arial size=2>Once I've logged in, AquireRequestState starts firing more often on each page request. On&nbsp;these calls (other than the first), any call to Session returns an error, which I trap, and leave the event.</FONT></P>
<P><FONT face=Arial size=2>The kicker here is that if you look at the HttpContext.Current.User object at this time, the object itself is a GenericPrincipal --&gt; FormsIdentity. It shows that I am Authenticated (which is good), but of course there are no roles - which causes me to return to the Login page if I access a page that has &lt;Location&gt;&lt;allow roles="Admin" /&gt; (ignore bad schema here) on it in web.config.</FONT></P>
<P><FONT face=Arial size=2>So its apparent that sometime during the life cycle, FormsIdentity is in charge, and it does not have any idea of my user roles. In reading some more posts, I've found that I can stash a string[] of Roles in the UserData section of the FormsAuthenticationTicket, which is in turn placed in a persistent or not persistent cookie. This means that like the original poster, I'd have to expose a Roles property from my Csla Principal object. With this in hand, I could recreate the Principal object like so:</FONT></P>
<P><FONT face=Arial size=2><EM>if (HttpContext.Current.Request.IsAuthenticated &amp;&amp; HttpContext.Current.User.Identity is FormsIdentity)</EM></FONT></P>
<P><FONT face=Arial size=2><EM>string[] roles = new string[] { "Admin" };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <FONT color=#a52a2a>//would normally come from FormsAuthenticationTicket.UserData.Split("|") --&gt; decrytped cookie. testing only.</FONT></EM></FONT></P>
<P><FONT face=Arial size=2><EM>HttpContext.Current.User = new GenericPrincipal(HttpContext.Current.User.Identity, roles);</EM></FONT></P>
<P><FONT face=Arial size=2>I would have NO problem doing this if it actually worked. It would come to the rescue when Session state was not available in AquireRequestState and make sure that the roles were being applied during the page (web.config roles) authorization process.</FONT></P>
<P><FONT face=Arial size=2>However this seems to have no effect whatsoever (sigh!). I've even placed the code in the AuthorizeRequest event because I've heard that AquireRequestState can occur too late for role based authorization.</FONT></P>
<P><FONT face=Arial size=2>Anyways, sorry for the long post... Rocky (or someone)&nbsp;to the rescue? :P</FONT></P>
<P><FONT face=Arial size=2>J'son</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JCannelos replied on Monday, February 26, 2007</h2><P><FONT face=Verdana size=2>Quick update... it turns out the multiple calls to AquireRequestState was for my AJAX scripts (WebResource.axd, et) - this is when Session State is unavailble. So now I'm not sure if AJAX + web.sitemap with securityTrimming + roles in web.config + CSLA security objects will all work together.</FONT></P>
<P><FONT face=Verdana size=2>Still back to square one... :(</FONT></P>
<P>J'son</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rrahlf replied on Wednesday, February 28, 2007</h2><P>I'm really glad to see this post.&nbsp; I'm just about to go through the same thing.&nbsp; This is my first app with CSLA.&nbsp; I'm going to be doing a simple sign on, just register and be signed on forever - no password, using forms authentication, custom CSLA security objects, and the site will also use AJAX .NET.</P>
<P>Please post any results any of you find, and I'll do the same.&nbsp; I'm looking forward to finding a solution to our problem.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pblaylock replied on Thursday, March 01, 2007</h2>I spent a frustrating period at the beginning of my current project tackling what sounds like a similar problem. It was a while ago I worked on this, so some of the details may not be exactly correct. I remember that I came to the conclusion that the roles check, as specified in the web.config file, happens before the Session State is restored.<br><br>The web.config role checks seem to happen on or after AuthenticateRequest, so you need the CSLA principle available at this point. If you are restoring the Principle from Session then it will not be available until AquireSessionState, which occurs after Authenticate Request. Bit of a catch 22.<br><br>The work around I came up with looks like this (I did this in a HttpHandler, but the same logic should work in Global.asax, also this is based on CSLA 1.0) ....<br><br>Store the roles in the cookie. In AuthenticateRequest load the roles from the cookie and put this into a Generic prinicple, this should allow the web.config role checks to work.<br><br>&nbsp;&nbsp;&nbsp; private void app_AuthenticateRequest(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>HttpCookie cookie = HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName];<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(cookie == null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FormsAuthenticationTicket ticket = null;<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; try<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ticket = FormsAuthentication.Decrypt(cookie.Value);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; catch(Exception ex)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HttpContext.Current.Server.Transfer("~/login.aspx");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; string[] roles = ticket.UserData.Split('|');<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; FormsIdentity identity = new FormsIdentity(ticket);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; GenericPrincipal principal = new GenericPrincipal(identity, roles);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HttpContext.Current.User = principal;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thread.CurrentPrincipal = HttpContext.Current.User;<br>}<br><br>In AcquireRequestState you can now get hold of the CSLA principal <br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; private void app_AcquireRequestState(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(HttpContext.Current.Session["CSLA-Principal"] != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Thread.CurrentPrincipal = (IPrincipal)HttpContext.Current.Session["CSLA-Principal"];<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HttpContext.Current.User = Thread.CurrentPrincipal;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // if the app domain resets on the server then the session objects will be lost,<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // but the user will still appear to be logged in according to the cookie, so <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // force the user to re-login.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(Thread.CurrentPrincipal.Identity.IsAuthenticated)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.Web.Security.FormsAuthentication.SignOut();<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HttpContext.Current.Server.Transfer("~/login.aspx");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>This seems to work ok for me.<br><br><br><br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
