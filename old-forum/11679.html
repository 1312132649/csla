<html><header><title>Csla.Xaml.ApplicationContextManager question</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Csla.Xaml.ApplicationContextManager question</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11679.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>maxal posted on Tuesday, November 06, 2012</h2><p>In our WPF application users can log out and then log in into the system. With current implementation Csla.Xaml.ApplicationContextManager we sometime have interesting problem. I would like to check if anyone had the same problem before, or have any other comments. Here is the problem.</p>
<p>&nbsp;</p>
<p>ApplicationContextManager stores IPrincipal internally, and the value is shared between threads. That creates the problem in the following sequence of events.</p>
<p><ol>
<li>User pressed &quot;Log off&quot; button</li>
<li>From the main thread we call DataPortal.BeginExecute method to do something, which creates Backgroundworker, new thread does not starts instantaneously, may take few milliseconds.</li>
<li>From the main thread we do something like this:&nbsp;<span>					</span>ApplicationContext.User = UnAuthenticatedPrincipal, which changes the value of stored principal in ApplicationContextManager</li>
<li>Now the background worker&#39;s thread is finally started, and&nbsp;SetThreadContext method is called, which changes the value of ApplicationContext.User again.</li>
</ol></p>
<p>I see some ways to address it, but interested to know how others do this and why.</p>
<p>We are on 4.3.10.0</p>
<div></div></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Tuesday, November 06, 2012</h2><p>So you start an async &quot;Logoff&quot; method that calls the DataPortal?&nbsp; </p>
<p>My best suggestion would be to add/alter the callback method and make sure to set <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplicationContext.User = UnAuthenticatedPrincipal,<br />in the callback. </p>
<p>Sometimes the User object is stored in each thread and the DataPortal is unaware of how the ApplicationContextManager handles this so I would be very hesitant to change this behavior in the framework. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>maxal replied on Tuesday, November 06, 2012</h2><p>Not exactly. The logoff is NOT an async operation. I can logoff immediately and reflect this in UI, which I do.</p>
<p>Theare are couple commands I call before the logging using BeginExecute method. And I use the fact that DataPortal BeginExecute actually grabs some infromation from application context before logoff is done. Examle: save some user settings, layouts, log statistics etc. Those are completely independent, and I don&#39;t really need or want to syncrhonize them. </p>
<p>I also don&#39;t want to wait for them to be executed to complete logging off in UI. We are working with remote app server (over internet), so it can take some time.</p>
<p>Your soultion is valid though, thank you for the response.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, November 06, 2012</h2><p>I hate to say it, but this is a &quot;feature&quot; :)</p>
<p>The User property is stored in a static field to overcome the sad fact that WPF makes it nearly impossible to change the principal&nbsp;once the app is running. They really did not think through an app scenario where the user logs on and off the app without closing the app between users...</p>
<p>The BackgroundWorker copies the main thread&#39;s context into the background thread because in non-WPF scenarios that is the only way to get the context and principal to flow automatically onto the background thread.</p>
<p>I suppose it could be argued that the BackgroundWorker shouldn&#39;t copy the User property in a WPF app because the value is already universal. However, even that change wouldn&#39;t fix your problem, it would just trade one race condition for another...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>maxal replied on Wednesday, November 07, 2012</h2><p>Thank you Rocky. Can you elaborate what did you mean by &quot;<span>&nbsp;</span><span>WPF makes it nearly impossible to change the principal&nbsp;once the app is running&quot;? </span></p>
<p>Assuming I figure out how to workaround problem with async calls, do you envision more problems with changing principal?</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
