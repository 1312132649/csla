<html><header><title>Some interesting findings when trying to get ASP Forms Authentication to play with CslaLight WCF</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Some interesting findings when trying to get ASP Forms Authentication to play with CslaLight WCF</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5246.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb posted on Thursday, August 14, 2008</h2>I've had some fun whilst working on the above topic.<br><br>Basically I have an existing ASP.Net Forms authentication setup that I wanted to integrate with a Silverlight application which uses CslaLight + CSLA3.6.<br><br>I set the WcfPortal service to run with ASPNetCompatibility mode (was relieved to see the ASPNetCompatibility attribute on the WcfPortal class btw), and then attempted to access HttpContext.Current.User from within one of my BOs on the server.<br><br>What was interesting was that I kept getting a Csla.Security.UnauthenticatedPrincipal back when debugging the HttpContext.Current.User - clearly not my FormsIdentity.<br><br>After trying a whole bunch of different configuration options in the ServiceReferences.clientconfig and the web.config, I then stumbled upon some of the code in the DataPortal client implementation where a ApplicationContext.User is serialised automatically in the BeginFetch routines.<br>I realised that every call to the WcfPortal would send the ApplicationContext.User too, <b>and when there isnt a ApplicationContext.User set, then a blank one (UnauthenticatedPrincipal) is sent</b>.<br><br>Now this causes me a problem, because I am relying on the server to initially provide the SL client back with an authenticated principal following a "start-up" BO call through the DataPortal (the server code would access the Forms authenticated principal and then load a CSLA principal for that Forms authed user), rather than the usual case of the SL client providing the server with their username and password through a login screen in the SL app.<br>After getting back the CSLA principal once, then that would be kept in the SL client and I would use that principal going forward.<br><br>The CSLA client behaviour isnt necessarily an issue on its own, however when combined with the fact that on the server side the ApplicationContext.User is set to the deserialised one just received over the wire, then I immediately saw my issue.<br>This is because in Csla.ApplicationContext, the following code exists:<br><font size="2" face="Courier New">&nbsp;&nbsp;&nbsp; public static IPrincipal User<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HttpContext.Current == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Thread.CurrentPrincipal;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HttpContext.Current.User;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (HttpContext.Current != null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpContext.Current.User = value;</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.CurrentPrincipal = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br></font>So yeah, because a ApplicationContext.User is always sent over the wire from the SL client to the server, I lose my FormsIdentity.<br>Now I know this CSLA behaviour is by design, so I'm not looking for a framework change.<br><br>I have found a way around this by using a custom IAuthorizationPolicy <em></em>with the WcfPortal service, using <a href="http://www.leastprivilege.com/HTTPBasicAuthenticationAgainstNonWindowsAccountsInIISASPNETPart3AddingWCFSupport.aspx">this excellent blog post</a> as my guide.&nbsp; By creating a HttpContextIdentityPolicy of my own, I am able to intercept the HttpContext.Current before CSLA gets its hands on it, and thus the policy is able to copy the HttpContext.Current.User into ServiceSecurityContext.Current.PrimaryIdentity.<br><br>I can then access my Forms authenticated user through ServiceSecurityContext.Current.PrimaryIdentity in my BO :)<br><br>Whew!<br><br>Anyway this is just for people's interest and maybe someone has found a better way to do this?<br><br>Also Rocky, you may want to be aware of this admittedly small side effect of having the CSLALight client serialise a blank ApplicationContext.User when one has not been explicitly set by the UI code.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, August 15, 2008</h2><P>Nice post.</P>
<P>I can see myself running in to this issue next year! At which time I will have forgotten about this! Hopefully a Search will bring it back up though.</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Sunday, August 17, 2008</h2>Thanks Joe.<br><br>While researching my approach I came across some of your posts and the login setup you run is very similar to mine.&nbsp; So I'm sure we can help each other out from time to time.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
