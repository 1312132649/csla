<html><header><title>Best Practices and Patterns on Pictures and Images?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Best Practices and Patterns on Pictures and Images?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7366.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>superkuton posted on Wednesday, July 29, 2009</h2>What are the existing practices and patterns on using pictures and images in CSLA?<br><br>I need to keep a picture for my Person object. <br><br>The SQL Server has an image column, but there are recommendations now to use the varbinary(max) data type.<br><br>There are also recommendations on just storing the picture in the file system and store the file name reference in a varchar column in the sql db.<br><br>Which is better to implement in a security and performance point of view?<br><br>Thank you.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, July 29, 2009</h2><P>Hopefully a SQL Server expert can answer your database related questions.</P>
<P>I'll point out that your property type (or at least your field type) needs to be Serializable in your business class, or your object won't work. I don't know if the Image type is Serializable, and you should check that. You might need to store the image data as a byte[] field, and convert it to an Image in the property get.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Vinodonly replied on Thursday, July 30, 2009</h2>image type is not the recommended approach from m$, use varbinary(max)...<br /><br />I'm using it for storing excel templates, doc files and zip files..<br /><br />Below is the code for reading from db<br /><br />fileinbytes = (byte[]) cm.ExecuteScalar();<br /><br />basically this is defined as byte array like this<br /><br />byte[] fileinbytes;<br /><br />and your stored proc returns that varbinary field in select..<br /><br />Once you have the bytes in byte array. you can write it on disk like this.<br /><br />File.WriteAllBytes(FileNamewithPath, fileinbytes);<br /><br />Suppose this is a excel file then you can use Process.Start to auto start/open this file..<br /><br />If you want to upload this on db then do the reverse i.e.<br /><br />byte[] fileinbytes = File.ReadAllBytes(FileName);<br /><br />and pass it to your stored proc which accepts varbinary(max) as a parameter..<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>andy replied on Thursday, July 30, 2009</h2><P>I use the same approach as mentioned above to read and write pdf for printing and email document.<BR>It should be applicable to your scenerio.</P>
<P>Andy</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cash_pat replied on Thursday, July 30, 2009</h2>&nbsp;Private Shared VisitorPhotoProperty As PropertyInfo(Of Byte()) = RegisterProperty(Of Byte())(Function(o) o.VisitorPhoto, "Visitor Photo")<br><br>&nbsp; Public Property VisitorPhoto() As Byte()<br>&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return GetProperty(VisitorPhotoProperty)<br>&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp; Set(ByVal value As Byte())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetProperty(VisitorPhotoProperty, value)<br>&nbsp;&nbsp;&nbsp; End Set<br>&nbsp; End Property<br><br>&nbsp; Public Property VisitorPhotoImage() As Drawing.Image<br>&nbsp;&nbsp;&nbsp; Get<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VisitorPhoto IsNot Nothing Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Convert byte array in variable to memory stream and the convert to image<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return System.Drawing.Image.FromStream(New System.IO.MemoryStream(ReadProperty(VisitorPhotoProperty)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Return Nothing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br>&nbsp;&nbsp;&nbsp; End Get<br>&nbsp;&nbsp;&nbsp; Set(ByVal value As Drawing.Image)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim tempMemStream As New System.IO.MemoryStream<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Convert Image to MemoryStream (Format JPEG)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value.Save(tempMemStream, System.Drawing.Imaging.ImageFormat.Jpeg)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Set Start position to read from<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMemStream.Position = 0<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Create byte array large enough to hold stream<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim photoBytes(CType(tempMemStream.Length, Integer) - 1) As Byte<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Convert memorystream to byte array<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMemStream.Read(photoBytes, 0, CType(tempMemStream.Length, Integer))<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Add byte array to the member variable<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VisitorPhoto Is Nothing OrElse Not VisitorPhoto.Equals(photoBytes) Then<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VisitorPhoto = photoBytes<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Storing Thumbnail<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VisitorThumbImage = value.GetThumbnailImage(100, 100, Nothing, New System.IntPtr())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Close the Memory Stream<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tempMemStream.Close()<br>&nbsp;&nbsp;&nbsp; End Set<br>&nbsp; End Property<br><br><b>For Fetching</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty(Of Byte())(VisitorPhotoProperty, CType(dr("VisitorPhoto"), Byte()))<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, July 30, 2009</h2><P><FONT face=Tahoma size=2>I'm not a "database expert", but I've been through this a few times.&nbsp; Here's what I've been told.</FONT></P>
<P><FONT face=Tahoma size=2>(By the way, these "best practices" are not CSLA-specific, but they certainly won't hurt your CSLA implementation):</FONT></P>
<P><FONT face=Tahoma size=2>1. Don't use "image" anymore - use VARBINARY(MAX).&nbsp; The "max var" types (VARCHAR(MAX) and VARBINARY(MAX)) are more efficient storage-wise in the database in comparison to their older counterparts (text and image, respectively).</FONT></P>
<P><FONT face=Tahoma size=2>2. Storing images in the database is a long-running run-and-gun battle.&nbsp; What they seem to have settled on where I've worked is a standard based on image size - if the images are fairly small, then go ahead and store them in the database.&nbsp; But if the images are large, store a filename in the database.&nbsp; There is a point where the size of the "max" fields will force SQL Server to store the column data on a separate data page, thus adding more I/O to the image retrieval.&nbsp; But I'm not sure what that size&nbsp;break is, and it may be somewhat dependent on how the database was initially built.&nbsp; Large images can usually be pulled faster through direct network I/O rather than as a byte stream from the database, especially when you consider the buffering techniques you may have to employ when pulling the&nbsp;image from&nbsp;the database.</FONT></P>
<P><FONT face=Tahoma size=2>3. Technically, images stored in a database are easier to secure, because there's only one place to secure them (which is already being secured).&nbsp; Storing images on a share somewhere means you have a separate set of security to manage.&nbsp; However, depending on your situation, that's not necessarily that big an issue, and it can largely be a one-time thing.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 30, 2009</h2><P>It is my understanding that SQL Server 2008 has some new way of storing large data in actual files, but files that are managed as (and appear as part of) the database.</P>
<P>Basically a supported hybrid approach to provide filesystem level performance for large files, but to also provide database security, backups and overall management.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 30, 2009</h2>If that's true, that would be really awesome.  I get that storing large binary data in databases can bloat the size... but the alternative (store the file path to the file) leads to everything becoming more complex; you have to backup that location in addition to your sql database, the location can easily get out of sync, you STILL need a way to get the binary data from the server to the client, which could mean a simple file share (prone to easy corruption if its writable and users find it), or reading the file into memory and storing in the BO anyway..<br /><br />So if this is a new feature of 2008, it would make my day!</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pondosinat replied on Thursday, July 30, 2009</h2><P>I think Rocky is referring to FILESTREAM which is new to sql 2008:</P>
<P><A href="http://msdn.microsoft.com/en-us/library/cc949109.aspx">http://msdn.microsoft.com/en-us/library/cc949109.aspx</A></P>
<P>We're using sql 08 but haven't tapped into this feature yet - looks perfect for your scenario...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Paul Czywczynski replied on Thursday, July 30, 2009</h2>I thought I read somewhere that text, ntext, and image are going to be obsolete in the next major version of SQL Server (sometime after SQL 2008 R2). They recommend using varbinary instead. I am going to switch to varbinary in our next version which will only support SQL2008 but I haven't decided if I am going to use the filestream feature yet. I need to do more analysis on our customer document sizes.<br><br><a href="http://coolthingoftheday.blogspot.com/2009/01/sql-server-varbinary-vs-filestream-code.html">http://coolthingoftheday.blogspot.com/2009/01/sql-server-varbinary-vs-filestream-code.html</a><br><br>-Paul<br><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
