<html><header><title>Multiple Add/Remove from a BusinessListBase</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Multiple Add/Remove from a BusinessListBase</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9726.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>MBursill posted on Monday, November 08, 2010</h2><p>&nbsp;</p>
<p>My object graph</p>
<p>ShoppingCart<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;|___ Products (contains &quot;Test Product A&quot;)<br />&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|____ Product</p>
<p>When the object graph is first fetched, Products contains product A. The user then navigates the UI and removes product A from the products list. Later, before saving, the user decides to re-added product A.</p>
<p>In short, product A started and ended in the list, despite X number of add/remove instances triggered by the user. The end result is the same as the starting result, so no insert or delete is necessary.</p>
<p>The &quot;IsNew&quot; of product A was&nbsp;originally&nbsp;false. When added back a second time I check for an&nbsp;existing&nbsp;product (using an IEqualityComparer) in the deleted list and do not issue a create (only a fetch child). Therefore product A is added to the products list with the IsNew still set to false.</p>
<p>The problem is, a save against the root object causes product A to call delete self.</p>
<p>I understand this is happening because an instance of product A exists in the products deleted list, however, I don&#39;t know how to avoid that.</p>
<p>What would be ideal is for CSLA&#39;s collection types to contain an IEqualityComparer&lt;ChildType&gt; property. When Save is called, the IEqualityComparer could be used to compare the objects of the deleted list against the objects of the current list to determine if it is necessary to call DeleteSelf.</p>
<p>I can&#39;t be the first person to encounter this scenario. Am I going about it the wrong way? What&#39;s the &quot;best&nbsp;practice&quot; for this type of requirement? Thanks,</p>
<p>-Mike.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, November 08, 2010</h2><p>BusinessListBase is designed to &quot;undelete&quot; items through the CancelEdit mechanism. It isn&#39;t really designed around the idea that you&#39;d delete an item and then add &quot;that same item&quot; into the list (since that has no meaning really does it?).</p>
<p>CSLA used to have a &quot;logical equality&quot; concept, but WPF data binding really messed with that - it likes reference equality only.</p>
<p>However, you can accomplish your scenario by overriding Child_Update. The default implementation is pretty straightforward:</p>
<pre style="font-family:consolas;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">protected</span>&nbsp;<span style="color:blue;">virtual</span>&nbsp;<span style="color:blue;">void</span>&nbsp;Child_Update(<span style="color:blue;">params</span>&nbsp;<span style="color:blue;">object</span>[]&nbsp;parameters)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;oldRLCE&nbsp;=&nbsp;<span style="color:blue;">this</span>.RaiseListChangedEvents;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.RaiseListChangedEvents&nbsp;=&nbsp;<span style="color:blue;">false</span>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">try</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;child&nbsp;<span style="color:blue;">in</span>&nbsp;DeletedList)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">DataPortal</span>.UpdateChild(child,&nbsp;parameters);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DeletedList.Clear();<br /> <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;child&nbsp;<span style="color:blue;">in</span>&nbsp;<span style="color:blue;">this</span>)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(child.IsDirty)&nbsp;<span style="color:#2b91af;">DataPortal</span>.UpdateChild(child,&nbsp;parameters);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">finally</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">this</span>.RaiseListChangedEvents&nbsp;=&nbsp;oldRLCE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /></pre>
<p>But you could easily add a little extra code in the loop through DeletedList to not process any items that you decide are actually in the active list.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Monday, November 08, 2010</h2><p>It also occurs to me that you can override InsertItem to accomplish your goal, in perhaps a more efficient way.</p>
<p>Just override the method, call the base implementation to actually do the insert, and then remove the &quot;duplicate item&quot; from DeletedList.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
