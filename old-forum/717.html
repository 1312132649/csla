<html><header><title>Parent/Child many levels deep architecture</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Parent/Child many levels deep architecture</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/717.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SteveChadbourne posted on Monday, July 24, 2006</h2><P>Hi</P>
<P>I understand the way that root and child object hierarchies work under csla, like the project tracker example, but what about hierarchies that are many levels deep? Should the hierarchy be broken in some way for performance reasons?</P>
<P>As an example, say I had 3 classes: petshop, cage and animal. I start out with a petshop&nbsp;class, a cagelist class and a cage class. I write a stored procedure to get a petshop and all associated cages. But what about animals? Does each cage class contain an animal collection? That means I have to load all animals for all cages when I might only be interested in one page. Where do I de-couple the cage and animal classes?</P>
<P>Steve</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Monday, July 24, 2006</h2><P>There are no easy answers to this situation.&nbsp; It is easy to use SQL to pull back parent and child resultsets using a single stored procedure call.&nbsp; However, I have not found any similar way to pull down multiple nested results.&nbsp; There is some code floating around out there where all of the grand-children items (or animals in your case) get pulled in by the child-object and then it gets run through another routine that sorts out what item belongs to what and adds them there, it is a bit messy and a bit inconsistent with the general CSLA design, but it can work.&nbsp; I have generally found in most of my designs that the need for a grandchildren can be avoided with better design choices.&nbsp; Sometimes, they are still needed, so I will put db access code in the grandchildren so they can load themselves.&nbsp; I know it is a performance hit, but I try to avoid having large resultsets.</P>
<P>Let's think about the design here.&nbsp; Do you really need to be able to load a Petshop + CageList + AnimalList at the same time?&nbsp; That's basically loading in all the data for the entire petshop.&nbsp;&nbsp; You could break them up.&nbsp; Why not make the animal list a "editable root collection" and disconnect it entirely from the cage class?&nbsp; You could add a couple of read-only fields to the cage class like 'TotalAnimals' so that a user looking a list of cages would know something about the animals without loading all the details.&nbsp; Then if the user want's more info have them click a 'Details' button that loads another form&nbsp;that creates and populates a&nbsp;new&nbsp;AnimalList collection using the CageID as the criteria.&nbsp; Anyway, it's just a thought.&nbsp; Think about how the users will interact with the software and let that help form your object design.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, July 25, 2006</h2>Just wanted to say that I think Jon is dead on here.&nbsp; You probably don't need to edit a petshop + cages + animals as one large transactional object.&nbsp; Its more likely that you'll be editing much smaller chunks of data.&nbsp; For example, if you're adding an animal, do you need to change any data which belongs with petshop (like the name)?&nbsp; Likely not.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Tom Cooley replied on Tuesday, July 25, 2006</h2>While both Jon &amp; Andy are right and you should avoid deep hierarchys, there are occaisions when your use cases dictate them. So, here is a technique I've used to assist with this. Using your example, the actors in this use case are:<br>PetShop (ER)<br>Cages (ECC)<br>Cage (EC)<br>Animals (ECC)<br>Animal (EC)<br><br>Given that your PetShop Fetch stored procedure returns three result sets, one with a single row for the PetShop, one for the cages with many rows, and one for the animals with many rows as well. The animals result set must have the foreign key to the cages for this to work.<br><br>The DataPortal_Fetch does its normal thing, executing the command and extracting its state from the first result set, then passing the second result set to a factory method in Cages like:<br><br>this.Cages.GetCages(dr);<br><br>But then it does the following:<br><br>dr.NextResult();<br><br>this.Cages.GetCageAnimals(dr);<br><br>This is another factory method in Cages class but it iterates through the Animals result set something like this:<br><br>internal void GetCageAnimals(SafeDataReader dr)<br>{<br>&nbsp;&nbsp;&nbsp; while (dr.Read())<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp; Guid cageId = dr.GetGuid("CageId");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  Cage cage = this[cageId];<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  if (cage != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  cage.Animals.GetAnimal(dr);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  }<br>}<br><br>This "distributes" the animals from the single result set into the Animals collection of the appropriate cage. Now, I wrote this straight into the forum so there may be a few typos or inaccuracies, but hopefully you get the gist of the idea.<br><br>I've seen other examples where people use datasets with relations to do the mapping, but I didn't really care for the approach. This was fairly simple to do. The only design stretch is that you're placing the responsibility of loading the grand children on the child collection that would not otherwise have had to be coupled to that class. To me, it was a small concession. I've only had to use this once and it has held up well.<br><br>Again, I try to avoid this design if possible, but it's nice to have a strategy for it when necessary.<br><br>Tom<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ktweedy replied on Tuesday, July 25, 2006</h2><P>My thought about this is using a DataReader makes this difficult since you have to get all the result sets for each parent object to iterate over.</P>
<P>Seems a&nbsp;DataSet&nbsp;with views or selecting&nbsp;DataRow[]&nbsp;would be an option for these situations.&nbsp; Each&nbsp;each parent object could&nbsp;perform a select on&nbsp;a DataTable to get its children rows and if it is a grand parent maybe also pass the&nbsp;DataSet or some subset of data to the child&nbsp;so it has its children data.&nbsp; For me I suspect I sould just pass the DataSet down the tree and let each parent find its children as needed.</P>
<P>Getting the DataSet would let you get all the data you need in one database call.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DogSpots replied on Tuesday, July 25, 2006</h2><P><FONT face=Arial size=2>I agree with ktweedy.&nbsp; Using a DataReader makes it difficult to get the entire result set in one database call.&nbsp; Using a DataSet is much easier.</FONT></P>
<P><FONT face=Arial size=2>There's some information about using DataSet, DataRow[] and SafeRowReader in the old forums.&nbsp; One particularly helpful thread is: </FONT><A href="http://groups.msn.com/CSLANET/general.msnw?action=get_message&amp;mview=0&amp;ID_Message=1304"><FONT face=Arial size=2>http://groups.msn.com/CSLANET/general.msnw?action=get_message&amp;mview=0&amp;ID_Message=1304</FONT></A></P>
<P><FONT face=Arial size=2>I've been using this approach based on the examples in that thread with very good results.</FONT>&nbsp; </P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vargasbo replied on Tuesday, July 25, 2006</h2>

<p class="MsoNormal">I deal with this issue all the time. The patterns I've used
is to get one depth below my current object.<br>
So when you first load the Petshop, you would pull back all its cages. Then,
when you selected a specific cage, then you would go out and load all its
animal(s). I'm sure you get the idea, this is better than having to load a huge
dataset. Cons, the application might be a little chatty, but it works great when
you have to work with objects (graph) that are five nodes deep.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SteveChadbourne replied on Tuesday, July 25, 2006</h2><P>Thanks people.</P>
<P>My app has an object design 5 nodes deep so I'm not looking to load all the data up front. The issues was when to load the next level. The csla paradigm seems to be that a parent loads its children so the petshop would load then cages then getcage would load all its animals. I wasn't sure whether to do this or just load the animals when they were needed. I'm leaning towards vargasbo's approach.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
