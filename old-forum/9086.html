<html><header><title>MVVM - Can the ViewModel Manipulate the View?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>MVVM - Can the ViewModel Manipulate the View?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9086.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Smith866 posted on Tuesday, June 15, 2010</h2><p>I have a design question regarding the MVVM pattern.&nbsp; Let me briefly describe my problem so you can see where I&#39;m coming from:</p>
<p>I have an Editable Root Collection that I am loading into a Silverlight DataGrid (The standard Silverlight Toolkit grid, not a 3rd party).&nbsp; I have added an &quot;Add&quot; button to my page that allows me to add records to my editable root list.&nbsp; The Add button is wired up to the AddNewCore function and everything works fine.&nbsp; The issue is that the grid is rather small, and sometimes you need to scroll down to see all of the items.&nbsp; In this case, when you press the Add button, it appears to the user that nothing has happened.&nbsp; In reality, the AddNewCore function has been called and there is a blank row waiting for them down at the bottom of the grid, if they happen to know to scroll down to find it.</p>
<p>I need to make my Add button scroll the grid down to the bottom and put focus in one of the columns in my new row.&nbsp; This isn&#39;t overly hard to do, but what I&#39;m wondering is how this should be accomplished in the MVVM world.&nbsp; I don&#39;t want to use code-behind, as I&#39;m pretty sure that should be avoided as much as possible.&nbsp; What I ended up doing was this:&nbsp; I passed my DataGrid as a parameter to my ViewModel when the Add button was pressed.&nbsp; The ViewModel can then attempt to manipulate the DataGrid as desired after the new row has been added.</p>
<p>This all seems to work just find, but I&#39;m just wondering if I have violated some MVVM principal by doing this?&nbsp; Is there a better solution?&nbsp; Should this kind of thing be handled by modifying the control itself?</p>
<p>I have attached my ViewModel code below:</p>
<p>public override void AddNew(object sender, ExecuteEventArgs e)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.AddNew(sender, e);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //This will select the newly added row, and then scroll the DataGrid there as well.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var myDataGrid = e.MethodParameter as DataGrid;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (myDataGrid != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myDataGrid.SelectedIndex = Model.Count - 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myDataGrid.ScrollIntoView(Model[Model.Count - 1], myDataGrid.Columns[0]);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myDataGrid.BeginEdit();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>cds replied on Tuesday, June 15, 2010</h2><p>I see your difficulty, but what you&#39;ve done does violate the MVVM pattern - as I understand it, the View should bind to the ViewModel - the ViewModel shouldn&#39;t be aware of the View - you&#39;ve now tightly bound your ViewModel to a specific implementation of the View - in that a DataGrid control will (or at least should - you&#39;ve got a null reference check there!) be present.</p>
<p>The correct way to do this would be to expose a property on the ViewModel for the current object and then have the DataGrid bind to that, scrolling as it needs to to ensure that current object was visible.</p>
<p>Of course, whether you can make the native Silverlight DataGrid do that is another matter, though perhaps you can accomplish it by subclassing or through an attached property.</p>
<p>Anyway, that&#39;s the theory - good luck putting it into practise! <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>paupdb replied on Tuesday, June 15, 2010</h2><p>If you insert your new record as the first element of your list, it will appear at the top of the DataGrid - at least thats what I recall.</p>
<p>AFAIK, the DataGrid reflect the exact order of it&#39;s ItemsSource elements.</p>
<p>&nbsp;</p>
<p>So if my vague recollection is correct, then no need to do anything special :)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bartol replied on Wednesday, June 16, 2010</h2><p>Hi,</p>
<p>This appears to be one of those cases where the limitations of the controls in the view do not allow a &quot;clean&quot; MVVM approach. It is important to remember that the goal of MVVM is not to eliminate code behind but to decouple the View from its data. Your solution breaks this goal. I suggest one of the the solutions below:</p>
<p><span style="font-size:11.8056px;">1. If the datagrid offers a record added event then handle that event and call ScrollIntoView in there.&nbsp;</span></p>
<p>2. Create an interface (IViewNewRecord) with a single method (NewRecordAdded) that is implemented by the view. You have to somehow pass a reference to this interface to the ViewModel (wherever you construct it) and then call the method whenever a new record is added. On the View side just call ScrollIntoView. This is a solution taken from the MVP pattern.</p>
<p>3. Create an event&nbsp;<span style="font-size:11.8056px;">in the ViewModel that is raised whenever a new record is added. This event is handled by the view where the ScrollIntoView is called. You will need to implement IDisposable in the View to get rid of the delegate reference when the View is closed.</span></p>
<p><span style="font-size:11.8056px;">Either of these methods will keep your data independent of your view allowing you to migrate to a better grid at some point in the future or replace the grid with a completely different control if required. Sure, they all require code in the code-behind file but they are better compromises than having a reference to the datagrid in the ViewModel.</span></p>
<p><span style="font-size:11.8056px;">&nbsp;</span></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
