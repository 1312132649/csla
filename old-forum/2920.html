<html><header><title>Many-To-Many Relations and OOD/OOP</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Many-To-Many Relations and OOD/OOP</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2920.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>av_harris posted on Monday, May 21, 2007</h2><P>Rocky,</P>
<P>I was trying to grasp how OOD/OOP handles a many-to-many relation and I stumbled on an old posting of yours: <A href="http://www.lhotka.net/Article.aspx?id=ff226256-903f-4aee-a921-8b09ef40901b">http://www.lhotka.net/Article.aspx?id=ff226256-903f-4aee-a921-8b09ef40901b</A>. In the post, you seem to be saying that the intermediate table concept doesn't fit into OOD/OOP. </P>
<P>In the Project Tracker sample, you have the Assignments table that looks to me like an intermediate table. My application will have several many-to-many relations. 1) should I be using an intermediate table?, 2) if yes, I was planning on having several "assignment" tables to handle each relation. Is this going to work?</P>
<P>I know this is more of a generic design question but I wanted to make sure that my design doesn't make life difficult for me in CSLA.</P>
<P>Art</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Plowking replied on Tuesday, May 22, 2007</h2><span id="ctl00_ContentPlaceHolder1_BodyLabel">In Rocky's post he states that<br><br>"A relational model requires such an intermediate table."<br><br>Assuming you are using a relational database, nearly everybody does, then yes you need an intermediate table to represent a many to many relationship. However, your object model should different to your relational model, and you will have to implement some kind of Object Relational Mapping when you build an OO application on a relational database.<br><br>Rockys article describes how you can use lazy loading to avoid an infinite loop in your many to many implementation.<br><br>So the answer is, you dont need to be afraid to use an intermediate table, at least in your database (in fact you will have to use one). You should not have an intermediate OBJECT however... (use lazy loading techniques discussed)<br></span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>av_harris replied on Tuesday, May 22, 2007</h2><P>I see now that he is talking about an "intermediate" object. However, how does this reconcile with the fact that there is an object named Assignement that corresponds to the Assignments table in the Project Tracker demo? Assignments looks like an intermediate table to me.</P>
<P>I thought I was able to follow the logic in the book and understood the need for the object. I just want to be sure that using an assignment&nbsp;object (that corresponds to my intermediate table) is the right way to go.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 22, 2007</h2><P>The Assignments table IS an intermediate table. You can't avoid that in a relational model.</P>
<P>The Assignment <EM>class</EM> is a normalization of behavior that would otherwise be duplicated between ResourceAssignment and ProjectResource.</P>
<P>I wrote ProjectResource first, because it fits into the edit-a-project use case. It was originally self-contained.</P>
<P>Later, when implementing the edit-a-resource use case I was working on ResourceAssignment and realized that it duplicated behaviors from ProjectResource.</P>
<P>So I did the correct thing, and refactored (normalized) those behaviors into a third object/class, so both ResourceAssignment and ProjectResource can collaborate with those centralized behaviors.</P>
<P>The Assignment class <EM>does not correspond</EM> to the Assignments table. It exists purely to normalize behaviors within the object model. Not all M:M data relationships end up with such a class - it depends on your use cases and whether there's behavior to normalize.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>av_harris replied on Wednesday, May 23, 2007</h2><P>Thanks. That clears things up for me. I guess I was calling the Assignment class intermediate because it controls the interaction of Project and Resource. And, I can see where, although, it does utilize Assignments, it doesn't directly correspond to the underlying table.</P>
<P>I have one more question regarding the M:M relationship. </P>
<P>I notice that there are no constraints set in the db to enforce the relation between Projects and Resources. Obviously, this can be enforced in the BO logic. Is this the preferred method? Personally, I've always resisted using the constraints just because I didn't want a redundant process that could make debugging more difficult. What would be the OO best practice here?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, May 23, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>av_harris:</strong></div><div>
<P>I notice that there are no constraints set in the db to enforce the relation between Projects and Resources. Obviously, this can be enforced in the BO logic. Is this the preferred method? Personally, I've always resisted using the constraints just because I didn't want a redundant process that could make debugging more difficult. What would be the OO best practice here?</P>
<P></div></BLOCKQUOTE></P>
<P>Oh, now you've put your foot in it... This is a dogmatic topic <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></P>
<P>You'll be hard-pressed to find a DBA willing to <EM>not</EM> have the constraints in the database.</P>
<P>But as a developer it is nice if they aren't there.</P>
<P>This is why I am a strong supporter of stored procedures. As a developer, I know my database design is sub-optimal (read: is often terrible). Making the database work well is somebody else's problem (see Douglas Adams for a complete description of why SEP fields are a good thing <img src="/emoticons/emotion-5.gif" alt="Wink [;)]" />).</P>
<P>By using sprocs, I have a very clear abstraction that documents what my app needs to see in terms of a logical view of the database. A database expert can come along after I've defined what I need, and can rework the <EM>physical</EM> database to make it sing - with little or no impact on the <EM>logical</EM> database I see.</P>
<P>Obviously I'm being a bit flippant here. But I'm also quite serious. Sprocs provide a powerful abstraction layer that really can allow the developer to get a lot of work done, and a database expert to do their job as well.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>av_harris replied on Wednesday, May 23, 2007</h2><P>Thanks for the advice. </P>
<P>Now I'm not saying you're right or wrong but since you've got the years of experience working with this stuff, I'm going to follow your lead. And, to all those purists out there reading this, let me say that it has always been my experience that a working app is always more desireable than one down for optimization repairs!</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
