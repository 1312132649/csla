<html><header><title>Updating Roles On The Fly?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Updating Roles On The Fly?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2466.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Savij posted on Friday, March 02, 2007</h2><P><FONT face=Verdana size=2>Hello,</FONT></P>
<P><FONT face=Verdana size=2>I am creating an application that uses Windows Authentication. I have two roles: Users &amp; Administrators (this is a proof of concept application). Using CSLA authorizations, I restrict the Users role to read only on a text box (databound to a BusinessBase inherited object). The Administrator role has write permissions. I want to allow an Administrator to enter a domain login &amp; password and allow temporary editing of the textbox. (like a temporary admin override)</FONT></P>
<P><FONT face=Verdana size=2>I made this work by using a&nbsp;Dictionary&lt;string,bool&gt; in my identity to store the roles. The string is the role name, and the bool marks temporary roles. So if an Administrator walks up and enters their domain login info, the application will add the roles of that Admin and mark them true for temporary. That way at then end of editing, I can just call to remove the temporary roles and the User is left with their roles intact.</FONT></P>
<P><FONT face=Verdana><FONT size=2>The problem is that when I add roles, the UI is not updating anything. The thread is updated with the new roles (using <FONT face="Courier New">System.Threading.Thread.CurrentPrincipal.IsInRole() sees everything properly). </FONT><FONT face=Verdana>How do I tell the business object to re-check so that it will see the new roles I just added?</FONT></FONT></P></FONT>
<P><FONT face=Verdana size=2>I call back to the</FONT> <FONT size=2>readWriteAuthorization1.ResetControlAuthorization(); <FONT face=Verdana>, but it doesnt seem to see the newly added roles?? Am I missing something?</FONT></FONT></P>
<P><FONT size=2><FONT face=Verdana>Thanks,</FONT></FONT></P>
<P><FONT size=2><FONT face=Verdana>-Jeff</FONT></P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, March 02, 2007</h2>This should be possible; the ptracker example lets you logout and login with a user with more privledges.. so it certainly should be possible.&nbsp; Check out the sample PTWin, your solution should be in there.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 02, 2007</h2>The key here is that your principal object's IsInRole() must answer true for the expected roles that have read/write permission to your properties. It doesn't matter how you do that, but that's the requirement.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Savij replied on Friday, March 02, 2007</h2><FONT face=Verdana size=2>I don't believe this is true in this case. In this case, I am adding and removing roles at runtime. The CanWriteProperty(true); is returning false all of the time. It seems to have something to do with the write cache. In BusinessBase the call to</FONT> 
<P><FONT size=2>VerifyAuthorizationCache() <FONT face=Verdana>doesnt allow for updated write premissions unless the actual principal changes. The code looks like this:</FONT></FONT></P>
<P><FONT size=2><FONT color=#0000ff>private</FONT> <FONT color=#0000ff>void</FONT> VerifyAuthorizationCache()</FONT></P>
<P><FONT size=2>{</FONT></P>
<P><FONT size=2><FONT color=#0000ff>if</FONT> (_readResultCache == <FONT color=#0000ff>null</FONT>)</FONT></P>
<P><FONT size=2>_readResultCache = <FONT color=#0000ff>new</FONT> <FONT color=#2b91af>Dictionary</FONT>&lt;<FONT color=#0000ff>string</FONT>, <FONT color=#0000ff>bool</FONT>&gt;();</FONT></P>
<P><FONT size=2><FONT color=#0000ff>if</FONT> (_writeResultCache == <FONT color=#0000ff>null</FONT>)</FONT></P>
<P><FONT size=2>_writeResultCache = <FONT color=#0000ff>new</FONT> <FONT color=#2b91af>Dictionary</FONT>&lt;<FONT color=#0000ff>string</FONT>, <FONT color=#0000ff>bool</FONT>&gt;();</FONT></P>
<P><FONT size=2><FONT color=#0000ff>if</FONT> (!ReferenceEquals(Csla.<FONT color=#2b91af>ApplicationContext</FONT>.User, _lastPrincipal))</FONT></P>
<P><FONT size=2>{</FONT></P>
<P><FONT color=#008000><FONT size=2>// the principal has changed - reset the cache</FONT></P></FONT>
<P><FONT size=2>_readResultCache.Clear();</FONT></P>
<P><FONT size=2>_writeResultCache.Clear();</FONT></P>
<P><FONT size=2>_lastPrincipal = Csla.<FONT color=#2b91af>ApplicationContext</FONT>.User;</FONT></P>
<P><FONT size=2>}</FONT></P>
<P><FONT size=2>}</FONT></P>
<P><FONT size=2><FONT face=Verdana>Notice that unless the</FONT> Csla.<FONT color=#2b91af>ApplicationContext</FONT>.User <FONT face=Verdana>has changed, it will not clear and update the _readCache and _writeCache.</FONT> <FONT face=Verdana>If I comment out the line</FONT> <FONT color=#0000ff>if</FONT> (!ReferenceEquals(Csla.<FONT color=#2b91af>ApplicationContext</FONT>.User, _lastPrincipal))&nbsp;<FONT face=Verdana>then it acts properly for me, however I am defeating the cache mechanism as it will clear with every property access.</FONT></FONT></P>
<P><FONT face=Verdana size=2>I also tried</FONT>&nbsp;<FONT size=2>Csla.<FONT color=#2b91af>ApplicationContext.</FONT><FONT color=#000000>Clear();&nbsp;<FONT face=Verdana>and then resetting the User to the current principal, but that still fails the if statement because it is checking by reference against the last User.</FONT></FONT></FONT></P>
<P><FONT face=Verdana size=2>I'm not sure how to handle this yet. Any suggestions would be great. I will continue my investigation at the same time.</FONT></P>
<P><FONT face=Verdana size=2>-Jeff</FONT>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, March 02, 2007</h2>You'll probably want to set the current prinicpal to that of the administrator, run your check, then reset the princpial back to the unprivledged user.&nbsp; That way you don't defeat the caching mechinism..<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, March 02, 2007</h2><P>Can someone please provide some more detail on this caching mechanism and its value? </P>
<P>If a user logs out and logs back in (and is assigned some new roles while logged out) then their principal should not be cached and the new roles should be ineffect. right?</P>
<P>Also, in a Web app, does this cache provide much value with hundreds of users hitting the site?</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 02, 2007</h2>






 





<div class=Section1>

<p class=MsoNormal><span>Oh, I see what&#8217;s being talked about here.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Yes, it is true that the authorization results per-property are
cached, and that the cache is only refreshed if the principal reference is
changed to another object. This optimization is important because of the
frequency at which CanReadProperty() and CanWriteProperty() are often called by
Windows Forms data binding.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>It isn&#8217;t the roles that are cached, it is the authorization
results themselves &#8211; allowing BusinessBase to entirely short-circuit the
looping-through-arrays and calling IsInRole() repeatedly that must occur to
actually do the authorization.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>If a user logs out and back in, it is almost certainly the case
that you&#8217;d create a new principal object for them, and the result of
doing that would trigger the cache to be flushed.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>What the original poster is doing is different &#8211; trying to
have their principal &#8220;switch modes&#8221;.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>For the purpose of admin override, what I&#8217;ve always done
is actually swapped principal objects, and so I&#8217;ve never encountered this
scenario. I think swapping principal objects is a superior answer in any case, if
for no other reason that it is the way .NET, Windows, Unix, Linux, Java and
other platforms solve the problem. I figure if all the smart security people
writing those platforms use a technique, it is probably a good technique.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>The coding for this idea isn&#8217;t hard. You can model it
after the WindowsPrincipal/WindowsIdentity approach, where they have a method
that allows you to temporarily elevate yourself to another identity, and then
to return to your original identity.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>What you can do is add a couple methods to your principal class<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>&nbsp; Private Shared _originalPrincipal As IPrincipal<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>&nbsp; Public Shared Sub SwitchTo(ByVal username As String,
ByVal password As String)<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; If IsPrincipalElevated Then<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Throw New
InvalidOperationException(&#8220;Already running as elevated user&#8221;)<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; End If<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; _originalPrincipal =
Csla.ApplicationContext.User<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; Login(username, password)<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp; End Sub<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>&nbsp; Public Shared Sub SwitchBack()<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; If Not IsPrincipalElevated Then<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Throw New
InvalidOperationException(&#8220;Not running as elevated user&#8221;)<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; End If<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; Csla.ApplicationContext.User =
_originalPrincipal<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; _originalPrincipal = Nothing<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp; End Sub<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>&nbsp; Public Shared Function IsPrincipalElevated() As Boolean<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp;&nbsp;&nbsp; Return (_originalPrincipal IsNot Nothing)<o:p></o:p></span></p>

<p class=MsoNormal><span>&nbsp; End Function<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Using these methods, you can easily create an &#8220;elevate
user&#8221; dialog that gets the supervisor&#8217;s username/password and logs
them in, but in a way where you can easily revert back to the original user&#8217;s
identity without any muss or fuss.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 02, 2007</h2>






 

 
  
 




<div class=Section1>

<p class=MsoNormal><span>You can&#8217;t change the roles required by the object, no.
What you should be changing are the roles provided by the principal object&#8217;s
IsInRole method. This is the widely accepted way role-based security is
handled, and CSLA just conforms to that norm.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<div>

<div>

<div>

<p class=MsoNormal><b><span>From:</span></b><span> Savij
[mailto:cslanet@lhotka.net] <br>
<b>Sent:</b> Friday, March 02, 2007 12:21 PM<br>
<b>To:</b> rocky@lhotka.net<br>
<b>Subject:</b> Re: [CSLA .NET] Updating Roles On The Fly?<o:p></o:p></span></p>

</div>

</div>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><span>I
don't believe this is true in this case. In this case, I am adding and removing
roles at runtime. The CanWriteProperty(true); is returning false all of the
time. It seems to have something to do with the write cache. In BusinessBase
the call to</span> <o:p></o:p></p>

<p><span>VerifyAuthorizationCache() </span><span>doesnt allow for
updated write premissions unless the actual principal changes. The code looks
like this:</span><o:p></o:p></p>

<p><span>private</span><span> <span>void</span>
VerifyAuthorizationCache()</span><o:p></o:p></p>

<p><span>{</span><o:p></o:p></p>

<p><span>if</span><span> (_readResultCache == <span>null</span>)</span><o:p></o:p></p>

<p><span>_readResultCache = <span>new</span>
<span>Dictionary</span>&lt;<span>string</span>,
<span>bool</span>&gt;();</span><o:p></o:p></p>

<p><span>if</span><span> (_writeResultCache == <span>null</span>)</span><o:p></o:p></p>

<p><span>_writeResultCache = <span>new</span>
<span>Dictionary</span>&lt;<span>string</span>,
<span>bool</span>&gt;();</span><o:p></o:p></p>

<p><span>if</span><span> (!ReferenceEquals(Csla.<span>ApplicationContext</span>.User,
_lastPrincipal))</span><o:p></o:p></p>

<p><span>{</span><o:p></o:p></p>

<p><span>// the principal has changed -
reset the cache</span><span><o:p></o:p></span></p>

<p><span>_readResultCache.Clear();</span><o:p></o:p></p>

<p><span>_writeResultCache.Clear();</span><o:p></o:p></p>

<p><span>_lastPrincipal = Csla.<span>ApplicationContext</span>.User;</span><o:p></o:p></p>

<p><span>}</span><o:p></o:p></p>

<p><span>}</span><o:p></o:p></p>

<p><span>Notice
that unless the</span><span> Csla.<span>ApplicationContext</span>.User </span><span>has changed, it
will not clear and update the _readCache and _writeCache.</span><span> </span><span>If I comment out the line</span><span> <span>if</span> (!ReferenceEquals(Csla.<span>ApplicationContext</span>.User, _lastPrincipal))&nbsp;</span><span>then it acts
properly for me, however I am defeating the cache mechanism as it will clear
with every property access.</span><o:p></o:p></p>

<p><span>I also
tried</span>&nbsp;<span>Csla.<span>ApplicationContext.</span><span>Clear();&nbsp;</span></span><span>and then resetting the User to
the current principal, but that still fails the if statement because it is
checking by reference against the last User.</span><o:p></o:p></p>

<p><span>I'm not
sure how to handle this yet. Any suggestions would be great. I will continue my
investigation at the same time.</span><o:p></o:p></p>

<p><span>-Jeff</span>&nbsp;<o:p></o:p></p>

<p class=MsoNormal><br>
<br>
<o:p></o:p></p>

</div>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Savij replied on Friday, March 02, 2007</h2><P><SPAN>Rocky,</SPAN></P>
<P><SPAN>"You can’t change the roles required by the object, no. What you should be changing are the roles provided by the principal object’s IsInRole method. "</SPAN></P>
<P><SPAN>I am doing exactly that. I am getting the roles of the administrator and adding it to the current principal. As a matter of fact, I step through the code and I can test for the new roles by doing this:</SPAN></P><SPAN>
<P>System.Threading.Thread.CurrentPrincipal.IsInRole("Administrator")</P>
<P>and it does equal true after the principal gets loaded. However, the object still fails the CanWriteProperty() test because the roles are already cached. I am thinking about modifying the BusinessBase (or some inherited object) and allowing a cache clear method for the purpose of re-reading the roles from the principal.</P>
<P>What do you think?</P>
<P>-Jeff</P></SPAN></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 02, 2007</h2>






 

 
  
 




<div class=Section1>

<p class=MsoNormal><span>If you don’t like my proposal in my previous post (which I do
think is the right answer), you can certainly add a ClearAuthorizationCache()
method to BusinessBase to solve the problem with your current implementation.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I don’t think I’ll add such a thing to the core framework
however, because I think that switching principal objects is the correct answer
overall, and the framework handles that scenario as-is.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<div>

<div>

<div>

<p class=MsoNormal><b><span>From:</span></b><span> Savij
[mailto:cslanet@lhotka.net] <br>
<b>Sent:</b> Friday, March 02, 2007 1:39 PM<br>
<b>To:</b> rocky@lhotka.net<br>
<b>Subject:</b> Re: [CSLA .NET] RE: Updating Roles On The Fly?<o:p></o:p></span></p>

</div>

</div>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p>Rocky,<o:p></o:p></p>

<p>&quot;You canâ€™t change the roles required by the object, no. What you
should be changing are the roles provided by the principal objectâ€™s IsInRole
method. &quot;<o:p></o:p></p>

<p>I am doing exactly that. I am getting the roles of the administrator and
adding it to the current principal. As a matter of fact, I step through the
code and I can test for the new roles by doing this:<o:p></o:p></p>

<p>System.Threading.Thread.CurrentPrincipal.IsInRole(&quot;Administrator&quot;)<o:p></o:p></p>

<p>and it does equal true after the principal gets loaded. However, the object
still fails the CanWriteProperty() test because the roles are already cached. I
am thinking about modifying the BusinessBase (or some inherited object) and
allowing a cache clear method for the purpose of re-reading the roles from the
principal.<o:p></o:p></p>

<p>What do you think?<o:p></o:p></p>

<p>-Jeff<o:p></o:p></p>

<p class=MsoNormal><br>
<br>
<o:p></o:p></p>

</div>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Savij replied on Friday, March 02, 2007</h2><P>Rocky,</P>
<P>Yes, you now understand it all correctly. I think I will do as you and others say (elevate the principal), afterall I don't intend to re-invent the wheel. I am however using Active Directory for my users, and the roles are stored in SQL. This is a requirement of the company I work for. What I need to do now is figure out how to create a new principal from an AD account. I am sure there are samples out there and I'll check it out on my own. </P>
<P>If anyone has a sample of code that shows how to create a principal object from a domain account it might short-cut my searching.</P>
<P>Thanks for taking the time Rocky, I understand how it all comes together now.</P>
<P>Jeff</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Savij replied on Friday, March 02, 2007</h2><P>I have it all working with the impersonation with rollback. I will blog the answer and post a link when it's done.</P>
<P>&nbsp;</P>
<P>Thanks again,</P>
<P>&nbsp;</P>
<P>Jeff</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 02, 2007</h2>






 

 
  
 




<div class=Section1>

<p class=MsoNormal><span>I should say, however, that if you don&#8217;t like the way CSLA
handles the roles for your objects, the CanReadProperty and CanWriteProperty methods
are virtual. You can override them in your custom base class (which I always
recommend people create) and entirely replace the way those methods are
implemented in your application.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<div>

<div>

<div>

<p class=MsoNormal><b><span>From:</span></b><span> Savij
[mailto:cslanet@lhotka.net] <br>
<b>Sent:</b> Friday, March 02, 2007 12:21 PM<br>
<b>To:</b> rocky@lhotka.net<br>
<b>Subject:</b> Re: [CSLA .NET] Updating Roles On The Fly?<o:p></o:p></span></p>

</div>

</div>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><span>I
don't believe this is true in this case. In this case, I am adding and removing
roles at runtime. The CanWriteProperty(true); is returning false all of the
time. It seems to have something to do with the write cache. In BusinessBase
the call to</span> <o:p></o:p></p>

<p><span>VerifyAuthorizationCache() </span><span>doesnt allow for
updated write premissions unless the actual principal changes. The code looks
like this:</span><o:p></o:p></p>

<p><span>private</span><span> <span>void</span>
VerifyAuthorizationCache()</span><o:p></o:p></p>

<p><span>{</span><o:p></o:p></p>

<p><span>if</span><span> (_readResultCache == <span>null</span>)</span><o:p></o:p></p>

<p><span>_readResultCache = <span>new</span>
<span>Dictionary</span>&lt;<span>string</span>,
<span>bool</span>&gt;();</span><o:p></o:p></p>

<p><span>if</span><span> (_writeResultCache == <span>null</span>)</span><o:p></o:p></p>

<p><span>_writeResultCache = <span>new</span>
<span>Dictionary</span>&lt;<span>string</span>,
<span>bool</span>&gt;();</span><o:p></o:p></p>

<p><span>if</span><span> (!ReferenceEquals(Csla.<span>ApplicationContext</span>.User,
_lastPrincipal))</span><o:p></o:p></p>

<p><span>{</span><o:p></o:p></p>

<p><span>// the principal has changed -
reset the cache</span><span><o:p></o:p></span></p>

<p><span>_readResultCache.Clear();</span><o:p></o:p></p>

<p><span>_writeResultCache.Clear();</span><o:p></o:p></p>

<p><span>_lastPrincipal = Csla.<span>ApplicationContext</span>.User;</span><o:p></o:p></p>

<p><span>}</span><o:p></o:p></p>

<p><span>}</span><o:p></o:p></p>

<p><span>Notice
that unless the</span><span> Csla.<span>ApplicationContext</span>.User </span><span>has changed, it
will not clear and update the _readCache and _writeCache.</span><span> </span><span>If I comment out the line</span><span> <span>if</span> (!ReferenceEquals(Csla.<span>ApplicationContext</span>.User, _lastPrincipal))&nbsp;</span><span>then it acts
properly for me, however I am defeating the cache mechanism as it will clear
with every property access.</span><o:p></o:p></p>

<p><span>I also
tried</span>&nbsp;<span>Csla.<span>ApplicationContext.</span><span>Clear();&nbsp;</span></span><span>and then resetting the User to
the current principal, but that still fails the if statement because it is
checking by reference against the last User.</span><o:p></o:p></p>

<p><span>I'm not
sure how to handle this yet. Any suggestions would be great. I will continue my
investigation at the same time.</span><o:p></o:p></p>

<p><span>-Jeff</span>&nbsp;<o:p></o:p></p>

<p class=MsoNormal><br>
<br>
<o:p></o:p></p>

</div>

</div>



</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
