<html><header><title>Using Windows authentication with a custom principal</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Using Windows authentication with a custom principal</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/844.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>albruan posted on Tuesday, August 08, 2006</h2><P>I've reread the appropriate sections regarding IIdentity and IPrincipal in Rocky's book, but I'm still having a problem trying to use custom authorization with Windows authentication in a WinForms project.</P>
<P>My client is wanting to dispense with having to key in a username/password combination to access the application I'm creating for them, so I'll be&nbsp;authenticating users via&nbsp;either Active Directory or Windows authentication.&nbsp; Due to granularity issues, I'm&nbsp;including a HasPermissions method, which acts similar to the IsInRole method,&nbsp;in a custom principal class based on the BusinessPrincipalBase.&nbsp; The problem I'm encountering is in trying to&nbsp;derive a&nbsp;custom identity from the WindowsIdentity object suitable for use in calling the HasPermissions method.&nbsp; Any ideas?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, August 08, 2006</h2>If you're using WindowsAuthentication, you need to set that in your application config.<br><br>I'm using WindowsAuth in my application; you just on start up set the User property in ApplicationContext to new WindowsPrincial( WindowsIdentity.GetCurrent() ).&nbsp; You should then just use the existing IsInRole method and create groups or roles as normal in active directory.&nbsp; Granualrity likely means you need more groups, or to actually use Roles (they are defined differently).<br><br>So, no need to write any custom objects; just use WindowsPrincipal and WindowsIdentity.<br><br>HTH<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>albruan replied on Tuesday, August 08, 2006</h2><P>I thought I'd clarify my original post somewhat.&nbsp; I'm not having problems getting the custom principal as my Login routine includes the following section of code just prior to returning windowsIdentity.IsAuthenticated to the caller:</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (windowsIdentity.IsAuthenticated)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CustomPrincipal principal = new CustomPrincipal(windowsIdentity);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Csla.ApplicationContext.User = principal;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</P>
<P>The&nbsp;real problem&nbsp;lies in trying to obtain a CustomIdentity for the user inside the HasPermissions method; said&nbsp;method being used to check whether someone is in a particular role for a particular department.&nbsp; A department manager in a department can add/delete/update items at the departmental level, whereas someone in the same department with less authority is&nbsp;only able to&nbsp;read departmental&nbsp;items.&nbsp; IsInRole would work perfectly if that was all there was to it.&nbsp; The fly in the ointment is that a department manager may be called on to lend assistance to another department as, say, an estimator; in such a case, the user shouldn't be allowed to do anything other than read departmental items.&nbsp; I need to be able to make a call similar to HasPermissions("Architectural", "DeptMgr") to see if the user is the department manager for the Architectural department.&nbsp; I'm not having any problems at all if I&nbsp;use custom authentication and authorization, in which HasPermissions is defined as:<BR><BR>&nbsp;&nbsp;&nbsp;public bool HasPermissions(string department, string role)<BR>&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CustomIdentity identity = (CustomIdentity)this.Identity;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return HasPermissions(department, role);<BR>&nbsp;&nbsp;&nbsp;}</P>
<P>BTW, the client isn't sure yet whether or not they're going to implement AD; it's one of several things they're looking at doing sometime in the future.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>esteban404 replied on Tuesday, August 08, 2006</h2><P>I've taken our's to a bit more hybrid approach.</P>
<P>I authenticate to the network then use a custom build for responsibilities within the application. I needed multiple levels of access so that we could build an audit trail that would satisfy quality standards for team involvement and authorization of specialized work. Basically, it it requires a Chemist, a lab tech can't sign off.</P>
<P>It has worked well, though I think in .NET 2.0 with CSLA 2.x it would work a hell of a lot better. Right now I've got a Frankenstein CSLA 1.53 with enhancements from CSLA 2.0 to help fill the gaps for field level authorization.</P>
<P>I anticipate&nbsp;users thinking it's too restrictive to make people who are supposed to do something do their job, so it'll allow anyone on the team to authorize and it logs who, what when and why. It has passed two internal TS16949 audits, an internal AS9100&nbsp;and I'm getting a DOD review soon from our "internal spooks".</P>
<P>_E</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
