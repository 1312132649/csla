<html><header><title>Hopefully common object modeling problem</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Hopefully common object modeling problem</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10210.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>willrogers posted on Monday, March 28, 2011</h2><p>Hello, and thanks in advance for your time. </p>
<p>We are using CSLA 3.5.1, although, ultimately, this problem may not have much to do with CSLA.</p>
<p>My company has gone a long way down the road of a common modeling error and is finally having to face it. I&#39;ve simplified the domain objects below to clarify the problem:</p>
<p>We have 3 classes defined as such:</p>
<p>class Person&lt;T&gt; : BusinessBase&lt;T&gt;</p>
<p>class Student : Person&lt;Student&gt;</p>
<p>class Teacher : Person&lt;Teacher&gt;</p>
<p>We are using NHibernate for our ORM, and the Student and Teacher classes are joined subclasses of Person in our mappings (we have Person, Student, and Teacher tables), using the PersonID as a derived key.</p>
<p>The problem, as you may have anticipated, is now we have a situation where a Student can also be a Teacher. Under the current object and data models, this causes a primary key violation when we try to add a Student that is already a Teacher or vice-versa.</p>
<p><strong>Question One: </strong>Is there any CSLA magic I can perform on the business object before saving the new record to prevent this situation?</p>
<p>If not...</p>
<p>In researching this problem, I&#39;ve seen two suggestions to solve it, The first is to favor composition over inheritance. To my understanding, this means Student and Teacher would each contain a Person property.<br /> <strong><br />Question Two:</strong> In order to get this to work, is it correct to assume the Student and Teacher tables would need a foreign key into the Person table? I guess I don&#39;t have a complete understanding of this solution, and would like some guidance.</p>
<p>The second solution involves thinking of Student and Teacher as Roles a given person plays. From what I&#39;ve seen, the Person class would need a Roles collection, and link table (PersonRoles?) is used to map the records in the Student and Teacher tables to the Person.</p>
<p><strong>Question(s) Three: </strong>What do the Role base class and the PersonRoles table look like?<strong>&nbsp;</strong>I believe the Student and Teacher subclasses would just contain their appropriate properties. Is this correct?</p>
<p>Any opinions on a solution? If anyone can find a fleshed-out example on the web, I&#39;d love to see it.</p>
<p>Thanks,</p>
<p>Will.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>ajj3085 replied on Monday, March 28, 2011</h2><p>I&#39;ve found NHibernate to be too constraining when trying to directly map your BOs to the database, for this exact reason.&nbsp; EF might be better in this regard, as I believe the mappings are a bit more advances (it looks to me like you map your tables, map your BOs, then a third map links the two), but I think there will simply always be things you can&#39;t just map away.</p>
<p>We hit similar pain at work, and other problems came up as a result of directly mapping our BOs with NH.&nbsp; Our solution was to create classes to match the table structure, map those in NH,&nbsp;and then load our BOs from those classes.&nbsp; When saving we did the opposite; rebuilding the data classes and having NH save those.</p>
<p>Basically you follow the same pattern as you would if you were using raw ado.net but instead of pulling each properties value out of a dictionary, you can pull it out of the data class&#39; property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>willrogers replied on Monday, March 28, 2011</h2><p>Thanks for your reply, Andy. Unfortunately, we&#39;re welded to NHibernate as we have 75 or more mappings complete and working with it. My gut tells me the problem is in the domain model, not in the data layer.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, March 29, 2011</h2><p>Your gut is right.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>CSLA objects should be modeled to fit the business process/use case, not the database design.&nbsp; Business objects are there to do the job the application needs, regardless of how the data the application works with is stored.&nbsp; Build your objects to fit the use case in question, and then create a separate mapping layer for NHibernate, like Andy did for his app.&nbsp; Then you can populate your CSLA BO&#39;s from your mapping classes.</p>
<p>Also remember that while reuse is a goal of OOD, it isn&#39;t an overarching goal.&nbsp; You&#39;ll find a lot of discussions on this topic here in the forum, but basically what it boils down to is that an inheritance hierarchy creates very tight coupling, so you need to be absolutely sure that the functionality in your base classes is used (and is correct) for all your subclasses.&nbsp; But you also need a good definition of &quot;functionality in your base classes&quot;.</p>
<p>If you read Rocky&#39;s posts, you&#39;ll find that things like properties are <strong>not</strong> &quot;base class functionality&quot;, because they don&#39;t do anything - they&#39;re boilerplate.&nbsp; You can also make an argument that common data-access code is not &quot;base class functionality&quot; as well.&nbsp; That can&nbsp;a little more nebulous, because that code doesn&#39;t directly serve the business purpose - but without persisted data, your app may not be worth a whole heck of a lot.&nbsp; You&#39;ll also find some people say that if you have to do the same thing to an object, rather than put it in a base class, you factor that out into a separate class and deal with it that way.&nbsp; That is a form of composition, though not necessarily in the strict sense.</p>
<p>I can&#39;t speak for the majority of the group, but I find my CSLA object graphs to be pretty shallow.&nbsp; I don&#39;t have a lot of base classes beyond the layer that Rocky recommends - which is to create a set of base classes that inherit from the CSLA types but don&#39;t add any functionality.&nbsp; This provides a &quot;seam&quot; against change in the CSLA framework, and also provides you a place to put your common application-specific functionality.&nbsp; But most of the time, that&#39;s it.&nbsp; I don&#39;t create very deep object hierarchies anymore.</p>
<p>In terms of your specific problem, without knowing more about the problem domain, it&#39;s a little hard to suggest a solution.&nbsp; From a database perspective, it appears that you&#39;ve made the assumption that a Person record links with either one Student record or one Teacher record, and that&#39;s no longer the case.&nbsp; Fixing that requires more code in your data layer, and possibly a database change as well, depending on how your keys are constructed.&nbsp; There is, unfortunately, no &quot;CSLA magic&quot; that&#39;s going to help that.&nbsp; But in terms of discussing whether you should have Student/Teacher classes, or Student/Teacher roles - well, that depends on the problem domain.&nbsp; At first blush, I&#39;d tend to go with the role concept, but a lot of that depends on what students and teachers can do, and what a &quot;hybrid&quot; person (someone who is both a student and a teacher) can do - because I can&#39;t necessarily assume that said hybrid can do everything.</p>
<p>Given the amount of road you&#39;ve already walked down, you&#39;re also going to have to evaluate whether you have the time/money/etc. to potentially back up a significant amount to change your database (and domain object) structure...</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>willrogers replied on Tuesday, March 29, 2011</h2><p>Thanks for the input, Scott.</p>
<p>To expound a bit on our design, we&#39;ve got a layer of Data Transfer Objects (DTOs) between the DB and the Business Objects (BOs). The NHibernate mappings map the DTOs to the database structure, and then we have mappings from our DTOs to our BOs. So we&#39;ve structured flexibility into our design but unfortunately haven&#39;t taken good advantage of it.</p>
<p>Given how far along we are with this project, we&#39;re looking for a minimal refactor here. With the understanding that Student and Teacher are analogs to our domain-specific entities, the reality is (e.g.,) that our &quot;Student&quot; is a generalized and very widely used BO that we can&#39;t afford to refactor. Our &quot;Teacher&quot; class, however, is much more purposefully used and frankly is not referenced as often. Given all of this, it&#39;s safest for us is to concentrate our efforts on the Teacher class. Changes can be made to the Person class, I believe, as long as the Student class usage doesn&#39;t require refactoring.</p>
<p>So we&#39;ve gone down the wrong path and are unable to completely undo it. Our hope is we can correct things in the Teacher-Person relationship, and follow this model with any future usage of the Person class.</p>
<p>I&#39;m still not sure which direction we&#39;re going to take it. I&#39;ll be talking to the architect in the near future.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, March 29, 2011</h2><p>Oh, so it sounds like you&#39;re not mapping your Csla based objects directly with NHibernate?&nbsp; So you have a PersonData which is mapped, and a StudentData and TeacherData, which are also mapped (NHibernate subclass I&#39;d imagine)?</p>
<p>Can you change the StudentData and TeacherData so that they no longer inherit PersonData, but instead point to&nbsp;a PersonData?&nbsp; I don&#39;t believe that would change your database design (or you could still keep it working), but you would have to change code in your DataPortal_xyz methods to use the new relationship.&nbsp; No reason you can&#39;t do this:</p>
<p>// In DP_insert</p>
<p>var studentDto = new StudentData { Person = new PersonData { PersonId = Id, FirstName = FirstName }, GPA = 3 };</p>
<p>Does that make sense?</p>
<p>This answer to your question on SO is what I was getting at:&nbsp; <a href="http://stackoverflow.com/questions/5461564/need-domain-modeling-advice-hopefully-common-scenario/5464974#5464974">http://stackoverflow.com/questions/5461564/need-domain-modeling-advice-hopefully-common-scenario/5464974#5464974</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Tuesday, March 29, 2011</h2><p>Well... if you can&#39;t refactor Student, and you can&#39;t break the current inheritance chain, you&#39;re not left with a lot of options.</p>
<p>1. Duplicate the required Student functionality within Teacher.&nbsp; Not a great idea, but it is probably the fastest solution.</p>
<p>2.&nbsp;Pull out the duplicate functionality into a separate class, and reference that class within both Student and Teacher.&nbsp; That doesn&#39;t change the signature of Student - it just delegates to the separate class -&nbsp;but it eliminates the duplication (and potentially gets you the &quot;favor composition over inheritance&quot; buzzphrase as well.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" />)&nbsp; Whether you want to make that shared class an instance inside your Student and Teacher classes, or a kind of static service class that acts on your Student and Teacher instances, depends on what it needs to do, and your architectural preferences.</p>
<p>If you consider #2, I would not&nbsp;assume you can put&nbsp;the shared functionality within Person.&nbsp;&nbsp;It&#39;s the obvious choice, and there&#39;s nothing intrinsically wrong with it.&nbsp; Just be sure that if you ever create a different kind of Person subclass (GraduateAssistant?) that the functionality will be needed there - or that you build in the time to&nbsp;restructure your class hierarchies.&nbsp; <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bowman74 replied on Wednesday, March 30, 2011</h2><p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Will, </span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">It sounds like you are generally dealing with your classes either as Students or Teachers but not generally directly as the type &quot;Person&quot;. You have also stated that you want to do this with a minimum of refactoring of your existing code.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">If this is the case then what you are really trying to maintain are the public properties and methods exposed by the Student and Teacher classes (including any inherited public methods). Or put another way, you don&#39;t want to refector the code that uses the Student class but changes could be done to the student class that are not visible externally.&nbsp; There is a way to do this but I want to state upfront that there are several drawbacks and this is not how I would design it from scratch. Having said that, as you are well aware there is not always an intersection between the optimal design and the design project constraints allows you to do.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Ok, this is what you could do; use containment and delegation. Modify your Student and Teacher classes so they no longer inherit from Person. Then add all of the public Person property and method signatures to the Student and Teacher classes and add implementation code so that they call into a contained Person class. I.e. the Student and Teacher classes would be top level classes that call into a single child, a Person. Back in the COM days we used to jokingly refer to this as manual inheritance.&nbsp; All of your external implementation code that deals with these classes won&#39;t know the difference as long as they were not dealing with them as type person.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">You would also have to add a new constructor to create new Students and Teachers (to the correct classes) that are existing people in your system. These constructors would take a PersonId as an extra parameter for a new Student/Teacher that would load the appropriate contained class. So all the metadata specific to the Student/Teacher would be new but the contained Person object would not be (as you know this has a big impact on how they persist).</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">There are several drawbacks to this approach and this is not an exhaustive list by any means:</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">1) Your Student and Teacher classes will no longer to be as type Person, so if you are passing them around as type Person that means more refactoring that you are trying to stay away from.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">2) Any new public properties/methods on the Person class will have to also be mirrored out on the Student and Teacher classes (hence, the manual inheritance joke).</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">3) You will still be dealing with the entity behavior wise as either a Student or a Teacher. They both can be the same underlying person but you either fetch them as one or the other. If this will be a problem will depend on your use cases.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">I can&#39;t tell you if this will work for you as I don&#39;t know enough about your problem. At least it sounds like it will superficially meet your needs and avoid a lot of refactoring. This isn&#39;t what I would do from scratch but life sometimes is what it is.</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Thanks,</span></p>
<p><span style="font-family:&#39;Arial&#39;,&#39;sans-serif&#39;;color:black;font-size:9pt;">Kevin</span></p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
