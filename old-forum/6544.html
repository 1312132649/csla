<html><header><title>Single Sign-On in ASP.NET and Silverlight</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Single Sign-On in ASP.NET and Silverlight</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6544.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH posted on Monday, March 02, 2009</h2><P>Hi,</P>
<P>I am using&nbsp;CLSA Light to build a Silveright app whose design calls for Single Sign-On (SSO). The goal is to protect the .aspx page that is hosting the Silverlight control with ASP.NET Forms Authentication.&nbsp;The user should only have to log in to the ASP.NET Forms Login page once and not have to log in again when the Silverlight app is loaded. </P>
<P>For SSO to be achieved, I'm thinking that somehow I need to set <EM>Csla.ApplicationContext.User</EM> to&nbsp;the valid <EM>Principal</EM> object (stored in <EM>HttpContext.Current.User</EM>) that was created when the user logged into the Forms login page.&nbsp;The Silverlight app needs a valid Principal object to leverage the CLSA authorization features.&nbsp;That said, I'm not really sure how to get access to the&nbsp;<EM>HttpContext.Current.User</EM> set by ASP.NET Forms Authentication or even if this is the right approach?</P>
<P>It seems wrong to force the user to have to log in to the Forms Login page and then login again within the Silverlight app.</P>
<P>Any ideas would be greatly appreciated!</P>
<P>Thanks, Richard</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, March 03, 2009</h2><P>This should be pretty easy, assuming the data portal is hosted in the same web app the user logged in to.</P>
<P>As your SL app starts up, just send a "login" request through the data portal and have that request return the Csla.ApplicationContext.User value. That object is serializable by definition, so it should just flow back to the SL client.</P>
<P>You can retrieve it using a CommandBase or ReadOnlyBase object - just put the server's IPrincipal object into a property of the business object, and when it gets back to the client set Csla.ApplicationContext.User to this value.</P>
<P>Something more or less like this:</P>
<BLOCKQUOTE dir=ltr>
<P>using System;<BR>using System.Security.Principal;<BR>using Csla;<BR>using Csla.Serialization;</P>
<P>[Serializable]<BR>public class PrincipalGetter : ReadOnlyBase&lt;PrincipalGetter&gt;<BR>{<BR>&nbsp; public static void BeginLogin()<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; var dp = new DataPortal&lt;PrincipalGetter&gt;();<BR>&nbsp;&nbsp;&nbsp; dp.FetchComplete += (o, e) =&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e.Object != null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Csla.ApplicationContext.User = e.Object.User;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<BR>&nbsp;&nbsp;&nbsp; dp.BeginFetch();<BR>&nbsp; }</P>
<P>&nbsp; public static PropertyInfo&lt;IPrincipal&gt; UserProperty = <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterProperty&lt;IPrincipal&gt;(c =&gt; c.User);<BR>&nbsp; public IPrincipal User<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; get { return ReadProperty(UserProperty); }<BR>&nbsp;&nbsp;&nbsp; private set { LoadProperty(UserProperty, value); }<BR>&nbsp; }</P>
<P>#if !SILVERLIGHT</P>
<P>&nbsp; private void DataPortal_Fetch()<BR>&nbsp; {<BR>&nbsp;&nbsp;&nbsp; this.User = Csla.ApplicationContext.User;<BR>&nbsp; }</P>
<P>#endif<BR>}</P></BLOCKQUOTE>
<P>This presupposes your server-side principal and identity objects inherit from CSLA base classes and use managed property values so they can be serialized to the SL client.</P>
<P>Just make sure to call BeginLogin() as your SL app starts up. And you may need to add some code to make sure the user can't start interacting with the app until this returns (remember it is async).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Tuesday, March 03, 2009</h2><P>Perfect! Thanks Rocky! That's what I was slowly coming to the conclusion I needed to do. Thanks for taking the time to put together the example. It's just what I need.</P>
<P>Cheers!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Tuesday, March 03, 2009</h2><P>Hi Rocky, </P>
<P>I've had a chance to implement your suggestion to retrieve the principal using a <EM>ReadOnlyBase </EM>object, but for some reason, in the <EM>DataPortal_Fetch</EM> method the <EM>Csla.ApplicationContext.User</EM> property is always set to<EM>&nbsp; {Csla.Security.UnauthenticatedPrincipal}</EM>. At this point even the <EM>HttpContext.Current.User</EM> property on the server is set to<EM>&nbsp; {Csla.Security.UnauthenticatedPrincipal}.</EM> I would have expected a valid authenticated instance of a principal object.</P>
<P>I have the data portal hosted in the same web app that I logged in to. I am also able to access a valid <EM>HttpContext.Current.User</EM> object from a test ASP.NET page in the same site. I can't seem to figure out why the <EM>Csla.ApplicationContext.User </EM>is not set since I see in the ApplicationContext class that if the <EM>HttpContext.Current != null</EM>,&nbsp;it will be&nbsp;used to set the <EM>Csla.ApplictionContext.User</EM>.&nbsp;Does the framework ever reset the principal stored in <EM>HttpContext.Current.User</EM>?</P>
<P>I'm new to CSLA so I'm likely missing something simple. I've pasted my custom PrincipalGetter class below:</P>
<P>Thanks very much!</P>
<P>Richard<BR>______________________________</P><FONT color=#0000ff size=2><FONT color=#0000ff size=2>
<P>using</FONT></FONT><FONT size=2> System;<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>using</FONT></FONT><FONT size=2> System.Security.Principal;<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>using</FONT></FONT><FONT size=2> Csla;<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>using</FONT></FONT><FONT size=2> Csla.Serialization;</P></FONT>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2>namespace</FONT></FONT><FONT size=2> CeCslaAppPrototype.Business.Security<BR>{<BR><FONT color=#0000ff>&nbsp; </FONT>[</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Serializable</FONT></FONT><FONT size=2>]<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>class</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2> : </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ReadOnlyBase</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2>&gt;<BR><FONT color=#0000ff>&nbsp; </FONT>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> BeginLogin(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventHandler</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventArgs</FONT></FONT><FONT size=2>&gt; completed)<BR><FONT color=#0000ff>&nbsp;&nbsp;</FONT>&nbsp; {<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var</FONT></FONT><FONT size=2> dp = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortal</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2>&gt;();<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;</FONT>&nbsp; dp.FetchCompleted += (o, e) =&gt;<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;</FONT>&nbsp; {<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</FONT></FONT><FONT size=2> (e.Object != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>)<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT>&nbsp; {<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT>&nbsp; Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ApplicationContext</FONT></FONT><FONT size=2>.User = e.Object.User;<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>completed(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>, </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventArgs</FONT></FONT><FONT size=2>.Empty);<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>}<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>};<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>dp.BeginFetch();<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>}</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PropertyInfo</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>&gt; UserProperty =&nbsp;<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>RegisterProperty(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PropertyInfo</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>&gt;(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"User"</FONT></FONT><FONT size=2>, </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"User Principal"</FONT></FONT><FONT size=2>));</P>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; public</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2> User<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get</FONT></FONT><FONT size=2> { </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> GetProperty(UserProperty); }<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set</FONT></FONT><FONT size=2> { LoadProperty(UserProperty, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>value</FONT></FONT><FONT size=2>); }<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>}</P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>
<P>&nbsp;&nbsp;&nbsp; #if</FONT></FONT><FONT size=2> !SILVERLIGHT<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> DataPortal_Fetch()<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>{<BR><FONT color=#008000 size=2><FONT color=#008000 size=2><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>// This is always {Csla.Security.UnauthenticatedPrincipal}&nbsp;</FONT></FONT><BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this</FONT></FONT><FONT size=2>.User = <FONT color=#ff0000>Csla.</FONT></FONT><FONT size=2><FONT color=#ff0000 size=2>ApplicationContext</FONT></FONT><FONT size=2><FONT color=#ff0000>.User;&nbsp;</FONT><BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>}<BR></FONT><FONT size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; #endif<BR></FONT></FONT><FONT size=2><FONT color=#0000ff>&nbsp; </FONT>}<BR>}</P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, March 03, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>The thing you are missing is an ASP.NET thing, not a CSLA thing.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I don&#8217;t remember the setting off the top of my head, but
you need to tell the WCF service (the data portal host) to use the user
identity of the ASP.NET process.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I think one or two of our security samples does this. Certainly the
Windows one does, though it is using a Windows identity rather than a
membership identity.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Wednesday, March 04, 2009</h2><P>Hi Rocky, that makes sense now and I've been trying to locate the examples you mentioned but couldn't find them. Sorry to have to ask, but could you point me at the examples you were thinking of so I can dig into this further?</P>
<P>In the meantime I did some research and I believe the settings that I need to enable in the <EM>Web.Config</EM> are as follows:</P>
<P>Under <EM>system.serviceModel</EM> add the following to enable allow access to the HttpContext:<BR><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&lt;</FONT></FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>serviceHostingEnvironment</FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2> </FONT></FONT><FONT color=#ff0000 size=2><FONT color=#ff0000 size=2>aspNetCompatibilityEnabled</FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>=</FONT></FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>true</FONT></FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>/&gt;</P></FONT></FONT>
<P>Under <EM>ServiceBehaviors</EM> add the following to enable impersonation:<BR><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&lt;</FONT></FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>serviceAuthorization</FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2> </FONT></FONT><FONT color=#ff0000 size=2><FONT color=#ff0000 size=2>impersonateCallerForAllOperations</FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>=</FONT></FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>true</FONT></FONT><FONT size=2>"</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>/&gt;</FONT></FONT></P>
<P>However, enabling the <FONT color=#ff0000 size=2>impersonateCallerForAllOperations </FONT>setting causes the following exception to be raised in the <EM>EndFetch </EM>method in the <EM>WcfPortalClientChannel</EM> class in the CSLA Light framework: </P>
<P><FONT size=2>&nbsp;&nbsp; at System.ServiceModel.AsyncResult.End[TAsyncResult](IAsyncResult result)<BR>&nbsp;&nbsp; at System.ServiceModel.Channels.ServiceChannel.SendAsyncResult.End(SendAsyncResult result)<BR>&nbsp;&nbsp; at System.ServiceModel.Channels.ServiceChannel.EndCall(String action, Object[] outs, IAsyncResult result)<BR>&nbsp;&nbsp; at System.ServiceModel.ClientBase`1.ChannelBase`1.EndInvoke(String methodName, Object[] args, IAsyncResult result)<BR>&nbsp;&nbsp; at Csla.WcfPortal.WcfPortalClient.WcfPortalClientChannel.EndFetch(IAsyncResult result)<BR>&nbsp;&nbsp; at Csla.WcfPortal.WcfPortalClient.Csla.WcfPortal.IWcfPortal.EndFetch(IAsyncResult result)<BR>&nbsp;&nbsp; at Csla.WcfPortal.WcfPortalClient.OnEndFetch(IAsyncResult result)<BR>&nbsp;&nbsp; at System.ServiceModel.ClientBase`1.OnAsyncCallCompleted(IAsyncResult result)</FONT></P>
<P>If I disable the <FONT color=#ff0000 size=2>impersonateCallerForAllOperations </FONT>setting, the exception is no longer raised but it still gives a&nbsp;Null <EM>HttpContext.Current.User</EM> principle object in the DataPortal_Fetch method. Is it possible that the account WCF is impersonating does not have permissions to call the server?</P>
<P>This seems to be proving tricky for me&nbsp;to sort out, likely because this is my first real attempt at using WCF...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, March 04, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>The security &#8220;samples&#8221; are actually in the test
download, because we created them to test the various authn models, not really
as samples.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

<p class=MsoNormal><b><span><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Wednesday, March 04, 2009</h2><P>Even through I'm using ASP.NET Forms Authentication instead of Windows auth, it appears I have my project configured correctly in the web.config. I can't see anything obvious in the security test examples that tells WCF to use the user identity&nbsp;of the ASP.NET process.&nbsp;I also confirmed that the WCF and ASP.NET are both running in the same AppDomain on the server. Based on what I have been reading, all you should have to do is enable&nbsp;asp.net compatibility in order to gain access to the HttpContext in WCF (<FONT size=2><FONT color=#0000ff>&lt;</FONT><FONT color=#a31515><FONT color=#a31515>serviceHostingEnvironment</FONT></FONT><FONT color=#0000ff><FONT color=#0000ff> </FONT></FONT><FONT color=#ff0000><FONT color=#ff0000>aspNetCompatibilityEnabled</FONT></FONT><FONT color=#0000ff><FONT color=#0000ff>=</FONT></FONT>"<FONT color=#0000ff><FONT color=#0000ff>true</FONT></FONT>"<FONT color=#0000ff><FONT color=#0000ff>/&gt;</FONT></FONT><FONT color=#000000 size=3>).</FONT></FONT></P>
<P>I plan to dig into this more tonight and I'll probably setup a simplified WCF service to test this outside of CSLA and make sure I can get that working first. I'm sure it's something simple I'm missing... security is fun!</P>
<P>Thanks for help so far Rocky!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Wednesday, March 04, 2009</h2><P>Ok, so I think I have some more useful information on this problem. </P>
<P>It appears the issue is actually&nbsp;not with my ASP.NET configuration rather it is&nbsp;in the CSLA Silverlight <EM>Csla.Server.Hosts.Silverlight.WcfPortal</EM> class. I determined this because if I add a new WCF service to my web site and enable aspnet compatibility (as above), code in the WCF service is able to access the HttpContext no problem (so I'm not crazy!;)</P>
<P>When the <EM>Fetch(CriteriaRequest request)</EM>&nbsp;method is called by the data portal, the <EM>SetContext()</EM> method is called and a <EM>request</EM> object from the client (I'm assuming - sorry I'm new) is passed in. The <EM>SetContext()</EM> method then&nbsp;does the following:</P>
<P><EM>ApplicationContext.User = (IPrincipal)MobileFormatter.Deserialize(<STRONG>request.Principal</STRONG>);</EM></P>
<P>If I inspect the <EM>ApplicationContext.User</EM> prior to the above&nbsp;assignment, it contains a valid <EM>{System.Web.Security.RolePrincipal} </EM>object which is what I am after! However,&nbsp;after the assignment operation is complete, <EM>HttpContext.Current.User </EM>and <EM>Thread.CurrentPrincipal&nbsp;</EM>is overwritten and is set to a <EM>{Csla.Security.UnauthenticatedPrincipal}</EM> object.</P>
<P>It seems that the Silverlight WcfPortal assumes and expects to receive a valid authenticated Principal object in the request from the client, so it doesn't appear that it will be possible to send a "login" request through data portal and have that request return the <EM>Csla.ApplicationContext.User (which is really HttpContext.Current.User from ASP.NET)</EM>. </P>
<P>I don't really know what the implications of this would be, but would it make more sense to prevent overwriting the HttpContext.Current.User principal (if it contains an authenticated Principal object) with an unathenticated Csla security Principal object?</P>
<P>The way I see it now, there is no way to accomplish my goal of Single Sign-On unless I stick with creating a separate non-Csla WCF Service to retrieve the HttpContext. (Wow, this is great! I feel like I'm learning lots!:)</P>
<P>Thoughts?</P>
<P>Thanks! </P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, March 04, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>That is interesting. Yes, I see exactly what you are saying.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>I would prefer to support your scenario directly, though I&#8217;m
not entirely sure what the solution should be. <o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Some sort of rule on whether to impersonate the client identity
on the server seems like the answer, though I don&#8217;t know if it can be as
arbitrary as looking at whether there&#8217;s already an authenticated
principal on the server. That&#8217;d be a pretty simple answer though :)<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Thursday, March 05, 2009</h2><P>It kind of makes sense to me that you could make some kind of a rule on the server that would always return the authenticated HttpContext.Current.User principal on the server when <EM>aspNetCompatibilityEnabled="true"</EM>. </P>
<P>You wouldn't always have an authenticated <EM>HttpContext.Current.User </EM>principal object anyways... only when <EM>aspNetCompatibilityEnabled="true"</EM> in the web.config. The rest of the time it would be null I think.</P>
<P>If someone has aspNetCompt enabled, I suspect an assumption could be made that their intention was that they wanted&nbsp;to access/share the principal set by ASP.NET with the WCF data portal.</P>
<P>Hopefully that suggestion is not way off-base. I'm really new to CSLA but plan to use it for a new Silverlight project so hopefully my knowledge of Csla will improve quickly so I can provide more valuable feedback in the future.</P>
<P>Cheers, Richard</P>
<P>P.S. If you were to add support for this scenario to Csla.net, what version&nbsp;would you expect it to appear in? I think it's a pretty valuable feature.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, March 05, 2009</h2>






 





<div class=Section1>

<p class=MsoNormal><span>I&#8217;m adding this to the wish list. Version 3.6.2 is
feature-complete at this point, so some resolution to this will likely be in
3.6.3.<o:p></o:p></span></p>

<p class=MsoNormal><span><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span>Rocky<o:p></o:p></span></p>

</div>



</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Thursday, March 05, 2009</h2><P>Great, thanks for doing that Rocky! I always hate doing it, but until then I'll likely just tweak the latest framework myself so it does what I need then make the changes necessary when the new feature is available in a future Csla release.</P>
<P>Thanks for all of you help with this. It's nice to know there's support behind the framework!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Friday, March 06, 2009</h2><FONT size=2>
<P>So I have had requests to publish my progress with this since it seems like a common scenario others are running into.&nbsp;However I have hit another stumbling block and haven't found a solution yet. </P>
<P>I am only using Forms authentication, so what I am attempting to do is modify the Csla framework (until the enhancement is made) to prevent overwriting the <EM>ApplicationContext.User </EM>principal with a <EM>UnauthenticatedPrincipal&nbsp;</EM>principal found in the request from the Silverlight client by modifying the <EM>Csla.Server.Hosts.Silverlight.WcfPoral </EM>class as follows:</P>
<BLOCKQUOTE dir=ltr>
<P><FONT color=#0000ff size=2><FONT color=#0000ff size=2>private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> SetContext(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>CriteriaRequest</FONT></FONT><FONT size=2> request)<BR>{<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp; ApplicationContext</FONT></FONT><FONT size=2>.SetContext((</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ContextDictionary</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.ClientContext), (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ContextDictionary</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.GlobalContext));<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp; IPrincipal</FONT></FONT><FONT size=2> principal = (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.Principal);<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; if</FONT></FONT><FONT size=2> ((principal.GetType() != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>typeof</FONT></FONT><FONT size=2>(Csla.Security.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>UnauthenticatedPrincipal</FONT></FONT><FONT size=2>)) &amp;&amp; (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>HttpContext</FONT></FONT><FONT size=2>.Current.User != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>) &amp;&amp; </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>HttpContext</FONT></FONT><FONT size=2>.Current.User.Identity.IsAuthenticated)<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp;&nbsp;&nbsp; ApplicationContext</FONT></FONT><FONT size=2>.User = principal;<BR>}</FONT></P></BLOCKQUOTE>
<P>With the above change, the ApplicationContext.User is not overwritten and is now available to return to the client. </P>
<P>The next issue becomes returning a Principal object in my <EM>PrincipalGetter </EM>business object that I created (see below). If I create a managed backing field to return the principal I get the following error from the <EM>MobileFormatter </EM>class:</P>
<BLOCKQUOTE dir=ltr>
<P><EM>Type 'System.Web.Security.RolePrincipal' with data contract name 'RolePrincipal:http://schemas.datacontract.org/2004/07/System.Web.Security' is not expected. Add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to DataContractSerializer.</EM></P></BLOCKQUOTE>
<P>It seems that the <EM>MobileFormatter</EM> does not understand how to serialize the <EM>RolePrincipal </EM>object that is now stored in my <EM>PrincipalGetter </EM>class (shown below). I'm not sure how I can get the RolePrincipal serialized and sent back to the client? </P>
<P>Any guidance would be greatly appreciated!</P>
<P>Thanks, Richard</P>
<P><STRONG>More info:</STRONG></FONT><FONT size=2></FONT></P>
<P><FONT size=2>The PrincipalGetter ReadOnlyBase object is defined as follows:</FONT></P><FONT size=2><FONT color=#0000ff size=2><FONT color=#0000ff size=2>
<BLOCKQUOTE dir=ltr>
<P></FONT></FONT><FONT size=2>[</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>Serializable</FONT></FONT><FONT size=2>]<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>class</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2> : </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ReadOnlyBase</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2>&gt;<BR>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; public</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> BeginLogin(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventHandler</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventArgs</FONT></FONT><FONT size=2>&gt; completed)<BR>&nbsp; {<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; var</FONT></FONT><FONT size=2> dp = </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>DataPortal</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PrincipalGetter</FONT></FONT><FONT size=2>&gt;();<BR>&nbsp;&nbsp;&nbsp; dp.FetchCompleted += (o, e) =&gt;<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</FONT></FONT><FONT size=2> (e.Object != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>)<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>{<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ApplicationContext</FONT></FONT><FONT size=2>.User = e.Object.User;<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>completed(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>, </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>EventArgs</FONT></FONT><FONT size=2>.Empty);<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT>}<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>};<BR><FONT color=#0000ff>&nbsp;&nbsp;&nbsp; </FONT>dp.BeginFetch();<BR><FONT color=#0000ff>&nbsp; </FONT>}<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>static</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PropertyInfo</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>&gt; UserProperty = RegisterProperty(</FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>new</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>PropertyInfo</FONT></FONT><FONT size=2>&lt;</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>&gt;(</FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"User"</FONT></FONT><FONT size=2>, </FONT><FONT color=#a31515 size=2><FONT color=#a31515 size=2>"User Principal"</FONT></FONT><FONT size=2>));<BR><FONT color=#0000ff>&nbsp; </FONT></FONT><FONT size=2><FONT color=#0000ff size=2>public</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2> User<BR><FONT color=#0000ff>&nbsp; </FONT>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; get</FONT></FONT><FONT size=2> { </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>return</FONT></FONT><FONT size=2> GetProperty(UserProperty); }<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; set</FONT></FONT><FONT size=2> { LoadProperty(UserProperty, </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>value</FONT></FONT><FONT size=2>); }<BR><FONT color=#0000ff>&nbsp; </FONT>}</P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>
<P>&nbsp; #if</FONT></FONT><FONT size=2> !SILVERLIGHT<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> DataPortal_Fetch()<BR><FONT color=#0000ff>&nbsp; </FONT>{<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp;&nbsp;&nbsp; this</FONT></FONT><FONT size=2>.User = Csla.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ApplicationContext</FONT></FONT><FONT size=2>.User;&nbsp;<BR></FONT><FONT size=2><FONT color=#0000ff>&nbsp; </FONT>}<BR></FONT><FONT size=2><FONT color=#0000ff size=2>&nbsp; #endif<BR></FONT></FONT><FONT size=2><FONT color=#0000ff>&nbsp; </FONT>}<BR>}</P></BLOCKQUOTE></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 06, 2009</h2><P>The MobileFormatter only knows how to serialize things that implement IMobileObject (or that inherit from MobileObject, MobileList, etc - because they implement the interface).</P>
<P>The MembershipIdentity, CslaIdentity and WindowsIdentity classes in CSLA .NET all inherit from MobileObject, and so can be serialized.</P>
<P>You'll probably need to do something like the WindowsIdentity class does - which is to load itself with a copy of the data from the server-side principal/identity, because the server-side WindowsPrincipal and WindowsIdentity objects aren't serializable <EM>at all</EM>. </P>
<P>So what is on the SL client is just a copy of the server-side data, but that works because it is the same list of roles and the same username, which is all that really matters.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Wednesday, March 11, 2009</h2><P>Thanks Rocky! That was the issue. </P>
<P>I created a custom principal that derives from <EM>CslaIdentity </EM>and in&nbsp;my <EM>PrincipalGetter</EM> business object's <EM>DataPortal_Fetch() </EM>method I load the custom principal with data with from <EM>HttpContext.Current.User</EM> principal object.&nbsp;In order to get access to the HttpContext, I had to change both of the <EM>SetContext() </EM>methods in the <EM>Csla.Server.Hosts.Silverlight.WcfPortal </EM>class as follows:</P><FONT size=2>
<P></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>private</FONT></FONT><FONT size=2> </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>void</FONT></FONT><FONT size=2> SetContext(</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>CriteriaRequest</FONT></FONT><FONT size=2> request)<BR>{<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp; ApplicationContext</FONT></FONT><FONT size=2>.SetContext((</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ContextDictionary</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.ClientContext), (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>ContextDictionary</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.GlobalContext));<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp; IPrincipal</FONT></FONT><FONT size=2> principal = (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>)</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>MobileFormatter</FONT></FONT><FONT size=2>.Deserialize(request.Principal);</P>
<P></P>
<P></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>&nbsp; // Check to see if the client is already authenticated in ASP.NET. If the principal received from the client is a Csla UnauthenticatedPrincipal,<BR></FONT></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>&nbsp; // check to see if there is an authenticated principal in the HttpContext. In order for this to work, aspnet compatibility mode must be enabled and <BR></FONT></FONT><FONT color=#008000 size=2><FONT color=#008000 size=2>&nbsp; // Forms authentication must be enabled so that the HttpContext.Current.User principal is available to the WCF Data Portal service.<BR></FONT></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; if</FONT></FONT><FONT size=2> ((principal.GetType() != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>typeof</FONT></FONT><FONT size=2>(Csla.Security.</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>UnauthenticatedPrincipal</FONT></FONT><FONT size=2>)) &amp;&amp; (</FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>HttpContext</FONT></FONT><FONT size=2>.Current.User != </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>null</FONT></FONT><FONT size=2>) &amp;&amp; </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>HttpContext</FONT></FONT><FONT size=2>.Current.User.Identity.IsAuthenticated)<BR></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp;&nbsp;&nbsp; ApplicationContext</FONT></FONT><FONT size=2>.User = principal;<BR></FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>&nbsp; else<BR></FONT></FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>&nbsp;&nbsp;&nbsp; ApplicationContext</FONT></FONT><FONT size=2>.User = </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>HttpContext</FONT></FONT><FONT size=2>.Current.User </FONT><FONT color=#0000ff size=2><FONT color=#0000ff size=2>as</FONT></FONT><FONT size=2> </FONT><FONT color=#2b91af size=2><FONT color=#2b91af size=2>IPrincipal</FONT></FONT><FONT size=2>;<BR>}</P></FONT>
<P>I think I have a workable solution now, but I did hit a few more snags. Since I wanted to secure the DataPortal service AND Silverlight client app using Forms Authentication, the issue I had is that when the Forms session expires, a communication error is raised to the client because the dataportal service is unavailable. </P>
<P>To get around this, I created a new WCF service that uses the ASP.NET <EM>System.Web.ApplicationServices.AuthenticationService</EM>. This server was not protected by Forms Authentication&nbsp;and is used to handle&nbsp;requests from the Silverlight Client related to authentication.&nbsp;When an error is encountered in the Silverlight client, I can use this new service to check to see if the client is authenticated by using the <EM>IsLoggedInAsync()</EM> method of the unsecured service. If the user is no longer logged in, I can pop-up a dialog window and ask for their credentials and I can call the&nbsp;WCF service's <EM>LoginAsync()</EM> method&nbsp;to log in&nbsp;again and get a new token. This allows the user to continue with their workflow in the client app instead of having to refresh the browser window and get redirected to a Forms Login page. That would cause&nbsp;any work they may have done when the session times out to be lost. If the user is still logged in, I just pass through the original error message because I can assume it is not related to authentication.</P>
<P>My approach may not be the best approach but I think it should work for what I need. </P>
<P>I think the scenario I've been fighting with will become very common place so it may be worth trying to come up with a cleaner solution that integrates better into the CSLA framework or design patterns in the future. I've listed the key requirements I had below for future reference:</P>
<P><STRONG>Single Sign On Requirements:</STRONG></P>
<OL>
<LI>The download of the Silverlight App itself is protected by Forms Authentication. 
<LI>The Data Portal is protected by Forms Authentication. 
<LI>The user does not want to log in again to the Silverlight client application if they have already logged in using Forms Authentication prior to downloading the Silverlight app. 
<LI>If the Forms Authentication session times out, the Silverlight client must be able to prompt for credentials and let the user continue their workflow once valid credentials are entered without losing their work,&nbsp;OR cancel the request to the server if authentication failed so they can at least copy any of their work out of the app.</LI></OL>
<P>Anyways, hope this helps people out there hitting the same issues.</P>
<P>Cheers, Richard</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RobKraft replied on Tuesday, November 24, 2009</h2>Thanks Richard and Rocky for your posts on this thread.  I intend to do something similar; but I plan to put the CSLA Principal object in the session, then pull it out of the session and assign it to ApplicationContext.User.<br /><br />private void DataPortal_Fetch()<br />{<br />ApplicationContext.User = (OurPrincipal)System.Web.HttpContext.Current.Session["Principal"];<br /><br />I will pull it from the session variable any time I feel the need to "recheck" on the server side that the user credentials allow the attempted action.<br />Does this approach seem reasonable, or am I overlooking something fundamental?<br />I think this approach also reduces the risk that a hacker on the client side could forge a false identity.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, November 24, 2009</h2>You can create an authorizer (I think it is IAuthorizeDataPortal) method<br />that is invoked first-thing when a data portal call comes in from the<br />client. That way you'd always get the principal set without having to<br />remember to do it in each DataPortal_XYZ method.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Tuesday, October 04, 2011</h2><p>Has this been resolved since this discussion? I too am need SSO for a silverlight csla.net app that lives in a forms based website.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, October 04, 2011</h2><p>Yes. The <em>Using CSLA 4</em> ebook series covers this in the <em>Data Portal Configuration</em> and <em>WPF/Silverlight</em> ebooks.</p>
<p>However, there&#39;s a bug in 4.1 that blocks the scenario. That bug is resolved in 4.2. Otherwise it works as described in the <em>Data Portal Configuration</em>&nbsp;ebook.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, October 05, 2011</h2><p>&nbsp;may have just missed it, but I can&#39;t find anywhere in the DataPortal Configuration book that references single sign on for silverlight application specifically. </p>
<p>Do I just need to simply utilize the &quot;Membership&quot; authentication type? Is it that simple? Wouldn&#39;t the WCF call need to send the Forms cookie somehow etc?</p>
<p>
I think I see my problem, I&#39;m trying to run an out of browser SSO scenario. My goal was to allow the user to launch the app in two ways:</p>
<ol>
<li>while logged into the website they can launch it from the &quot;attached&quot; SL app which simply &quot;detached&quot; the app or </li>
<li>Startup &quot;detached&quot; and prompt them with credentials</li>
</ol>
<p>The goal is to prevent them from having to log in twice if they&#39;ve already logged into the website. Unfortunately, in scenario 1, once detached I can&#39;t pull from session at that point and I can&#39;t pull from Csla.ApplicationContext.User.... Looks like this is simply not possible, am I wrong?</p>
<p>
(The out of browser is somewhat of a requirement here, because the application needs access to the My Documents folder)</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 05, 2011</h2>Look at the section starting on page 100-102.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 05, 2011</h2><p>The technique works with custom and membership models (they are really the same).</p>
<p>Basically, follow these steps:</p>
<p>&nbsp;</p>
<ol>
<li>Implement a custom identity that goes to the server and retrieves the username and roles of the server-side principal (the ebook shows how to do this for membership and Windows server-side principals)</li>
<li>As the SL app starts up, immediately fetch that custom identity and put the resulting principal in ApplicationContext.User - now the client has a principal that is a copy of the server-side data - as close to the server principal as you can get really</li>
<li>Set the client-side AuthenticationType to Windows so it doesn&#39;t send the client-side principal to the server on every data portal call</li>
<li>Set the server-side AuthenticationType to Windows so it doesn&#39;t expect the client to send the principal</li>
</ol>
<p>This all works, assuming that the user has authenticated with the server before the SL app launches. Basically, if using custom or membership authentication, the user must log into the web site before the SL app is loaded. If using Windows authentication, the user must log into the web site with their Windows credentials before the SL app is loaded.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 05, 2011</h2>And again, there was a bug (fixed in 4.2) that blocked this scenario from completely working. Specifically steps 3-4 in my previous post require 4.2.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, October 05, 2011</h2><p>Thanks for the help Rocky. I must be missing something though, because I&#39;ve followed these steps explicitly, but once the PrincipalGetter gets to the server-side in the DataPortal_Fetch method, the Principal is an unauthenticated System.Security.Principal.GenericPrincipal.</p>
<p>1. Implemented custom CslaIdentity and CslaPrincipal (Didn&#39;t use membership identity because app was built before native support)</p>
<p>2. Async is made call to the PrincipalGetter class to fetch the principal values from the server as soon as the startup object is initialized</p>
<p>3. Before initializeComponent in App.xaml.cs: Csla.ApplicationContext.AuthenticationType = &quot;Windows&quot;;</p>
<p>4. Server side web.config: &lt;add key=&quot;CslaAuthentication&quot; value=&quot;Windows&quot;/&gt;</p>
<p>Logged in to the web app, loaded the SL app with breakpoint on the server-side PrincipalGetter fetch method and the principal is System.Security.Principal.GenericPrincipal rather than my custom authenticated principal. Interestingly, I tried pulling the persisted value in the Session, but found that &#39;System.Web.HttpContext.Current&#39; is null.&nbsp; Seems as though my Silverlight application isn&#39;t running in the httpcontext. I suppose this problem is non-Csla, but can anyone shove me in the right direction here?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SWITCH replied on Wednesday, October 05, 2011</h2><p>Have you checked your web.config to make sure aspNetCompatibilityEnabled=&quot;true&quot;? I once had an issue where this was not set, in which case I think HttpContext.Current is always null.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Wednesday, October 05, 2011</h2><p>Thanks SWITCH! That helps me make progress. I&#39;m now seeing the authenticated System.Web.Security.RolePrincipal in the Csla.ApplicationContext.User property. I was hoping/expecting to see my custom Principal, is there anyway to configure Csla so that my CustomPrincipal value is loaded? </p>
<p>I suppose I COULD just load the principal manually once on the server and store my needed values into the PrincipalGetter and send it back to the client (but only if the RolePrincipal was indeed properly authenticated). </p>
<p>Can I safely trust the RolePrincipal and do this? Or is there an easier way?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 05, 2011</h2>This is discussed in the Using CSLA 4: ASP.NET MVC ebook - and I think in the 2008 book too. To have your custom principal available on the web site, request after request after request, you need to implement code in global.asax.cs to reload the principal on each page request.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, October 06, 2011</h2><p>Thanks Rocky, though I am implementing the global.aspx.cs persisting code for principal. However I had forgot about one very relevant line of code that I had taken from the Sample project I snagged it from a year ago:</p>
<p>if(Csla.ApplicationContext.AuthenticationType=&quot;Windows&quot;) return;</p>
<p>I suppose this was written so that the code was smart enough to be prepared for various auth types for demonstration... but it was written before using the Windows Auth type in this way for Silverlight.</p>
<p>So, since I&#39;m not TRUELY using windows authentication&nbsp; (just doing that to &quot;trick&quot; the server to not expect the client to send the principal) I should just remove this line from my global app code, right?</p>
<p>Thanks so much yet again, Rocky!</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, October 06, 2011</h2><p>I&#39;m sorry to drag this thread on, but in taking my own advice above, it seems that DataPortalResult object is null when it gets back to the client. </p>
<p>I notice that my compress host is properly compressing the object during convertresponse, but on the compressedProxy, ConvertResponse is never getting called. Strange because this was working fine until implementing the above. :(</p>
<p>NOTE: as soon as I change the server&#39;s authtype back from &quot;Windows&quot; to &quot;Csla&quot; the proxyhost works again but the Principal on the server is now null as would be expected. What am I missing?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>decius replied on Thursday, October 06, 2011</h2><p>Got it! A stupid moment on my part. I was just missing an assembly reference. The DataPortalResult error property spelled this out for me plain as day, but it took me hooking up the CSLA source code and stepping through to realize to check those contents. Doh!</p>
<p>Adding the reference that contained my principal object resolved the problem.</p>
<p>EDIT: Actually, I decided to just send it to the client as a CslaPrincipal because my custom principal has a ton of other custom child objects that had been developed over time, and I was going to have to add each object to the client library and silverlightify them (yuk). </p>
<p>
EDIT AGAIN: Okay, so that won&#39;t work either, it&#39;s still requiring the custom type during deserialization even if I cast it. If I only need to check if the user is logged in on the web server or not, is there any harm to just passing the bool IsAuthenticated value back alone? That would save me a lot of trouble.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NET-H24 replied on Monday, April 29, 2013</h2><p>Cant we achieve this keeping Authentication to be CSLA instead of Windows</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
