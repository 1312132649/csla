<html><header><title>Security and ORMs</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Security and ORMs</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8860.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks posted on Friday, April 30, 2010</h2><p>OK, bit late I know, but I&#39;m doing more research on CSLA 3.8 inc. reading more of the 2008 book. I&#39;m thinking about how to change our (outdated, CSLA 3, ported from CSLA 2) architecture to support unit testing. This will include updates to our CodeSmith Templates (VB, so maintained by us as more and more people seem to be shunning VB and the templates seem not to be available/up to date.)</p>
<p>The more I read about CSLA&#39;s direction, the more I realise that more and more people are using ORMs to do the data access, including using the objects that Linq to SQL or EF generate as DTOs when separating data access from the business objects to support mocking.</p>
<p>I have consciously made the decision not to use ORMs because of the security implications. Of course I see the benefits, don&#39;t get me wrong. But the idea of opening up permissions on the base tables in your database simply doesn&#39;t fit with the concept of defence in depth. I used to have full permissions on tables in Access databases. That was proven not to be a good plan a time or two, but was always frowned upon by security experts and I was persuaded to change my thinking. Fast forward just 4 or 5 years and the industry is being engulfed by a tide of ORMs that simply forget this teaching.</p>
<p>I am not convinced that most developers are considering the security implications of ORMs sufficiently. Have people had any experiences that convince them that security experts are going along with the tide in respect of ORMs? It seems to me that instead developers are deciding to ignore them (including DBAs who are being talked of as dinosaurs); a case of he who shouts loudest wins.</p>
<p>Rocky, I note that you have posted about a number of projects where Magenic have used ORMs. Have you put in place any compensating controls to stop people being able to use Microsoft Query, or Access, or whatever, to connect directly to database servers and query/modify data at will? Do you always recommend an application server when using an ORM? Is the situation different for web and LAN development environments, perhaps with people just not doing LAN much any more (we do a both, although web is more prevalent)?</p>
<p>There is another way to achieve developer productivity, and that is static code generation. We can generate the majority of SPs and objects very quickly with our templates and retain productivity whilst denying access to all base tables. Obviously the result needs some tweaking sometimes, but that is to be expected. However, not using an ORM leaves me without DTOs for use between layers unless I generate those too, and the amount of code/number of places&nbsp;that would need changing when a property is added is worrying me.</p>
<p>Is it REALLY OK that developers turn their backs on database security? Or are some developers being attracted by shiny and new and forgetting the important security lessons learned from the past?</p>
<p>Your thoughts, particularly real world situations,&nbsp;will be gratefully received.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, April 30, 2010</h2><p>My thoughts on the matter...</p>
<p>I wouldn&#39;t necessarily agree that all ORM&#39;s simply ignore database security.&nbsp; EF allows you to map your entities to stored procedures if you wish, instead of directly to the tables.&nbsp; My ORM experience is a little limited, but I believe NHibernate does this as well.</p>
<p>A lot depends on your situation, but in web environments, &quot;direct access&quot; to the database tables doesn&#39;t have to be as much of an issue.&nbsp; If your website is an Intranet site, you can set up your site so that the database connection is via&nbsp;the network account that manages your site&#39;s application pool.&nbsp; So your users have no direct access to the database, and don&#39;t know the ID that is connecting.&nbsp; On publicly-facing sites (or any site that requires a login), you have more work to do to implement this solution, but it&#39;s still possible.</p>
<p>Desktop situations do provide some potential issues.&nbsp; But again, EF allows you to map your entities to stored procedures if you so desire.&nbsp; And there is always the app-server concept, as you&#39;ve described.&nbsp; The trend I see in desktop apps is more of an &quot;occasionally connected&quot; type of situation - something like Outlook, where the desktop app only connects to a local data store, and a separate process talks to the database.&nbsp; This provides a level of isolation as well.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, April 30, 2010</h2><p>I agree with Scott.&nbsp; I use Linq To Sql, and map every objects CUD to stored procedures.&nbsp; Some procedures manuipulate data in multiple tables if they are doing a certain task (such as invoice canceling, which mainly involves copying rows and updating other rows).&nbsp; The procs are locked down appopriately by limiting their execution to certain database roles, and logons are actually AD groups, not individual users.&nbsp; So including Linq to Sql hasn&#39;t changed how I do things at all; except that fetch records and modifying them is more initutive (create objects, set properties which include some object to object ones and you&#39;re done).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockyRocks replied on Sunday, May 16, 2010</h2><p>OK, very interesting, thanks for the responses.</p>
<p>So it looks like some people are using SPs for create/update/delete but allow read access to tables to allow simple querying. Perhaps it is also possible to use SPs for fetch, but then you lose all the benefits of using an ORM really.</p>
<p>Thoughts continue ...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Sunday, May 16, 2010</h2><p>I wouldn&#39;t say you lose all the benefits of an ORM if you are 100% SP.&nbsp; For what it&#39;s worth, I work in a shop that until recently forced all database access via stored procedures.&nbsp; However, that attitude is beginning to change, and we had discussions with our DBA&#39;s before we began to do that.&nbsp; We have the luxury of being primarily a web-development shop, and my team is almost exclusively intranet apps, which makes it even simpler.&nbsp; But even the guys who do the internet sites use L2S, and they don&#39;t have any huge heartburn over database access and security.&nbsp; They require more setup than I do, but once you figure it out it just becomes a piece of your development pie.&nbsp; And you&#39;d have to go through most of that even if you weren&#39;t using an ORM.</p>
<p>An ORM&#39;s primary goal is to provide a more &quot;object-centric&quot; method of talking to your database, without having to concern yourself with the particulars of how that discussion happens.&nbsp; The fact that you&#39;re using stored procedures instead of whatever SQL your ORM of choice builds is, in some ways, incidental.&nbsp; Yes, we all know that it&#39;s not 100% insulated from the particulars of interacting with a database.&nbsp; But it&#39;s still a good tool, and IMHO working with entity objects is a lot easier than working with DataTables/DataSets (even typed ones).</p>
<p>And, like Andy, I still use SP&#39;s for the more complicated processes, or for some &quot;direct delete&quot; situations (I see no need to load an object entity just to delete it from the database.)&nbsp; I use EF, and like L2S it just maps the SP to a function call.&nbsp; Again, I don&#39;t have to care about all the plumbing involved with talking to the database.</p>
<p>Yes, you could argue that a 100% SP solution means you have to go through more work in your ORM, and that&#39;s true.&nbsp; But that&#39;s largely a one-time cost which I believe is outweighed by the benefits.&nbsp; If I can let the tool build my DAL (which is essentially how I use the ORM entities), and use other OO techniques to get data into and out of my business objects - well, I think I&#39;m&nbsp;money ahead.</p>
<p>HTH</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, April 30, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>tmg4340<br></b> A lot depends on your situation, but in web environments, &quot;direct access&quot; to the database tables doesn&#39;t have to be as much of an issue.&nbsp; If your website is an Intranet site, you can set up your site so that the database connection is via&nbsp;the network account that manages your site&#39;s application pool.&nbsp; So your users have no direct access to the database, and don&#39;t know the ID that is connecting.&nbsp; On publicly-facing sites (or any site that requires a login), you have more work to do to implement this solution, but it&#39;s still possible.</div></p>
<p>I don&#39;t think it&#39;s all that different with the desktop, either. </p>
<p>We&#39;ve supported an ODBC application for years (just now getting CSLA/ADO.NET version into production) in which the connection credentials were not available to the end user.&nbsp; So end users could access the database only via the application, not directly, and the application level security was deemed adequate for protecting the database. This approach translated to CSLA perfectly (and we incidentally also bolted CSLA on top of an ORM, albeit a lesser known one). </p>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
