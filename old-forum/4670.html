<html><header><title>Edit level issue when child object is removed, then added back to the collection.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Edit level issue when child object is removed, then added back to the collection.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/4670.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar posted on Friday, April 11, 2008</h2><P>I'm thinking the BusinessListBase needs to override the add method to see if the child that is being added, is already in the deleted list.&nbsp; If it doesn't, on the AcceptChanges method of the BusinessListBase, the child will have AcceptChanges called twice, once while in the items List, and once while in the DeletedList.&nbsp; This causes an EditLevelMismatch.</P>
<P>Steps needed to Recreate this issue.</P>
<P><CODE>Parent.BeginEdit(); </CODE><BR><CODE>Child myChild = Child.GetChild(); </CODE><BR><CODE>parent.Add(myChild); </CODE><BR><CODE>parent.Remove(myChild); </CODE><BR><CODE>parent.Add(myChild); </CODE><BR><CODE>Parent.ApplyEdit();</CODE></P>
<P>Any reason the Business List Base couldn't handle this by overriding the Add function?</P>
<P><CODE>public override void Add(&lt;T&gt; item){&nbsp;</CODE><BR><CODE>&nbsp;&nbsp;&nbsp;if(DeletedList.Contains(item)){ DeletedList.Remove(item)};&nbsp;</CODE></FONT><BR><CODE>&nbsp;&nbsp;&nbsp;base.Add(item); </CODE><BR><CODE>}</CODE></P>
<P>Any other Suggestions?</P></CODE></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, April 12, 2008</h2>Good point, I've added this to the <A href="http://www.lhotka.net/cslanet/wishlist.aspx">wish list</A> as a to-do item.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar replied on Monday, April 14, 2008</h2><P>There are a couple gotchas with this as well that need to be implemented</P>
<P>Parent parent = Parent.NewParent();<BR>Child child = Child.NewChild();<BR>parent.Add(child);<BR>parent.BeginEdit();<BR>parent.Remove(child);<BR>//User decides they want to undo manually what they just did<BR>parent.Add(child); // At this step, the editLevelAdded value of the child gets incremented from 0 to 1<BR>parent.CancelEdit(); //Now on a cancel the child will be removed from the parent because the add&nbsp;edit level is set at 1</P>
<P>This can be fixed by keeping track of the editLevelAdded as you currently do in the UnDeleteChild() method when adding the child to a class where it is in the deleted list.&nbsp; Except another issue happens when you do something like this:<BR>Parent parent = Parent.NewParent();<BR>Child child = Child.NewChild();<BR>parent.Add(child);<BR>parent.BeginEdit();<BR>parent.Remove(child);<BR>//User decides they want to add it to a different parent<BR>Parent parent2 = Parent.NewParent();<BR>parent2.Add(child);&nbsp; // At this step, the editLevelAdded value of the child gets incremented from 0 to 1 because we have nothing in the deleted list to compare it to<BR>//This updates the value in the deleted list of the parent<BR>parent.CancelEdit(); //So now on a cancel the child will be removed from the parent because the edit level is set at 1</P>
<P>I believe the best way to fix this is always add a clone of the object to the deleted list, so the editLevel added value will always be stay the same, even if the object is added to a different collection</P>
<P>Parent parent = Parent.NewParent();<BR>Child child = Child.NewChild();<BR>parent.Add(child);<BR>parent.BeginEdit();<BR>parent.Remove(child); // Clone the object and set the clone to the deleted list in the RemoveItem() method<BR>//User decides they want to add it to a different parent<BR>Parent parent2 = Parent.NewParent();<BR>parent2.Add(child);&nbsp; // At this step, the editLevelAdded value of the child gets incremented from 0 to 1 because we have nothing in the deleted list to compare it to<BR>//This updates the value in the deleted list of the parent<BR>parent.CancelEdit(); //So now on a cancel the child will be removed from parent2 because the edit level is set at 1, but the clone of parent is uneffected, and it is added back to the list.&nbsp; If the object is removed form parent 2 and added back to parent, the Add method will need to updated the editLevelAdded value of the item, to whatever the clone has.</P>
<P>&nbsp;</P>
<P>Are there any other issues you can think of with this solution?<BR></P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, May 27, 2008</h2><P>On further thought, this is a complex problem.</P>
<P>On the surface it would seem that the problem could be resolved as you suggest, or perhaps better by doing the check in the InsertItem() override (so all types of insertion/add are caught).</P>
<P>But the problem then is that the child object is still marked as deleted, so its IsDeleted==true.</P>
<P>I suppose one possibility is to detect that you are trying to re-add that item and then undelete the object, rather than actually re-adding it.</P>
<P>But really this whole scenario is not supported. To "undelete" a child you are supposed to call CancelEdit() on the parent (the list), thus restoring the child and list to its previous state.</P>
<P>So I think I will not address this in CSLA itself. However, there's nothing stopping you from overriding Add() as you suggest in your own custom base class. Or doing something similar in InsertItem() as long as you call base.InsertItem() when you are done.</P>
<P>But you can't do the undelete approach, because UndeleteChild() is private. So you'll have to come up with some scheme of your own by which you can mark the child object so IsDeleted==false.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar replied on Thursday, May 29, 2008</h2><P>So if I have a list of 500 objects, I mark one for deletion, and edit 400 other ones, in order to undelete the item that I deleted I need to call Cancel edit and redo the other 400 changes?&nbsp; Granted you're not usually going to be doing this sort of thing, but it is an issue if your children can be represented in a treeview, and the user has the option of checking(adding a child object) and unchecking(removing a child object).&nbsp; Maybe I should abandon trying to always keep the BO in sync with the tree and only read the tree when they call save?&nbsp; This would resolve any issue with deleting and then reading the same object.</P>
<P>Oh and, since when have you been afraid to use refelection to call a private method?&nbsp; :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Thursday, May 29, 2008</h2><P><FONT face=Tahoma size=2>I may be wrong on this, but I don't think it's a fear of using reflection to call a private method.&nbsp; It's the concept that the method was marked as "private" for a reason - it contains behavior that is not defined outside the scope of the class.&nbsp; Using reflection to call it is, in essence, an unsupported behavior - even though, in this instance, invoking that behavior is not likely to cause any serious side effects.</FONT></P>
<P><FONT face=Tahoma size=2>As for your issue, I might take a different approach.&nbsp; I would create a separate property and bind to that in your treeview - maybe something like "IsRemoved".&nbsp; Yes, you would still need to check each&nbsp;BO and delete them on a Save based on this property value, but then you could still keep your BO's in sync with your UI and not worry about the delete behaviors.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlabar replied on Thursday, May 29, 2008</h2><P>That's actually not a bad idea.&nbsp; If I hadn't already implemented the other method, I probably would have used that one.&nbsp; The only issue is I would have to add it to every class that I wanted to use it for and overwrite the List Update/Save implementation.&nbsp; </P>
<P>I just created extension methods to do what I suggested to Rocky to add.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
