<html><header><title>Someone explain the reason for multiple BO's for the same entity to me.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Someone explain the reason for multiple BO's for the same entity to me.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3737.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Telarian posted on Wednesday, October 17, 2007</h2>This is the big point upon which I think I get confused when it comes to "behavior centric" thinking and design. Correct me if I'm wrong, the impression I've been getting from the forum on this subject, is that I should basically create multiple BO's to represent the same conceptual entity, based on the context in which I'm using it. So in other words, I should have one BO for "employee" if I'm using it in the context of maintaining the employee's information. Another BO for "employee" if I'm using it in the context of assigning that employee to say an "order". Yet another BO for "employee" if I'm using it in the context of calculating the employee's commission on a sale. Etc, etc, etc.<br><br>Is that accurate? It seems so strange. I know that reuse is not the primary goal. I think I've gotten that drilled home sufficiently. Still it seems like there are so many things that have to be done again and again for each "employee"esque BO that could have been done together if we just used one "employee" BO that was adapted to work in each situation. I suppose that "adapted to work in each situation" bit is the point eh? It all just seems so counter intuitive and counter to what I've been taught. From database to normal discussions of OO concepts where it's the "employee" and "order" objects that are always discussed. Not the "OrderEmployee" object.<br><br>Am I getting it? Am I just crazy? <br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Wednesday, October 17, 2007</h2>The amount of "duplicates" you create really depends on your use cases.&nbsp; In your example I would create an editable Employee business object that lets me load edit and validate and save a single employee.&nbsp; Then I would write a read-only Employee list business collection and a read-only Employee business object.&nbsp; The read-only version would only include the fields that I want to view in the list box or a datagrid when searching or choosing the employee from a list.&nbsp; The read-only is a light-weight version that loads faster, is read-only, and contains no validation logic (unlike the editable version).&nbsp;&nbsp; </div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, October 17, 2007</h2><P>I agree with Jon.</P>
<P>I would assign the EmployeeID to an Order not an employee BO.</P>
<P>My ROC might have a contained class of Info objects which are ReadOnly.</P>
<P>I might also have a stand alone ReadOnly Employee object - for displaying Employee data instead of editing it.</P>
<P>I might have an NVL of EmpID and Name too.</P>
<P>But I probaly would have&nbsp;a single Editable Root&nbsp;Employee BO which is used for editing an employee record. And I might tweak it to do special things for a given employee like you suggested. (Maybe I am too data centric too!)</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brad replied on Wednesday, October 17, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Telarian:</strong></div><div><br>Am I getting it? Am I just crazy? ... It all just seems so counter intuitive and counter to what I've been taught.<br></div></BLOCKQUOTE><br><br>I struggled with this point for months when I began using
CSLA. We’ve been drilled for years to promote re-use. This concept, unfortunately,
comes at the cost of coupling. We tend to have an object and just “add some
small responsibility here” and then “add something small there” – we end up
with objects that tightly coupled and unmaintainable. Rocky’s framework
encourages us to design our business objects in a way that clearly separates
object responsibilities.<o:p> <br><br></o:p><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Telarian:</strong></div><div><br>This is the big point upon which I think I get confused when it comes
to "behavior centric" thinking and design. Correct me if I'm wrong, the
impression I've been getting from the forum on this subject, is that I
should basically create multiple BO's to represent the same conceptual
entity, based on the context in which I'm using it.<br></div></BLOCKQUOTE><br><br>You are correct in your deductions. In theory, you could
have <i>n</i> business objects which access
data from table <i>A</i>. <i>n</i> is a scary number, because I
immediately think unlimited. However, I’ve found in practice that usually you
will have no more than 3 or 4 business objects that access table <i>A</i>. I’ve found that you start reusing
objects based on behaviour, rather than data – and this has helped tremendously
in my application designs. With code generation, even this amount of objects
can be simple to create and maintain.<br><br>That said, this framework isn’t a maintenance silver bullet.
It can, however, shift the maintenance burden to a more explicit area. And that
to me is a Good Thing™.<br><br>I’m not sure at what time everything “clicked” for me, but
now I’m finally <i>at peace</i> with the
idea of creating multiple objects which are based from the one database entity.
I continually look for areas where reuse of behaviour is appropriate. I also
look for refactoring opportunities for objects which retrieve their data from
the same table – if there are common methods between business objects, get them
out into either static methods or base classes.<br><br>Good luck – I found this issue to be the hardest mental leap while using
the framework… and the hardest to explain to co-workers.<o:p></o:p><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 18, 2007</h2>The problem is that each 'adaptation' you create for that one new or changed use case has a very high potential to break ALL the other existing use cases. <br><br>This makes doing the change that much more difficult, because instead of testing that one use case, you must now retest them all.&nbsp; Even after the testing, there may be bugs you missed, and you've broken the application in multiple places.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Thursday, October 18, 2007</h2><P>I dunno if this thought helps or hinders...but if you want to make the analogy of BO's to something you are already familiar with, think of BO's like stored procedures...you wouldn't make a single stored procedure for&nbsp;each table&nbsp;with tons of CASE statements to control your logic.&nbsp; You'd have <EM>n </EM>stored procedures touching the same tables for different purposes.</P>
<P>Having said that....I've been lurking on these forums and reading the book for a couple weeks now and haven't written a single line of code yet. :-)&nbsp; I'm just trying to take it all in while I wait for my development environment to be completed.</P>
<P>&nbsp;</P>
<P>Ryan</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 18, 2007</h2>Funny you should mention that; I actually worked one place were we did basically that to help keep the number of procs down.&nbsp; Wow, what a nightmare.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>webjedi replied on Thursday, October 18, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>Funny you should mention that; I actually worked one place were we did basically that to help keep the number of procs down.&nbsp; Wow, what a nightmare.<BR></div></BLOCKQUOTE></P>
<P>That's just plain crazy and someone should be punished for that. :-)</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 18, 2007</h2>Well, the good thing was it was never a shipping product, and the one that thought up the idea was able to figure out that it was a bad idea... but I spent days just writing the procs.. yuck.&nbsp; <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>robert_m replied on Thursday, October 18, 2007</h2><P>It' s not that you have to come up with a new class for every use-case your conceptual entity is involved in. So, you can&nbsp;have a&nbsp;single Employee class that does many different things, nothing wrong with that. It's relations between two or more classes that are sometimes tricky and that may justify introducing additional classes. If you model an invoice,&nbsp;3 classes will do:&nbsp; Invoice , InvoiceItem&nbsp;and an InvoiceItemList where Invoice will have a member of type InvoiceItemList. No extra classes here. This is quite simple and straightforward because classes are in simple hierarchical (parent - child) relationship, ie. invoice has items, item is a part of invoice and invoice item doesn't make much sense outside of the context of invoice it belongs to.&nbsp;</P>
<P>But with your example, (emloyees and orders),&nbsp;we have a two-way relationship. We might want to&nbsp;list all orders for a given&nbsp;employee - which&nbsp;means your&nbsp;Employee class should maintain a list of Order instances. On the other hand, every order has an associated Employee, which implies our Order class should contain an&nbsp;Employee instance. Now we have a circular reference&nbsp;(Employee&nbsp;contains Order and Order contains Employee) which is not&nbsp;good from&nbsp;maintainence point of view&nbsp;- every time you change Order you implicitly change (and&nbsp; probably break !)&nbsp;Employee and vice versa. One way out of this situation&nbsp;would be to introduce "intermediary" class which will have the sole responsibility of maintaining the relationships between customers and orders - an OrderEmployee class.&nbsp;This class&nbsp;would be&nbsp;quite simple&nbsp;(therefore easy to maintain) and Employee and Order classes are no longer entangled...</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, October 18, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>robert_m:</strong></div><div>But with your example, (emloyees and orders),&nbsp;we have a two-way relationship. We might want to&nbsp;list all orders for a given&nbsp;employee - which&nbsp;means your&nbsp;Employee class should maintain a list of Order instances. </div></BLOCKQUOTE><br><br>Actually I'm not sure your employee class would maintain such a list.&nbsp; I think your Orders factory would take an employee id or Employee object which it would use to fetch such a list.&nbsp; You might have a GetOrders method on your employee class... but it would just call the Orders factory method I just mentioned.&nbsp; The Orders list itself would likely be readonly, as would the orders it contained.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>robert_m:</strong></div><div>On the other hand, every order has an associated Employee, which implies our Order class should contain an&nbsp;Employee instance. Now we have a circular reference&nbsp;(Employee&nbsp;contains Order and Order contains Employee) which is not&nbsp;good from&nbsp;maintainence point of view&nbsp;- every time you change Order you implicitly change (and&nbsp; probably break !)</div></BLOCKQUOTE><br><br>Not at all.&nbsp; Your order would have an employee id property, which it would use to link back to the employee.&nbsp; But it would NOT have an Employee editable class as a property.&nbsp; At most, it'd have a readonly Employee object, which it would use ONLY to get the id from so that the order could save itself.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>robert_m:</strong></div><div>One way out of this situation&nbsp;would be to introduce "intermediary" class which will have the sole responsibility of maintaining the relationships between customers and orders - an OrderEmployee class.&nbsp;This class&nbsp;would be&nbsp;quite simple&nbsp;(therefore easy to maintain) and Employee and Order classes are no longer entangled...</div></BLOCKQUOTE><br><br>I don't think you'd need a class to maintain the relationships between the two, unless you have a use case which you're changing the orders that belong to employees in some kind of batch setting.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>robert_m replied on Friday, October 19, 2007</h2><P>Well, I agreee with you&nbsp;- what you suggest will work&nbsp;in most situations, but it all depends on the requirements of the app you're building. Maybe&nbsp;employees / orders&nbsp;pair is not the best example,&nbsp;but&nbsp;sometimes you do bump into a situation where you have mutually dependent classes. And when you do, it usually&nbsp;is better to introduce another class to handle the relationship - easier to maintain.</P>
<P>There's a sample of something similar in ProjectTracker CSLA sample application (ProjectResource class that handles relationship between Project and Resource classes)</P>
<P>Anyway, the point I was trying to make is that introducing another class into your business model doesn't&nbsp;always increase the complexity of your code, but on the contrary it can sometimes make it simpler to handle and maintain...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, October 19, 2007</h2>Right, it always depends.&nbsp; I guess the point you were trying to make got lost as I got too caught up in the details.&nbsp; Sorry.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Telarian replied on Friday, October 19, 2007</h2>It seems a lot easier to use simple ID's in some of these objects rather than an instance of an object but isn't that breaking encapsulation?<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
