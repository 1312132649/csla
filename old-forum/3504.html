<html><header><title>Facade class and rule management</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Facade class and rule management</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3504.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert posted on Monday, September 10, 2007</h2>In my app, I have a class called EmployeeEvent that is responsible for tracking an employee's activities on the shopfloor. An event represents an employee moving from one activity to another. The UI needs to maintain a relationship between the employee's previous event and the new one being created, all within a transaction. To facilitate this, we're using a facade class to manage the two events and to expose filtered lists for a couple of UI dropdowns.<br><br>One of the debates is where to maintain the rules for the employee events, in the EmployeeEvent class or in the facade class. Many of these rules deal with relational constraints. For example, we do not allow events during a shift that has been closed and we do not allow an event's time to be closed if there is uncompleted work during that event's time frame. The two approaches we've discussed are:<br><br>A) Maintain all the rules in the facade class. The theory here is that the EmployeeEvent class should not be responsible for maintaining rules that require interaction with other classes. My concern with this approach is that, if the EmployeeEvent class were scoped public, it would expose unprotected properties.<br><br>B) Maintain rules in the EmployeeEvent class and use the facade class' filtered lists to prevent rules from ever being broken. In this case, the EmployeeEvent class interacts with whatever classes necessary to protected its own data and the facade class is merely used to help the UI. The question here, though, is how to deal with the possibility of broken rules in the EmployeeEvent class and bubble them up to the UI.<br><br>Any thoughts would be appreciated.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dean replied on Tuesday, September 11, 2007</h2><font size="6"><font size="3">so EmployeeEvent is not a child of the employee?<br><br>Dean<br></font></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Tuesday, September 11, 2007</h2>Correct. EmployeeEvent is not a child of Employee.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dean replied on Wednesday, September 12, 2007</h2><font size="3">What are the use cases that apply to these events?<br><br></font><font size="2"><font size="3">It seems like the rules, in some ways, are not "employeeevent" rules but possibly employee rules. An employee can't "check out/punch out" of a project that isn't finished, an employee can't work on a closed project. <br><br>So possibly your desire to create this facade/UI class to control/collect the events could be looked at as a collection that would be contained in an employee type object.&nbsp; I try to always look at these very friendly UI classes closely to make sure I haven't confused UI demands with business object demands. And if it's a UI "helper" I put it in the UI. Which would mean that they can't have biz rules.<br><br>Hope this helps.<br><br>Dean</font><br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>bgilbert replied on Wednesday, September 12, 2007</h2>Dean, <br>There are three use cases:<br><br>1) User submits a single transaction that closes a previous employeeEvent, if it exists, and creates a new one. This requires coordination and event handling to manage the relationship between the two employeeEvents.<br><br>2) Supervisor initializes a shift, creating initial employeeEvents for each employee assigned to the shift.<br><br>3) Supervisor maintains previously recorded employeeEvents in a grid type UI.<br><br>The solution we've developed in the past two days involves using a switchable object for the employeeEvent class. This allows us to use it as a child when filling a collection for the grid-based UI. It also allows instantiation of two individual objects when we need to deal with the transaction of the previous and new employeeEvent. The employeeEvent class maintains the rules and the facade class is used by the first and second use cases to prevent the rules from being broken by managing the transaction. <br><br>This will work for now. I'm not convinced I have the perfect design, but it seems to be a reasonable division of responsibilities. We did, to your point, look at having the employee class manage employeeEvents, but we wanted to keep employees as more of a root object.<br><br>Thanks for your input.<br><br>Barry<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
