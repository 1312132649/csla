<html><header><title>Managed string field null inconsistency</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Managed string field null inconsistency</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5988.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoshL posted on Saturday, December 13, 2008</h2>Assuming a managed Name property on the Person BO, the following test passes:<br /><br />            Person person = Person.NewPerson();<br />            Assert.AreEqual(string.Empty, person.Name);<br />            person.Name = null;<br />            Assert.IsNull(person.Name);<br /><br />and this test fails:<br /><br />Assert.AreEqual(string.Empty, person.Name);<br /><br />Shouldn't a null person.Name be treated as String.Empty?<br /><br />I would suggest that setting a property value to null should give it the same effective value as it has before any value is set into it. For strings, this would allow callers to assume that the value will never be null. I believe that this is the intent of treating a null as an empty string to begin with. So long as callers can store and retrieve a null value, code that uses the property values must deal with the possibility of a null.<br /><br />If a business object developer wants to treat string.Empty as different from null, they should specify null as the default value for the property.<br /><br />Thanks</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, December 13, 2008</h2><P>There was a bug in 3.5.2 and 3.6 Beta1 where a null value was not converted to string.Empty.</P>
<P>Version 3.5.3 and 3.6 RTW (when it comes) resolve this issue, and any null input value for a string property is automatically converted to string.Empty. This brings the behavior in line with that for private backing fields.</P>
<P>If you want to preserve null string values, you'll need to override the default implementation. This should be rare however, because doing so means you can't use data binding.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoshL replied on Saturday, December 13, 2008</h2>Thanks, Rocky. I look forward to the updated code.<br /><br />However, I'm curious why you say that the use of null strings "means you can't use data binding". I'm working in WinForms, and find that that data binding null strings has always worked just fine for me. Nullable numbers are problematic when using the Microsoft WinForms GridView, but this is easy to work around. The DevExpress grid handles nullable types by default.<br /><br />That said, my preference is to be consistent with whatever approach is taken - in this case that null strings will be represented in the framework as string.Empty consistently. In Oracle, a null string and an empty string are the same anyways. For SQL Server, I'll just make sure that I convert empty strings to null when saving to the database to reduce storage and allow database check constraints and null constraints to operate.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, December 13, 2008</h2>Perhaps data binding has changed. For a very long time it has been the case<br />that a null string value in a property would cause Windows Forms data<br />binding to throw a null reference exception. This is the reason all strings<br />are 'de-nulled' in CSLA and all my example code.<br /><br />Rocky</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
