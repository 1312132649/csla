<html><header><title>CSLA Authentication: why does the server trust the Principal object</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Authentication: why does the server trust the Principal object</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8780.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>vjmasin posted on Wednesday, April 07, 2010</h2><p>I am investigating how to do custom authentication in my CSLA application. I understand that the Principal object is passed from client to server (and back) on every request. What I don&#39;t understand is, assuming a login has taken place and the&nbsp;Principal/Identity is marked as authenticated, why the server trusts the Principal object on all subsequent requests. Wouldn&#39;t it be easy for someone to write a &#39;fake&#39; client where it sets the Principal as authenticated and pass that in? What am I missing?</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>JonnyBee replied on Wednesday, April 07, 2010</h2><p>Hi, </p>
<p>If you decide to go for &quot;mobile objects&quot; pattern - this implies that you trust your clients to do authorization.If you do not trust your clients you should use WCF, RIA Services of OData to expose your data and do your own authorization there. </p>
<p>And&nbsp; to protect your app you should use signed assemblies and not allow modifications to your custom identity/principal objects.&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>vjmasin replied on Thursday, April 08, 2010</h2><p>I&#39;m using CSLA over WCF. Are you saying that I should be implementing some type of WCF authentication rather than the CSLA custom authentication, and that the latter is only for trusted clients? I&#39;m wondering how any server software can trust its clients (even inside the firewall someone could write a program to access it). But I guess if I check on each call that my principal/identity is of my custom class, and I don&#39;t allow instantiation of that class unless it has been authenticated, then no one should be able to spoof it.</p>
<p>Perhaps that&#39;s what you meant about not allowing mods to the identity/principal object. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Thursday, April 08, 2010</h2><p>I think there are some things that you can do incrementally to raise the bar for potential hackers.</p>
<p>I think we&#39;ll see more and more of this discussion as Silverlight apps pick up in terms of securing an application.</p>
<p>I guess there are two aspects:</p>
<p>1) keeping the source away from non-clients or non-trusted people. </p>
<p>For XAP files, it might be putting it within an ASP.Net site with forms authentication such that a user must be authenticated prior to even getting to your XAP.</p>
<p>One can also use Obfuscation to provide an extra layer of defense to simply make it harder for the casual pest. DeepSea was pretty intuitive. .NET Reactor wasn&#39;t as clear to me. I was under time pressure and just tried another tool (DeepSea) as a result.</p>
<p>Sign your assemblies.</p>
<p>2) mitigating clients who have your code and have malicious intent. (I suppose this is where the compromised principal object comes into play)</p>
<p>I think if one were to basically encrypt/hash a token on the principal/identity that includes the identity of the user, it would seem to me that you know that the principal is one you created (at least the portions which you include as a check in your encrypted token).</p>
<p>If permissions are being serialized within your object, I guess there are two ways to do this - take your principal (that you can verify the identity through a token) and reload the permissions. Another possibility might be to create a salted hash of the permissions and verify that the permissions validate against that salted value when dataportal requests are made.</p>
<p>--</p>
<p>I would love to hear other ways people are going about securing their applications without dismantling the single application approach. If anything I&#39;ve stated is flat-out wrong, please correct me.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, April 08, 2010</h2><p>First, if you don&#39;t trust your clients then you should use SOA. You should be creating two completely separate apps - one on the server and one on the client. You should assume all aspects of the client app have been compromised, and construct the server app to be exceedingly paranoid. The best way to accomplish this is to hire a game developer from one of the major MMORPG firms (Sony, etc), because they are the global experts on this problem space. The problem space, btw, is extremely complex and is nearly impossible for normal people to comprehend, much less resolve. We&#39;re talking low level byte hacks, replay attacks on the network, man-in-the-middle scenarios. All sorts of nasty stuff. Bad guys are very determined and very smart and (assuming you are a valuable target) they have nearly unlimited budgets.</p>
<p>Second, if you really look at this in any detail you must do THREAT analysis. It is nearly impossible for normal business apps to justify the expense of the sort of security required by online games, game consoles or the military. Defeating the threat posed by actual hackers is insanely expensive.</p>
<p>Third, defeating the threat posed by non-hackers isn&#39;t so bad. Most business apps can actually afford that cost - but again, THREAT analysis is required to determine your cost threshold. And if you don&#39;t trust your client you shouldn&#39;t be doing n-tier architecture, you should be doing SOA. Yes, SOA is much more complex and expensive than n-tier, but it is the architecture that addresses the untrusted client.</p>
<p>Fourth, there are middle ground solutions. If you &quot;sort of don&#39;t trust&quot; your client, and don&#39;t want to incur the expense of SOA, you can strengthen your principal object (for example). That&#39;s a low-hanging fruit solution. Just have the server create an encrypted token that includes the hash signature (SHA256 probably, as SHA1 has been cracked) with a sliding expriry period and put that into Csla.ApplicationContext.GlobalContext. This is encrypted using a symmetric key known only to the server.</p>
<p>You can create an implementation of IAuthorizeDataPortal that runs before any other server code. This can decrypt the token, and can calculate a signature for the principal that came with the request. If the two signatures match (the new one and the recorded one from the token) and the token hasn&#39;t expired, then all is still good. Update the timestamp and re-encrypt the token so the expiry window slides.</p>
<p>It is a little complex, but not too bad. And there&#39;s a little perf hit, but probably not too bad (symmetric encryption and signing isn&#39;t terribly slow).</p>
<p>The cool thing is that you can also implement (if you want) additional functionality in the token to prevent replay attacks. That requires more work yet, as the server needs to keep track (in some manner) which tokens it has seen, so it can reject any token it has already seen. I am not an expert on that, so there may be other options, but the one I know if requires (sadly) maintaining some server-side state with the expected inbound value for the next token. Of course server-side state is hard to manage efficiently, but this is a decent solution to prevent replay scenarios.</p>
<p>Man-in-the-middle is best prevented by using SSL. Other techniques exist too, but SSL is already there and already does it correctly (assuming you have a real cert issued by a real CA), so it is by far the best answer.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
