<html><header><title>CSLA Silverlight Dynamic Button / Template Page - Can't Work It Out!</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA Silverlight Dynamic Button / Template Page - Can't Work It Out!</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6844.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>FraggleRocks posted on Thursday, April 23, 2009</h2><P><FONT face=Arial>I have a 5 editable root lists and a "generic" silverlight page which contains a toolbar, a data-grid and an Add Row Button.&nbsp; As I construct the generic page I pass a parameter to the constructor telling it which business object it is to provide an editable client for.&nbsp; In the constructor I create the relevant datagrid columns and also include a delete button column.&nbsp; This all works fine.&nbsp; the correct data is displayed and changes are persisted.</FONT></P>
<P><FONT face=Arial>The problem I have is that the editable page contains an "Add Row" button,&nbsp;When I&nbsp;have 5 different Silverlight pages and define the CSLA properties for the button in the XAML for each page, I get correct behaviour.&nbsp; But when I try and dynamically set the CSLA propeties in the page constructor the button does not work.&nbsp; If I step through with the debugger the properties appear to be set, but have no affect.</FONT></P>
<P><FONT face=Arial>What I am trying to achieve is to code <EM>only</EM> the differences or specialisms of the generic page.&nbsp; Does anyone know how to solve my "setting button CSLA property setting at runtime" problem, or have comments on a better strategy?&nbsp;&nbsp; Many Thanks.</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, April 23, 2009</h2><P>This is a little tricky because of the async world in SL.</P>
<P>In .NET there's the IBindingList interface. That doesn't normally exist in SL, but we created a small subset of it - specifically to address this issue.</P>
<P>So if you cast any CSLA list object to Csla.Core.IBindingList you can get at an AddNew() method.</P>
<P>If the list overrides AddNewCore(), then the UI can call IBindingList.AddNew() and a new item gets added to the list. Conceptually this is no different from .NET.</P>
<P><EM>Except</EM> the AddNewCore() method in SL is actually there so you can start an async operation to create the new object. When the creation process is complete (whether sync or async) you <EM>must</EM> call OnCoreAdded() to tell CSLA that the new child has been created.</P>
<P>The whole point of this is to allow the UI to use IBindingList.AddNew() on any list type - as long as that list supports adding new items by overriding AddNewCore() - just like in .NET.</P>
<P>The only wrinkle, as I say, is that we had to support the possibility of async creation because this is SL after all...</P>
<P>If you can create the child in a sync manner, it is pretty easy:</P>
<BLOCKQUOTE dir=ltr>
<P>protected override void AddNewCore()<BR>{<BR>&nbsp; var newItem&nbsp;= new ChildObject();<BR>&nbsp; OnCoreAdded(this, new DataPortalResult&lt;ChildObject&gt;(newItem, null, null))<BR>}</P></BLOCKQUOTE>
<P>That's as close as you can get to the .NET model.</P>
<P>But hopefully you can see how this <EM>could</EM> start an async call, such as to the data portal, to create the new object, in which case you'd just provide the address of OnCoreAdded as the callback handler for the data portal's CreateCompleted event.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
