<html><header><title>Is there anyone out there that can provide some guidance on DataMapper Best Practices</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Is there anyone out there that can provide some guidance on DataMapper Best Practices</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8830.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash posted on Thursday, April 22, 2010</h2><p>As a part of some &quot;architectural studies&quot; for an up-coming project, I have been looking at the DataMapper class.&nbsp; We are looking at using data transfer objects (DTO) to communicate with the database and probably MVVM objects to communicate with WPF.&nbsp; One of the downsides with each of these is the need to transfer data from one object to another; e.g., from the DTO to the business object and back.&nbsp; On a recent project using DTOs, a significant source of &quot;oh, crap&quot; errors sprang from changes in the DTOs (which were code generated) that did not get into the business objects.&nbsp; Dropping a field/column will get you a compile error, thus, getting the attention of the developer.&nbsp; The effects of adding a property and not including in the various &quot;copy lists&quot; are typically much more subtle.&nbsp; That is, the typical pattern was add the new thing to the database, regenerate the DTO code, add the property to the business object but forget to add the transfer to the fetch or to the update logic.&nbsp; </p>
<p>At first glance, the DataMapper would seem to be a way to handle this automagically.&nbsp; However, in working with this functionality, I have bumped my nose several times:</p>
<ul>
<li>One of the prime drivers for the use of DTO and MVVM objects is the ability to unit test everything completely.&nbsp; I have worked out how to structure things so that I can do true unit tests.&nbsp; For my studies, I am writing unit tests using RhinoMocks.&nbsp; DataMapper does not like the proxy object generated by RhinoMocks.&nbsp; I can avoid most of the problems by suppressing exxceptions, but that leaves me feeling somewhat dirty.&nbsp; </li>
<li>DataMapper goes in the from does by invoking the properties on the object.&nbsp; This is appropriate for the DTO and MVVM objects but not so much for the business objects.&nbsp; Without DataMapper, I would be using LoadProperty and bypassing a lot of the events and checks.&nbsp; I can suppress the checks but again I am left feeling a bit dirty.</li>
<li>DataMapper is not particularly friendly when there is no setter for the property.&nbsp; This makes it painful to use for the primary key values that typically do not have a setter.&nbsp; This makes it useless for read only objects.&nbsp; Granted the typical read-only &quot;info&quot; object only has a couple of properties, but that is not always the case.</li>
</ul>
<p>It would seem to me that it would be useful to have a more specialized data mapper that was smarter in at least two ways:</p>
<ul>
<li>It would only attempt copies for the set of properties present on both objects, minus any properties on an ignore list.</li>
<li>If the target object was derived from BusinessBase (and thus had a FieldManger), the mapper would use Load/Set Property to store data into the object.&nbsp; This would eliminate the problem with read-only properties.&nbsp; </li>
</ul>
<p>I am looking on feedback on a couple of issues.&nbsp; One, is my intended use of DataMapper reasonable?&nbsp; Two, has anyone done something along this line?&nbsp; If so, is anyone willing to share?</p>
<p>I certainly can come up with a more-or-less reasonable solution using code generation with partial classes and even partial methods.&nbsp; Even so, this seems like a more fragile solution.&nbsp; DataMapper (or a variation) seems like the better way to go.</p>
<p>Jon Stonecash</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, April 22, 2010</h2><p>I emailed you directly regarding &quot;MVVM objects&quot;, so I&#39;ll ignore that here.</p>
<p>In terms of using DTOs to persist data, I&#39;m right there with you - great idea! But I think you are putting them at a peer level with the business objects, and I surely wouldn&#39;t do that. Instead, I&#39;d treat the DTOs like the parameters passed to and from a database via stored procedure calls.</p>
<p>In other words, you are constructing a data access layer (DAL) that consumes and provides DTOs. That&#39;s good, because it decouples the caller of the DAL from anything beyond simple .NET types. And it is good because this sort of DAL is easily mocked. (Hey DAL! You have a huuuge nose!)</p>
<p>But it is still just a DAL - which means it should be invoked from DataPortal_XYZ methods or from an object factory (subclass ObjectFactory). </p>
<p>If you invoke the DAL from DP_XYZ you can use all the standard friendly data portal and child data portal constructs, which is nice. Let CSLA manage the metastate properties for you, etc. Better still, you don&#39;t need to break encapsulation because the code interacting with your business object property values is <em>inside the business object</em>. This is honestly my preferred approach - use a provider or DI model to select the concrete DAL and away you go. Easy to do, easy to mock/test, easy to maintain.</p>
<p>If you invoke the DAL from factory objects, you can use all the standard stuff in ObjectFactory, including LoadProperty/ReadProperty/MarkAsChild/MarkNew/MarkOld/etc to get/set property values and manage the metastate properties as required. This is more work, and requires that you have a deeper understanding of the metastate property behaviors so you get everything done correctly. But it can be very powerful if you create specialized subclasses of ObjectFactory that meet your particular technical requirements.</p>
<p>And if you use the object factory approach you can do your mocking at the object factory level (implement a custom factory loader and swap out the entire set of factory objects), or by using a provider or DI model to select the concrete DAL.</p>
<p>The object factory approach isn&#39;t as easy and requires a deeper understanding of CSLA behaviors, but it can be more powerful.</p>
<p>In neither case do you need DataMapper, because you aren&#39;t dealing with peer level objects. The DTOs are always subservient to the DP_XYZ or object factory code. When using DP_XYZ you preserve encpasulation - it is the purest OO solution. When using factory objects, the ObjectFactory base class helps you break encapsulation in ways that aren&#39;t <em>too</em> terrible, and at least are easy to do.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Friday, April 23, 2010</h2><p>Rocky,</p>
<p>My approach is right in line with your comments.&nbsp; I have looked at the Object Factory and it seems a bit too massive for my needs.&nbsp; I am planning on using a dependency injection / provider model for the DTO/DAL functionality.&nbsp; Within that approach, the very specific issue that I am concerned with is in the DataPortal_xxx methods.&nbsp; Let me narrow the discussion down to DataPortal_Insert where:</p>
<ol>
<li>The logic creates an appropriate DTO object.</li>
<li>The logic copies the contents of the Business Object into the DTO.&nbsp; </li>
<li>The logic sends the DTO off to the DAL to be inserted in the persistent store.</li>
<li>The logic captures the side effects of the insert (generated primary key, if we do not use a GUID, timestamps, values diddled by defaults and triggers, etc).</li>
</ol>
<p>What I am concerned with is the statements in the code that handle step #2.&nbsp; Without a data mapper,  I will have one DTO.XXX = BO.XXX for each property (or LoadProperty(XXXProperty, DTO.XXX) for Fetch).&nbsp; If the business object contains a significant number of properties, that can add up to a lot of code that has be to generated and maintained.&nbsp; If the set of properties is stable, we can write the code once and get on with other things.&nbsp; If the set of properties is volatile, it is all too easy to forget to add a line in each of the DP_XXX methods (or the common methods called by these methods).&nbsp; Been there, done that, got the (now ratty) T-shirt to prove it.&nbsp; </p>
<p>It just seemed to me that an intelligent DTO data mapper could reduce the friction of this particular aspect of using DTO to transport data.&nbsp; The current data mapper seems to have echos of an earlier version of CSLA.&nbsp; What I was looking for was something more attuned to the managed properties approach.&nbsp; </p>
<p>Let me toss in two additional points: First, I will be using project-specific base classes that derive from r each of the CSLA business base classes.&nbsp; This is to simplify the handling of the dependency injection; I want the business objects to be tightly focused on business concerns rather than plumbing.&nbsp; I anticipate that I could add logic in these base classes to make the mapping process easier.&nbsp; Second, we will be using code generation to build the core of the DTO objects.&nbsp; There will be some hand-worked DTO classes and extensions to the generated code through partial classes and methods but the vast majority of the classes will be simple enough to crank out like potato chips.&nbsp; If I go down the data mapper route, each of these classes could inherit from a hand-crafted DTOBase class that could provide some helper logic (either directly or through composition).</p>
<p>Any thoughts?</p>
<p>Jon Stonecash</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, April 23, 2010</h2><p>The DataMapper exists to address&nbsp;two specific scenarios&nbsp;- copying data into and out of a Web Form postback and copying data into and out of a DTO for a web service or WCF service. In both cases the operation is outside the object and is conceptually at a peer level - the interface object is a peer to the business object.</p>
<p>You can use a DataMap to get more advanced, including mapping to fields - but that assumes you have private fields - and it would require that you maintain the map, so I don&#39;t think it addresses your concern.</p>
<p>Certainly you could create something like DataMapper that does what you are talking about - though it might need to subclass ObjectFactory to get access to the LoadProperty/ReadProperty methods necessary to break encapsulation.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, April 23, 2010</h2><p>Actually you probably don&#39;t need to be so fancy. You can ask the field manager for the list of properties defined for your type. You could then foreach through them to get/set each property value (using LoadProperty/ReadProperty). You can use the features in Csla.Reflection to &quot;reflect&quot; against the DTO to get/set those property values using dynamic method invocation (or lambda expressions in CSLA 4).</p>
<p>Protected methods to do this could be added to your custom base classes and away you go.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Saturday, April 24, 2010</h2><p>Just to tie this one off, here is what I ended up doing:</p>
<p>I wrote a static CoreDataMapper class with two public methods: one to copy the contents of a data transfer object (DTO) to a business object (BO), and a second to copy the contents of the BO to the DTO.&nbsp; The DTO objects implement (what turned out to be) a &quot;marker&quot; interface that provides a tiny bit of type safety.&nbsp; I will probably switch this to &quot;object&quot; at some time in the future; that way, I am not restricted on what I can use as a DTO.&nbsp; The BO objects implement an IMapBusiness interface.&nbsp; I want to use use the data mapper with items eventually derived from BusinessBase and ReadOnlyBusinessBase and the interface seems to be the most straight forward way of getting that to happen.&nbsp; </p>
<p>The IMapBusiness interface has three methods: First, GetRegisteredProperties returns a List&lt;IPropertyInfo&gt; for the object.&nbsp; Second, LoadNamedProperty invokes the protected LoadProperty method of the BO.&nbsp; Third, ReadNamedProperty invokes the protected ReadProperty method of the BO.&nbsp; Each of these methods is a one line &quot;pass through&quot; method.&nbsp; As I noted earlier in this thread, we are extending the standard CSLA business base classes with our own base classes.&nbsp; [This is a technique that I strongly recommend; it allows for project level extensions of CSLA without making changes to CSLA, itself.]&nbsp; I implemented this interface in our base classes for BusinessBase and ReadonlyBusinessBase as an explicit interface; the explicit implementation keeps the methods out of Intellisense and allows me to be less guilty about breaking the encapsulation of the business objects.</p>
<p>The intent of the CoreDataMapper is to reduce the amount of code that I have to write in the DataPortal_XXX and Child_XXX methods.&nbsp; The data mapper is not all that clever; at this point, there are several situations (including child collections) that it does not handle.&nbsp; I added a &quot;DoNotAutoMap&quot; attribute that can be applied to the properties of a BO to warn off the data mapper.&nbsp; In those cases, I must revert to writing the copy logic myself. &nbsp;</p>
<p>Of course, none of the of the above has been tested in full project implementation.&nbsp; I fully expect that a fair amount of it will under go changes as we make our way through the project.</p>
<p>&nbsp;</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
