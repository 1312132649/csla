<html><header><title>Possible CSLA .NET 3.5 enhancement (indexed LINQ queries)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Possible CSLA .NET 3.5 enhancement (indexed LINQ queries)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3894.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka posted on Tuesday, November 13, 2007</h2><P>A colleague of mine at <A href="http://www.magenic.com">Magenic</A>, Aaron Erickson, has written a <A href="http://www.codeplex.com/i4o">library for LINQ (i4o)</A>&nbsp;that adds indexed query capability when doing a select from a list of objects. Aaron has volunteered to merge this functionality into CSLA .NET 3.5, which is very cool!</P>
<P>The result should be that LINQ queries run against a BLB or ROLB list would use an index on the child object properties, and thus repeated queries against the same list would be faster.</P>
<P>Obviously creating and maintaining an index isn't free. It takes processing power and memory. But if you do a lot of LINQ queries against a list, having an index can make a major difference in performance.</P>
<P>With this feature, would you:</P>
<OL>
<LI>Expect indexing to be on by default or off by default?</LI>
<LI>Want any on/off switch to be public or protected?</LI>
<LI>Want to have lazy creation of the index (so the first LINQ query turns it on and builds the index and thus is slow, but subsequent LINQ queries are very fast)?</LI></OL>
<P>Any other feedback/ideas are welcome too. This will be one of the major new features in CSLA 3.5, and I'd rather get input now than after we're in a beta cycle.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>William replied on Tuesday, November 13, 2007</h2>Here are my feedback.<br><br>1. I think indexing should be off by default. As in SQL Server table, there is no index defined by default, except clustered index, which rearranges the underlying data pages. However, I think the equivalent of LINQ index is non-clustered index SQL Server.<br><br>2. I prefer a tri-state switch to cover up item (3), as On, Off, OnDemand. The property should be public as the client/UI should be able to decide when it needs performance and the trade off, and BO should not dictate this on behalf of different usage contexts.<br><br>3. See (2).<br><br><br>Thanks.<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, November 14, 2007</h2>I haven't used any .Net 3 or higher stuff yet, so I'm not sure I can answer directly.&nbsp; I would like to know though, how often do you see Linq querying of business objects?&nbsp; I know that it will happen... but how likely / useful is it?&nbsp; That might help determine sane defaults.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, November 14, 2007</h2><P>Rocky,</P>
<P>Interesting timing. My colleague Alex and I were just working on indexing of collections. We did some perf testing and determined that when you are looping over the collection (in a For Each statement) that calling methods&nbsp;like Item and Contains (which loop&nbsp;until they&nbsp;find a value) are 1,000 times slower than using the indexing mechanism described in the article.We are in the middle of adding a Property named ItemWithIndex to our BusinessListBase class.</P><FONT color=#0000ff size=2>
<P>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Overridable</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>ReadOnly</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Property</FONT><FONT size=2> ItemWithIndex(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> key </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Object</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> C</P></FONT>
<P>We planned on loading the index on the first request and then re-using it on subsequent requests. We also decided not to keep the index up to date with any list changes so we avoided the work of modifying all the Add and Remove methods. </P>
<P>Instead, if the index does not contain the item, we branch the call back to the standard Item method which does have the up to date list. </P>
<P>So if a collection has 2,000 items in it and is not changed, then the index is built on the first pass and then re-used 1,999 times. This is extremely useful when looping over the collection ina For Each statement.</P>
<P>If you add 1 item to the list then the index is still used 1,999 times and the standard Item method is used once.</P>
<P>Indexing is always ON for our new method. </P>
<P>Indexing should probably be ON by default as that gives a huge perf gain. The developer should be able to "turn indexing on/off" for a given List. I guess the switch should be Public as the dev could then set it in either the BO or the UI. If they want the default to be off then they can set in in their code-gen templates.</P>
<P>I think lazy creation of the index is fine. But will you keep the index up to date as the collection changes? Or should the index be re-built at some point? What is that point? Number of requests that miss the index? Or on demand?</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, November 14, 2007</h2><P>Contains() is interesting, because it ties into the other thread I started about Equals(). Contains() loops through the list looking for an object that is Equals() to the current object. </P>
<P>If Equals() reverts to System.Object.Equals() then it no longer would be bound to <EM>any</EM> property on the object, but instead is (by my understanding) bound to a hidden GUID value created on a per-object basis by System.Object - and that couldn't be indexed because it is private to System.Object...</P>
<P>I'm somewhat surprised that the indexer (Item property) was sped up? That doesn't use a key value at all right? Just a numeric location index.</P>
<P>Our intent is to maintain the index(es) over time, so they are always current. It isn't that hard to do and provides a consistent perf benefit for queries. </P>
<P>The index technique we're using right now is a simple dictionary/hashtable. Nothing fancy. I do have a red-black binary tree implementation that would probably be more memory-efficient. But there's a higher processing cost to maintaining a balanced binary tree than to maintaining a hashtable, so it is a bit hard to say whether CPU or memory is a more precious resource... At the moment, because a hashtable is simpler, we're sticking with that.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, November 14, 2007</h2><P>"I'm somewhat surprised that the indexer (Item property) was sped up? That doesn't use a key value at all right? Just a numeric location index."</P>
<P>Rocky - I should have qualified that. It is an Overload of the Item property that got sped up. The overload works just like Contains.</P>
<P>e.g. This is not exact code because the index As Integer standard Item method would cause this to not compile. But it gives the idea.</P><FONT color=#0000ff size=2>
<P>Public</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Overloads ReadOnly</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Property</FONT><FONT size=2> Item(</FONT><FONT color=#0000ff size=2>ByVal</FONT><FONT size=2> key </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Integer</FONT><FONT size=2>) </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> SomeBO<BR></FONT><FONT color=#0000ff size=2>Get<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Dim</FONT><FONT size=2> obj </FONT><FONT color=#0000ff size=2>As</FONT><FONT size=2> SomeBO<BR>&nbsp; </FONT><FONT color=#0000ff size=2>For</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Each</FONT><FONT size=2> obj </FONT><FONT color=#0000ff size=2>In</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Me<BR>&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>If</FONT><FONT size=2> obj.key = key </FONT><FONT color=#0000ff size=2>Then<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>Return</FONT><FONT size=2> obj<BR>&nbsp;&nbsp;&nbsp; </FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>If<BR>&nbsp; </FONT><FONT color=#0000ff size=2>Next<BR></FONT><FONT color=#0000ff size=2>&nbsp; Return</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Nothing<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Get<BR></FONT><FONT color=#0000ff size=2>End</FONT><FONT size=2> </FONT><FONT color=#0000ff size=2>Property</P></FONT>
<P>We are using a Dictionary(<FONT color=#0000ff>Of</FONT> <FONT color=#0000ff>Integer</FONT>, List(<FONT color=#0000ff>Of</FONT> C)) in our index.</P>
<P>Alex said that it is of negligible size while in memory. But that Serialization causes the size of the BO to grow more than if the index was not present. Perhaps significantly. Are you aware of this potential issue? Will cloning of the BO clone the index? Any issues returning the index through the DataPortal as part of the object graph? I thought there was an issue around Hashtables and serialization. Like the Hashtable had to be a field in class marked Serializable or something.</P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, November 14, 2007</h2><P>I see, that makes sense. I don't think I'll be adding overloads like that for these methods/indexers. But once the indexing capability is implemented, you'd be able to implement such an indexer/Item property or a Contains() that would run a LINQ query to do the work, and that would use the index if there is one.</P>
<P>There's no plan to serialize the indexes. The indexes will be marked as NonSerializable and would be recreated on the client and/or app server. That's one reason why I think lazy loading of the indexes is so important.</P>
<P>Consider the scenario of loading a list. The list is created/populated on the app server, then is immediately returned to the client. Creating a set of indexes on the app server would be a complete waste, because they'd never be used, and serializing those indexes back across the wire would be highly counter-productive, especially across slower network links.</P>
<P>So the indexes must be created per-AppDomain/machine/tier. And to avoid that type of overhead, they must be lazy loaded - created on demand.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DavidDilworth replied on Friday, November 16, 2007</h2><P>My suggestions would be:</P>
<P>(1) Off by default.&nbsp; Don't enable something that you don't expect to use.</P>
<P>(2) I can see that public gives most flexibility, but protected is probably the better scope from a design perspective.&nbsp;&nbsp;One pattern could be to make it accessible via&nbsp;the Criteria, but keep the actual property scope in the BO&nbsp;protected?&nbsp; That way you can make the choice via Criteria passed to the factory?&nbsp; Also, it would need to be virtual in the CSLA base classes so that it could be overridden in a derived class with a fixed value if needed.</P>
<P>(3) I like the suggestion of having it On/Off/OnDemand, so you have control over how you want the BO to work.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Wednesday, November 14, 2007</h2><P>1.&nbsp; I'd expect indexing to be off by default.</P>
<P>2. Public would probably be better, to give the gui developer more options.</P>
<P>3. I think this feature would be a nice to have, and should have the option to turn it on or off.</P>
<P>This might be overkill, but perhaps a method to manually kick off the indexing so the developer could possibly have a list indexing in the background.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Wednesday, November 14, 2007</h2>I'd like to change my suggestion to have indexing turned ON by default.&nbsp; After looking at the i4o implementation and taking a database paradigm, indexing is based on the table.&nbsp; The developer runs a query and it uses the indexes defined on the table(similar to the way i4o defines indexes at the&nbsp;class level) by default.&nbsp; If the developer doesn't want to use the indexes on the table they have to specify in the query not to use them.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
