<html><header><title>Optimization question for ERLB-like class</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Optimization question for ERLB-like class</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7095.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 posted on Friday, June 12, 2009</h2><P>I have implemented a pageable/virtual mode&nbsp;list&nbsp;class modeled from&nbsp;EditableRootListBase to support large database tables. Almost all the object saving code is copied directly&nbsp;verbatim&nbsp;from EditableRootListBase. </P>
<P>Basically, I would like to avoid&nbsp;calling&nbsp;&nbsp;SaveItem()&nbsp; when the object is not dirty.&nbsp;In my case, calling IndexOf() on an object not the cache is *very* expensive (at least on the first call) as it requires loading the entire set of primary keys determine which page the object would be on. </P>
<P>(Long story, but any change to the filter or sort on a paged list must clear the page cache, since the ordinal offset of any object in the cache is now wrong.&nbsp;Since the top row in the grid is the "current" item when this happens, the first thing that happens after the new sort/filter is applied is the current changes and a SaveItem() occurs on the the former top row, even if it wasn't changed. Oops, now that object isn't in the cache any more)</P>
<P>As I was looking at this it seem to me that the same issue exists (with less obvious impact) in ERLB.&nbsp; Even if an object isn't dirty, ERLB may clone the object and replace the original reference with the&nbsp;clone. &nbsp;So, one question is why ERLB itself doesn't treat SaveItem on a clean object as a NOP?</P>
<P>I could just change my class, but the&nbsp;the UI is agnostic as to the type of underlying list and just sees an IList of BusinessBase objects. Since a normal ERLB SaveItem can potentially return a new reference even if the object isn't dirty, I want to make sure my class works like ERLB to the extent necessary.</P>
<P>I'm currently working around this by pre-testing the object to see if is dirty and calling CancelEdit rather than ApplyEdit. Does this seem like a reasonable approach? Can you think of a better way to deal with this?</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
