<html><header><title>void IParent.RemoveChild(IEditableBusinessObject child)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>void IParent.RemoveChild(IEditableBusinessObject child)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8133.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo posted on Saturday, December 12, 2009</h2>Hi there,<br /><br />While I was messing around with the "Csla.Core.BusinessBase" object I found the following interesting method:<br /><br />void IParent.RemoveChild(IEditableBusinessObject child)<br />{<br />    var info = FieldManager.FindProperty(child);<br />    FieldManager.RemoveField(info);<br />}<br /><br />The "IParent.RemoveChild" method XML documentation states the following:  This method is called by a child object when it wants to be removed from the collection.<br /><br />Ok, now that we got that out of the way, let’s dig inside this function. As we can see, the code inside the function makes a call to the "FieldManager.FindProperty()", so let’s take a look at that method and see what that method does:<br /><br />internal IPropertyInfo FindProperty(object value)<br />{<br />    var index = 0;<br />    foreach (var item in _fieldData)<br />    {<br />        if (item != null &amp;&amp; item.Value != null &amp;&amp; item.Value.Equals(value))<br />            return _propertyList[index];<br />        index += 1;<br />    }<br />    return null;<br />}<br /><br />The interesting part of this method is the “item.Value.Equals(value)” call. The problem here is that it’s using “Equals” to compare the object when I think that what this should be doing is a reference comparison.<br /><br />If we do a value (Equals) comparison we risk that the developer might have implemented the "Equals" method in a way that two BusinessObjects could be evaluated as being the same and this will end up causing problems. <br /><br />Perhaps I am wrong about this but I just wanted to make the call out in case this could be a potential issue.<br /><br />Thanks.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Saturday, December 12, 2009</h2><P><FONT size=2 face=Tahoma>Well - I'd argue that having two objects in a collection which are logically equal presents its own set of issues, irrespective of whether "RemoveChild" gets the right one.&nbsp; Determing "the right one" in that case is relatively ambiguous.&nbsp; I realize the method call is receiving "the right one", but that's&nbsp;usually initiated by developer code, so who's to say the developer found the right one to delete in the first place?</FONT></P>
<P><FONT size=2 face=Tahoma>And ReferenceEquals wouldn't necessarily solve the issue either - what if the developer adds the same child object to the collection twice?&nbsp; Normally I would think you'd disallow that, but if you're worried about logical equality within the collection, then your case removes the unique constraint from the collection.</FONT></P>
<P><FONT size=2 face=Tahoma>In any event, Equals() has been the .NET standard for equality-checking for a while...</FONT></P>
<P><FONT size=2 face=Tahoma>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Saturday, December 12, 2009</h2>Scott,<br /><br />OK, I am fine with what you said, but.... that is the reason I included the following paragraph in my original post:<br /><br /><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>rxelizondo:</strong></div><div><br /><P>The "IParent.RemoveChild" method XML documentation states the following: This method is called by a child object when it wants to be removed from the collection. </P><br /></div></BLOCKQUOTE><br /><br />The child object is calling the method when*it* wants to be removed from the collection. I would not make sense that child "abc" called the method to get itself removed from the collection and end up removing child "xyz" right?<br /><br />Just making a call out :)<br /><br />Like you said, a well implemented property would probably never run into an issue like the one I explained, and of course, there is also the issue with the function accepting an object which would mean that it could accept value type object which would mean that reference comparison would never be true.... Maybe the FindProperty object should only accept IEditableBusinessObject since any other object would probably not make sense?<br /><br />Thanks.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, December 14, 2009</h2><P>Csla used to&nbsp;force you to implement a GetIdValue method, the idea being that you WANTED the logically "equal" instance.&nbsp; So the above code is correct from that perspective.</P>
<P>This requirement was dropped however when it was discovered that Wpf does the wrong thing; it was using Equals when it it should have been using ReferenceEqual, and this discepency was causing Wpf not to referesh its databinding.&nbsp; </P>
<P>If someone wants to use logical equality and they can, I don't see any reason Csla should prevent them from doing so.</P>
<P>You can read about the original issue here:&nbsp; <A href="http://www.lhotka.net/weblog/CommentView,guid,06f305de-ec32-4e20-b042-171b58f305ae.aspx">http://www.lhotka.net/weblog/CommentView,guid,06f305de-ec32-4e20-b042-171b58f305ae.aspx</A></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Monday, December 14, 2009</h2>Thanks Andy,<br /><br />To me, the use of Equals should have never been used regardless of whether the CSLA forced you to use GetIdValue or not.<br /><br />Please note (this is important) that I am basing this post *solely* by the XML documentation of that method (this is *key*).<br /><br />The XML documentation does *not* state: This method is called by a child object when it wants itself *or* a value equivalent child to be removed from the collection.<br /><br />It clearly states: This method is called by a child object when *it* wants to be removed from the collection.<br /><br />So basically, if object in heap address of OxF54E74AF wants to be removed form the parent then object heap address of OxF54E74AF should be the one removed and none other.<br /><br />So using Equals is just asking for trouble, this should have been implemented as RefEquals from the get go. If anything, from a performance point of view, RefEquals would be one whole microsecond faster so there :)<br /><br />In any event, this is just a silly post, even if I am right about this, there is a 99.9% probabilities that is not going to get fixed because its unlikely that someone will ever run into this issue so lets not bother with this. I was just putting it out there so Rocky would see it and if he wants to do something about it that is fine with me, if not that is also fine with me.<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, December 15, 2009</h2><P>Prior to verion 3.0 CSLA supported the concept of "logical equality" as a general practice. That was very valuable.</P>
<P>Unfortunately WPF came along, and WPF doesn't allow any interpretation of Equals() as being different from ReferenceEquals(). This (imo) is really poor on their part, because it means Equals() is essentially always useless - but it is what they did in WPF.</P>
<P>So CSLA 3.0 and higher doesn't support logical equality. If you override Equals() you'll break CSLA and WPF and (I think)&nbsp;Silverlight.</P>
<P>Since overriding Equals() breaks core .NET functionality, I don't feel too bad if it also breaks CSLA functionality - Microsoft set the bar, I'm just lowering myself to match it :)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, December 15, 2009</h2>Does it actually break Csla functionality?&nbsp; I thought if you were using WinForms it was still possible to have logical equality if you override Equals and GetIdValue.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Wednesday, December 16, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div>
Unfortunately WPF came along, and WPF doesn't allow any interpretation of Equals() as being different from ReferenceEquals(). 
</div></BLOCKQUOTE>

I guess technically, Microsoft broke the Equal/ReferenceEquals  semantics from the get go. For example:<br /><br />object o1 = new object();<br />object o2 = new object();<br /><br />bool foo = o1.Equals(o2);<br /><br />In the example avobe, the variable &#x201c;foo&#x201d; is false when it really shold be true right? I am sure there must be a good reason for this but it still contradicting what Equal and ReferenceEquals should stand for.<br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, December 16, 2009</h2><P><FONT size=2 face=Tahoma>Actually, from MSDN:</FONT></P>
<P><FONT size=2 face=Tahoma>"The default implementation of Equals</FONT><FONT size=2 face=Tahoma>&nbsp;supports reference equality for reference types".</FONT></P>
<P><FONT size=2 face=Tahoma>Which is why your example works as it does.</FONT></P>
<P><FONT size=2 face=Tahoma>I don't necessarily consider them contradicting.&nbsp; MSDN calls it "value equality versus reference equality".&nbsp; Equals is overridable so that "value equality"&nbsp;can be defined for an object.</FONT></P>
<P><FONT size=2 face=Tahoma>HTH</FONT></P>
<P><FONT size=2 face=Tahoma>- Scott</FONT></P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
