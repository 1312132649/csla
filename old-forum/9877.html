<html><header><title>How to wait until BeginRefresh(...) has completed?</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How to wait until BeginRefresh(...) has completed?</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/9877.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Gort posted on Thursday, December 16, 2010</h2><p>Does anyone have any suggestions of the best way to wait for a BeginRefresh(...) call to complete before doing further operations?&nbsp; Basically, I just want the async call to be synchronous for this particular case.&nbsp; I&#39;ve tried a couple options but am not getting things to work quite right.</p>
<p>Tks.</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, December 16, 2010</h2><p>What you are looking for is technically called a &quot;continuation&quot; - where you start the next task in a sequence when the previous task completes.</p>
<p>I assume you are doing this in a viewmodel object, and the easiest way to do this is to override OnRefreshed - that&#39;s the method which is invoked when BeginRefresh completes (or OnError if it fails - you really need to override both).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Gort replied on Friday, December 17, 2010</h2><p>I am trying to instantiate a view model from my App.xaml.cs file and want the execution to wait until the view model instantiation is complete.<br /><br />Here is my code in App.xaml.cs:<br /><br />SiteViewModel svm = new SiteViewModel();<br /><br />var x = svm.SomeProperty;<br /><br /><br />In SiteViewModel:<br /><br />public SiteViewModel()<br />{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; GetData();<br />}<br /><br />private void GetData()<br />{<br />&nbsp;&nbsp;&nbsp; BeginRefresh(&quot;GetBySiteIdAsync&quot;, new object[] { 1 });<br />}<br /><br />protected override void OnRefreshed()<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp; base.OnRefreshed();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />}<br /><br />OnRefreshed() does get called, but not until after execution has continued in the statement above so &#39;svm.SomeProperty&#39; is always null/empty.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, December 17, 2010</h2><p>Well you can&#39;t &quot;wait&quot; because you are living in an async world. To &quot;wait&quot; would mean blocking the UI thread, which is the whole reason Microsoft forces server access to be async - to prevent you from blocking the UI thread. While you could work around this and block the UI thread, that&#39;d be a horrible thing to do since it would <em>entirely lock up the browser</em>.</p>
<p>Instead, you need to embrace the reality of working in an async world.</p>
<p>I typically don&#39;t try to load anything in app.xaml.cs - that&#39;s too early (and too hard to debug). Instead, I do my first loading of things in my main form or the first content control hosted in the main form.</p>
<p>And I always have some strategy for &quot;locking out&quot; user interaction on the main form when necessary. This often involves having a Canvas &quot;overlay&quot; that sits over the top of any content in my UI. I&#39;ll typically data bind this to some IsBusy flag on the viewmodel or presenter or whatever.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
