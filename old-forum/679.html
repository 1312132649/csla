<html><header><title>Some design questions.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Some design questions.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/679.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Thursday, July 20, 2006</h2>Hi all,<br><br>I have two applications now, which currently share a common Contacts business layer.&nbsp; The main application uses all of the layer, but the other app, which is actually an outlook plug-in, uses only a few objects.&nbsp; My concern though is that I may make some changes to a portion of the database or business object model which don't affect the plug-in, I don't want to re-deploy the plugin, but at the same time technically the libraries its using is outdate.&nbsp;&nbsp; I'm starting to think I should seperate out the functionality common to both to yet another assembly.&nbsp; <br><br>Also, I have some classes in the Contacts assembly which could be used as is in my Quoting business assembly.&nbsp; My thought is to move these classes to a base business assembly, which is referenced by both.&nbsp; Does this sound acceptable?&nbsp; Or should I just forget about what I have in my Contacts assembly for now, and design what I need for quoting in isolation?&nbsp; I don't want to tightly couple the assemblies, but it may be useful to have them collaborate by using shared interfaces. <br><br>Thanks<br>andy<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 20, 2006</h2>My opinion on this isn't likely to be popular, so take it for what it is worth.<br><br>There's the idea that the primary goal of OO is reuse. I think that is a myth. Reuse is a fortunate side-effect if and when it happens, but it isn't the goal. The goal is maintainability.<br><br>In practical terms this means that an object should exist within a use case. If it happens to fit into another use case that's awesome, and you should reuse it - but only if you don't have to compromise the object's responsibility to do it (in other words, you shouldn't add conditional code to make it work in another use case). This kind of reuse is surprisingly common, even with these rules, and that is good.<br><br>But then you get into cross-application reuse. Over the past 12 or so years, I've come to the conclusion that this type of reuse has a higher cost than benefit. Another word for this type of reuse is coupling - because you are taking a tightly coupled dependency on a shared assembly/component. Yes, you get reuse, but you also effectively combine both your applications into one application that must be versioned together. That cost is too high!<br><br>This is one area where I think the SOA people are getting it right. Applications should be silos. They should share nothing. No sharing of assemblies, components or databases.<br><br>Over the years we've all tried different things - using formal interface DLLs to help decouple applications from their actual components, etc. But it has never worked. Even if you can change the underlying assembly without changing the interface, you still changed the underlying assembly, and that functional (semantic) change almost always breaks other consumers of that assembly. This was (and is) one of the primary causes of DLL hell.<br><br>So what I am suggesting? That you make a concious choice as to whether you have a single big application with multiple UI's, or seperate applications. If you have seperate applications, then I suggest you not share assemblies between them.<br><br>If that is too hard to swallow, then share the assemblies, but do so in a side-by-side manner. In other words, allow each application to have a copy of the assembly, and to continue running with that copy even if a newer version is available and in use by another application. This is the default .NET way of doing things anyway, so is easy from a technical perspective - but it may or may not be practical from a business perspective...<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 20, 2006</h2>Some very good points to think about.&nbsp; The end goal is that we have one database with contacts, quoting / invoicing, and inventory information.&nbsp; Sales needs to know how many items we have in stock right now, orders place need to reduce inventory, and parts / manufacturing needs to add to inventory / add new items, etc.&nbsp; One database to rule them all, as it is.<br><br>So I've been thinking of this as one application with many UIs.&nbsp; One for sales / invoicing, one for manufactoring, and in the future, we want to allow customers to order over the web.&nbsp; Maybe this is the wrong approach though?<br><br>More specifically, the two apps I have now are the full contacts app, and the outlook plugin.&nbsp; The app supports the idea of 'notes' for a contact.&nbsp; Notes have a subject, body and attachments.&nbsp; Users could drag an email to the desktop, then drag the .msg file to my application to save it as a note for a contact.&nbsp; The outlook plugin simply automates this process; its adding a new note (the email) to the contact's notes as automatically.&nbsp; <br><br>I'm not sure if that changes anything though, and I certainly need to think about this quite a bit... I'm starting phase two, which will build the quoting / invoicing system.&nbsp; Phase three will add the manufacturing piece (which will affect ordering behind the scenes, as a placed order will now have the responsibility to update inventory).&nbsp; I think the use case is mostly the same, except with that added responsibility..<br><br>Thanks for the reply.<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, July 20, 2006</h2>



<p class="MsoNormal"><span>If you are going to use the Contacts
assembly in multiple projects, break it up logically.<span>&nbsp; </span>Do not break it up based up shared
functionality.<span>&nbsp; </span>This will help solve your
problem and protect you from future projects that use these assemblies.<o:p></o:p><br>
There is
nothing wrong with sharing assemblies as long as it done correctly.<span>&nbsp; </span>This can get tricky though.<span>&nbsp;&nbsp; </span>Make sure that the behavior of the classes
doesn’t change much between applications.<span>&nbsp;
</span>If they do change slightly, there are elegant ways to handle this.<span>&nbsp; </span>However, if the differences become great, it
just becomes a nightmare.<span>&nbsp; </span>This is one of
the reasons why a DAL is valuable.<span>&nbsp; </span>You
can swap in a different DAL for different project without creating
problems.<span>&nbsp; </span>Further, before you share assemblies
between projects, keep in mind the OOP principles.<span>&nbsp; </span>These will help guide you down the right
path.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 20, 2006</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong><strong>malloc1024</strong>:</strong></div><div><span>If you are going to use the Contacts
assembly in multiple projects, break it up logically.<span>&nbsp; </span>Do not break it up based up shared
functionality.<span></div></BLOCKQUOTE><br><br>Contact note managment, although a small subset of the functionality, could be a good logical seperation.&nbsp; This is where I was leaning.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>malloc1024:</strong></div><div></span></span><span>Make sure that the behavior of the classes
doesn’t change much between applications.<span></div></BLOCKQUOTE><br><br>This won't be a problem.&nbsp; The Note concept in each application will always be the same; this is because the plug-in is simply automating something that can be done manually in the main application.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>malloc1024:</strong></div><div></span></span><span><span></span>If they do change slightly, there are elegant ways to handle this.<span> </div></BLOCKQUOTE><br><br>Would you mind sharing what these ways may be? <img src="/emoticons/emotion-2.gif" alt="Big Smile [:D]" /><br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>malloc1024:</strong></div><div></span></span><span>Further, before you share assemblies
between projects, keep in mind the OOP principles.<span></div></BLOCKQUOTE><br><br>Always, well I try to anyway.&nbsp; In this case, one application is simply automating something that can be done manually.&nbsp; The end result is the same.<br><br>Thanks for the post.<br>Andy<br></span></span><span><span><br></span></span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, July 20, 2006</h2>

<p class="MsoNormal"><span>It sounds
like you are on the right track.<o:p></o:p><br>
What I
meant about elegant ways are design patterns.<span>&nbsp;
</span>Design patterns like the strategy, decorator, state etc. will allow you
to change the behavior of an object dynamically.<span>&nbsp; </span>They will allow you to add code instead of
change code (open-closed principle).<span>&nbsp;
</span>Therefore, making changes to your code will not break things.<span>&nbsp; </span>Design patterns, when used correctly can help
bridge the differences between your projects elegantly.</span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, July 20, 2006</h2>Ah, got ya.&nbsp; Good thing I just got a design patterns book; I need to finish though, i've only read the stragegy pattern so far.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
