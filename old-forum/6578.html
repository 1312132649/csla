<html><header><title>Static constructor performance.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Static constructor performance.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6578.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell posted on Sunday, March 08, 2009</h2>Hi folks.<br>I would like to ask a question about the performance impact of having the static constructor. In the book Expert C# Business Objects on page 249 there is a short discussion devoted to the subject. The statement that having the static constructor adversely affects the performance seems so interesting to me that I have taken the liberty to test it.<br><br>Here is my test app:<br><br><font face="Courier New" size="2">public static class C1</font><br><font face="Courier New" size="2">{</font><br><font face="Courier New" size="2">&nbsp; public static int N;</font><br><br><font face="Courier New" size="2">&nbsp; static C1() { N = (new Random()).Next(); }</font><br><font face="Courier New" size="2">&nbsp; public static int f(int p) { return p + 1; }</font><br><font face="Courier New" size="2">}</font><br><font face="Courier New" size="2">public static class C2</font><br><font face="Courier New" size="2">{</font><br><font face="Courier New" size="2">&nbsp; public static int f(int p) { return p + 1; }</font><br><font face="Courier New" size="2">}</font><br><font face="Courier New" size="2">class Program</font><br><font face="Courier New" size="2">{</font><br><font face="Courier New" size="2">&nbsp; static void Main()</font><br><font face="Courier New" size="2">&nbsp; {</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; const int N = 1000000;</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; int i, x = 0;</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; Stopwatch sw = new Stopwatch();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; N; ++i)</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; {</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Start();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = C1.f(x);</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Stop();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; }</font><br><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; // Make sure no code gets optimized away.</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; Console.WriteLine("{0} iterations of C1.f took {1}ms (C1.N = {2})",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.ToString(),</font>&nbsp; <font face="Courier New" size="2">sw.ElapsedMilliseconds, C1.N);</font><br><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; x = 0;</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; sw.Reset();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; N; ++i)</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; {</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Start();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = C2.f(x);</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sw.Stop();</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; }</font><br><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; // Make sure no code gets optimized away.</font><br><font face="Courier New" size="2">&nbsp;&nbsp;&nbsp; Console.WriteLine("{0} iterations of C2.f took {1}ms", x.ToString(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font><font face="Courier New" size="2">sw.ElapsedMilliseconds);</font><br><font face="Courier New" size="2">&nbsp; }</font><br><font face="Courier New" size="2">}</font><br><br>I have compiled it in the release build (VS 2008) and here are the results:<br><font face="Courier New">1000000 iterations of C1.f took 1764ms (C1.N = 1876561082)<br>1000000 iterations of C2.f took 1757ms<br></font><br>I am running on Intel(R) Core(TM)2 Duo CPU P8400 @ 2.26GHz<br><br>According to this simple test there is almost no performance penalty in having the static constructor. So, I wonder whether my test is wrong or there are some changes in the way C# compiler creates code, which have eliminated the performance impact described in the book.<br>What do you think?<br><br>Thanks.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Sunday, March 08, 2009</h2><P><FONT face=Tahoma size=2>This is not how I typically see timing code written.&nbsp; I'm not saying it's wrong - but I'm betting you would get different results if you didn't start and stop around each method call.&nbsp; Typically, the stopwatch is started before the loop is started, and stopped after it's ended.&nbsp; You can argue that it's not a true timing, since there is code that is not germane to the test factoring into the overall time.&nbsp; But it's also closer to how your "real world" code is executed, and the extra instructions aren't likely to drastically affect the overall timing.&nbsp; Having the stopwatch code inside the loop is going to interrupt the actual flow of the loop, which would tend to even out the results.&nbsp; It also adds quite a bit of time to the overall performance.</FONT></P>
<P><FONT face=Tahoma size=2>I took your code, moved the "Start" and "Stop" calls outside the loops, built it in Release mode, and ran it.&nbsp; The first loop took 7ms, while the second&nbsp;loop took 2 ms.&nbsp; I'm running on a P4 3GHz.&nbsp; Obviously, 7ms vs 2ms is not going to make anyone complain about performance - but it still took almost four times as long, and illustrates what I was talking about.&nbsp; Extrapolate that out to a class that does&nbsp;"real" work, and you'll see what Rocky was talking about.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Sunday, March 15, 2009</h2>Do you mean 7ms for 1,000,000 iterations, which is 7ns per iteration.<br>So it is 7ns vs 2ns, when the functions are practically empty, so we measure just the method invocation time. If the functions did anything useful, the difference would have been negligable.<br>I still do not see why should I bother about static constructors.<br>BTW, I have not noticed any change in reflector for both calls. Can you explain it?<br>Thanks.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Sunday, March 15, 2009</h2><P><FONT face=Tahoma size=2>Your test is testing how long it takes to call static methods in a class, which in this (and almost any)&nbsp;case would be negligible.&nbsp; Rocky's discussions concerning performance relate to calling instance methods in a class that also has a static constructor.&nbsp; That is a different set of code to test, and I have to assume Rocky tested that rather extensively - otherwise it wouldn't have warranted mention in the book (or in the numerous forum discussions surrounding this issue.)</FONT></P>
<P><FONT face=Tahoma size=2>You won't see any differences in Reflector because your test code only has static methods.&nbsp; If your test classes were more similar to CSLA BO's - i.e. had instance methods, a static construcor, and test loops that called the instance methods - I would expect to see different code in Reflector, as well as different performance profiles.</FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, March 16, 2009</h2>Honestly I'm not sure about the warning against using static constructors.&nbsp; At this point, we (the Csla community on 3.6) are using static field initializes, and as far as I can tell... the compiler does this by creating a static constructor for you.<br><br>Check it out sometime using MSIL.&nbsp; I believe this code:<br>private static int x = 35;<br><br>Ends up being compiled to this:<br><br>private static int x;<br><br>static MyClass() {<br>&nbsp;&nbsp;&nbsp; x = 35;<br>}<br><br>So if you have your own static ctor code, the x initialization will be done prior to your code.&nbsp; So if you have this:<br><br>private static int x = 35;<br><br>static MyClass() {<br>&nbsp;&nbsp; doSomething();<br>}<br><br>It will compile to:<br>private static int x;<br>
<br>
static MyClass() {<br>
&nbsp;&nbsp;&nbsp; x = 35;<br>&nbsp;&nbsp;&nbsp; doSomething();<br>
}<br>
<br>If you find something different let me know... but I think static field initializiers get the same performance hit as just using your own static ctor. <br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>markell replied on Monday, March 16, 2009</h2>Well, I have changed the test to measure instance methods. The results are consistent with the static calls. Invoking an instance method of a class with the static constructor takes 1 to 4 ns more on average, which amounts to 1 to 4 ms on 1,000,000 calls. In my opinion, it is negligible.<br><br>I have also compared the IL code in reflector and found that both loops differ in just one opcode - <br>the one with the static constructor calls <font face="Courier New"><b>ldloc.3</b></font> where the other one calls <font face="Courier New"><b>ldloc.s c2</b></font>&nbsp; (c2 is the instance of the class without the static constructor). However, since I do not grok IL, that says absolutely nothing to me, except that probably <b>ldloc.3</b> takes slightly more time to execute than <b>ldloc.s c2</b>.<br><font face="Courier New"></font><br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
