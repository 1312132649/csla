<html><header><title>Design Issue - Uses Case</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Design Issue - Uses Case</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/3861.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>griff posted on Thursday, November 08, 2007</h2><font face="Arial">Hi<br><br>Another design issue I have.<br><br>I need a ro object to populate a screen and for use in sending details via email .<br>The data required exists in several tables that are all related (parent/child etc).<br><br>tblJobs---&gt;tblJobDates----&gt;tblTimeSheets----&gt;tblStaff<br>tblJobDates---&gt;tblVenueDetails<br>tblJobs-----&gt;tblClientDetails<br>tblJobs-----&gt;tblPatientDetails<br>tblJobs-----&gt;tblSubClientDetails<br><br>So I can't decide what to do.....in this instance I will be pulling back 1 record only (and child records)<br><br>1) do I simply design a stored proc to pull back all relevant data from the table and populate a ro object. <br><br>Pros: easiest to do, best performance<br><br>Cons: user requests additional fields so a need to amend st.proc and ro object, little reuse maybe elsewhere in the application<br><br>2) Design a larger ro object that loads the full ro child objects into it<br><br>Pros: Have access to all fields in child objects so as requirements change should be able to deal with easier... also ro child objects can be used elsewhere in the app.<br><br>Cons: slower performance (but is this the case as I intend to pull back only 1 parent record), overkill in that I have large class object from which I really only need access to 20 or so data items out of several hundred say.<br><br>Anyone had similar?<br><br>Thanks<br><br>Richard<br><br><br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonStonecash replied on Thursday, November 08, 2007</h2>This is one of those cases where "it all depends".&nbsp; You have mentioned some of the factors, but let me add a few more thoughts.<br><br>First, my preference is to have the "leanest" possible implementation that will satisfy the use case.&nbsp; If the use case changes, then that "lean" implementation must be changed explicitly to adapt to the change in the use case.&nbsp; The lean version should be much easier to understand, much easier to unit test, and much easier to debug: there are simply fewer moving parts to deal with.<br><br>Second, on the other hand, there may be some unstated requiements in the use case that require "very rapid response" when the requirements change.&nbsp; Those requirements may direct you down the path that says add a few of the more likely extensions but nothing like "select * from everything".&nbsp; If you cannot figure out what the "likely suspects" are, I would recommend doing nothing.&nbsp; Wait for the change and accept the fact that it might take a while.<br><br>Third, beware of reuse that springs from a desire to save code.&nbsp; As soon as you employ the same (non-utility) class for two or more use cases, you are risking the coupling of all of the use cases that use that class.&nbsp; When one of the use cases changes, then what do you do?&nbsp; You can, of course, perform some detailed analysis to see what the impact of the change would be on all of the use cases but that takes time and testing and entails the risk that you did not catch all of the problems that it causes.<br><br>This is a balance between maintainability and enhancibility.&nbsp; Good maintenance practices push you in the direction of "leanness" and "low coupling".&nbsp; Good enhancibility practice also is built on low coupling but should involve other practices such as code generation and components.<br><br>Jon Stonecash<br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, November 08, 2007</h2><P>Maybe you could just "lazy load" the child objects. The child reference in the object starts out null, and when the property is first accessed, you load the child object and return it.</P>
<P>This has the advantage of flexibility and not loading child data that won't be referenced unless it is needed.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>griff replied on Thursday, November 08, 2007</h2>Hi<br>the lazy load won't work here as I will need to access some of the data items in all child tables - so I do have to load everything.<br><br>The lean option does sound possibly right, my only concern here is that several of my tables/objects similiar requirements such as formatting the address correctly (client, patient, venue etc) and names (title, lastname etc) - I could do this in the st. proc but I know I will re-use this functionality each time I want to interact with a client, patient, venue etc. so I am thinking that the ro object can contain this functionality and be available next time I interact with that object. <br><br>As you say 'it all depends'<br><br>Richard<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, November 08, 2007</h2>If you have many objects that require formatting an address, add a shared format function to the address class.  Create an interface that contains the information needed to format an address.  The shared format function would accept the interface object and return the properly formatted string.  You can do something similar to formatting names.  The behavior of formatting and address or name should only be in one class.  I would not use a SPROC for this.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>griff replied on Friday, November 09, 2007</h2><P>Hi</P>
<P>being new to OO design etc.&nbsp; Can you expand on the interface object.&nbsp; Is this more complicated/different from simply having another object e.g. cFormatAddress that accepts address data items and formats accordingly.</P>
<P>Richard</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DavidDilworth replied on Friday, November 09, 2007</h2><P>No not really.&nbsp; But using an interface would then enforce a strict contract that has to be followed wherever it is consumed.</P>
<P>A simple example for a Person could be:<BR><BR>public interface IPerson<BR>{<BR>&nbsp;&nbsp;&nbsp;string&nbsp; Title {get;}<BR>&nbsp;&nbsp;&nbsp;string&nbsp;&nbsp;Firstname {get;}<BR>&nbsp;&nbsp;&nbsp;string Lastname {get;}<BR>}</P>
<P>And then different formatting functions in your formatting class might look something like:</P>
<P>string GetFullName(IPerson person) {...implementation goes in here...}<BR>string GetShortName(IPerson person) {...implementation goes in here...}</P>
<P>So your formatting functions don't need to know about the Type of the object that contains the properties Title, Firstname and Lastname.&nbsp;&nbsp;It just knows there are&nbsp;property getters available for any object that implements the IPerson interface.</P>
<P>This is based on a <A href="http://en.wikipedia.org/wiki/Design_Patterns">design principle</A> that states&nbsp;"Program to an interface, not an implementation".</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DavidDilworth replied on Friday, November 09, 2007</h2><P>And as for whether you should go for option (1) or option (2) from your original question.&nbsp;&nbsp;</P>
<P>I would probably recommend option (1).&nbsp; Unless you think that future requirements for the BO will be very changeable.</P>
<P>Adding 1 new field/property and associated SQL in your SP is not a massive re-engineering project once you've got the basic BO built.&nbsp; It should be a relatively quick and easy&nbsp;job to do.</P>
<P>Design your BO to meet your Use Case.&nbsp; Don't design it to meet all possible variations of all possible Use Cases that you don't actually know about yet.</P>
<P>You could say this advice is based on the <A href="http://en.wikipedia.org/wiki/YAGNI">YAGNI</A> school of thought.</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
