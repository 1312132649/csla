<html><header><title>OT: Suggestions how to derive from singleton class.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OT: Suggestions how to derive from singleton class.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1877.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Thursday, November 30, 2006</h2><P>I have a need to extend a class that is implemented in a base (UI-framework) library as a singleton class.&nbsp; Without going into too much detail, the class was designed to serve as a base class for application-specific implementation but implemented as a singleton in order to take advantage of that pattern, but to also provide a pseudo-global means of accessing settings and properties needed throughout the application.&nbsp; It is critical that the same instance of the class is used throughout - thus the singleton implementation.</P>
<P>While I know that everything you read about implementing singleton indicates that the class should be sealed (NotInheritable in VB), this class is intended to be extended, so we seem to have an inherent conflict.&nbsp; In the "base" class, properties that are used by other classes in the UI-framework library as well as by application code are defined.&nbsp; But in order to provide a single, consistent way to access the information, we are able to extend the class by deriving a new class from it in our application code addign whatever additional properties and methods as are necessary.</P>
<P>The best example of what we are trying to accomplish can be found in the .NET Framework with the System.Net.WebRequest base class and derived FileWebRequest, FtpWebRequest and HttpWebRequest classes.&nbsp; The WebRequest.Create() method accepts the request's URI and instantiates the proper class based in the value.&nbsp; This requires that the derived classes be "registered" with the application in the config file by indicating what URI prefix is associated with each class (e.g. ftp -&gt; FtpWebRequest).</P>
<P>Perhaps I need to be a little more concrete...</P>
<P>Essentially, we are using a UI-framework that supports automation-based application development (a derivative of the MVC pattern).&nbsp; If we use the infamous and oft-referred MS-Office paradigm, all Office applications share a common set of properties and methods exposed through the Application object.&nbsp; But, each has it's own spin.&nbsp; For instance, if we were developing Excel and Word, we would have a base Application class in our common Office library (Office.Application) that would have Caption, CommandBars and DisplayRecentFiles properties as well as Help and Quit methods, etc.&nbsp; Each application would then implement their own Application class (Excel.Application and Word.Application) derived from Office.Application.&nbsp; The Excel class would have an ActiveSheet property whereas the Word class would have an ActiveDocument property.</P>
<P>This is essentially the model we are trying to follow.</P>
<P>One last note, it has occurred to me that we could possibly accomplish this by abandoning the singleton pattern and implementing each property and method statically - which would more resemble the current (2003 and before) versions of the Office apps - but, we are using this framework to support ASP.NET apps as well as Windows.&nbsp; This is an important distinction because static variables behave in a bit of a different way with ASP.NET apps then might be intuitive.&nbsp; Because of the ASP.NET process model, client request share the same process and thereby share the same static variables.&nbsp; Anyone who has tried to store a singleton (static) object in Session and noticed how one client's changes magically affect other clients has experienced this problem.&nbsp; And, since we need a separate instance of our object PER USER (i.e. per session), it would be a logistical nightmare to have to work-around this problem on a per property and method basis whereas addressing this in the singleton method allows us to encapsulate the fix in the base class and remove this from the shoulders of our application developers.</P>
<P>FYI - there's a great work-around for the ASP.NET singleton problem.&nbsp; See <A href="http://dotnet.org.za/eduard/archive/2004/07/07/2609.aspx">http://dotnet.org.za/eduard/archive/2004/07/07/2609.aspx</A></P>
<P>Hopefully that explains our situation thoroughly.&nbsp; I have scoured the web for info on this and have found nothing, so I am hoping that the experienced users of this forum will chime in and help us figure out how to make this happen.</P>
<P>Thanks for your input...</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Tuesday, December 05, 2006</h2>Hey SonOfPirate,<br><br>Wouldn't it be best to use Generics + Reflection here?<br><br>The Singleton factory method would then become a generic method, something like:<br><br>public class SingletonBase<br>&nbsp;&nbsp;&nbsp; protected sub new()<br>&nbsp;&nbsp;&nbsp; end sub<br><br>&nbsp;&nbsp;&nbsp; public shared function GetInstance(Of T As SingletonBase) as T<br>&nbsp;&nbsp;&nbsp; end function<br><br>end class<br><br>(this code snippet was typed from scratch, sorry for any errors ;-) )<br><br>You could also put in an additional constraint to the Of T that ensures that it has a parameter-less constructor, I know for sure it is possible but I don't recall the specific syntax at the moment.<br><br>Using reflection you can then instantiate a (singleton) instance of T and return it. <br><br><br>However, I guess that if you would implement it as such, the class would not be a 'true' singleton, as you would allow different types of instances to be created. You can put some checks in the factory method to throw exceptions that prevent this from happening, or you can support this by maintaining a private dictionary that is indexed by Type. So then you would actually have something like a 'Multiton', that maintains a Singleton of each type. Using a private dictionary that is indexed by type (or type.tostring()) for this purpose is trivial.<br><br><br>Am I addressing your needs? Or did I misunderstand your question?<br><br>Kind regards,<br>Bayu<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>The reason this won;t work is that we need the same instance of the object to be used by code in ALL of the class libraries that need it.&nbsp; So, running with the example, when running our Word application, code in both the Word and Office class libraries need to use the same instance of the Application class.&nbsp; Same with our Excel app.&nbsp; However, even though both Word and Excel know that they want to create Application.GetInstance&lt;Word.Application&gt;() or Application.GetInstance&lt;Excel.Application&gt;, respectively, the classes in our common Office class library don't know how to instantiate the object this way since they won't know what application is being executed.&nbsp; All that code knows is Application.GetInstance&lt;Office.Application&gt;.&nbsp; The end result is separate instances for each class library and not what we are trying to accomplish.</P>
<P>We need a way for code in the base library to instantiate the most sub-class applicable to that application.&nbsp; In our example, either Word.Application or Excel.application depending on which app is running.&nbsp; This way, every reference to the Application object in the app will refer to the same instance throughout.</P>
<P>Make more sense?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, December 07, 2006</h2>Why not just store a dictionary of Application objects with the type as the key?<br><br>public Application GetInstance&lt;T&gt;()<br>{<br>&nbsp;&nbsp;&nbsp; if (!_applications.ContainsKey(typeof(T)))<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  _applications.Add(typeof(T), new T());<br><br>&nbsp;&nbsp;&nbsp; return _applications[typeof(T)];<br>}<br><br>I realize the syntax is not perfect, but do you get the idea?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>Same reason - all references need to be the same instance.&nbsp; That is why I indicated the singleton pattern originally.&nbsp; And, as I mentioned, the base class library doesn't know anything about the derived type.</P>
<P>So, for instance, if we have code in our base Office class library that makes use of the Application.CommandBars property, such as:</P>
<P><CODE>Application.CommandBars.ListChanged += new EventHander(CommandBars_ListChanged);</CODE></P>
<P>And, in our actual application library, Word.dll, we have the following code:</P>
<P><CODE>Application.CommandBars.Add(new CommandBar("myBar"));</CODE></P>
<P>unless both references to "Application" are returning the same instance, the second statement will not trigger the desired event in the base class library.</P>
<P>To go with the generic approach suggested, we would have the following statements:</P>
<P><CODE><B>in Office.dll:</B><BR>Application&lt;Office.Application&gt;.CommandBars.ListChanged += new EventHander(CommandBars_ListChanged);</CODE></P>
<P>and,</P>
<P><CODE><B>in Word.dll:</B><BR>Application&lt;Word.Application&gt;.CommandBars.Add(new CommandBar("myBar"));</CODE></P>
<P>Clearly these are two separate instances whether we are tracking them in a dictionary or not.</P>
<P>What we need is a way for the following to be true from both the base class library (Office.dll) and the application class library (Word.dll):</P>
<P><CODE>(Office.Application.Current == Word.Application.Current)</CODE></P>
<P>so that any calling code will return the same instance no matter how many layers deep the object model is or how many assemblies are involved.</P>
<P>Does that make things clearer?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Thursday, December 07, 2006</h2>Ah sorry, I thought you wanted one of each type (i.e. Word, Excel, etc.).&nbsp; This is close to what office did in the COM model as you would call GetObject("Word.Application") to get an open word application or create a new one.<br><br>If you just want to have one instance line up and are not worried about more than one type of application being active at once then just set the current office app while having Current know how to keep the office apps separate if it is going to be run in a web context.&nbsp; I guess I just do not understand why you cannot just set the current app and be done with it?&nbsp; Current would need to be static, but internally it would sort out which one to use in a web context.&nbsp; That way all of the office objects would know where to look.<br><br>So what am I missing?<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, December 07, 2006</h2><P>Nah, you're still not getting it.&nbsp; Forget the COM model because that didn't use inheritance with a common base class library.</P>
<P>Yes, you can instantiate the "client application" - for lack of a better name - using Word.Application or Excel.Application.&nbsp; But the common, Office class library doesn't know anything about either of those applications even existing, let alone which is running.&nbsp; And, for that matter, both could be running - and multiple sessions of each could be running.&nbsp; It doesn't matter.&nbsp; When ANY code in ANY class in ANY library within the process of the current application calls for the current Application object, we want it to return the same object.</P>
<P>Maybe this will help.&nbsp; Here's some quick example code of our three Application classes:</P>
<P>In Office.dll (our common base class library):</P>
<P><CODE>public class Application<BR>{<BR>&nbsp; &nbsp; private CommandBarCollection _commandBars;<BR>&nbsp; &nbsp; private static Application _currentInstance;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public CommandBarCollection CommandBars<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_commandBars == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _commandBars = new CommandBarCollection(this);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _commandBars;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }</CODE></P>
<P><CODE>&nbsp;&nbsp;&nbsp; public static Application Current<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_currentInstance == null)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>?????????</B><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _currentInstance;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>}<BR><BR>public class MainMenu : Office.Menu<BR>{<BR>&nbsp; &nbsp; public MainMenu(Office.Application application) : base(application)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; application.CommandBars.ListChanged += new CommandBarChangedEventHandler(CommandBars_ListChanged);<BR>&nbsp; &nbsp; }<BR><BR><BR>&nbsp; &nbsp; private CommandBars_ListChanged(object sender, CommandBarChangedEventArgs e)<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; if (e.ListChangedType == ItemAdded)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Items["Toolbars"].Add(new MenuItem(e.CommandBar.Name));<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>In Word.dll (a "client application" referencing the common base class library):</P>
<P><CODE>public class Application : Office.Application<BR>{<BR>&nbsp; &nbsp; private DocumentCollection _documents;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public DocumentCollection Documents<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_documents == null)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _documents = new DocumentCollection(this);<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return _documents;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; protected void Initialize()<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; CommandBars.Add(new FormattingToolbar());<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>In Excel.dll (another "client application" referencing the common base class library):</P>
<P><CODE>public class Application : Office.Application<BR>{<BR>&nbsp; &nbsp; private WorkbookCollection _workbooks;<BR>&nbsp; &nbsp; <BR>&nbsp; &nbsp; public WorkbookCollection Workbooks<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; get<BR>&nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_workbooks == null)<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _workbooks = new WorkbookCollection(this);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _workbooks.SelectionChanged += new SelectionChangedEventHandler(Workbooks_SelectionChanged);<BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _workbooks;<BR>&nbsp; &nbsp; &nbsp; &nbsp; }<BR>&nbsp; &nbsp; }<BR><BR>&nbsp; &nbsp; private Workbooks_SelectionChanged(object sender, SelectionChangedEventArgs e)<BR>&nbsp; &nbsp; {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Application.Title = e.SelectedItem.Name;<BR>&nbsp;&nbsp;&nbsp; }<BR>}</CODE></P>
<P>This is a pretty simplistic example but does demonstrate the needed functionality with the exception of how to instantiate the Application class.&nbsp; As you can see, the object used by the MainMenu class in Office.dll needs to be the same as what's used in Word.dll (and Excel.dll) if the event is to respond to changes made to the CommandBars collection by code in that library - such as adding the FormattingToolbar in Word.dll.</P>
<P>Does this shed better light on the situation?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, December 08, 2006</h2><p><code>Set the current instance when the application instantiates.</code></p><p><code><br></code></p><p><code>public class Application<br>{<br>&nbsp; &nbsp; private CommandBarCollection _commandBars;<br>&nbsp; &nbsp; private static Application _currentInstance;<br><br></code></p><p><code>&nbsp;&nbsp;&nbsp; protected Application()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  if (_currentInstance != null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  throw new AppAlreadyExistsException();<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  _currentInstance = this;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;  <br>&nbsp; &nbsp; public CommandBarCollection CommandBars<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; get<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_commandBars == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _commandBars = new CommandBarCollection(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _commandBars;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }</code></p>
<code>&nbsp;&nbsp;&nbsp; public static Application Current<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; get { return _currentInstance; }<br>&nbsp; &nbsp; }<br>}</code></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>Yea that'd work except that it relies on "who gets there first".&nbsp; If the first call to Application.Current is made as:</P>
<P><CODE>app = Office.Application.Current;</CODE></P>
<P>then the instance will be of the Office.Application type; whereas, if the first call is:</P>
<P><CODE>app = Word.Application.Current;</CODE></P>
<P>then the instance will be of the Word.Application type.</P>
<P>I like the solution, but there is no assurance that it is the desired type that is set.</P>
<P>In the Word application, we need it to always be Word.Application.&nbsp; If we use this approach and the call from within the Office base class library (first statement above) executes first and the _currentInstance is set to type Office.Application then not only will we not be able to take advantage of the additional properties and methods added by the derived Word.Application class, but we will generate a run-time exception when we try to access one of them.</P>
<P>Know what I mean?</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, December 08, 2006</h2>I would assume that your UI framework library could only work in the context of an application UI.&nbsp; Even if that is not the case, there is no reason why the first instance of an application running could not override the office application instance when it is created.&nbsp; However, I would think that if you are inheriting the base application, then you could not have an instance where the base application was on its own.<br><br>public class BaseUIApplication<br>{<br>&nbsp;&nbsp;&nbsp; private static _current;<br>&nbsp;&nbsp;&nbsp; protected BaseUIApplication()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  if (_current == null)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  _current = this;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public static BaseUIApplication Current<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  get { return _current; }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>public class SpecificUIApplication : BaseUIApplication<br>{<br>}<br><br>public static class Program<br>{<br>&nbsp;&nbsp;&nbsp; public static void main()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  using (new SpecificUIApplication())<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp; using (new MainForm())<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  }<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br>In this example, the UI application will have to be the specific one for all uses of BaseUIApplication.&nbsp; You just would not have any case where BaseUIApplication would not be the inherited class.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P>So then, how will other classes in the base class library make use of the base Application class (BaseUIApplication)?</P>
<P>As I've said, that is one of the requirements.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, December 08, 2006</h2>The SpecificUIApplication isa BaseUIApplication.&nbsp; It is both.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2>But the classes in the base library have no knowledge of the SpecificUIApplication.&nbsp; You cannot code against classes you do not know exist not to mention that you lose the whole point of having a base class library if it is calling into a specific application's code.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, December 08, 2006</h2>Nor do they need to know about SpecificUIApplication.&nbsp; You code your base class library to the classes within it.&nbsp; If you derive some of the classes into new classes, the base class library will be able to use the new classes under the guise of the base classes.&nbsp; That is part of what polymorphism is all about.&nbsp; For instance, if I inherit from TextBox and modify some of the behaviour, the rest of System.Windows.Forms will still be able to work with my new TextBox, and the new TextBox will exhibit the new behaviour that I added.&nbsp; Parts of CSLA work with this as well as they call methods on BusinessBase and BusinessListBase.&nbsp; Some of those methods can be overridden by business objects, but CSLA still knows how to work with them.<br><br>Let's try this: come up with a scenario that you believe will not work with the code snippet previously posted, and we will look at coming up with a solution.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, December 08, 2006</h2><P><CODE>public class BaseUIClass<BR>{<BR>&nbsp; &nbsp; public void Initialize()<BR>&nbsp; &nbsp; {<BR>&nbsp; &nbsp; &nbsp; &nbsp; BaseUIApplication.Current.CommandBars.Add(new CommandBar("myBar"));<BR>&nbsp; &nbsp; }<BR>} </CODE></P>
<P>This code will ONLY work if code that initializes the SpecificUIApplication executes first.&nbsp; In the scenerio you described this will be the case but since many clients applications of many types will make use of the base library there is no guarantee that this will be the case.&nbsp; By making the BaseUIApplication abstract, all we do is ensure that a run-time exception is thrown when an attempt is made to access the BaseUIApplication.Current property before initialized by the client application.</P>
<P>I am looking for a better, more reliable and stable approach.&nbsp; Also keep in mind that we will be using this to drive web applications as well as windows form apps.&nbsp; Perhaps relying on Application and CommandBars as the example steered things in an unintended direction.&nbsp; The whole point is to have a singleton class that is used in one class library extended and used in another.</P>
<P>I will have to setup and test some different scenerios and see if anything comes from it, I guess.&nbsp; Not as easy an answer as I'd hoped to get.&nbsp; <img src="/emoticons/emotion-8.gif" alt="Indifferent [:|]" /></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Saturday, December 09, 2006</h2>Well, I just do not see that as an issue as only one instance of a UIApplication class would be in use within a Windows or Web application.&nbsp; So when the Windows or Web application starts, it creates the UIApplication that should be used and you are done with it.&nbsp; But you do not like that, so I will offer a few other suggestions.<br><br>One is to keep in mind that the Office automation model does not use the singleton pattern except for the current document (I think).&nbsp; Everything else requires a reference to an object to perform an operation.<br><br>The other is that you your base classes can instantiate objects they know nothing about.<br>Activator.CreateInstance("MySpecificApplicationLibrary",&nbsp; "MySpecificApplicationLibrary.MySpecificApplication");<br>would create an instance of an inherited class even when called from base class code.&nbsp; Your windows or web application could have the dll and type to create in the .config file.<br><br>Good luck!<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
