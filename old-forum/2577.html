<html><header><title>Definition of behaviour</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Definition of behaviour</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2577.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>gderoeck posted on Thursday, March 22, 2007</h2><P>Hello!</P>
<P>I've been reading the forum and have thumbed through the book to find a clear definition of behaviour, but haven't found one.&nbsp; I understand the mantra of "classes are defined by behaviour" and agree that this is vital to correct design.&nbsp; I've heard Rocky state that a class should only have one responsibility/behaviour.&nbsp; Question I have is, how broad is the term "behaviour" supposed to be?</P>
<P>In EditableRoot objects,&nbsp;there are&nbsp;methods such as Create, Update, Fetch and Delete.&nbsp; Could these methods not be considered individual&nbsp;behaviours?&nbsp; Or,&nbsp;should behaviour be&nbsp;defined&nbsp;in CSLA in a more general sense, like "Maintain an Invoice"?</P>
<P>My whole reasoning behind asking this question is, number one, I'm new to CSLA - have written only one application using the framework so far.&nbsp; Our BA has put together a Use Case model for another, larger application and I'm trying to define and design the objects around the model, as stated here and in the book.</P>
<P>She has steps in the use case such as "Create the chart", "Save the chart" and "Delete the chart".&nbsp; (This is a medical application.)&nbsp; Now, I understand that "Display the chart" could be (and probably should be) a readonly object - that's not difficult to understand.&nbsp; But, the use case model I'm looking at has these three steps mentioned earlier that, I think, could fall under a more general category of "Maintain a chart", or something to that effect.</P>
<P>Am I off on this?&nbsp; Is my thinking correct?&nbsp; I guess the only trap I would need to watch out for is to make sure "Maintain a chart" doesn't become so broad that it loses its responsiblity.</P>
<P>Thank you in advance for any input - I just want to make sure I am on the right track in my design.</P>
<P>-Greg</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Thursday, March 22, 2007</h2><p class="MsoNormal">Responsibility and behavior are not interchangeable terms.<span>&nbsp; </span>Behavior is what the class does while a responsibility
is a reason for change.<span>&nbsp; </span></p>

<p class="MsoNormal"><o:p>&nbsp;</o:p></p>

<p class="MsoNormal">Rocky is referring to the single-responsibility principle
which states that a class should have only one responsibility (reason for
change).<span>&nbsp; </span>The business object’s
responsibly is to enforce business rules for an entity.<span>&nbsp; </span>This should be its only responsibility.<span>&nbsp; </span>Once you add database code to the BO, you introduce
another reason for change.<span>&nbsp; </span>The BO will
change if the business rules change and when the<span> persistence logic changes</span>.<span>&nbsp; </span>This violates the single-responsibility
principle.</p>

<p class="MsoNormal"><o:p>&nbsp;</o:p></p>

<p class="MsoNormal">If the business rules state the chart can be added, updated
and deleted, then these functions belong in the chart object.<span>&nbsp; </span>This satisfies the single-responsibility because
they fall under the category of business rules.<span>&nbsp;
</span>However, the actual code that interacts with the database is another responsibility
and should probably be separated.<span>&nbsp; </span></p>

<span>Keep in mind the single- responsibility principle
is a guideline and not a rule.</span></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Thursday, March 22, 2007</h2><P>To expound on what malloc said, you are correct that creating, updating, deleting, etc. ARE different behaviors but, as malloc said, they fall within the single-responsibility principal for the object.&nbsp; Where behavior is important is when looking at inheritance, encapsulation, collaboration, etc.&nbsp; The goal of the framework is to inherit behavior.&nbsp; This is supported, for example,&nbsp;by having the data portal CRUD operations in a base class.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>gderoeck replied on Thursday, March 22, 2007</h2><P>Wonderful, that's the clarification I was looking for.&nbsp; Just so I can make sure I understand....</P>
<P>It would be accurate to say that a class, in a well defined model, would have one responsibility.&nbsp; The behavior(s) of the class is/are directly related to that responsibility.&nbsp; So, in a class, the word "behaviour" could be interchangeable with the word "action".&nbsp; (Stop me if I'm off on this...)</P>
<P>So, take my example.&nbsp; I have a Chart object that has the responsibility of maintaining chart data, meaning it has behaviors of creating the object with default values,&nbsp;retrieving, adding, updating, or deleting chart data.&nbsp; Now, I have another class, named ChartDisplay&nbsp;that has the responsiblity of&nbsp;retrieving certain fields for readonly&nbsp;display (for a print preview, for example).&nbsp; This class has the behaviours of creating the object&nbsp;and retrieving data.</P>
<P>This&nbsp;next part is&nbsp;where I may be off.............</P>
<P>Now, since the Create behaviour is common among these two classes (meaning, they both return an object with the same default property), would it be correct to assume that this could be a candidate for normalization?&nbsp; If&nbsp;a Create method returns an object of either type&nbsp;with&nbsp;a common&nbsp;default property (say, a User object that contains the UserID, FirstName, LastName, etc), I would think this is correct.&nbsp; All I would have to do is designate which type of object to create.&nbsp; Meaning, the Create() method could become either it's own class or part of a module that contains common behaviours, thus normalizing the behaviour.&nbsp; (Much like the Assignment module in PT).</P>
<P>The Retrieve, or Fetch behaviour isn't common between the two because they don't return the same set of data.</P>
<P>So, am I getting this or am I still confused?</P>
<P>Thank you both for the responses - I'm trying to make sure I start down the right path.</P>
<P>-Greg</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, March 23, 2007</h2>Greg,<br><br>I don't see how the create is common to both the editable and read-only objects.&nbsp; Actually, I would think that the read-only object would only have fetch behaviors.<br><br>Regarding the definition of behavior, the other posters are correct.&nbsp; I think someone said at one point that technically having the data access in the code does violate the SRP, but that there really is no good way to help overcome this, so we must accept that we violate the prinicpal.&nbsp; That's ok, because SRP is a guideline... we should follow it, unless we have very carefully considered the reasons that we need to.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Friday, March 23, 2007</h2>

<p class="MsoNormal"><span>If the
creation of a business object has behavior that does not fit the responsibility
of the business object, it should be separated into another class.<span>&nbsp; </span>This is typically done with a factory.<span>&nbsp; </span><o:p></o:p></span></p>

<p class="MsoNormal"><span><o:p>&nbsp;</o:p></span></p>

<p class="MsoNormal"><span>If
ChartDisplay is a read-only version of Chart, you could create a factory class that
sets the defaults and returns a common interface.<span>&nbsp; </span>You would need to create an interface that
would contain the properties and methods that are common to both.<span>&nbsp; </span>However, ChartDisplay and Chart really don’t have
any behavior in common and you would end up casting to its concrete classes in
most cases.<span>&nbsp; </span>This makes the factory in
this case less useful and probably unnecessary.<span>&nbsp;
</span><o:p></o:p></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate replied on Friday, March 23, 2007</h2><P>Greg,</P>
<P>I think you hit the nail on the head when you said that your Chart object is responsible for managing chart DATA and your ChartDisplay object is responsible for providing the data to the UI for presentation.</P>
<P>I understand the inclination that both of these objects share the same creation process but I caution you to think a little deeper and examine how common they really are.&nbsp; For instance, will they both use the same SQL statement / stored procedure?&nbsp; If you define a common ChartBase class, would you have to override the create method in each of your derived classes in order to make them work?</P>
<P>Remember, just because two objects may work on the same data and may share some properties does not mean they are good candidates for inheritance.&nbsp; All objects have some form of a creation/instantiation behavior but unless the implementation of that behavior is common, inheritance may not be appropriate.&nbsp;&nbsp;Of course, an abstract (MustInherit in VB) base class which forces you to implement the method in your derived class is an acceptable way to implement common properties, etc. if you are concerned about code reuse.&nbsp; But, I caution you that once you create an object graph such as this, you are also introducing possible issues with polymorphism.&nbsp; Ask yourself if you really want to accidentally use a ChartDisplay object when you want a Chart object.&nbsp; Having an abstract base class or interface common between the objects and used as the return type from a factory method, for example, means that you have to be aware that either object could be returned.</P>
<P>This last point is a significant reason why you should always program to interfaces - because of the extensibility, etc. of the approach.&nbsp; However, you need to do so with awareness of the flip-side and that is the unwanted risk that an unintended object that also implements the interface is returned.</P>
<P>Because you have two clearly defined responsibilities, I do believe that you need two classes: Chart and ChartDisplay.&nbsp; However, thinking through how their behaviors are implemented, it seems to be that they don't have much in common other than the data that they work on.&nbsp; And this is not enough basis for inheritance.&nbsp; At least, IMO.</P>
<P>HTH</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>gderoeck replied on Friday, March 23, 2007</h2><P>This is all great information, thank you to everyone for your input.</P>
<P>I'm thinking that the Create method I referred to may have been a bad example.&nbsp; In actuality, the reason I used it is because both the Chart and the ChartDisplay object will be used at the same time.&nbsp; </P>
<P>The idea is that a Chart will be have various sections, or properties, that will be child objects.&nbsp; At the beginning, the Chart(editable root) and the ChartDisplay(readonly root) will be created exactly the same way every time - by passing an existing User object to an identical&nbsp;child property in both classes.&nbsp; This object will already exist because it would have been created when the user logged into the application.&nbsp; So, both objects will be created the same way.&nbsp; </P>
<P>The Chart object will be updated by&nbsp;filling child objects through the individual screens in the application.&nbsp; For example, the user logs in and creates a chart.&nbsp; At this point, the ChartDisplay object would contain only the data from the User object and nothing else, since nothing has been filled in yet.&nbsp; At the same time, the Chart object will contain the exact same User object and nothing else as well.&nbsp; As the user fills in sections of the application, or Chart&nbsp;(such as Cardiac, NeoNatal, Burn) and saves them, the associated&nbsp;child object is&nbsp;populated with data.&nbsp; The Chart object is responsible for Updating, Saving and Deleting the core data within the object.&nbsp; As well, it encapsulates the data within the child objects so that no manipulation of that data is done outside of the Chart object itself.</P>
<P>The ChartDisplay object is responsible for providing a "View", or Fetch of the actual description fields of the data.&nbsp; This data is then displayed in the UI and refreshed every time the user completes or cancels out of a section.&nbsp; The ChartDisplay object would also have ReadOnly children representing the individual sections that mirror the Chart object's children.&nbsp; </P>
<P>When a chart is complete, it needs to be either FAXed or printed.&nbsp; There will be another object that will be responsible for this as well that will be passed the ChartDisplay object for processing.</P>
<P>I hope I explained that well enough.&nbsp; In what I have so far, there's no inheritance used really.</P>
<P>Again, I'm still in the design mode of this, so nothing's in stone yet. :)&nbsp; Again, thank you all for your comments.&nbsp; I appreciate the help!</P>
<P>-Greg</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 23, 2007</h2><P>This is why responsibilities and behaviors should both be described by short phrases. Single words can imply similarity where there is no real similarity.</P>
<P>Order has "create"</P>
<P>Customer has "create"</P>
<P>But "Create an order" and "Create a customer" are clearly not the same behavior.</P>
<P>Of course, once you dig into <EM>how</EM> to implement both those behaviors you may find some commonality. Certainly that's what CSLA is all about - defining and implementing commonality across data binding, n-tier behaviors, persistence and so forth.</P>
<P>But remember that reuse is a side-effect of good OO design; not a goal.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>malloc1024 replied on Friday, March 23, 2007</h2>

<p class="MsoNormal"><span>Greg,<br></span></p><p class="MsoNormal"><span><br></span></p><p class="MsoNormal"><span>I am not
exactly sure if you need a ChartDisplay class here.<span>&nbsp; </span>The Chart class can be used to display the
information to the UI.<span>&nbsp; </span>However, if you
want to present the Chart data to the UI in a different way, you could create a
ChartDisplay class that would accept a Chart object and wrap it.<span>&nbsp; </span>This would create another view of your data.<span>&nbsp; </span>You could also flatten your object model and
make it read-only with the wrapper class if you like.<o:p></o:p></span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>gderoeck replied on Monday, March 26, 2007</h2><P>Thanks again to everyone.&nbsp; Great discussion!</P>
<P>Malloc - the reason I'm thinking of two classes is because there will be a difference in the data in the sense that the actual values of the fields will be the ones updated, saved, etc, whereas the description of these values will be the display fields.&nbsp; Much of the data in the UI will be displayed in drop downs, list boxes and check box fields and each of these will have values associated with them that will be saved as opposed to the descriptions.&nbsp; The backend data will be foreign keys associated to data tables for the majority of the application.&nbsp; So, you can see that the store procs to retrieve the data will be different because, in the Chart object, the fields will be the values whereas the ChartDisp class will be the actual descriptions.&nbsp; To combine the two would result in one big bad class and would violate the "one responsibility" thought.</P>
<P>Rocky - I see your point where you say responsibilities and behaviours should be described in short phrases.&nbsp; That makes it much easier to define the responsibility, obviously.&nbsp; I forgot about that section of the book where you covered that - I need to go back and read it more carefully.&nbsp; It probably was a stretch to think that the Create method could be combined for both classes.&nbsp; I'll take another look at that as well.&nbsp; Thank you!</P>
<P>-Greg<BR></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jimbo replied on Tuesday, March 27, 2007</h2>I notice that malloc used the word "Entity". What is an Entity in the csla world? It's not a common word in Rocky's terms. Is it a BO, a representation of a data relation, a DTO, or what?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, March 27, 2007</h2>I don't think it's normally used in the Csla world, unless you're talking about entity in the relational db context.&nbsp; I think malloc's use of entity would best be replaced by 'use case'<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
