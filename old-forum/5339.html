<html><header><title>CSLA &quot;Correct&quot; Way</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>CSLA &quot;Correct&quot; Way</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5339.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wbmstrmjb posted on Wednesday, September 03, 2008</h2>We are struggling to understand the "proper" way to implement CSLA objects in general for any typical database application.  Going the ProjectTracker route of each object being whatever properties that object needs from various sources is nice, but does not lend itself to codegen.  Going the route of one object per table and then combining those objects in larger objects doesn't have great performance because each object needs to make it's own database calls.<br /><br />So my question is as follows.  What is the normal proper CSLA way to implement the following (dumb but easy to follow) example:<br /><br />Classes: Person (PersonID, Name), Car (CarID, PersonID, Make), MaintenaceRecord (MaintenanceID, CarID, StationID, ServiceDone), Station (StationID, StationName)<br /><br />Relationships: Person has 0 or more cars.  Cars have 0 or more MaintenaceRecords.  MaintenanceRecords are for a single shop.<br /><br />In a UI that shows the Person Info and Car Info with MaintenaceRecords with Station Info below, you need all 4 tables of data.<br /><br />Option 1:  The non-codegen way to do this would be to create a task-centric object that had the properties of the Customer and Car in it and give it a child of MaintenanceRecords collection and each MaintenanceRecord would also include the Station Info in it properties.  Basically 3 objects needed, a RO PersonCar, a RO StationMaintenanceRecord, and a ROList StationMainenanceRecordList.  These are all custom objects that do not work well with codegen (unless I am missing something with codegen).  The SQL used to get this info needs to be custom SPs or custom join queries within the objects.<br /><br />Option 2:  To codegen it, we codgen all 4 tables into objects and lists for each.  Now we have 8 total objects.  We make a new BO that contains an instance of Station and an instance of MaintenanceRecord and call it StationMaintenanceRecord (like above).  Then make a list of those StationMaintenanceRecordList (like above).  We make a new BO that contains an instance of Person, and an instance of Car, and an instance of StationMaintenanceRecordList and call it PersonCar (like above).  Each of the 8 lower level objects were codegened, but now a load of PersonCar take 4 seperate calls to the DB instead of one call (or maybe 2 in the case of not passing a multi-return DR down to the child).<br /><br />Both options have their problems and both make certain things easier.  Obviously this scenario is very basic and so codegen isn't necessary, but I am asking in the theoretical sense so that our rather large application can use whatever methodology is presented.  Are we missing a third option completely that would be the best practice?  Of the two I described, neither seem feasible because Rocky advocates codegen, but also would not advocate a mash up of objects that each make independent calls.  So where are we going wrong?<br /><br />Thanks,<br />Mike</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>sergeyb replied on Wednesday, September 03, 2008</h2>Mike,<br /><br />You might want to look at the DeepData sample.  It shows how to load data into a graph from a single stored procedure.  If you want to code gen, sure you can do that.  IMHO, I would code gen all the objects you listed in Option 2, then manually modify code to create a single object graph that has customer as the root.  All you would need to do is add a property for each child or child list and ChildPortal access methods in your children.  So, you have the best of both worlds - you code gen a bulk of code, but you modify it to be correct from business perspective.  I would definitely use a single SP with multiple results sets as well.<br /><br />Does this make sense?<br /><br />Sergey Barskiy<br />Principal Consultant<br />office: 678.405.0687 | mobile:&#160;404.388.1899<br />Magenic &#174;<br />Microsoft Worldwide Partner of the Year | Custom Development Solutions, Technical Innovation<br /><br />-----Original Message-----<br />From: Wbmstrmjb [mailto:cslanet@lhotka.net] <br />Sent: Wednesday, September 03, 2008 8:39 PM<br />To: Sergey Barskiy<br />Subject: [CSLA .NET] CSLA "Correct" Way<br /><br />We are struggling to understand the "proper" way to implement CSLA objects in general for any typical database application.  Going the ProjectTracker route of each object being whatever properties that object needs from various sources is nice, but does not lend itself to codegen.  Going the route of one object per table and then combining those objects in larger objects doesn't have great performance because each object needs to make it's own database calls.<br /><br />So my question is as follows.  What is the normal proper CSLA way to implement the following (dumb but easy to follow) example:<br /><br />Classes: Person (PersonID, Name), Car (CarID, PersonID, Make), MaintenaceRecord (MaintenanceID, CarID, StationID, ServiceDone), Station (StationID, StationName)<br /><br />Relationships: Person has 0 or more cars.  Cars have 0 or more MaintenaceRecords.  MaintenanceRecords are for a single shop.<br /><br />In a UI that shows the Person Info and Car Info with MaintenaceRecords with Station Info below, you need all 4 tables of data.<br /><br />Option 1:  The non-codegen way to do this would be to create a task-centric object that had the properties of the Customer and Car in it and give it a child of MaintenanceRecords collection and each MaintenanceRecord would also include the Station Info in it properties.  Basically 3 objects needed, a RO PersonCar, a RO StationMaintenanceRecord, and a ROList StationMainenanceRecordList.  These are all custom objects that do not work well with codegen (unless I am missing something with codegen).  The SQL used to get this info needs to be custom SPs or custom join queries within the objects.<br /><br />Option 2:  To codegen it, we codgen all 4 tables into objects and lists for each.  Now we have 8 total objects.  We make a new BO that contains an instance of Station and an instance of MaintenanceRecord and call it StationMaintenanceRecord (like above).  Then make a list of those StationMaintenanceRecordList (like above).  We make a new BO that contains an instance of Person, and an instance of Car, and an instance of StationMaintenanceRecordList and call it PersonCar (like above).  Each of the 8 lower level objects were codegened, but now a load of PersonCar take 4 seperate calls to the DB instead of one call (or maybe 2 in the case of not passing a multi-return DR down to the child).<br /><br />Both options have their problems and both make certain things easier.  Obviously this scenario is very basic and so codegen isn't necessary, but I am asking in the theoretical sense so that our rather large application can use whatever methodology is presented.  Are we missing a third option completely that would be the best practice?  Of the two I described, neither seem feasible because Rocky advocates codegen, but also would not advocate a mash up of objects that each make independent calls.  So where are we going wrong?<br /><br />Thanks,<br />Mike<br /><br /></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Wednesday, September 03, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Wbmstrmjb:</strong></div><div>...Going the route of one object per table and then combining those objects in larger objects doesn't have great performance because each object needs to make it's own database calls....</div></BLOCKQUOTE></P>
<P>I too am interested in this discussion, but this is the route we have taken and so far it is performing much better than the implementation it is replacing. I have concerns though, and we have made extensive use of "lazy loading" to avoid loading child objects unless they will actually be used.</P>
<P>From my experience in this forum, there seems to be strong support for tailoring the object design to match the exact way they are used (e.g. the "use case"), with it being fine -- even preferable from a performance standpoint -- to have multiple objects mapped to the same database table. However, I don't see how that lends itself to code generation unless there is some intermediate design tool I'm not familiar with. </P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, September 03, 2008</h2><P><FONT face=Tahoma size=2>This has been discussed a couple of times in other threads.</FONT></P>
<P><FONT face=Tahoma size=2>Code generation cannot necessarily develop all your classes.&nbsp; However, it can often be used for generating the majority of your classes - those maintenance-type screens where the use case pretty much matches the database table structure.&nbsp; Code generation helps get these more mundane screens out of the way, leaving you time to work on the more interesting sections.</FONT></P>
<P><FONT face=Tahoma size=2>Code generation can also help for the more interesting sections as well.&nbsp; Often times, code generation can develop a majority of the class structure.&nbsp; It won't be a 100% solution, but depending on how closely the use case matches the table structure, it can get you a long ways towards 100% - and it's boilerplate code you didn't have to write.&nbsp; <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /></FONT></P>
<P><FONT face=Tahoma size=2>HTH</FONT></P>
<P><FONT face=Tahoma size=2>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Q Johnson replied on Wednesday, September 03, 2008</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Wbmstrmjb:</strong></div><div>...However, I don't see how that lends itself to code generation unless there is some intermediate design tool I'm not familiar with. </P>
<P></div></BLOCKQUOTE></P>
<P>Maybe that "intermediate design tool" you mention here is just a code gen template waiting to be built.</P>
<P>I just want to&nbsp;offer for your consideration&nbsp;that&nbsp;the degree to which&nbsp;a solution's&nbsp;architecture "lends itself to code generation" is probably&nbsp;as dependent&nbsp;on how&nbsp;much YOU lend yourself to code generation as it is on other factors.</P>
<P>Using templates produced by others (ala CSLAGEN or other template providers of other code generation products) to generate the CSLA classes is a great start.&nbsp; It certainly makes you more productive than if you wrote them by hand.&nbsp; But there are other opportunities for applying it that are limited only by your imagination and willingness to write templates.&nbsp; </P>
<P>Give some thought to letting it do even more for you.</P>
<P>Good luck!</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Wednesday, September 03, 2008</h2>I've had pretty good luck leaving objects like Customer and Car in their own objects, but filling multiple objects out of one SQL call.&nbsp; I haven't looked at the Deep Data sample, but this sounds very much like the approach that's taken there.<br><br>I'd create a composite object like you mentioned in cases where I want to load just a portion of a deep / wide object graph in a large collection.&nbsp; In a case like this, it's worth creating the custom task-centric object to more closely match the needs of the UI, because you really cut the data access needs vs. loading the whole object graph for multiple objects.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wbmstrmjb replied on Thursday, September 04, 2008</h2>I think this is making more sense.  So I can leave each table in it's own class.  But instead of puting the SQL into each individual class, build a combined SP that the parent loads and distributes.  That should work while still allowing for the classes (less the data access) to be codegened.<br /><br />One other question I have is what are the pros and cons to inheritance vs. wrapping the objects?  In the case of the PersonCar in my example, would it be better to extend Person and include an instance of Car as a property, or make a PersonCar object that has an instance of each?  Is there a strong reason to do one or the other?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Thursday, September 04, 2008</h2>Well, if I understand the scenario, the relationship between Person and Car is pretty central to your model.&nbsp; I'd go ahead and just have a Person object with a Cars list that's going to have zero or more Car objects in it.<br><br>If you need to compress this relationship, like for searching or lists or something, then follow the Project Tracker example and do a PersonInfo readonly object, or whatever you need for your scenario.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Friday, September 05, 2008</h2><P>Speaking of inheritance...</P>
<P>This is something of a side-issue, but you'll also get great flexibility by not deriving directly from the CSLA data object classes themselves but instead inserting a common base class between your generated classes and the intended CSLA base class. (specifically, your own BusinessBase, BusinessListBase, EditableRootListBase, ReadOnlyListBase, and CommandBase -derived common root classes)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dlambert replied on Friday, September 05, 2008</h2>Good point.&nbsp; I discovered this particular tip a little too late to conveniently implement in my first CSLA project, but I think it would have helped in a couple spots.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Wbmstrmjb replied on Friday, September 05, 2008</h2>Can you shed some light as to common functionality you would add to the middle layer?</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Saturday, September 06, 2008</h2><P>^^^^^</P>
<P>Ours is a special case, since we are using an Object-Relational mapper for data access. </P>
<P>Our "middle layer" does all the data access -- using the ORM (the Wilson ORMapper in our case, but NHibernate also can be made&nbsp;to work).</P>
<P>However, here are some other things our middle layer does:</P>
<P>(1) Referential integrity constraint enforcement - blocks deletion where not allowed, propagates deletes where allowed, and provides for Validation rules to warn user when foreign key value doesn't exist, or when new primary key value collides with an existing object.</P>
<P>(2) COUNT, EXISTS, and aggregate functions (SUM, MIN, MAX)&nbsp;via CommandBase for all of our table-mapped objects.</P>
<P>(3) Logging</P>
<P>(4) Auditing</P>
<P>(5) Retrieval of database schema information so we can enforce maximum field length (again via business rules) to match the actual back-end database size. </P>
<P>(and this is just a sampler...)</P>
<P>We have to support 3 different back-end databases (various versions of Oracle, SQL Server, and Access), so this approach might not work for everyone, but it's working very well for us so far. </P>
<P>Anyway, this is just to illustrate what you can do in a middle layer...</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
