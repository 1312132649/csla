<html><header><title>Extending BusinessRules to Support Client-Side Validation in ASP.NET MVC</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Extending BusinessRules to Support Client-Side Validation in ASP.NET MVC</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11964.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 posted on Wednesday, May 01, 2013</h2><p>I am working on a way to make custom CSLA validation rules work with the extensible validation architecture of ASP.NET MVC. I have worked out how to extend MVC to inject the client-side rules, like this:</p>
<p>1. Create subclass of DataAnnotationsModelValidatorProvider, overriding GetValidators():</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; protected override IEnumerable&lt;ModelValidator&gt; GetValidators(ModelMetadata metadata, ControllerContext context,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEnumerable&lt;Attribute&gt; attributes)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var items = attributes.ToList();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (AddImplicitRequiredAttributeForValueTypes &amp;&amp; metadata.IsRequired &amp;&amp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; !items.Any(a =&gt; a is RequiredAttribute))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; items.Add(new RequiredAttribute());<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var validators = new List&lt;ModelValidator&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var attr in items.OfType&lt;ValidationAttribute&gt;())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // custom message, use the default localization<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attr.ErrorMessageResourceName != null &amp;&amp; attr.ErrorMessageResourceType != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validators.Add(new DataAnnotationsModelValidator(metadata, context, attr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // specified a message, do nothing<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (attr.ErrorMessage != null &amp;&amp; attr.ErrorMessage != WorkaroundMarker)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validators.Add(new DataAnnotationsModelValidator(metadata, context, attr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ctx = new MessageContext(attr, metadata.ContainerType, metadata.PropertyName,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.CurrentThread.CurrentUICulture);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var errorMessage = validationMessageDataSource.GetMessage(ctx);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var formattedError = errorMessage == null<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? GetMissingTranslationMessage(metadata, attr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : FormatErrorMessage(metadata, attr, errorMessage);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var clientRules = GetClientRules(metadata, context, attr,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; formattedError);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validators.Add(new LocalizedModelValidator(attr, formattedError, metadata, context, clientRules));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (metadata.Model is IValidatableObject)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validators.Add(new ValidatableObjectAdapter(metadata, context));<br /><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return validators;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>2. Create a ValidatableObjectAdapter class that extends ModelValidator. This class uses 2 interfaces IValidatableObject and IClientValidationRule (a custom one) to pull the validation data from CSLA:</p>
<p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// Adapter which converts the result from &lt;see cref=&quot;IValidatableObject&quot;/&gt; to &lt;see cref=&quot;ModelValidationResult&quot;/&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;remarks&gt;Client side validation will only work if the rules from &lt;see cref=&quot;IValidatableObject.Validate&quot;/&gt; <br />&nbsp;&nbsp;&nbsp; /// implements &lt;see cref=&quot;IClientValidationRule&quot;/&gt;&lt;/remarks&gt;<br />&nbsp;&nbsp;&nbsp; public class ValidatableObjectAdapter <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : ModelValidator<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ValidatableObjectAdapter(ModelMetadata metadata, ControllerContext controllerContext)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : base(metadata, controllerContext)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.metadata = metadata;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly ModelMetadata metadata;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Gets or sets a value that indicates whether a model property is required.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;true if the model property is required; otherwise, false.&lt;/returns&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override bool IsRequired<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get { return true; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// When implemented in a derived class, returns metadata for client validation.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// The metadata for client validation.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/returns&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;remarks&gt;Will only work if the rules from &lt;see cref=&quot;IValidatableObject.Validate&quot;/&gt; implements &lt;see cref=&quot;IClientValidationRule&quot;/&gt;&lt;/remarks&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override IEnumerable&lt;ModelClientValidationRule&gt; GetClientValidationRules()<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var validator = (IValidatableObject)metadata.Model;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var validationResults = validator.Validate(new ValidationContext(metadata.Model, null, null));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var validationResult in validationResults)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var clientRule = validationResult as IClientValidationRule;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (clientRule == null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var rule = new ModelClientValidationRule<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage = clientRule.ErrorMessage,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationType = clientRule.ValidationType<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var kvp in clientRule.ValidationParameters)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rule.ValidationParameters.Add(kvp);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return rule;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// When implemented in a derived class, validates the object.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;param name=&quot;container&quot;&gt;The container.&lt;/param&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// A list of validation results.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/returns&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override IEnumerable&lt;ModelValidationResult&gt; Validate(object container)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var validator = (IValidatableObject)metadata.Model;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var validationResults = validator.Validate(new ValidationContext(metadata.Model, null, null));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var validationResult in validationResults)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool hasMemberNames = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (var memberName in validationResult.MemberNames)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hasMemberNames = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var item = new ModelValidationResult<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberName = memberName,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message = validationResult.ErrorMessage<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return item;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hasMemberNames)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return new ModelValidationResult<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MemberName = string.Empty,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message = validationResult.ErrorMessage<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p>Here is the custom interface:</p>
<p>&nbsp;&nbsp;&nbsp; public interface IClientValidationRule<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Gets complete error message (formatted)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string ErrorMessage { get; set; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Gets or sets parameters required for the client validation rule<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IDictionary&lt;string, object&gt; ValidationParameters { get; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// Gets client validation rule (name of the jQuery rule)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string ValidationType { get; set; }<br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p>
<p>3. Modify CSLA to implement the 2 interfaces, IValidatableObject and IClientValidationRule.</p>
<p>This is where I am running into a wall. Ideally, I would like to make implementing the IClientValidationRule part of the business rule itself so that implementing this optional interface and creating a jQuery library are all that are needed to support client-side validation of CSLA rules.</p>
<p>However, there doesn&#39;t seem to be a way to iterate the rules that are registered using BusinessRules.AddRule() to get at those client rules to return in GetClientValidationRules(). Ideally, I would cast the rule to the interface type and return the values that are defined in the rule itself. CSLA seems to only allow access to the broken rules, which don&#39;t seem to have any reverse mapping to the rule object that created them. Is there a way to get the original rule type (or better yet, instance) from BrokenRules?</p>
<p>BrokenRules has an internal constructor - I tried subclassing it but its internal constructor sets a private property. Furthermore, the BrokenRules property of BusinessBase is not virtual.</p>
<p>Another question: Why isn&#39;t this already part of CSLA? If CSLA had its own ModelValidatorProvider out of the box, people wouldn&#39;t need to pull their hair out to do this sort of thing. A mixed bag of client and server-side validation usually isn&#39;t acceptable because the server validation rules only fire when the all of the client ones fail. Ideally, we would run them all on the client and with MVC it is possible, provided CSLA had a facility to define the metadata for those rules.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Thursday, May 02, 2013</h2><p><span style="font-family:Times New Roman;font-size:small;">Hi, </span></p>
<p><span style="font-family:Times New Roman;font-size:small;">IValidatableObject only exists for .NET 4 and 4.5 - not for Silverlight or WinRT. <br />IClientValidationRule is from a 3rd party library griffin.mcvccontrib. <br />IClientValidatable is from System.Web.Mvc namespace and also requires other&nbsp;types from the System.Web.Mvc namespace </span></p>
<p><span style="font-family:Times New Roman;font-size:small;">CSLA has it&#39;s own advanced RuleEngine that can add attribute rules derviced from <span class="selflink">System.ComponentModel.DataAnnotations<span>.</span>ValidationAttribute </span>into it&#39;s rule own engine. </span><span style="font-family:Times New Roman;font-size:small;">And&nbsp;the CSLA RuleEngine runs on all supported platforms - not just a subset where System.Web.Mvc is available.</span></p>
<p><span style="font-family:Times New Roman;font-size:small;">So&nbsp;from a CSLA perspective - if you want to use javacript validation in your client you should implement your own IClientValidateable&nbsp;rules and javascripts and add these as attributes in your model rather that trying to tweak the CSLA rules into supporting MVC ClientSide validation.&nbsp;</span></p>
<p><span style="font-family:Times New Roman;font-size:small;">This may change in the future -&nbsp; but this&nbsp;is the recommendation for now. </span></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Thursday, May 02, 2013</h2><p>Yes, I realize IClientValidatable is the &quot;recommended&quot; way of doing this from Microsoft, but they dropped the ball by including this interface in the System.Web.Mvc DLL. This means there is no way to use it in my business library without setting a hard reference to MVC - something I am trying to avoid. In addition to this snag, once you go down the road of using DataAnnotations attributes exclusively, there is no way to use rule severity, priority, or any of the other enhancements provided by CSLA.</p>
<p>I ended up cannibalizing Griffin.MvcContrib because it was also tying the business layer directly to the presentation layer. However, there is no reason why CSLA couldn&#39;t have a similar interface to IClientValidationRule that supports rule severity to enable business rules to optionally support client-side validation. IValidatableObject isn&#39;t technically required.</p>
<p>My goal is to extend the CSLA rules subsystem to support client validation, not to change the implementation from the way it is or make it incompatible with other presentation technologies. Unfortunately, with so many private, internal and non-virtual members this task is not easy. I was hoping that you might know a workaround that I couldn&#39;t locate. The only thing I really need is a way to iterate the business rules collection so I can cast the rules to IClientValidationRule and pull the metadata from my custom rules - however, it would also be nice if all of the built in CSLA rules also supported client validation metadata by implementing the interface as well.</p>
<p>Short of that, I am left with 5 options. Let me know if you spot any others that I have missed.</p>
<p>1. Add IClientValidationRule and a custom ModelValidatorProvider to CSLA as a contribution so everyone using MVC can benefit from it (without forcing everyone using MVC to tie their business layer directly or indirectly to System.Web.Mvc.dll).</p>
<p>2. Add IClientValidationRule and a custom ModelValidatorProvider to a fork of CSLA and use Git to merge in future enhancements from the CSLA main repository.</p>
<p>3. Make copies of several of the BusinessRules types in my own CSLA extension library and modify them to suit my needs.</p>
<p>4. Make a secondary RulesManager in my own CSLA extension library that can be used in addition to the existing rules system so the rules that are defined can be iterated over. Create overloads of all of the writable base classes that have a custom AddRule() method that wraps BusinessRules.AddRule() and my custom RuleManager.AddRule() into a single method call.</p>
<p>5. Surrender and set a hard reference to System.Web.Mvc.dll from my business layer so I can use IClientValidatable, and pray Microsoft will someday realize the error in their ways and fix it. The damage could be minimized by putting my custom DataAnnotations into a separate assembly so the business layer doesn&#39;t reference System.Web.Mvc directly.</p>
<p>&nbsp;</p>
<p>I am leaning in the direction of going with #4 because it is the least invasive way to do it, has support for all CSLA features, and allows me to upgrade CSLA painlessly, but it has the unfortunate side effect of making all of my CSLA classes conform to a slightly different API call for adding rules.</p>
<p>I am going to rule out #3 because historically the rules system of CSLA has been a moving target and is likely to continue to be. There would be little chance any future enhancements or bug fixes to CSLA business rules would make it into my project. </p>
<p>However, I would also consider making a contribution - either what I describe in #1 or simply by adding a property to BusinessRules so they can be iterated over, provided there is a fair chance the contribution would make it into a future release.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 03, 2013</h2><p>Hi,</p>
<p>There is one more option - which is what were planned to use for this kind of enabling. </p>
<p>A business object may expose the rule descriptions in URI form (and expose through an interface implemented in an intermediate generic base class):</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:blue;">string</span>&gt;&nbsp;GetRuleDescriptions()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;BusinessRules.GetRuleDescriptions();
&nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
<p>And this would return f.ex:</p>
<p><i>rule://csla.rules.commonrules.dataannotation/Name?a=System.ComponentModel.DataAnnotations.RequiredAttribute<br />rule://csla.rules.commonrules.dataannotation/Num2?a=System.ComponentModel.DataAnnotations.RangeAttribute<br />rule://csla.rules.commonrules.maxvalue-system.int32-/Num1?max=5000<br />rule://businessruledemo.lessthanproperty/Num1?lessthanproperty=Num2<br />rule://businessruledemo.calcsum/Sum?inputproperties=Num1,Num2<br />rule://csla.rules.commonrules.minvalue-system.int32-/Sum?min=1<br />rule://csla.rules.commonrules.maxlength/Name?max=10<br />rule://csla.rules.commonrules.required/StateName</i></p>
<p><i>IE: this is the rule descriptions for the current RuleSet of registered rules for this object.<br /></i></p>
<p>The first 2 rules are data annotation rules <br />The next ones is CSLA rules from CommonRules namespace or rules implemented in your app. </p>
<p><b>Would it be an option to create your own parser of the RuleDescription and create the appropriate mvc classes / javscript mappings in the MVC&nbsp; Controller?&nbsp;</b></p>
<p>The common rules does not include the priority nor is the list sorted in priority order. That could be amended if required. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Friday, May 03, 2013</h2><p>Johnny,</p>
<p>Thanks for spotting another option.</p>
<p>However, after looking a little at the particulars, I can see there are a few issues with this approach:</p>
<p>1. This would require a &quot;fix&quot; in the controller for every action that uses it. I am looking for a way to do this as part of the framework so it doesn&#39;t have to be solved again later. That said, this approach could still be used with ModelValidatorProvider.</p>
<p>2. Being that the target application will be both multi-tenant and multi-language, and I am already using an approach that uses DataAnnotation or CSLA Business Rule data type combined with Model data type to do the localization lookup, it would be easiest if I had access to the type of business rule rather than creating yet another mapping table that would need to be maintained for every type and potentially every tenant.</p>
<p>3. The ruleType part of the Uri is lowercased and otherwise &quot;fixed&quot;, which makes it difficult to construct a reflection call to get an instance of the rule type (required for localization, preferred to get the jQuery function name) based on this URI.</p>
<p>&nbsp;</p>
<p>I am still inclined to try to take a more direct approach because the primary reason why the current application is being rewritten is because it requires too much maintenance. Ironically, this URI approach solves the most difficult problem - getting the property/value mapping, but makes the easy jQuery function name and error message properties difficult to infer. Creating another collection to track the rule instances or simply adding a property to CSLA make the BusinessRules collection iterable is much simpler from a maintenance standpoint.</p>
<p>BTW - I used the MessageDelegate property of the PropertyRule to solve the localization requirement, but I noticed that this property is mysteriously missing from the ObjectRule class. When localizing, we need to localize all of the validation messages, not just the ones that apply to properties.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 03, 2013</h2><p>Hi, </p>
<p>ObjectRules will typically validate the entire object (maybe even call an external rule engine) and probably set different messages on many properties in the BO so that&#39;s why there is no MessageDelegate on ObjectRule class. </p>
<p>You are using .NET all the way so you could use reflection. If you import FasterFlect (available on NuGet) and add this extension:</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;"><span style="color:blue;">using</span>&nbsp;System;
<span style="color:blue;">using</span>&nbsp;System.Collections.Generic;
<span style="color:blue;">using</span>&nbsp;System.Linq;
<span style="color:blue;">using</span>&nbsp;Csla.Rules;
<span style="color:blue;">using</span>&nbsp;Fasterflect;
 
<span style="color:blue;">namespace</span>&nbsp;CslaReflect
{
&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:blue;">class</span>&nbsp;<span style="color:#2b91af;">BusinessRulesExtensions</span>
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">public</span>&nbsp;<span style="color:blue;">static</span>&nbsp;<span style="color:#2b91af;">IEnumerable</span>&lt;<span style="color:#2b91af;">IBusinessRule</span>&gt;&nbsp;GetBusinessRules(<span style="color:blue;">this</span>&nbsp;Csla.Core.<span style="color:#2b91af;">BusinessBase</span>&nbsp;host)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">if</span>&nbsp;(host&nbsp;==&nbsp;<span style="color:blue;">null</span>)&nbsp;<span style="color:blue;">throw</span>&nbsp;<span style="color:blue;">new</span>&nbsp;<span style="color:#2b91af;">ArgumentNullException</span>(<span style="color:#a31515;">&quot;host&quot;</span>);
 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;businessRules&nbsp;=&nbsp;(Csla.Rules.<span style="color:#2b91af;">BusinessRules</span>)&nbsp;host.GetPropertyValue(<span style="color:#a31515;">&quot;BusinessRules&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;typeRules&nbsp;=&nbsp;(Csla.Rules.<span style="color:#2b91af;">BusinessRuleManager</span>)&nbsp;businessRules.GetPropertyValue(<span style="color:#a31515;">&quot;TypeRules&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;typeRules.Rules.AsEnumerable();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp; }
}
</pre>
<p>Then you can use this code to get an enumerable of business rules like this:</p>
<pre style="font-family:Consolas;font-size:13;color:black;background:white;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;root&nbsp;=&nbsp;<span style="color:#2b91af;">Root</span>.NewEditableRoot();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">var</span>&nbsp;rules&nbsp;=&nbsp;root.GetBusinessRules();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">foreach</span>&nbsp;(<span style="color:blue;">var</span>&nbsp;rule&nbsp;<span style="color:blue;">in</span>&nbsp;rules)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#2b91af;">Debug</span>.Print(rule.RuleName);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />will printout this from my previous example:<br /><br />rule://csla.rules.commonrules.dataannotation/Name?a=System.ComponentModel.DataAnnotations.RequiredAttribute<br />rule://csla.rules.commonrules.dataannotation/Num2?a=System.ComponentModel.DataAnnotations.RangeAttribute<br />rule://csla.rules.commonrules.maxvalue-system.int32-/Num1?max=5000<br />rule://csla.rules.commonrules.minvalue-system.int32-/Sum?min=1<br />rule://csla.rules.commonrules.maxlength/Name?max=10<br />rule://csla.rules.commonrules.required/StateName</pre></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Friday, May 03, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b>ObjectRules will typically validate the entire object (maybe even call an external rule engine) and probably set different messages on many properties in the BO so that&#39;s why there is no MessageDelegate on ObjectRule class. </div></p>
<p>That makes sense. I guess I will have to think of another way to do localization if I end up making any object rules. My thought was that object rules would be loosely coupled and therefore only produce one message each. In order to be compatible with MVC they would definitely need 1 rule per message, but for other technologies that might not be the case.</p>
<p>&nbsp;</p>
<p>Thanks for the tip on FasterFlect. I will give it a try. I am guessing that this inherently means no support for partial trust, but that isn&#39;t a strict requirement for my project.</p>
<p>&nbsp;</p>
<p>BTW - How do you paste formatted code into this forum?</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 03, 2013</h2><p>Hi,</p>
<p>I use <strong>VS 2012</strong>&nbsp;with Blue Color Scheme and <strong>Productivity Power Tools</strong>&nbsp;extension (one of the features here is <strong>HTML Copy</strong>).&nbsp;</p>
<p>Pasting code works fine in <b>Firefox </b>and <strong>IE</strong> &nbsp;- for some weird reason not in <strong>Chrome</strong>.&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 03, 2013</h2><p>Hi,</p>
<p>I have som concerns as you will only be able to support a subset of the CSLA rule engine.</p>
<p>&nbsp;</p>
<ol>
<li>Gateway rules may contain one or more business rules as inner rules and there is no defined way of accessing these inne rules. (ex: CanWrite = nly call inner rule if user has write access). The actual message comes from the inner rules(s).&nbsp;</li>
<li>A rule may set different messages on a number of fields (this is actually supported).</li>
<li>A rule may update one or more fields with new values.</li>
<li>&quot;Short circuiting&quot; rule may be used as in a &quot;workflow&quot; to stop rule processing (ex: StopIfNotCanWrite = do not validate field if user does not have Write Access)</li>
<li>A rule may read/write properties directly on the object from context.Target</li>
<li>Object rules is never automatically executed - only in CheckRules og explicit call to CheckObjeectRules - so I would not worry too mucth about these in terms on client side validation.&nbsp;</li>
<li>Transformation rules may change the field value (ex ToUpper, ToLower, RemoveWhitespace)</li>
</ol>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Friday, May 03, 2013</h2><p>Thanks for being concerned <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" />.</p>
<p>My primary concern is in extending my client side rules beyond what come out of the box with MVC. Actually, what started all of this was a simple requirement to make a property conditionally required based on another property (something Microsoft included in ASP.NET, but for some reason left out of MVC). Actually, there is a way to do it in MVC by removing the error manually from the ModelState, but there is then no way to tell CSLA to ignore the&nbsp;RequiredAttribute on the server side.&nbsp;It didn&#39;t make sense to duplicate the entire class just to meet this requirement, which is to support an A/B test scenario. However, I also have other things I want to migrate from the old application. For example, I am doing credit card number validation including number ranges&nbsp;and Luhn algorithm check in JavaScript using an ASP.NET control that I want to port to MVC. Also, there is a serious shortcoming to the way the RegularExpression validators work - namely, that there is no way to exclude meaningless optional values such as spaces or dashes from being evaluated by the regular expression, which either makes the regular expression overly complex or causes usability problems with conforming to a really strict format.</p>
<p>What I would like to achieve is making it possible to implement client side validation from CSLA&nbsp;by simply doing 2 things:&nbsp;1) implementing IClientValidationRule&nbsp;in the&nbsp;CSLA validation rule and 2) adding a corresponding jQuery library to implement the details on the client.</p>
<p>Some CSLA business rules won&#39;t have anything to do with validation, therefore will not implement the IClientValidationRule interface, which means they will be skipped over entirely -&nbsp;that is part of the plan. It wouldn&#39;t be too difficult to segregate rules that deal with validation from rules that modify values (loose coupling dictates it should be done this way anyway), and modifying values will either strictly be done on the client or server side - no need to do both. It does sound like I might need to&nbsp;find a way&nbsp;to include more than one error message per rule, though.</p>
<p>I am not sure if I will have any requirements that warrant using Gateway rules or Object rules at this point. I am not as concerned about actually implementing the features of CSLA so much as leaving the door open so it is possible, if needed. The main thing I had my eye on was rule priority, because I can foresee the need to warn the user that something should be filled out that wasn&#39;t, but making it required would slow down the data entry process to the point where it is not acceptable. That said, I will probably need to build my own client-side integration point in MVC to take care of that detail, since MVC validation rules are an all or nothing proposition.<br /></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Friday, May 03, 2013</h2><p>Just as a sidenote - you can combine ShortCircuiting rules and others with DataAnnotationRule to f.ex. make a field Required only when some other condition is met as CSLA Rules with a priority less than zero will be executed before the DataAnnotation rules (wich will always have priority = 0).</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Friday, May 03, 2013</h2><p>Thanks for that info. I will try that for this case. But as previously mentioned, it is still worth it to create a way to make client-side validation rules for other cases. I invested 6 weeks in making ASP.NET validation controls before I realized that MVC did things differently. I would like to recoup that investment going forward. I will also review the CSLA e-book section on rules, the MVC rule customization docs, and jQuery validation library docs before actually diving into this so I can map out a definite direction before writing an implementation.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>NightOwl888 replied on Sunday, May 05, 2013</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b>Just as a sidenote - you can combine ShortCircuiting rules and others with DataAnnotationRule to f.ex. make a field Required only when some other condition is met as CSLA Rules with a priority less than zero will be executed before the DataAnnotation rules (wich will always have priority = 0).</div></p>
<p>&nbsp;</p>
<p>While this was a good suggestion, in my case it was trading one client validation problem for another because I am also validating the string length of the value when it is not required. So, no dice here either.</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>_pisees_ replied on Thursday, August 14, 2014</h2><p><div style='padding-left: 50px;background-color:silver'><b>JonnyBee<br></b></p>
<p>I&nbsp;have some concerns as you will only be able to support a subset of the CSLA rule engine.</p>
<p style="CLEAR:both;"></div></p>
<p>&nbsp;</p>
<p>@JonnyBee continuing on this point. Would your concerns be alleviated if focus just on validation rules, perhaps just what is in csla.rules.commonrules?</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
