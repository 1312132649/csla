<html><header><title>TriggerAction obscuring the actual problem, replacing the stack trace</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>TriggerAction obscuring the actual problem, replacing the stack trace</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11639.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 posted on Wednesday, October 10, 2012</h2><p>I could be misreading this, but I think there&#39;s an issue with TriggerAction where it ends up obscuring the stack trace.</p>
<p>Initial Exception Stack - I basically can just create a null variable and try to reference a property.</p>
<p>&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.PaymentVoidMenuItemViewModel.ExecuteAction()<br />&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.MenuItemViewModelBase.HandleTriggerAction(TriggerAction action, ExecuteEventArgs args)<br />&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.MenuItemViewModel`1.HandleTriggerAction(TriggerAction action, ExecuteEventArgs args)</p>
<p>(We use an intermediary HandleTriggerAction to help suppress things like double-clicks firing off methods multiple times - which gets kind of tricky when async calls are involved).</p>
<p>End up getting a null reference exception:</p>
<p>&nbsp;&nbsp; at Csla.Xaml.TriggerAction.CallMethod(Object sender, EventArgs e)<br />&nbsp;&nbsp; at System.Windows.Controls.Primitives.ButtonBase.OnClick()<br />&nbsp;&nbsp; at System.Windows.Controls.Button.OnClick()<br />&nbsp;&nbsp; at System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(MouseButtonEventArgs e)<br />&nbsp;&nbsp; at System.Windows.Controls.Control.OnMouseLeftButtonUp(Control ctrl, EventArgs e)<br />&nbsp;&nbsp; at MS.Internal.JoltHelper.FireEvent(IntPtr unmanagedObj, IntPtr unmanagedObjArgs, Int32 argsTypeIndex, Int32 actualArgsTypeIndex, String eventName, UInt32 flags)</p>
<p>It would be tremendously useful&nbsp; to actually see the first trace, because it becomes clear where the error may have occurred.&nbsp; We log our errors - the former is helpful, the second is worthless.</p>
<p>I am trying to get my debugging working for CSLA to step through it and see it in action, but is there something that can be done for this sort of scenario / has anyone encountered this?&nbsp; The reality is that sometimes we&#39;ll program in bugs into the methods our trigger actions call and to have a stacktrace that means something would be very helpful.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, October 10, 2012</h2><p>I see - so I presume I have an ex.InnerException and by throwing it I&#39;m getting my inner exception but not the stack trace to it... hmm... I imagine the goal is to just drop the targetinvocationexception but that stack trace lost sure would be nice.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (System.Reflection.TargetInvocationException ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ex.InnerException != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ex.InnerException;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 10, 2012</h2><p>It has been a while, but iirc the issue, it is because dynamically calling the method via reflection (or a lambda expression&nbsp;- whichever we&#39;re using now) causes the underlying stack trace to be lost due to a context switch.</p>
<p>Of course I could be misremembering too...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, October 10, 2012</h2><p>I rebuilt the CSLA dlls without the rethrow and also just writing out the exception that was caught to see what would happen.&nbsp; Throwing a NotSupportedException in the trigger action&#39;s method that is called, I get the full exception.</p>
<p>Obviously one gets the &quot;System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.&quot; piece.&nbsp; I&#39;m not sure how you feel about it but the exception below would be very valuable in terms of diagnosing errors.</p>
<p>&nbsp;System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.NotSupportedException: Specified method is not supported.<br />&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.PaymentVoidMenuItemViewModel.ExecuteAction()<br />&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.MenuItemViewModelBase.HandleTriggerAction(TriggerAction action, ExecuteEventArgs args)<br />&nbsp;&nbsp; at [ProductName].Silverlight.ViewModels.Menu.MenuItemViewModel`1.HandleTriggerAction(TriggerAction action, ExecuteEventArgs args)<br />&nbsp;&nbsp; --- End of inner exception stack trace ---<br />&nbsp;&nbsp; at System.RuntimeMethodHandle.InvokeMethod(Object target, Object[] arguments, Signature sig, Boolean constructor)<br />&nbsp;&nbsp; at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean skipVisibilityChecks)<br />&nbsp;&nbsp; at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)<br />&nbsp;&nbsp; at System.Reflection.MethodBase.Invoke(Object obj, Object[] parameters)<br />&nbsp;&nbsp; at Csla.Xaml.TriggerAction.CallMethod(Object sender, EventArgs e)</p>
<p>&nbsp;</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, October 10, 2012</h2><p>What did you change specifically?</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Wednesday, October 10, 2012</h2><p>In Csla.Xaml.TriggerAction.CallMethod() towards the bottom - commented the three lines (to just throw the caught exception with the original stack trace)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (System.Reflection.TargetInvocationException ex)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.Diagnostics.Debug.WriteLine(ex.ToString());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (ex.InnerException != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; throw ex.InnerException;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>
<p>
<p><span style="font-family:Consolas;font-size:x-small;"><span style="font-family:Consolas;font-size:x-small;"></span></span></p>
</p>
</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, October 12, 2012</h2><p>That&#39;s a breaking change, but might be worth it. My preference is to strip out the useless reflection exception and to just keep the real exception, but losing the stack trace isn&#39;t good either.</p>
<p>I&#39;ll give this some thought.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>skagen00 replied on Friday, October 12, 2012</h2><p>Yup, I appreciate that.&nbsp; We&#39;ve made the change locally (our only one to CSLA) so that we can better assess any errors our clients are encountering - it was always an exception that really gave us no clue as to what they may have encountered..</p>
<p>Thanks for considering it!</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
