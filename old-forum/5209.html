<html><header><title>DataContext - Results Set Cache Mismatch</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>DataContext - Results Set Cache Mismatch</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/5209.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JabbaTheNut posted on Thursday, August 07, 2008</h2><P><FONT size=2>I am about to embark on a large project using CSLA 3.5/6 and Linq to SQL.&nbsp; However, I wanted to better understand how the CSLA ContextManager works.&nbsp; Joe Rattz (author of Pro LINQ: Language Integrated Query in C# 2008) wrote the following in another forum about the Results Set Cache Mismatch problem associated with long-lived DataContexts:</FONT></P>
<BLOCKQUOTE dir=ltr>
<P><FONT size=2>"DataContexts should be short-lived.&nbsp; How short?&nbsp; As short as possible, yet reasonable.&nbsp; Why?&nbsp; Well, as one of the key Microsoft developers working on LINQ to SQL told me, the data in a DataContext is stale the moment you retrieve it.&nbsp; The reason this is significant has to do with the way data is returned from your query.</FONT></P>
<P><FONT size=2>I cover this in detail in Chapter 16 of my book, Pro LINQ: Language Integrated Query in C# 2008.&nbsp; Basically what happens is that when you query data from the database with LINQ to SQL, the query is executed in the database to determine which records should be returned.&nbsp; However, if you have already retrieved any of those records with the existing DataContext, instead of returning the record's data from the database, the already retrieved data that is cached inside the DataContext is returned instead.&nbsp; The DataConext determines what data is returned, and this may not match what is currently in the database.&nbsp; In my book, I refer to this as the Results Set Cache Mismatch and I provide an example demonstrating this on pages 504-505.&nbsp; Because of this, it is quite possible to have data returned from a query that does not match the query!&nbsp; I cannot recommend strongly enough to read this portion of my book and understand what is happening.</FONT></P>
<P><FONT size=2>The issue here is that the longer a DataContext lives, the more cached data it has, and the more likely a resuts set cache mismatch may occur.&nbsp; Therefore, keep your DataContexts short-lived.&nbsp; I would recommend a guideline of something along the lines of using them for a single transaction or SubmitChanges method call.&nbsp; If for some reason I had multiple SubmitChanges method calls in the same function call, I would feel comfortable sharing the DataContext among them. This is a judgement call though, and your situation may be different.</FONT></P>
<P><FONT size=2>Will sharing a DataContext across calls that occur 5 minutes apart kill you?&nbsp; Probably not.&nbsp; I would not, however, create a DataContext and use it for the life of a long running process."</FONT></P></BLOCKQUOTE>
<P><FONT size=2>How is the ContextManager dealing with DataContexts? And, are there any&nbsp;potential issues regarding the above&nbsp;in CSLA?</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Curelom replied on Thursday, August 07, 2008</h2>CSLA lets you manage how you retrieve/modify data.&nbsp; How linq to sql in CSLA is used is entirely up to you.&nbsp; If you follow the examples in the Project Tracker, you shouldn't have any more problems with the data getting stale than using regular sql queries.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JabbaTheNut replied on Thursday, August 07, 2008</h2><P>Thanks for your quick reply.</P>
<P>How does the ContextManager deal with DataContexts?&nbsp; Does it keep them alive for reuse? Or, are they terminated upon completion?&nbsp; If not kept alive, what does the ContextManager do?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, August 08, 2008</h2>The ContextManager does it's just using simple reference counting.&nbsp; Everytime GetManager is called, the ref count is updated.&nbsp; When Dispose is called (usually done via the using statement) the ref id decremented.&nbsp; Once it reaches zero, the DataContext is disposed.&nbsp; If GetManager is called and the count is zero, the DataContext is created.&nbsp; <br><br>The ContextManager's role isn't to "keep the connection alive," it's just a convient way to avoid having to either pass a DataContext to child objects via parameters in method calls or to put it in a ApplicationContext and having child objects assume its there.&nbsp; So there aren't really any concerns about keeping DataContexts around, because they will usually only be open until the root BO completes it's DP_XYZ method.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JabbaTheNut replied on Friday, August 08, 2008</h2>That's perfect.&nbsp; Thanks for the explanation.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
