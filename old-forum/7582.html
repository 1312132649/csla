<html><header><title>Linq to Csla speed</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Linq to Csla speed</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7582.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Ash002 posted on Tuesday, September 08, 2009</h2><font face="Courier New" size="2">Hi <br><br>We have a use of linq on a BLB which can take approx. 5/100s  of a second to execute. On a BLB descendant we run:<br><br> var result = (from item in this where item.InternalName = internalName select item).FirstOrDefault()<br><br>The collection size is only small, 120 or so. We are processing some objects for export to excel. However when processing  uses about 40 calls per object, the time adds up, ie about 2 seconds per object. This is very slow. A foreach loop takes no time at all, hence processing decreases to 5/100s for the whole object. Is the delay is caused by Linq to Csla's advanced features, ie creating a synchronised query result set? <br><br>To avoid this delay, we can avoid Linq to Csla by effectively casting the BLB using ToList(),<br><br> </font><font face="Courier New" size="2"> var result = </font><font face="Courier New" size="2">(from item in this.<b>ToList</b>&lt;RegisterField&gt;() where item.InternalName = internalName select item).FirstOrDefault()<br><br>Timing indicates ToList() is slightly faster than a foreach loop. Is there a performance hit to ToList()? and is it a decent practice? bearing in mind these result sets are not data bound to a UI.<br><br>I did try out the Linq to Csla indexing and that seemed slow too, and really a solution for a large set of data rather than a small one.<br><br>Thanks<br><br>Ashley<br></font></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Tuesday, September 08, 2009</h2><P>L2C indexing is only useful in limited scenarios, because there is a very real cost to creating and maintaining the index. This is true of any indexing scenario, including those in databases like SQL Server.</P>
<P>You should use L2C indexing only if both of these are true:</P>
<OL>
<LI>You have a large collection</LI>
<LI>You do many queries over the same collection instance</LI></OL>
<P>And if your collection changes&nbsp;a lot, you might find that maintaining the index is too expensive as well. In such a case, careful testing is indicated.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonnyBee replied on Wednesday, September 09, 2009</h2>Hi,<br><br>You must also be aware of cahcing scenarios - that often serialize the instance to a "cache storage". Since the index is not serializable that means the index will have to be rebuilt every time you get the instance from the cache store. <br><br>/jonnybee<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Wednesday, September 09, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>JonnyBee:</strong></div><div>Hi,<BR><BR>You must also be aware of cahcing scenarios - that often serialize the instance to a "cache storage". Since the index is not serializable that means the index will have to be rebuilt every time you get the instance from the cache store. <BR><BR>/jonnybee<BR></div></BLOCKQUOTE></P>
<P>I pointed this out a few months ago in a discussion of ASP.Net. Since the Session is serialized the index is not useful since it costs so much to re-build on each postback. </P>
<P>Joe</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
