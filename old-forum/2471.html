<html><header><title>object and db table identity</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>object and db table identity</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2471.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>jhw posted on Friday, March 02, 2007</h2><P>I have always used a autonumber id integer for every table so that there is a single primary key. This key is used as the id for objects that are loaded out of the db. One problem with this is that objects don't get their id until submitted into the db. Sometimes it would be nice to have the id prior to saving.</P>
<P>My question is in regards to using guid's instead. Is there a lot of cost to using them compared to an interger as an id. And can a person rely on them to be unique.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Friday, March 02, 2007</h2><DIV>It makes things easier if you use GUIDs. Anything that makes things easier has a cost.</DIV>
<DIV>&nbsp;</DIV>
<DIV>So the question is, is the cost worth it?</DIV>
<DIV>&nbsp;</DIV>
<DIV>I say yes.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Others say no.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Do a search of the forum(s)&nbsp;and decide for yourself.</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, March 03, 2007</h2><P>If you do use an autonumber, you still do need to give your objects a "temporary id" until they are saved. GetIdValue() <EM>must always return a unique value</EM>.</P>
<P>The easiest way to do this is to use negative numbers, auto-decrementing them from a static/Shared field in your class.</P>
<P>private static int _lastNewId;</P>
<P>[RunLocal]<BR>protected override void DataPortal_Create(object criteria)<BR>{<BR>&nbsp; _lastNewId--;<BR>&nbsp; _id = _lastNewId;<BR>&nbsp; // ...<BR>}</P>
<P>If you let DP_Create() run on an app server, you'd need to use some locking code for thread-safety:</P>
<P>private static int _lastNewId;</P>
<P>protected override void DataPortal_Create(object criteria)<BR>{<BR>&nbsp; _id = System.Threading.Interlocked.Decrement(_lastNewId);<BR>&nbsp; // ...<BR>}</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Obelix replied on Monday, March 05, 2007</h2><P>Is that unique value, </P>
<P>A) Unique to every object in the BO Object Model I have created?</P>
<P>or</P>
<P>B) Unique within a given Collection/List of objects?</P>
<P>i.e. does every object in a single hierarchy of object and collections have to have it's own Unique GUID, or do all objects in a given instance of an object model share the same GUID?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, March 05, 2007</h2>It should be unique within the type.&nbsp; So all Customer objects should have their own unique Ids, but Orders may have their own set of unique ids which may overlap the set of customer ids... unless of course you'll be storing Customer objects in the same list as Orders.. but I don't see a good reason to do that!<br><br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Obelix replied on Monday, March 05, 2007</h2><P>Thanks Andy. Makes complete and utter sense when explained like that. </P>
<P>ThanX<BR>Obelix</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, March 05, 2007</h2>Obelix, glad I could help.&nbsp; Usually I'm the one that doesn't explain things clearly. <img src="/emoticons/emotion-1.gif" alt="Smile [:)]" /><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JonM replied on Monday, March 05, 2007</h2>We are using the CombID, so far it works great.&nbsp; It is a guid, but instead of being completely random it is based on datetime+random.&nbsp; This makes it so the guids generated are always incrementing and therefore solve the database indexing problems that guids traditionally have.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dshafer replied on Friday, March 09, 2007</h2><P>Jon,</P>
<P>This incrementing guid sounds interesting.&nbsp; I've tried googling it, but can't find any other mention of it.&nbsp; Do you know of a site that explains the use of this combId?</P>
<P>Thanks,</P>
<P>Dustin</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, March 09, 2007</h2><P>I recall reading that article. It is by Jimmy Nilsson.</P>
<P>Here it is:</P>
<P><A href="http://www.informit.com/articles/printerfriendly.asp?p=25862&amp;rl=1">http://www.informit.com/articles/printerfriendly.asp?p=25862&amp;rl=1</A></P>
<P>Joe</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>dshafer replied on Tuesday, March 13, 2007</h2><P>Joe,</P>
<P>Thanks for the link.&nbsp; In case anybody is interested, the following C# code will create the COMB or "sequential" guid.&nbsp; By the way, this code is only meant as a sample, and is by no means the best or most efficient way to do this.</P><FONT size=2>
<P></FONT><FONT color=#008000 size=2>//Store the current date and time</FONT><BR><FONT color=#2b91af size=2>DateTime</FONT><FONT size=2>dtNow = </FONT><FONT color=#2b91af size=2>DateTime</FONT><FONT size=2>.Now;</FONT></P>
<P></FONT><FONT color=#008000 size=2>//Number of days since 01/01/1900</FONT><BR><FONT size=2></FONT><FONT color=#2b91af size=2>DateTime</FONT><FONT size=2> dtBase = </FONT><FONT color=#0000ff size=2>new</FONT><FONT size=2> </FONT><FONT color=#2b91af size=2>DateTime</FONT><FONT size=2>(1900,01,01); </FONT><BR><FONT color=#2b91af size=2>TimeSpan</FONT><FONT size=2> ts = dtNow - dtBase; </FONT><BR><FONT color=#0000ff size=2>int</FONT><FONT size=2> days = ts.Days; </FONT><FONT color=#008000 size=2></FONT>&nbsp;</P>
<P><FONT color=#008000 size=2>//Convert number of days to hex</FONT><BR><FONT size=2></FONT><FONT color=#0000ff size=2>string</FONT><FONT size=2> hexDays = </FONT><FONT color=#2b91af size=2>Convert</FONT><FONT size=2>.ToString(days, 16).PadLeft(4, </FONT><FONT color=#a31515 size=2>'0'</FONT><FONT size=2>).ToUpper();</P>
<P><FONT color=#008000 size=2>//Number of milliseconds since midnight</FONT><BR><FONT size=2></FONT><FONT color=#0000ff size=2>double</FONT><FONT size=2> milliSeconds = dtNow.TimeOfDay.TotalMilliseconds;</P>
<P><FONT color=#008000 size=2>//Convert number of milliseconds to number of sql clock ticks (3.333333333 milliseconds per clock tick)</FONT><BR><FONT size=2></FONT><FONT color=#0000ff size=2>double</FONT><FONT size=2> milliPerTick = 3.0 + (1.0/3.0); </FONT><BR><FONT color=#2b91af size=2>Int64</FONT><FONT size=2> clockTicks = </FONT><FONT color=#2b91af size=2>Convert</FONT><FONT size=2>.ToInt64(milliSeconds / milliPerTick);</P>
<P><FONT color=#008000 size=2>//Convert number of clock ticks to hex&gt;</FONT><BR><FONT size=2></FONT><FONT color=#0000ff size=2>string</FONT><FONT size=2> hexTicks= </FONT><FONT color=#2b91af size=2>Convert</FONT><FONT size=2>.ToString(clockTicks, 16).PadLeft(8, </FONT><FONT color=#a31515 size=2>'0'</FONT><FONT size=2>).ToUpper();</P>
<P><FONT color=#008000 size=2>//Create a "sequential" guid using the first 24 characters of a generated guid, plus the binary datetime that we generated earlier</FONT><BR><FONT size=2></FONT><FONT color=#2b91af size=2>Guid</FONT><FONT size=2> nextSeqGuid = </FONT><FONT color=#0000ff size=2>new</FONT><FONT size=2> </FONT><FONT color=#2b91af size=2>Guid</FONT><FONT size=2>(</FONT><FONT color=#2b91af size=2>Guid</FONT><FONT size=2>.NewGuid().ToString().Substring(0,24) + hexDays + hexTicks);</FONT></P>
<P><FONT size=2>Dustin</P></FONT></FONT></FONT></FONT></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Wednesday, March 14, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>jhw:</strong></div><div><p>I have always used a autonumber id integer for every table so that there is a single primary key. This key is used as the id for objects that are loaded out of the db. One problem with this is that objects don't get their id until submitted into the db. Sometimes it would be nice to have the id prior to saving.</p>
<p>My question is in regards to using guid's instead. Is there a lot of cost to using them compared to an interger as an id. And can a person rely on them to be unique.</p></div></BLOCKQUOTE><br><br>Using a GUID in the database is a bad idea for a number of reasons. I'll give a couple here:<br><br>1. A uniqueidentifier is twice the size of a bigint and 4 times the size of an int. In our high storage world, this isn't a big deal. But it isn't just the storage of the value in the column. If this is your primary key, then it is also indexed. This means your index is 2 or 4 times larger than needed, which means it could take up to two or four times as long to traverse the index in lookups to find rows. Since the majority of actions against a database are reads, I think it's obvious why doubling or more the time for performing an index seek is a bad idea.<br><br>2. A uniqueidentifier is a non-sequential number. If you cluster on a uniqueidentifier as most primary keys are, then already inserted rows may have to be moved in order to accommodate another row stuck into the table at a random location. Disk I/O is a very slow operation which significantly increases the lock time for your inserting table. For auto-incremented clusters, this is never going to happen as all rows are tacked onto the end of the table.<br><br>There are many other less significant reasons to avoid using a GUID, but these two are two of the top ones.<br><br>Your best bet is to start with the negative number like Rocky mentioned and work your way up. If you still want to use a GUID, then add it as an additional column on the table but still use an auto-number as the primary key.<br><br>The GetIdValue method only has to be unique for the CSLA object. Create a new GUID when an object is created and save that to the database along with the other columns. Then refill that value when you DP_Fetch. That way you can still use an auto-number for the table's primary key and all of your queries and joins.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, March 15, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>jhw:</strong></div><div>1. A uniqueidentifier is twice the size of a bigint and 4 times the size of an int. In our high storage world, this isn't a big deal. But it isn't just the storage of the value in the column. If this is your primary key, then it is also indexed. This means your index is 2 or 4 times larger than needed, which means it could take up to two or four times as long to traverse the index in lookups to find rows. Since the majority of actions against a database are reads, I think it's obvious why doubling or more the time for performing an index seek is a bad idea.</div></BLOCKQUOTE><br><br>This is true, although a number is a number and computers are very good with numbers.&nbsp; Also consider that as we move to 64 bit computing, the comparision would be two dwords, which should be pretty performant.<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>jhw:</strong></div><div>2. A uniqueidentifier is a non-sequential number. If you cluster on a uniqueidentifier as most primary keys are, then already inserted rows may have to be moved in order to accommodate another row stuck into the table at a random location. Disk I/O is a very slow operation which significantly increases the lock time for your inserting table. For auto-incremented clusters, this is never going to happen as all rows are tacked onto the end of the table.</div></BLOCKQUOTE><br><br>This is not true; if you look a few posts up, you see a discussion on a COMBID, which takes a guid and modifies it in such a way that part of it is still sequential, and thus doesn't screw up the indexing.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Thursday, March 15, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>This is true, although a number is a number and computers are very good with numbers.&nbsp; Also consider that as we move to 64 bit computing, the comparision would be two dwords, which should be pretty performant.</div></BLOCKQUOTE><br><br>Twice as long is still twice as long. It is common to accept some performance penalty where there is a offsetting benefit. But I don't think a 100% performance penalty on the most prevalent operation should be taken lightly.<br><br><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>ajj3085:</strong></div><div>This is not true; if you look a few posts up, you see a discussion on a COMBID, which takes a guid and modifies it in such a way that part of it is still sequential, and thus doesn't screw up the indexing.</div></BLOCKQUOTE><br><br>I saw the COMBID, but that's only taking a random GUID and replacing that last 6 bytes with 6 sequential bytes. Those last 6 bytes may have some semblance of being sequential, but I can assure you they will not sort sequentially when inserted into the database. The first 10 bytes are still random and will not sort in the same order they are inserted. Which means indexing/clustering on the COMBID will still give you the same penalties as indexing/clustering on a real GUID.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, March 15, 2007</h2><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>Twice as long is still twice as long. It is common to accept some performance penalty where there is a offsetting benefit. But I don't think a 100% performance penalty on the most prevalent operation should be taken lightly.</div></BLOCKQUOTE><br><br>I'm sure most of us here also index nchar / nvarchar columns, and probably set the collation to case insensitive.&nbsp; Comparatively, those would take much more time than two dword comparisions.&nbsp; I don't think we need to worry about using a 128 bit number vs. a 32 bit one..<br><br><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>I saw the COMBID, but that's only taking a random GUID and replacing that last 6 bytes with 6 sequential bytes. Those last 6 bytes may have some semblance of being sequential, but I can assure you they will not sort sequentially when inserted into the database. The first 10 bytes are still random and will not sort in the same order they are inserted. Which means indexing/clustering on the COMBID will still give you the same penalties as indexing/clustering on a real GUID.</div></BLOCKQUOTE><br><br>Funny, because the linked article gives some interesting results that seem to contradict you for both inserting and selecting data.&nbsp; Also, FWIW, that's not the first article I've seen describing the modification of a Guid in that way... the whole point of the COMBID is to make the Guid quicker in database inserting and selecting.&nbsp; If the techinique didn't work, no one would have bothered&nbsp; with it..<br><br>Keep in mind, most of us here are not building applications for millions of users querying Google sized databases; COMBIDs might have a slight hit on performance (if you believe the article, its almost just as good as ints), but not so much that it will cause anyone a huge problem.&nbsp; For the most part, network traffic slows our apps down the most.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Friday, March 16, 2007</h2>I also index nchar/nvarchar columns. They have their place. But I try to avoid
writing joins against them which you would likely do with a GUID
primary key.<br><br>The linked article is very easy to test to see that
the ordering is
still random. Simply create a temporary table, load the results into
the table in the order in which the article gave them, then return an
ordered resultset. It will not be in the same order the values were
placed into the table. The results may be somewhat less random than a
full GUID, but they are still unordered. It is obvious that it
mitigates the problems with a true GUID, but it does not eliminate them.<br>
<br>
Taking the 5 generated directly from the article in the order they were
listed, you can use the code below to show that they still order
differently from the order they are inserted.<br>
<br>
declare @table table (<br>
&nbsp;&nbsp;&nbsp; [guid] uniqueidentifier<br>
)<br>
<br>
insert into @table values ('E25AFE33-DB2D-4502-9BF0-919001862D20')<br>
insert into @table values ('83E689D3-8549-4094-B223-919001862D20')<br>
insert into @table values ('CC22A56D-0CD5-43C5-990E-919001862D20')<br>
insert into @table values ('D5149998-1718-468C-B1AD-919001862D20')<br>
insert into @table values ('CBD0182D-4A0E-40AC-9A4C-919001862D20')<br>
<br>
select * from @table order by guid<br>
<br>
<br>
Keep in mind that a clustered index physically orders the data in a
table. If you are inserting new rows into a table with a sequentially
increasing clustered index, then each insert will physically occur one
after the other on the disk. Because of this, page splits won't occur
during inserts. Using a GUID (or the COMBID), data will be inserted
randomly into physical data pages which will cause page splits.<br><br>The
databases don't have to be exceptionally large to see a perceptable
difference in performance. I say this from experience.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Brian Criswell replied on Friday, March 16, 2007</h2>Um, the article did point out that the ordering of COMBs is slightly random because COMBs generated in the same .003 second timeslice will generate the same last six bytes and the ordering will depend on the rest of the COMB.&nbsp; If you separate the inserts so that there is .003 seconds between them, you get the order they were generated in.<br><br>declare @table table (<br>&nbsp;&nbsp;&nbsp; [guid] uniqueidentifier<br>)<br><br>select @aGuid = cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier)<br>select @aGuid<br>insert into @table values (@aGuid)<br>waitfor delay '00:00:00.003'<br><br>select @aGuid = cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier)<br>select @aGuid<br>insert into @table values (@aGuid)<br>waitfor delay '00:00:00.003'<br><br>select @aGuid = cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier)<br>select @aGuid<br>insert into @table values (@aGuid)<br>waitfor delay '00:00:00.003'<br><br>select @aGuid = cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier)<br>select @aGuid<br>insert into @table values (@aGuid)<br>waitfor delay '00:00:00.003'<br><br>select @aGuid = cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier)<br>select @aGuid<br>insert into @table values (@aGuid)<br>waitfor delay '00:00:00.003'<br><br>select * from @table order by guid<br><br>Running a simple test on my system showed that I can only fit about 114 inserts into a .003 second time frame.&nbsp; Your results will vary.<br><br>declare @table table (<br>&nbsp;&nbsp;&nbsp; [guid] uniqueidentifier<br>)<br><br>declare @int int<br>select @int = 0<br><br>while @int &lt; 10000<br>begin<br>&nbsp;&nbsp;&nbsp; insert into @table values (cast(cast(newid() as binary(10)) + cast(getdate() as binary(6)) as uniqueidentifier))<br>&nbsp;&nbsp;&nbsp; select @int = @int + 1<br>end<br><br>select * from @table order by guid<br><br>The reason that I like Guids is that I can generate a unique number on the client and that will be the object's id.&nbsp; COMBs generated on different clients would be slightly more prone to generating out of order ids.&nbsp; Although the page splits would still not be nearly as much of a problem as with plain guids.<br><br>For most applications the programming simplicity added by guids would probably come at a neglible cost, especially if the move is made to COMBs, where inserting half a million rows only takes .1 seconds longer.<br><br>Can you not rebuild your pages periodically as part of maintenance?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Friday, March 16, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>Twice as long is still twice as long. It is common to accept some performance penalty where there is a offsetting benefit. But I don't think a 100% performance penalty on the most prevalent operation should be taken lightly.</div></BLOCKQUOTE></P>
<P>Just becasue it is twice as long in bytes does not equate to twice as long in time to perform an operation especially when dealing with indexes that are implemented using btrees. If you go by the benchmarks in that article it show only a 10% increase in query time with that dataset.<BR></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>I saw the COMBID, but that's only taking a random GUID and replacing that last 6 bytes with 6 sequential bytes. Those last 6 bytes may have some semblance of being sequential, but I can assure you they will not sort sequentially when inserted into the database. The first 10 bytes are still random and will not sort in the same order they are inserted. Which means indexing/clustering on the COMBID will still give you the same penalties as indexing/clustering on a real GUID.<BR></div></BLOCKQUOTE></P>
<P>Thats like saying inserting a the date of&nbsp; '1/2/2006' and then '1/1/2007' will not be inserted sequencially&nbsp;or sort sequentially because of the alphabetically sort of the date string.&nbsp;Guid's are not strings, the string representation of a guid is hex based and follows PPOONNMM-LLKK-JJII-GGHH-AABBCCDDEEFF&nbsp;the sort however is based in its binary representation which is based on the letter ordering in&nbsp;that&nbsp;string pattern, notice how the last group is&nbsp;sorted first.&nbsp;&nbsp;&nbsp;</P>
<P>Also in SQL 2005 they introduced the newsequentialid() function to do something similar to COMB for exactly this issue.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Friday, March 16, 2007</h2>I hadn't heard of the NewSequentialId in Sql2005, so I did some searching. I found an article comparing it against NewId and BigInt. <a href="http://sqljunkies.com/Article/4067A1B1-C31C-4EAF-86C3-80513451FC03.scuk">http://sqljunkies.com/Article/4067A1B1-C31C-4EAF-86C3-80513451FC03.scuk</a><br><br>While page splits may be avoided by this new function versus the COMBID's function, the other performance issues still remain. In fact, if you add it up using the author's example, instead of a 1.1GB database, he has a 1.8GB database. Taking just the indexes into account, that's an extra 324MB of index data to search through.<br><br>This article also shows that when an insert for a sequential guid and a bigint are done in the same batch, the total effort of the guid insert is 60% and the bigint insert is 40%. If it were only a 10% overhead, wouldn't the numbers would be more along the lines of 52/48?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Friday, March 16, 2007</h2><DIV>See?&nbsp; Just like I said, some say guids are good and some say they are not.</DIV>
<DIV>&nbsp;</DIV>
<DIV>If you are a performance freak then guids are going to twist your nickers in a bunch.&nbsp; Often for no reason because the user won't even see a difference.</DIV>
<DIV>&nbsp;</DIV>
<DIV>But performance people are a wierd bunch so there you go.&nbsp;</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Michael Hildner replied on Friday, March 16, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>pelinville:</strong></div><div> 
<DIV>See?&nbsp; Just like I said, some say guids are good and some say they are not.</DIV>
<DIV>&nbsp;</DIV>
<DIV>If you are a performance freak then guids are going to twist your nickers in a bunch.&nbsp; Often for no reason because the user won't even see a difference.</DIV>
<DIV>&nbsp;</DIV>
<DIV>But performance people are a wierd bunch so there you go.&nbsp;</DIV>
<P></div></BLOCKQUOTE></P>
<P>Laughing out loud here - nothing like a little entertainment after a long day :) Thanks pelinville!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Saturday, March 17, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>I hadn't heard of the NewSequentialId in Sql2005, so I did some searching. I found an article comparing it against NewId and BigInt. <A href="http://sqljunkies.com/Article/4067A1B1-C31C-4EAF-86C3-80513451FC03.scuk">http://sqljunkies.com/Article/4067A1B1-C31C-4EAF-86C3-80513451FC03.scuk</A><BR><BR>While page splits may be avoided by this new function versus the COMBID's function, the other performance issues still remain. In fact, if you add it up using the author's example, instead of a 1.1GB database, he has a 1.8GB database. Taking just the indexes into account, that's an extra 324MB of index data to search through.<BR><BR>This article also shows that when an insert for a sequential guid and a bigint are done in the same batch, the total effort of the guid insert is 60% and the bigint insert is 40%. If it were only a 10% overhead, wouldn't the numbers would be more along the lines of 52/48?<BR></div></BLOCKQUOTE></P>
<P>You seem to be glossing over how Comb Guid's work and how SQL stores them, if you insert rows into the system within a small span of time the last 48bits(which is sorted first) will be the same and the rest random, so yes it will act just like a normal guid. However in the real world most systems do not have rows inserted that quickly, therefore the the last 48bits slowy increment minimizing page splits. Comb id is not flawed your test was unless the systems you develop for insert 300 rows a second (in which case Guid's are probably a bad choice, then again any surrogate key would probably be a bad choice). Yes newsequientialid() is a better algorithm as it covers your test case aswell.</P>
<P>Also again you seem to have a simplistic view of how data is retrieved in SQL as though its always a index scan and not a seek and somehow SQL is transversing all that extra 324 MB to find a single value.&nbsp;Also how many databases have 20 million rows where 25% of the data is the surrogate&nbsp;PK? Very synthetic and unrealistic.&nbsp;</P>
<P>When I said 10% increase in query time I should have been more specific in select/retrieval time, not insert time. Notice how that article did not get into retrieval time instead only focusing on insert time, in most typical OLTP systems the read write ratio is 80:20. The weighted cost of inserts is usually much lower than the select time, yet most of guid's disadvantages are in inserts, less so with sequential guids.</P>
<P>Although bigint and int definetly have thier place, performance is usually a non factor if guid's are used for identifying "root entities" such as&nbsp;Project or Resource, and the development/replication/migration advantages are great.</P>
<P>Justin</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Monday, March 19, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Justin:</strong></div><div>You seem to be glossing over how Comb Guid's work and how SQL stores them, if you insert rows into the system within a small span of time the last 48bits(which is sorted first) will be the same and the rest random, so yes it will act just like a normal guid. However in the real world most systems do not have rows inserted that quickly, therefore the the last 48bits slowy increment minimizing page splits. Comb id is not flawed your test was unless the systems you develop for insert 300 rows a second (in which case Guid's are probably a bad choice, then again any surrogate key would probably be a bad choice). Yes newsequientialid() is a better algorithm as it covers your test case aswell.</div></BLOCKQUOTE><br><br>If you're using CSLA's root/child pattern, you don't think you'd have multiple inserts in that span of time?<br>
<p><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Justin:</strong></div><div>Also again you seem to have a simplistic view of how data is retrieved in SQL as though its always a index scan and not a seek and somehow SQL is transversing all that extra 324 MB to find a single value.&nbsp;Also how many databases have 20 million rows where 25% of the data is the surrogate&nbsp;PK? Very synthetic and unrealistic.</p><p><br>When I said 10% increase in query time I should have been more specific
in select/retrieval time, not insert time. Notice how that article did
not get into retrieval time instead only focusing on insert time, in
most typical OLTP systems the read write ratio is 80:20. The weighted
cost of inserts is usually much lower than the select time, yet most of
guid's disadvantages are in inserts, less so with sequential guids.</p><p><br>Although bigint and int definetly have thier place, performance is
usually a non factor if guid's are used for identifying "root entities"
such as&nbsp;Project or Resource, and the development/replication/migration
advantages are great.</p><p>Justin</p></div></BLOCKQUOTE><br>
<br>
No, my view is not that simplistic. As a member of the performance "weird bunch", to quote a poster above, I'm very much aware of my query plans and how SQL retrieves data. Though even with a seek, how many additional MBs of index information must be sifted through to get to what you're seeking?<br><br>My point is not that GUIDs don't have a place. My point is only that GUIDs should not be the default. I've spent over 40 hours on the phone with MS's SQL team fixing performance issues related to using GUIDs as primary keys. I'm intimiately familiar with the ins and outs of how SQL treats indexes and data pages among other things. Yes, this system was large, but not abnormally large. It was a supply chain application that serviced only 11 production plants.<br><br>Development/replication/migration can all be solved quite simply with GUIDs as the primary key. But if we're talking about simple applications, then replication and migration are probably not necessary items. As for development, I could argue that its easier to develop using sequential numeric keys than GUIDs for the sheer debugging and ad-hoc query savings. Its much quicker to type in "384" into an ad-hoc query than to copy and paste (or re-type) a GUID. Solving the unique GetIdValue problem with a utility method at the start of development is a one-time thing. Its also very simple to solve the replication/migration issues using a GUID as a non-primary key.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>pelinville replied on Monday, March 19, 2007</h2><DIV><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>Development/replication/migration can all be solved quite simply with GUIDs as the primary key. But if we're talking about simple applications, then replication and migration are probably not necessary items. <BR></div></BLOCKQUOTE></DIV>
<DIV>&nbsp;</DIV>
<DIV>I find that this is quickly not being the case. With the advent of SQL Everywhere and pocket pc and cell phone apps, being able to say "this thing here refers to this, and only this, set of data" is a wonderful thing.</DIV>
<DIV>&nbsp;</DIV>
<DIV><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>As for development, I could argue that its easier to develop using sequential numeric keys than GUIDs for the sheer debugging and ad-hoc query savings. Its much quicker to type in "384" into an ad-hoc query than to copy and paste (or re-type) a GUID. <BR></div></BLOCKQUOTE></DIV>
<DIV>&nbsp;</DIV>
<DIV>Them be fightin' words mister!&nbsp; At first I thought the same as you, but work with guids long enough and they simply don't pose that problem.&nbsp; </DIV>
<DIV>&nbsp;</DIV>
<DIV>First if you query on the first 4 or five 'characters' in the guid you will usually find the one you want.&nbsp; Maybe a couple more will show up but finding the row you need isn't that difficult.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Now if these ad-hoc queries are in an application then of course you never have to type in that guid to begin with.</DIV>
<DIV>&nbsp;</DIV>
<DIV>And if you do development in Visual Studio use Developer Express Code&nbsp;Templates to basically write the sql for you.</DIV>
<DIV>&nbsp;</DIV>
<DIV>And while&nbsp;'384' is easy to remember and type I find '4395053' to be&nbsp;very easy to forget&nbsp;and/or mistype when I am a hurry so I usually use copy/paste anyway to make sure I&nbsp;get it right.&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV>But MAINLY guids make things like simple object caching, object comparison, object creation and maintanence and services much easier to write and maintain.&nbsp; </DIV>
<DIV>&nbsp;</DIV>
<DIV><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>Solving the unique GetIdValue problem with a utility method at the start of development is a one-time thing.<BR></div></BLOCKQUOTE></DIV>
<DIV>&nbsp;</DIV>
<DIV>That usually does not work while off line.&nbsp; Again, pocketpc/cellphone apps are not always connected to the network.&nbsp; My customers expect offline capability even for their simple apps. And clickOnce apps that are deployed over the internet suffer user-noticeable performance hits when you have to retrieve the next number.&nbsp; </DIV>
<DIV>&nbsp;</DIV>
<DIV><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>Its also very simple to solve the replication/migration issues using a GUID as a non-primary key.<BR></div></BLOCKQUOTE></DIV>
<DIV>&nbsp;</DIV>
<DIV>This is where I agree with you 100%.&nbsp; Needing to use something other than a GUID for the primary key because it is a high transaction system I understand.&nbsp; But I will still want a GUID to id the object. My apps would probably not even use the PK in that case so the GUID would have to be a Unique Key.</DIV>
<DIV>&nbsp;</DIV>
<DIV>So you can convince me that there will be performance hits if a GUID is used as the primary key.&nbsp; And I don't care.&nbsp; There are ways to overcome this hit to a certain extent.&nbsp;Whatever performance problems that remain are often not noticeable or can be solved with a bit more hardware.&nbsp;</DIV>
<DIV>&nbsp;</DIV>
<DIV>But to say development is easier when using numbers to identify the objects.&nbsp;&nbsp;That is just crazy talk. I mean the fact that one piece of information id's that OBJECT among all other OBJECTS in the UNIVERSE!</DIV>
<DIV><BR>BTW. Don't take the comments I wrote personally.&nbsp; Maintenance/time&nbsp;of development&nbsp;freaks like me are also weird.&nbsp; Just not as weird as you.<img src="/emoticons/emotion-2.gif" alt="Big Smile [:D]" /><BR></DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Wednesday, March 21, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>If you're using CSLA's root/child pattern, you don't think you'd have multiple inserts in that span of time?</div></BLOCKQUOTE></P>
<P>You would for the child objects of course, but they would all have identical guid for thier&nbsp;FK to the parent so again minimized page splits.&nbsp;&nbsp;This is why I said they are ideal for root object PK's. Obviously it would be a bad choice to say have a GUID for the PK of a Order Item child object of an Order object, it should instead be the Order GUID + a sequential int.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div>No, my view is not that simplistic. As a member of the performance "weird bunch", to quote a poster above, I'm very much aware of my query plans and how SQL retrieves data. Though even with a seek, how many additional MBs of index information must be sifted through to get to what you're seeking?</div></BLOCKQUOTE></P>
<P>Obviously with only a 10% performance penalty on joins for&nbsp;400%&nbsp;the key bytes it's not "shifting" through all those extra bytes. If you are familiar with how SQL server and most relational DB's implement indexes you would know more bytes per unque key value does not have a 1:1 effect on index seek time.<BR></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>My point is not that GUIDs don't have a place. My point is only that GUIDs should not be the default. I've spent over 40 hours on the phone with MS's SQL team fixing performance issues related to using GUIDs as primary keys. I'm intimiately familiar with the ins and outs of how SQL treats indexes and data pages among other things. Yes, this system was large, but not abnormally large. It was a supply chain application that serviced only 11 production plants.</div></BLOCKQUOTE></P>
<P>Again for someone who is intimately familiar with with SQL indexes and storage engine it seems odd you would come here proclaiming 1st that a index that is 2-4 times the size of an int takes 2-4 times as long to transverse to find matches, and 2nd that we can be assurred COMB GUID will not sort sequencially&nbsp;since both are incorrect.<BR></P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>Development/replication/migration can all be solved quite simply with GUIDs as the primary key. But if we're talking about simple applications, then replication and migration are probably not necessary items. As for development, I could argue that its easier to develop using sequential numeric keys than GUIDs for the sheer debugging and ad-hoc query savings. Its much quicker to type in "384" into an ad-hoc query than to copy and paste (or re-type) a GUID. Solving the unique GetIdValue problem with a utility method at the start of development is a one-time thing. Its also very simple to solve the replication/migration issues using a GUID as a non-primary key.<BR></div></BLOCKQUOTE></P>
<P>You could argue that point, and on a small development project that might be true. My argument from experience implementing small projects that evolved into large projects all based on 32 bit ints for keys is that&nbsp;yes "384" easy easy to rememeber "2154336873" is not so easy. Even smaller numbers are easy to transpose and anyone who is serious about debugging or retreiving the right data ad-hoc is going to use cut and paste to eliminate typo's. Secondly "384" is too easy to remeber especially&nbsp;out of context and being&nbsp;passed around within variables, as it is easy to store the key of one entity and make a simple error and have it be used to retrevie a different type of entity that just happens to have the same id, not generating error, GUID avoid this simple mistake all together. </P>
<P>Nothing wrong with being a part of the "weird bunch" when it comes to performance, but I have found most reasons used to avoid GUID's are from misinformation, and trying to eek out 10% more PK lookup performance is not the best place to spend optimiztion time, as those queries are usually the best performing in the entire application, vs the more complex analysis query's or user search functions that don't really even deal with a PK lookup but are comparing the other attributes of the entity and taking up most of the resources.</P>
<P>Justin</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Clayton replied on Wednesday, March 21, 2007</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Justin:</strong></div><div><p>You would for the child objects of course, but they would all have identical guid for thier&nbsp;FK to the parent so again minimized page splits.&nbsp;&nbsp;This is why I said they are ideal for root object PK's. Obviously it would be a bad choice to say have a GUID for the PK of a Order Item child object of an Order object, it should instead be the Order GUID + a sequential int.</p>

<p>Obviously with only a 10% performance penalty on joins for&nbsp;400%&nbsp;the key bytes it's not "shifting" through all those extra bytes. If you are familiar with how SQL server and most relational DB's implement indexes you would know more bytes per unque key value does not have a 1:1 effect on index seek time.<br></p>

<p>Again for someone who is intimately familiar with with SQL indexes and storage engine it seems odd you would come here proclaiming 1st that a index that is 2-4 times the size of an int takes 2-4 times as long to transverse to find matches, and 2nd that we can be assurred COMB GUID will not sort sequencially&nbsp;since both are incorrect.<br></p>

<p>You could argue that point, and on a small development project that might be true. My argument from experience implementing small projects that evolved into large projects all based on 32 bit ints for keys is that&nbsp;yes "384" easy easy to rememeber "2154336873" is not so easy. Even smaller numbers are easy to transpose and anyone who is serious about debugging or retreiving the right data ad-hoc is going to use cut and paste to eliminate typo's. Secondly "384" is too easy to remeber especially&nbsp;out of context and being&nbsp;passed around within variables, as it is easy to store the key of one entity and make a simple error and have it be used to retrevie a different type of entity that just happens to have the same id, not generating error, GUID avoid this simple mistake all together. </p>
<p>Nothing wrong with being a part of the "weird bunch" when it comes to performance, but I have found most reasons used to avoid GUID's are from misinformation, and trying to eek out 10% more PK lookup performance is not the best place to spend optimiztion time, as those queries are usually the best performing in the entire application, vs the more complex analysis query's or user search functions that don't really even deal with a PK lookup but are comparing the other attributes of the entity and taking up most of the resources.</p>
<p>Justin</p></div></BLOCKQUOTE><br><br>My intent from my posts was not to say that all of the data will be sifted through. That's why I used phrases such as "up to two or four times" in my first post instead of giving it as an absolute. Obviously it depends on the fill factor of the index pages, etc. I wish there was a program that could graphically display the B-tree with int vs GUID values as a way to illustrate my point, but I don't know of one.<br><br>My whole intent has been to point out that there are obvious performance and space penalties for GUIDs that are not strictly necessary. The benefits of GUIDs can be had using the GUID as a non-PK and still retain the benefits from using a sequential number as the PK. I also think I've shown quite simply that the COMB GUID does not sort sequentially in all circumstances.<br><br>My whole reasoning for posting has been to give light to the problems I faced with a GUID as PK system. Yet this seems to have devolved into something akin to an argument, so I'll rest my case here. I will certainly read any response you may have, but it is unlikely I will continue. I believe we may be at a point where we have to agree to disagree.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Justin replied on Wednesday, March 21, 2007</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Clayton:</strong></div><div><BR>My intent from my posts was not to say that all of the data will be sifted through. That's why I used phrases such as "up to two or four times" in my first post instead of giving it as an absolute. Obviously it depends on the fill factor of the index pages, etc. I wish there was a program that could graphically display the B-tree with int vs GUID values as a way to illustrate my point, but I don't know of one.<BR><BR>My whole intent has been to point out that there are obvious performance and space penalties for GUIDs that are not strictly necessary. The benefits of GUIDs can be had using the GUID as a non-PK and still retain the benefits from using a sequential number as the PK. I also think I've shown quite simply that the COMB GUID does not sort sequentially in all circumstances.<BR><BR>My whole reasoning for posting has been to give light to the problems I faced with a GUID as PK system. Yet this seems to have devolved into something akin to an argument, so I'll rest my case here. I will certainly read any response you may have, but it is unlikely I will continue. I believe we may be at a point where we have to agree to disagree.<BR></div></BLOCKQUOTE></P>
<P>Lets not mince words, this is an debate, you arguing against and I arguing for GUID's both based on our experiences, I would hope all here benifit in some way from the debate and would not characterize it as "devolved".</P>
<P>You seemed to be pretty susinct it your proclimations that GUID's will at least *2 the index seek time (when the reality is *1.10) &nbsp;and that COM GUID's would never sort sequentially (arguing based on thier alphabetic sort). Instead of admitting&nbsp;error with these claims you have only&nbsp;"moved the goalposts", redefining what you meant by "doubling or more the time for performing an index seek" and "COMBID will still give you the same penalties as indexing/clustering on a real GUID".</P>
<P>I simply wanted to quell any misinformation about GUID's and&nbsp;COMB GUID's that may turn people away from them. </P>
<P>Perhaps a summary of known pro's and con's we can agree on? Please correct me if this has any errors (Note most natural keys for data are more than 16bytes and are not sequetial therfore having similar issues as GUID's):</P>
<P>Pros:</P>
<P>1. GUID's are statistically unique allowing the PK of a entity to be assigned disconnected from a central database, allowing a new BO's&nbsp;to be initialized without a roundtrip to the central DB.</P>
<P>2. Since GUID are globally unique no special measures must be taken for replication as there will be no domain conflicts when merging data from separate systems.</P>
<P>2.Random GUID's&nbsp;lead to more&nbsp;secure systems as it is nearly impossible to guess previous or&nbsp;next&nbsp;PK's for an entity or even randomly guess a valid PK.&nbsp;&nbsp;</P>
<P>Cons:</P>
<P>1. GUID's are 16bytes, int are 4bytes, bigint 8bytes, GUID require more storage than int's or bigint's&nbsp;could be up to 2-4 times slower on an index scan, but only ~1.10 times slower on a seek. </P>
<P>2. Random GUID's can cause excessive index page splitting and fragmentation (once fill factor has been exhausted)&nbsp;affecting tables that have a high volume of inserts. This can be even more pronounced if the GUID is a clustered index as the table becomes fragmented. This requires more database maintence overhead to reorganize indexes.&nbsp;</P>
<P>COMB GUID's eliminate con #2 in systems that&nbsp;generate GUID's&nbsp;at less then 300 a second(this does not affect batch inserts as the COMB GUID algorithm can be implemented in client code generating the GUID at real time not as it's being inserted into db). </P>
<P>SQL Newsequentialid() function can eliminate con #2 at any generation rate but cannot be implemented in client code.</P>
<P>3. GUID's cannot be used for paging datasets or other comparision's that involve &gt; or &lt; as they are meaningless.</P>
<P>Justin</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>hurcane replied on Thursday, March 22, 2007</h2>&nbsp;This has been an interesting thread to read. We took the compromise route in our office. None of our transactional objects (customer orders, purchase orders, etc.) know their primary key when they are new. <br><br>We have two private fields in these objects to handle the identity. One is the primary key and the other is a GUID. DataPortal_Create instanatiates the guid variable. DataPortal_Fetch instantiates the primary key variable.<br><br>Our GetIdValue overrides look like this for these objects:<br>Public Overrides Sub GetIdValue() As Object<br>&nbsp;&nbsp;&nbsp; Return IIf(Me.IsNew, mFakeID, mPrimaryKey)<br>End Sub<br><br>The GUID doesn't go in the database, so the performance people on our team are satisfied. It really just gets used for comparison purposes. We don't explicitly use GetIdValue in any of our business or UI code.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
