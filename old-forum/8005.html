<html><header><title>How to manage many to many relationships without creating too many classes</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>How to manage many to many relationships without creating too many classes</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8005.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef posted on Tuesday, November 17, 2009</h2>I've the following use case:<br>&nbsp;&nbsp;&nbsp; An employee can choose from a countrylist the countries he wants to work in. In the UI this is typically done with a dual list. (two listboxes and
        some buttons to move item(s) from one listbox to the other)<br><br>I was thinking to create the following objects following the projecttracker example:<br>&nbsp;- CountryList (ReadOnlyListBase)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase)<br>&nbsp;- Employee (BusinessBase)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - SelectedCountries (BusinessListBase)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - SelectedCountry (BusinessBase)<br><br>When modeling the application like this, I can create a fully functional application.<br>But I'm not so happy with the design.<br>I find that too much classes are created.<br>I'm more in favor of the following model:<br>&nbsp;- CountryList (ReadOnlyListBase)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase)<br>
&nbsp;- Employee (BusinessBase)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - List&lt;CountryInfo&gt; (just a property)<br><br>But in this case I don't see how this must be saved to the database. When reading the book I've noticed that only BusinessBase has the methods(fetch,insert,update and create). How do I need to code this. So the employee object needs to save the list of selected countries.<br><br><br><br><br><br><br><br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Tuesday, November 17, 2009</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>alef:</strong></div><div></P>
<P>I was thinking to create the following objects following the projecttracker example:<BR>&nbsp;- CountryList (ReadOnlyListBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase)<BR>&nbsp;- Employee (BusinessBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - SelectedCountries (BusinessListBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - SelectedCountry (BusinessBase)<BR><BR>When modeling the application like this, I can create a fully functional application.<BR>But I'm not so happy with the design.<BR>I find that too much classes are created.<BR>I'm more in favor of the following model:<BR>&nbsp;- CountryList (ReadOnlyListBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase)<BR>&nbsp;- Employee (BusinessBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - List&lt;CountryInfo&gt; (just a property)<BR></div></BLOCKQUOTE></P>
<P>In the example you have given you have eliminated two classes at the expense of increased complexity.&nbsp; One of the classes you eliminated (SelectedCountries) is actually quite trivial to implement since the vast majority of the functionality you need is encapsulated in the base class.&nbsp; The goal is to increase maintainability of the code, not necessarily to reduce the total number of classes.&nbsp;While there is a balance to be struck, your second design does not buy you much, and indeed may cost you (IMHO).&nbsp; By going with the first design, you will enable your child objects to save themselves to the database, again with minimal code.</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, November 17, 2009</h2><P>I'd go with your first design.</P>
<P>CountryList / CountryInfo is meant to display information about a country.</P>
<P>Employee / SelectedCountries / SelectedCountry is meant to allow you to edit an employee (Employee), and define a relationship between zero or more countries (SelectedCountries / SelectedCountry).&nbsp; </P>
<P>Since there are two different roles there (display of information vs. representing a relationship between Employee and Country), you should have seperate classes.</P>
<P>HTH</P>
<P>Andy</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Wednesday, November 18, 2009</h2>Thanks for the reactions.<br>So can I conclude that with CSLA it is NOT possible to implement the second design or maybe it is possible but the framework is not taken into account this design and that is the reason it will be more complex.<br>Suppose that for the employee you want to choose also the languages he can speak, the courses he want to follow, ....<br><br>Also suppose you have another editable root object which also needs a country list.<br>So we'll need to add a lot of extra classes. So I don't known that this will increase the maintainability.<br><br><br>On top of that the code in the UI for the duallist is not so easy. It is not possible to bind just a couple of objects. Because the left side of the duallist has objects of type CountryInfo and the right side of the duallist has objects of the type SelectedCountry. So these are two different kind of object types.<br>So I've the following code in the UI:<br><br><br>&nbsp;&nbsp;&nbsp; public PisteWedstrijdEdit(Employee employee)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeComponent();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // store object reference<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _employee = employee;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // set up binding&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BindUI();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // check authorization<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ApplyAuthorizationRules();<br>&nbsp;&nbsp;&nbsp; }<br><br><br>&nbsp;&nbsp;&nbsp; private void BindUI()<br>&nbsp;&nbsp;&nbsp; {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridControlAvailableCountry.DataSource = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridControlSelectedCountry.DataSource = null;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTable dtAvailable = new DataTable();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtAvailable.Columns.Add("Id", typeof(int));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtAvailable.Columns.Add("Value", typeof(string));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTable dtSelected = dtAvailable.Clone();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectedCountries selectedCountries = _employee.SelectedCountries;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (selectedCountries == null) return;<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (CountryInfo countryInfo in CountryList.GetCountryList())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (selectedCountries.Contains(countryInfo.Id))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtSelected.Rows.Add(new object[] { countryInfo.Id, countryInfo.Name});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtAvailable.Rows.Add(new object[] { countryInfo.Id, countryInfo.Name});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridControlAvailableCountry.DataSource = dtAvailable;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gridControlSelectedCountry.DataSource = dtSelected;<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private void dualListAdd_AfterAction(object sender, DualListActionEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SelectedCountry selectedCountry = _employee.SelectedCountries.AddNew();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selectedCountry.CountryId = (int)gridViewSelectedCountry.GetDataRow(e.ToIndex)["Id"];<br><br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; private void dualListDelete_AfterAction(object sender, DualListActionEventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _employee.SelectedCountries.Remove((int)gridViewAvailableCountry.GetDataRow(e.ToIndex)["Id"]);<br>&nbsp;&nbsp;&nbsp; }<br><br><br><br>So because we have two different kind of object types (SelectedCountry, CountryInfo) and a duallist needs two of the same kind in the UI we need to implement a workaround.<br>In the BindUI() method we'll provide the two listboxes the same type of object, these are two datatables which we'll create on the fly.<br><br>And in the events (dualListAdd_AfterAction, dualListDelete_AfterAction) we need to synchronize our business objects with the reality.<br><br>So as you can see we don't have anymore the simple binding.<br><br><br><br><br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, November 18, 2009</h2>Oh, its entirely possible to create the second design in csla... its just that more than likely you'll wind up regretting it down the road.</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Fintanv replied on Wednesday, November 18, 2009</h2><P>For what its worth here is how I would approach the problem:</P>
<P>- ICountry (Interface that exposes the country properties)</P>
<P>-&nbsp; CountryList (ReadOnlyListBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase) : ICountry</P>
<P>- CountryCollection (BusinessListBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp; - Country (BusinessBase) : ReadOnly properties : ICountry</P>
<P><BR>&nbsp;- Employee (BusinessBase)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - SelectedCountries (CountryCollection ): Property that may initially be empty or populated with already saved employee choices.&nbsp; This is the list of countries that will be persisted when you 'save' your employee business object.</P>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - NonSelectedCountries (CountryCollection ): Property that may&nbsp;be populated by the values stored in CountryList or from a direct db call, minus those countries found in the SelectedCountries property (could be passed in as an 'exclusion' list to the factory method).</P>
<P>You can then encapsulate the functionality to move the countries from selected list to non-selected list within your Employee root&nbsp;class.</P>
<P>Your UI listboxes bind to the two collections exposed by your root object.&nbsp; Your UI buttons determine what countries are selected and then pass this info to the method in your root that handles the move between the lists.</P>
<P>No need for workarounds hosted in the UI, and encapsulates the use case into a single business object (Employee).&nbsp; This is more maintainable at the use case level of granularity.</P>
<P><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Wednesday, November 25, 2009</h2><br>I've created a full working example of this like the description of Fintanv.<br>Maybe at the end Lhotka can add it to the examples.<br>For the GUI using a business model like this is a dream. It is really simple, just two lines of code :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void cmdAdd_Click(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _employee.AddCountry(((ICountry)AvailableCountriesListBox.SelectedItem));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void cmdDelete_Click(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _employee.RemoveCountry(((ICountry)SelectedCountriesListBox.SelectedItem));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>In the business layer some things to pay attention.<br>The DataPortal_Update method of the class Employee can't use the following:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FieldManager.UpdateChildren(cn, this);<br>I've replaced this with the following<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Update Child object(s)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataPortal.UpdateChild(ReadProperty(SelectedCountriesProperty),cn, this);&nbsp;&nbsp; <br>Reason : employee has two collections SelectedCountries and NonSelectedCountries. Only the SelectedCountries must be saved to the database.<br>If we use FieldManager.UpdateChildren then CSLA will try to save both collections to the database.<br><br><br><br>For the rest everything is normal code.<br><br><br>But still I'm not convinced of the design (the business layer)<br><br>In the database we have an intermediate table but in the OO model we don't always match up. If we don't have extra information on the relationship between Employee and Country (i.e.. a property to express his favor in a percentage for that country) I don't see a reason to have objects like CountryCollection and Country.<br>When doing some research I stumbled on an old posting of yours: http://www.lhotka.net/Article.aspx?id=ff226256-903f-4aee-a921-8b09ef40901b. In the post, you seem to be saying that the intermediate table concept doesn't fit into OOD/OOP. <br><br>ajj3085 is saying it is possible to do this. Is it possible to show me how to do this? <br>You can a find full working example in attachment.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Wednesday, November 25, 2009</h2><P>It's ok that your business object design doesn't match your database design.&nbsp; It usually shouldn't.&nbsp; The reason is that your business layer is driven by use cases, or what the user is trying to do.&nbsp; This rarely directly matches the goals of database design, which is a relational model designed to reduce duplicate data and normalize it.&nbsp; Those goals are different, so its no suprise that they produce different models.&nbsp; That's why you do your mapping between the two in your DataPortal_XYZ methods, or ObjectFactory.</P>
<P>&nbsp;</P>
<P>It wouldn't be hard to bulid the other model you suggest, and I"m sure you can figure out how to do this.&nbsp; The pain will come in though ifyour data model changes, or if one use case changes and the other doesn't.&nbsp; you'll either end up violating the Single responsiblity principal, or you'll have to do the work to create the design you now have anyway.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Friday, November 27, 2009</h2><br>I'm a bit confused now. <br><br>The OO model like <a>Fintanv</a> is describing is a one to one mapping with the database tables. <br>The country objects represents the bridge table. The dataportal methods of Country will update the bridge table.<br><br>In the contrary the OO model<br><br>&nbsp;- CountryList (ReadOnlyListBase)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - CountryInfo (ReadOnlyBase)<br>&nbsp;- Employee (BusinessBase)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - List&lt;CountryInfo&gt; (just a property)<br><br>directly represent the many-to-many relationship, without the need to create composite entities.<br><br>I must admit to have a consistent design, we should always keep a collection of the object mapped to the bridge table. That way, if you decide to add attributes to the bridge table later, you won't have completely redo your object model and hence your application. You could simply add properties to the object mapped to the bridge table.<br><br><br>When reading the article<br>http://www.lhotka.net/Article.aspx?id=ff226256-903f-4aee-a921-8b09ef40901b<br>Lhotka is saying "What you've hit on here is an example of where relational models and OO models don't always match up".<br>So the model he is proposing doesn't correspond to the one of <a>Fintanv</a><br>We can say that in my use case an Employee not owns 'Countries'. Lhotka says "<i>To effectively implement this type of scenario you almost always need to use a technique called lazy loading.</i>"<br>In my use case I prefer not the lazy loading (when getting an employee and I want immediately also the countries where the employee wants to work), but the OO model described in the article gets more my favor.<br><br><br>It is nice to hear that CSLA is supporting both models. But I regret I can't see how to do this. Please is it possible to implement this in my example. I've put some effort to create this example so that we have a good starting point.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>peteisace replied on Saturday, November 28, 2009</h2>Er, I wouldn't bother with the first way, just make the second way do what you actually want.<br /><br />What are the objects here? it's only Employee and Country (and the list that ties them together). You should read ALL the countries into your BusinessListBase class, irrespective of whether they have been selected or not. You will need a public settable property on your Country object, called "Selected". You don't need to model the selected country different from one that's not, it's the same object, just a slightly different state. Then just expose 2 properties on your list class: "Selected" and "Available". Implement like this:<br /><br />public IEnumerable Selected<br />{<br />     get { return this.Where(p => p.Selected); }<br />}<br /><br />then bind the appropriate grid to the appropriate property on you list class. When the user hits the a button just grab the country instance and reverse the selected status:<br /><br />private void CountrySelectedClick(object sender, RoutedEventArgs e)<br />{<br />      Button b = (Button)sender;<br />      Country country = (Country)sender.DataContext;<br />      Country.Selected = !country.Selected;<br />}<br /><br />you may need to override OnChildChanged on the list class and fire PropertyChanged events for the available / selected properties to get the grids updating in the UI cleanly.<br /><br />This way you persist every country so it can do the relevant insert / delete based on it's selected status.<br /><br />Easy :)</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
