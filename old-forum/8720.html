<html><header><title>DataPortal.BeginFetch with lambda expression doesn't compile.</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>DataPortal.BeginFetch with lambda expression doesn't compile.</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8720.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman posted on Wednesday, March 24, 2010</h2><p>I&#39;m using VS2010 Beta 2, SL4, CSLA 3.8.2, Expert C# 2008 Business Objects book.</p>
<p>On page 433 is some sample code (similar to below)&nbsp;that generates a &quot;Cannot convert lambda expression to type &#39;object&#39; because it is not a delegate type&quot; compile error.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dp = new DataPortal&lt;Intellifolders&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.BeginFetch(new SingleCriteria&lt;Intellifolders, Guid&gt;(_userGuid),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });</p>
<p>Is the syntax in the book obsolete now? I admit to being very inexperienced with lambdas.</p>
<p>Thanks,</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>rsbaker0 replied on Wednesday, March 24, 2010</h2><p>I usually solve these problems with an appropriate cast. For instance, a lambda like () =&gt; {...} can be cast to Action where a parameterless delegate is required. So, perhaps you can cast your delegate to Action&lt;o_type, e_type&gt; for whatever types you are expecting for o and e. </p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman replied on Thursday, March 25, 2010</h2><p>I tried a somewhat different approach, based on code I found in this forum, as shown below. I get into GetSubfolders and dp.BeginFetch is executed, but I never get into the matching DataPortal_Fetch method.Ultimately the VS JIT debugger window pops up with &quot;Unhandled error in SL app, Code 404, Category: ManagedRuntimeError, System.Reflection.TargetInvocationException: Message has been thrown by the target of an invocation. ---&gt; &quot; but I can&#39;t seem to get the debugger to connect.</p>
<p>I&#39;m trying to lazyload SubFolders of a currently selected Folder object in a treeview control.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static&nbsp; void GetSubfolders(Intellifolder parent)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dp = new DataPortal&lt;Intellifolders&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.FetchCompleted += (o, e) =&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.BeginFetch(new SubFolderCriteria(_userGuid, parent.NodeID));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>#if !SILVERLIGHT<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void DataPortal_Fetch(SubFolderCriteria criteria)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (CLXIntelliFolders folderData = new CLXIntelliFolders())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (DataSet ds = folderData.GetIntelliFoldersListADO(criteria.UserGuid))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (DataRow r in ds.Tables[0].Rows)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(Intellifolder.GetIntellifolder(r));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Thursday, March 25, 2010</h2><p>I haven&#39;t done much with Silverlight, but usually 404 when dealing with an http type request means &quot;page cannot be&nbsp;found&quot; or something similar.&nbsp; You get this error if you specify a valid host name in an URL but the actual target isn&#39;t there, say <a href="http://www.lhotka.net/junk">http://www.lhotka.net/junk</a></p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman replied on Thursday, March 25, 2010</h2><p>I suspect the 404 is collateral damage from the incorrect use of the lambda...if I comment out the call that causes the lambda to execute, the error goes away. </p>
<p>The fact that I don&#39;t get into the matching DataPortal_Fetch method is my biggest concern at this point.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>KevinKlasman replied on Thursday, March 25, 2010</h2><p>I&#39;m trying the traditional event handler approach now. </p>
<p>And I may have misreported the error that is occurs, even with this new approach...its a 4004, not 404. And I still think this is a red-herring, in that I haven&#39;t really finished (cause I don&#39;t yet know how) the code that causes this dp.Fetch to execute.</p>
<p>Wait, maybe its my strategy that is incorrect. The crash occurs when my treeview SelectedItemChange method ends. Maybe the crash is occuring before the DataPortal_Fetch method returns, causing that response to be lost or otherwise screwing things up.</p>
<p>So, here&#39;s my current strategy. Note that I&#39;m only worried about retrieving existing data at this point.</p>
<p>1. Load top level folders via a bound list object (Intellifolders)&nbsp;derived from EditableRootListBase. This works fine.</p>
<p>2. When the user clicks one of these folders, I want to get the subfolders if they haven&#39;t already been gotten. Here&#39;s the treeview event. My crash occurs when this event completes it seems (at&nbsp; least it happens when I step off of the final brace). I am uncertain how to code this event, but it seems like what I have should work, despite being hacky. I&#39;m sure I&#39;ll need to expand or collapse the treeview node here, but first things first...I just want to get the data right now.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void MainTreeView_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs&lt;object&gt; e)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intellifolder folder = MainTreeView.SelectedItem as Intellifolder;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (folder != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (folder.SubFolders != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ???<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>3. The &quot; if (folder.SubFolders != null)&quot; statement in the event handler above causes the Intellifolder.Subfolder get&nbsp;property to fire, which in turn causes the LoadProperty to fire. Once this works, it should fill the current Intellifolders object, which is then linked to the parent Intellifolder object and life will be good. I get into the GetSubfolders factory method fine, but as I said before, the SubFolders get property and treeview event finish next and the crash happens. </p>
<p>What seem wonky to me is that to get the LoadProperty method in parent class to compile, the factory method GetSubFolders cannot be void, which isn&#39;t how the other factory methods are declared. (I&#39;m sure I really don&#39;t understand how the factory methods work.) This is probably where this strategy is breaking down. My incomplete understanding of the async behavior is likely the cause.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private static PropertyInfo&lt;Intellifolders&gt; SubFoldersProperty = RegisterProperty&lt;Intellifolders&gt;(c =&gt; c.SubFolders);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Intellifolders SubFolders<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!FieldManager.FieldExists(SubFoldersProperty))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.IsNew)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //LoadProperty(SubFoldersProperty, Intellifolders.NewIntellifolder());<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LoadProperty&lt;Intellifolders&gt;(SubFoldersProperty, Intellifolders.GetSubfolders(this));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return GetProperty(SubFoldersProperty); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set { SetProperty(SubFoldersProperty, value); }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>4. The factory and dataportal_fetch method look like this:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static Intellifolders GetSubfolders(Intellifolder parent)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dp = new DataPortal&lt;Intellifolders&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.FetchCompleted += new EventHandler&lt;DataPortalResult&lt;Intellifolders&gt;&gt;(dp_FetchCompleted);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.BeginFetch(new SubFolderCriteria(_userGuid, parent.NodeID));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return null; // ???<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; internal static void dp_FetchCompleted(object sender, DataPortalResult&lt;Intellifolders&gt; e)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (e != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// load each returned Intellifolder<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>#if !SILVERLIGHT<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void DataPortal_Fetch(SubFolderCriteria criteria)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (CLXIntelliFolders folderData = new CLXIntelliFolders())<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (DataSet ds = folderData.GetIntelliFoldersListADO(criteria.UserGuid))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (DataRow r in ds.Tables[0].Rows)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Add(Intellifolder.GetIntellifolder(r));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />#endif</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Thursday, March 25, 2010</h2><p>Async factory methods must be void. They can not return a value, because the method returns (completes) before the async result comes back.</p>
<p>This is why async factory methods accept a callback parameter, so the caller of the async factory can provide a callback method that is invoked when the async operation does complete.</p>
<p>This is also why using lambda expressions is so much simpler than using a separate event handler - because you need some way to provide the callback method delegate to the async handler, which is automatic with lambdas, but requires a bunch of other manual code without lambdas.</p>
<p>For example, here&#39;s a factory method that does nothing except invoke the callback (which is pretty typical):</p>
<p>&nbsp;&nbsp;&nbsp; public static void GetSearchForPosts(string searchText, EventHandler&lt;DataPortalResult&lt;SearchForPosts&gt;&gt; callback)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var dp = new DataPortal&lt;SearchForPosts&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.FetchCompleted += callback;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dp.BeginFetch(new SingleCriteria&lt;string&gt;(searchText));<br />&nbsp;&nbsp;&nbsp; }</p>
<p>The calling code looks like this:</p>
<p>SearchForPosts.GetSearchForPosts(&quot;search term&quot;, (o, e) =&gt;<br />&nbsp; {<br />&nbsp;&nbsp;&nbsp; if (e.Error&nbsp;== null &amp;&amp; e.Object != null)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // process result<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; });</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, March 25, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>Dan Billingsley<br></b>
<p>Hey Rocky, since Linq and lambdas are bringing the whole concept and understanding of delegates to the mainstream, have you given any thought of applying it to the age-old issue of the Dataportal_XYZ method &quot;magic names&quot;?&nbsp;</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>Yes, but in an n-tier deployment this won&#39;t work for a couple reasons. First, it is quite likely that your data access methods don&#39;t even exist on the client, so the lambda wouldn&#39;t compile. Second, lambda expressions aren&#39;t serializable, so I&#39;d have to invent a serialization model for them - which is possible, but highly problematic due to the first issue (that the methods probably aren&#39;t there to start with).</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, March 25, 2010</h2><p>I think what you are suggesting is something like this:</p>
<p>return DataPortal.Fetch&lt;Customer&gt;(c =&gt; c.GetTheCustomer());</p>
<p>Basically have the Fetch() and other methods accept a Func&lt;T&gt; - which could be a delegate, lambda, etc.</p>
<p>That could work, except that the GetTheCustomer() method would need to exist in the context where this code was compiled - which would normally be on the client. Silverlight or not, a good many people do things to prevent their data access code from existing on the client, so this code wouldn&#39;t compile.</p>
<p>But even if you require that the GetTheCustomer() method be implemented on the client, the problem is still not solved, because the delegate/lambda/etc is declared and instantiated on the client when this code executes. So there&#39;s still the problem of picking up the call context and transferring it to the server so the GetTheCustomer() method actually runs on the server.</p>
<p>There are various ways to do this now, including some clever tricks with the new Dynamic keyword in C#. That&#39;d actually require some changes in how you interact with the data portal on the client though, because you&#39;d need to get the object to be of type Dynamic before the magic dynamic interceptor I&#39;d build would be able to intercept the method call before it occurred and transfer it to the server.</p>
<p>You are right, code isn&#39;t serialized today. And code itself wouldn&#39;t be serialized in this case - but the call context would be.</p>
<p>The more probable solution though, would be to use the same technique we use in RegisterProperty(), which actually reflects against the type based on the lambda expression to get the property name. The same technique could be used to reflect against the type based on a lambda expression to get the target method name, and that method name could be passed to the server as a string. The result would be pretty much the same as today, with just a few extra bytes of string data passed on every data portal call.</p>
<p>But again we come back to the reality that this only works in the DataPortal_XYZ model, not the object factory model. And it only works if the target method exists on the client, which it never would in Silverlight and often doesn&#39;t even in .NET.</p>
<p>And we can&#39;t dismiss the DP_XYZ vs object factory difference quickly either. By changing the signature of DataPortal.Fetch() to accept a lambda that would only work with DP_XYZ, we&#39;d double the number of Fetch() overloads - only half of which would work with either data portal model. I shudder to think of the confusion that would result as people tried to use the wrong set of overloads with the wrong data portal model.</p>
<p>To make things worse, one of the things I ultimately want to do with the data portal is open up the set of models so people can add their own. At which time who knows what this would lead to...</p>
<p>All in all, it just isn&#39;t going to happen.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, March 26, 2010</h2><p>Maybe not.&nbsp; One of the things about partial methods is that if there&#39;s no implementation, the method is removed from the class entirely.&nbsp; So, from your client-side compilation, the server-side implementation wouldn&#39;t exist, and the partial method could be removed - even though it&#39;s being referenced from your lambda expression.&nbsp; Then you&#39;re back to the lambda expression not compiling.</p>
<p>- Scott</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 26, 2010</h2><p>I think it would also be possible to do this:</p>
<p>public void GetTheCustomer(CriteriaType criteria)<br />{<br />#if SILVERLIGHT<br />&nbsp; throw new InvalidOperationException(&quot;GetTheCustomer&quot;);<br />#else<br />&nbsp; // write implementation here<br />#endif<br />}</p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Friday, March 26, 2010</h2><p>I believe partial methods exist&nbsp;largely to manage the new WPF control/eventing model.&nbsp; Without partial methods, the WPF way of control composition would lead to ridiculous overhead in event management.&nbsp; They certainly have uses in a partial-class construct, but I think their&nbsp;benefit there is much less limited unless you have a situation similar to what WPF presents.</p>
<p>- Scott</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
