<html><header><title>LinqBindingList Performance - A Suggestion</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>LinqBindingList Performance - A Suggestion</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/7450.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Woggly posted on Thursday, August 13, 2009</h2>Hello!<br /><br />We had some performance problems when we were editing a large amount of objects in a datagrid, which is bound to a LinqBindingList. By using a profiler we found out, that the method ItemShouldBeInList needs most of the time. We looked at it carefully and found out, that it would be enough for us to only check if the item fits the where-condition. We modified the method like shown below. What do you think? Will this cause any problems later on? We testet our app where the List is used and everything worked fine.<br /><br /> private bool ItemShouldBeInList(T item)<br />    {<br />      InnermostWhereFinder whereFinder = new InnermostWhereFinder();<br />      MethodCallExpression whereExpression = whereFinder.GetInnermostWhere(_expression);<br />      if (whereExpression == null) return false;<br />      if (whereExpression.Arguments.Count       if (whereExpression.Arguments[1] == null) return false;<br />      Expression> whereBody = (Expression>)((UnaryExpression)(whereExpression.Arguments[1])).Operand;<br /><br />      List list = new List { item };<br /><br />      return list.AsQueryable().Count(whereBody) > 0;<br /><br />      //var searchable = _list as Linq.IIndexSearchable;<br />      //if (searchable == null)<br />      //  return false;<br />      //else<br />      //  return searchable.SearchByExpression(whereBody).Contains(item);<br />    }<br /><br />Thanks in advance!</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, August 13, 2009</h2><P>I added this to the issue tracker, hopefully Aaron has time to look at it in the near future.</P>
<P>Thanks for the suggestion!</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>AaronErickson replied on Sunday, September 06, 2009</h2><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>Woggly:</strong></div><div>Hello!<br /><br />We had some performance problems when we were editing a large amount of objects in a datagrid, which is bound to a LinqBindingList. By using a profiler we found out, that the method ItemShouldBeInList needs most of the time. We looked at it carefully and found out, that it would be enough for us to only check if the item fits the where-condition. We modified the method like shown below. What do you think? Will this cause any problems later on? We testet our app where the List is used and everything worked fine.<br /><br /> private bool ItemShouldBeInList(T item)<br />    {<br />      InnermostWhereFinder whereFinder = new InnermostWhereFinder();<br />      MethodCallExpression whereExpression = whereFinder.GetInnermostWhere(_expression);<br />      if (whereExpression == null) return false;<br />      if (whereExpression.Arguments.Count       if (whereExpression.Arguments[1] == null) return false;<br />      Expression> whereBody = (Expression>)((UnaryExpression)(whereExpression.Arguments[1])).Operand;<br /><br />      List list = new List { item };<br /><br />      return list.AsQueryable().Count(whereBody) > 0;<br /><br />      //var searchable = _list as Linq.IIndexSearchable;<br />      //if (searchable == null)<br />      //  return false;<br />      //else<br />      //  return searchable.SearchByExpression(whereBody).Contains(item);<br />    }<br /><br />Thanks in advance!</div></BLOCKQUOTE><br /><br />Sorry for the late response... been on a project putting in 60 hour weeks for awhile, finally catching up on OSS.<br /><br />I think your optimization will work for smaller cases, but may not work well for larger cases, where an index can be used.  If searchable contains a large number of items, the index will be used through SearchByExpression, whereas AsQueryable will not search using the index.<br /><br />This really gets exposed on types such as string, where equality of strings is not an "on the CPU" operation.  For the general case, I fear this change will make some cases worse.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
