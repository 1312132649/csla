<html><header><title>Isolation Level Escalation Bug and Workarounds</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Isolation Level Escalation Bug and Workarounds</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6564.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>tlong posted on Thursday, March 05, 2009</h2><P>We found this problem when profiling our production SQL 2005 box and trying to figure out why even simple select statements from our CSLA app were acquiring extra locks versus running the select in a query window.&nbsp; (Disclaimer: We are still running 2.1.4 but it would appear that this problem will exist in newer CSLA versions since the TransactionlDataPortal pattern is the same.)</P>
<P>When using the Trasactional attribute / TransactionScope with a BO&nbsp;method, the isolation level on the connection is raised to&nbsp;Serializable by default.&nbsp; But when the connection is returned to the ADO.Net pool, the isolation level is not reset back to the default of Read Committed.&nbsp; And when ADO.Net calls sp_reset_connection before re-using the connection, SQL 2005 doesn't change the isolation level back to the db&nbsp;default, apparently this behavior is by design.&nbsp;&nbsp; FYI, in most cases the SQL isolation level default is left at the out-of-the-box setting of Read Committed.</P>
<P>The net result is that subsequent re-users of the same connection will have an escalated isolation level, which for even simple non-transactional selects will make the server acquire more locks.&nbsp; Maybe you want Serializable all the time, maybe not.&nbsp; But in the current CSLA design, you get it always for transactional and sometimes for non-transactional, which seems too arbitrary.</P>
<P>Workaround #1 - We worked around this by altering the TransactionalDataPortal to always use Read Committed (since we didn't need the stricter Serializable default) like this:</P><FONT size=2>
<P></FONT><FONT face="Courier New"><FONT size=1><FONT color=#0000ff><FONT color=#0000ff>Dim</FONT></FONT> tranopts <FONT color=#0000ff><FONT color=#0000ff>As</FONT></FONT> TransactionOptions</FONT></FONT></P>
<P><FONT face="Courier New" size=1>tranopts.IsolationLevel = IsolationLevel.ReadCommitted</FONT></P>
<P><FONT face="Courier New"><FONT size=1><FONT color=#0000ff><FONT color=#0000ff>Using</FONT></FONT> tr <FONT color=#0000ff><FONT color=#0000ff>As</FONT></FONT> <FONT color=#0000ff><FONT color=#0000ff>New</FONT></FONT> TransactionScope(TransactionScopeOption.Required, tranopts)</FONT></FONT></P>
<P>Workaround #2 - Another option would have been to always begin and commit an empty transaction before disposing of the connection, but this has to be done religiously&nbsp;in each Transactional BO method.&nbsp; It looks like this:</P><FONT size=2>
<P><FONT face="Courier New" size=1>cn.BeginTransaction().Commit()</FONT></P>
<P><FONT size=3>or if you want to reset to a specific isolation level:</FONT></P>
<P><FONT face="Courier New" size=1>cn.BeginTransaction(System.Data.IsolationLevel.ReadCommitted).Commit()</FONT></P>
<P><FONT size=3>This isn't really a CSLA bug as much as an ADO.Net/SQL bug, but it would nice if the framework could somehow handle this.&nbsp; Even better would be to give us the ability to set default isolation levels for transactional and non-transactional methods.&nbsp; </FONT><FONT face="Courier New" size=1></FONT></P></FONT></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoeFallon1 replied on Friday, March 06, 2009</h2><P>Nice catch!</P>
<P>I&nbsp;and the developers on my team spent a lot of time last year figuring this out and then fixing the application to stop using Serializable as the default Isolation Level and use Read Committed. We are using normal ADO.Net but when we built our templates we used the value from the CSLA 1.x book which was Serializable. It was only later when we profiled the app that we noticed the extra locks and perf penalty associated with it. The upside is obviously more reliable transactions. But the downside outweighs that benefit in our simple cases.</P>
<P>I agree that the TransactionalDataportal should at a minimum use Read Committed. But even better would be a way to set the isolation level.</P>
<P>Joe</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Sunday, March 08, 2009</h2>A way to set the isolation level would be ok, but not changing the default at this point.&nbsp; If you need something different now, it should be only three lines of code to setup the TransactionScope yourself, right?<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tlong replied on Wednesday, March 11, 2009</h2><P>Roll-your-own doesn't solve the problem.</P>
<P>Even if you do the TransactionScope manually on your Save/Update methods, if you choose an isolation level other than the default of ReadCommitted, you will still have the issue with the isolation on non-transactional methods being potentially incorrect.&nbsp; </P>
<P>Add in&nbsp;the fact that the isolation escalation will only happen for some of your recycled connections, and you'll have a heck of a time finding and&nbsp;debugging this problem.</P>
<P>I would venture to guess that most CSLA/ADO.Net/SQL apps suffer this problem, but the developers and users are completely unaware of the issue.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, March 11, 2009</h2><P>tlong, I don't understand what you just said.</P>
<P>Are you saying that if you write code in a root object that creates its own TransactionScope with a specific isolation level, that this won't work right?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tlong replied on Wednesday, March 11, 2009</h2><P>Correct, it doesn't fix the problem.&nbsp; A better description&nbsp;would be "isolation level persistance" rather than escalation.</P>
<P>If the TransactionScope in your root object uses an isolation level other than the default (let's say Serializable) that will persist on the connection even when it is returned to the ADO.Net connection pool.&nbsp;&nbsp;Any subsequent method (transactional or not) using that recycled connection from the pool will still have the Serializable isolation level, rather than the default of ReadCommitted for a new, unused connection.</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tlong replied on Wednesday, March 11, 2009</h2><P>I found this after my original post.&nbsp; Perhaps a better explanation of the problem:</P>
<P><A href="http://www.softlion.com/blogs/post/2008/11/21/SQL-Server-transaction-isolation-level-and-NET-sql-library-pitfall-bug-!.aspx">http://www.softlion.com/blogs/post/2008/11/21/SQL-Server-transaction-isolation-level-and-NET-sql-library-pitfall-bug-!.aspx</A></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, March 11, 2009</h2><P>So this is a bug with SqlConnection, not TransactionScope. Which means that if I do enhance CSLA so you can specify the isolation level on the Transactional attribute, anyone using SQL Server would need to do this bug-fix/workaround, or I'd need to make the data portal (or ConnectionManager) check to see if it is a SqlConnection object and do this workaround.</P>
<P>Interesting, thanks for pointing this out.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tlong replied on Friday, March 13, 2009</h2><P>You're right, being able to set isolation level for the Transactional attribute doesn't really address the problem, unless&nbsp;you happen to choose to use the default isolation level of ReadCommitted.&nbsp; We have been looking into adding a new "TransactionalReadCommitted" attribute to the DataPortal to get the behavior we want.&nbsp;</P>
<P>I'm not sure how many developers want/need/care to set isolation levels and they can always do it manually with their own TransactionScope.</P>
<P>Also, after thinking about it, I don't think the framework should deal with the SQLConnection isolation level pesistance&nbsp;bug.&nbsp; It's not needed for anyone who's not running SQLServer and it's very possible Microsoft will address the bug in the future.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Turntwo replied on Thursday, October 14, 2010</h2><p>Sure - they can do it manually in each data access method - but it would be better to have it configurable in one place (so those of us using SQL Server can set it to Read Commited instead of Serializable across the application - and still use the nifty TransactionScope attribute).&nbsp; </p>
<p>I agree that the SQL Persistance bug should be handled separately however.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
