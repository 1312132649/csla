<html><header><title>Validation on object level</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Validation on object level</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8730.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef posted on Friday, March 26, 2010</h2><p>I&#39;ve the following Business Rule (the code doesn&#39;t really matter). But this buniness is not bound to a particular property, but must be executed at object level. How can I do this because ValidationRules.AddRule needs always a propertyInfo? So the purpose is that the business rule must be verified when the object is in a dirty state and the object is inserted or updated in the database.</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; private static bool Maximum2LoopnummersOrKampnummers&lt;T&gt;(<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T target, Csla.Validation.RuleArgs e) where T : PisteWedstrijdRegistratie<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int aantalLoopnummers = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int aantalKampnummers = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_discipline1IdProperty != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisciplineInfo discipline1 = DisciplineLijst.GetDisciplineLijst().Where<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (d =&gt; d.Id == target.ReadProperty(_discipline1IdProperty)).Single();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (discipline1.IsLoopnummer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalLoopnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalKampnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_discipline2IdProperty != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisciplineInfo discipline2 = DisciplineLijst.GetDisciplineLijst().Where<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (d =&gt; d.Id == target.ReadProperty(_discipline2IdProperty)).Single();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (discipline2.IsLoopnummer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalLoopnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalKampnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (_discipline3IdProperty != null)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisciplineInfo discipline3 = DisciplineLijst.GetDisciplineLijst().Where<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (d =&gt; d.Id == target.ReadProperty(_discipline3IdProperty)).Single();<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (discipline3.IsLoopnummer)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalLoopnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aantalKampnummers += 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (aantalLoopnummers &gt; 2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Description = &quot;Maximum 2 loopnummers zijn toegelaten.&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (aantalKampnummers &gt; 2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.Description = &quot;Maximum 2 kampnummers zijn toegelaten.&quot;;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br /><br />&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:lightgreen'><h2>RockfordLhotka replied on Friday, March 26, 2010</h2><p>The typical solution is to attach the rule to a fake property. AddRule() doesn&#39;t require a IPropertyInfo, it can also take a string property name - and in that case you can create your own fake property name.</p>
<p>This is a valuable technique you can use to create &quot;rule sets&quot; that are executed when you want to run them by name.</p>
<p>CheckRules() also has an overload that takes a string, which would be the same name as the fake property.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Friday, March 26, 2010</h2><p>&nbsp;</p>
<p>I&#39;ve implemented the following code with a fake property Max2 and did also an override of the IsValid method. The only problem I still have is that I don&#39;t see the error appear at the row indicator in the grid.</p>
<p>&nbsp;&nbsp;&nbsp; /// &lt;summary&gt;<br />&nbsp;&nbsp;&nbsp; /// All custom rules need to be placed in this method.<br />&nbsp;&nbsp;&nbsp; /// &lt;/summary&gt;<br />&nbsp;&nbsp;&nbsp; /// &lt;returns&gt;Return true to override the generated rules; If false generated rules will be run.&lt;/returns&gt;<br />&nbsp;&nbsp;&nbsp; protected bool AddBusinessValidationRules()<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.AddRule&lt;PisteWedstrijdRegistratie&gt;(Maximum2LoopnummersOrKampnummers,&quot;Max2&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br />&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; public override bool IsValid<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules(&quot;Max2&quot;);&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return base.IsValid; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 26, 2010</h2><p>Windows Forms data binding relies on the PropertyChanged event to know that it should update its validation display. You&#39;ll need to call OnUnknownPropertyChanged() to raise the event so data binding knows to display the results.</p>
<p>You should absolutely NOT override IsValid to check rules. IsValid gets called a lot, and you could suffer nasty performance impact. Besides, this won&#39;t allow for any raising of events. If you raise a PropertyChanged event in IsValid I think you&#39;ll create an infinite loop and get a stack overflow exception.</p>
<p>You need to decide what should trigger your rule. Is it a property changing? Or does this rule run when the object is created or saved? Or when the user leaves the row in the grid?</p>
<p>Then you need to override the correct method in response - such as OnChildChanged(), OnPropertyChanged(), Save(), or others. </p>
<p>If you need to detect when the user has finished editing the object in a datagrid, you should be able to override AcceptChangesComplete() - though that&#39;s an advanced scenario and you MUST make sure to call base.AcceptChangesComplete() or you&#39;ll break basic CSLA functionality.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Friday, March 26, 2010</h2><p>I need to detect when the user has finished editing the object in the grid by leaving the row.</p>
<p>I&#39;ve implemented the following code:</p>
<p>A) business layer</p>
<p>&nbsp;&nbsp;&nbsp; protected override void AcceptChangesComplete()<br />&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules(&quot;Max2&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.AcceptChangesComplete();<br />&nbsp;&nbsp;&nbsp; }</p>
<p>B) user interface</p>
<p>&nbsp;&nbsp;&nbsp; private void gridViewRegistraties_InvalidRowException(object sender, DevExpress.XtraGrid.Views.Base.InvalidRowExceptionEventArgs e)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Suppress displaying the error message box<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.ExceptionMode = ExceptionMode.NoAction;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(e.ErrorText);<br />&nbsp;&nbsp;&nbsp; }</p>
<p>==&gt; this gives me the error description in the row indicator and I get the following messagebox : &quot;Object is not valid and can not be saved.&quot; I suppose this error is raised by calling  base.AcceptChangesComplete() and is an error produced by the CSLA framework?</p>
<p>&nbsp;</p>
<p>A second possibility would be the following which gives really the description of what is going wrong as implemented in the business layer by setting the e.Description property. And also the error is displayed in the row indicator of the grid. So here the user sees two times what is going wrong.</p>
<p>&nbsp;&nbsp;&nbsp; private void gridViewRegistraties_InvalidRowException(object
sender, DevExpress.XtraGrid.Views.Base.InvalidRowExceptionEventArgs e)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Suppress displaying the error message box<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.ExceptionMode = ExceptionMode.NoAction;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; KAVVVLibrary.PisteWedstrijdRegistratie pwr = e.Row as KAVVVLibrary.PisteWedstrijdRegistratie;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pwr != null)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(pwr.BrokenRulesCollection.ToString());<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />
&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;</p>
<p>Can you confirm that this is the way to go because I doubt a little bit because you are mentioning it is an advanced scenario and I only have two lines of code? Must base.AcceptChangesComplete(); be called as last step in AcceptChangesComplete?</p>
<p>&nbsp;&nbsp;&nbsp; protected override void AcceptChangesComplete()<br />
&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules(&quot;Max2&quot;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.AcceptChangesComplete();<br />
&nbsp;&nbsp;&nbsp; }</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Friday, March 26, 2010</h2><p><div style='padding-left: 50px;background-color:silver'><b>alef<br></b>
<p>Can you confirm that this is the way to go because I doubt a little bit because you are mentioning it is an advanced scenario and I only have two lines of code? Must base.AcceptChangesComplete(); be called as last step in AcceptChangesComplete?</p>
<p>&nbsp;&nbsp;&nbsp; protected override void AcceptChangesComplete()<br />&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationRules.CheckRules(&quot;Max2&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.AcceptChangesComplete();<br />&nbsp;&nbsp;&nbsp; }</p>
<div style="CLEAR:both;"></div>
</div></p>
<p>That is correct, though you should probably call the base method first, before checking rules, otherwise the accept operation won&#39;t be complete before your rules are run. I don&#39;t remember exactly what all happens during the base class operations, but it is important <img src="http://forums.lhotka.net/emoticons/emotion-1.gif" alt="Smile" /></p>
<p>From what you describe, are you using an ERLB as a list? In that case things may be more complex. The reason is that the save operation is triggered by the base AcceptChangesComplete() - that&#39;s how ERLB knows to save the object. So in that case you absolutely need to call the base method <em>after your rules have run</em>.</p>
<p>So I guess if your current code is working then you are good, and should leave it as-is.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>alef replied on Saturday, March 27, 2010</h2><p>I&#39;m using an ERLB as list because I want to update/insert the data to the database when the user clicks off the row in the grid.</p>
<p>I can confirm what you are telling that in this case (EditableRootListBase) the call to the base method <i>must be after </i>ValidationRules.CheckRules(&quot;Max2&quot;);</p>
<p>I&#39;ve tried to switch this but indeed then the rule is not checked and an invalid object is saved to the database.</p>
<p>&nbsp;</p>
<p>I don&#39;t understand why this should be different in cases other then ERLB. I don&#39;t have such a case for the moment so I can&#39;t experiment with this.</p>
</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, March 27, 2010</h2><p>This is why I said it was an advanced scenario, you need to understand the order of events and what is going on as the objects interact <img src="http://forums.lhotka.net/emoticons/emotion-2.gif" alt="Big Smile" /></p>
<p>How does ERLB know that the user has &quot;left the row&quot;? The whole concept of &quot;leaving the row&quot; is a UI concept. But data binding calls CancelEdit or ApplyEdit as the user leaves the row. Of course CancelEdit means do nothing, but ApplyEdit then must mean commit the change.</p>
<p>So ERLB uses the fact that ApplyEdit was called to know that it should insert/update/delete the object. That is triggered when the base method is called. So if you call the base method before checking your rules, then the object will be deleted by the time your rules run, which means you must run your rules before calling the base method.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Sunday, March 28, 2010</h2><p>Incidentally, we work extensively with ERLB in our app and the automatic saving when leaving a row was one of the hardest things to get worked out properly. (And&nbsp;also eventually one of the reasons why we ended up turning off the IEditableObject interface and doing the BeginEdit/ApplyEdit calls in a central &quot;EditManager&quot; that tracks all root objects currently being edited). </p>
<p>The main problem is what to do when the current row is broken and the user is trying to navigate away (even switch to another MDI form in the application since we tried to keep everything modeless).&nbsp; We had problems where the user couldn&#39;t even close the screen because of the internal workings of the grid. Perhaps I could solve these&nbsp;differently&nbsp;now having had a couple of years experience with the way the grid we use&nbsp;works, but our current solution seems to work OK. </p>
<p>What we do now if the user leaves the row and the object is invalid is to just leave the invalid object in the grid and not save the row. If the user wants to fix it, they can move back to the row to correct the error (after all, there is a red X sitting where the problem is).&nbsp; If they try to close the screen, we can warn them there are unsaved changes, but if they want to ignore the error, that is their choice. In any case, we didn&#39;t write the broken object to the database.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
