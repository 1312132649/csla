<html><header><title>Root/Child Object Design</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Root/Child Object Design</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2572.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>BMT posted on Wednesday, March 21, 2007</h2><P>I'm working on my first project using CSLA and have a general design question--I think my problem may just be a question of semantics.&nbsp; Although parts of my question seem to be addressed in many posts, I couldn't find a definitive answer (if there is such a thing in the development world).</P>
<P>The basic question is this:&nbsp; Is it okay for a root object (Business Base) to contain a "root" collection (Business List Base) of editable child objects (Business Base)?&nbsp; i.e. Just because an object is below another object in the hierarchical structure doesn't necessarily make it a CSLA child object.</P>
<P>Here's&nbsp;a more specific example:</P>
<P>My top-level root object is an Account.&nbsp; Below that are several collections of objects (such as Invoices, Orders, Licenses, Users, Notes, Equipment, etc.).&nbsp; From a UI perspective, nearly all of these sub-objects will be edited by means of a detail form (i.e. not directly in a grid).&nbsp; Should the overall design, then, be (1) Account is a root object, (2) the Invoices collection is a root object--even though it is contained within the Account object, and (3) individual Invoices are are a child of the collection?</P>
<P>I realize that this means that each each of the "root" collections in the top-level root would be responsible for retrieving/updating/deleting its own data (which is probably better anyway so that the data is loaded only when requested by the user).</P>
<P>Thanks in advance for any comments...</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Bayu replied on Thursday, March 22, 2007</h2>Hey!<br><br>I have scenario's implemented as you describe all the time. So let's see if I can be of help to you. ;-)<br><br>The 'recipe' I use is the following:<br>- I would have an Account BO that is an editable root object, so can be displayed, edited and saved independently of its children<br><br>- for each of the grids that will display 'child collection' I create a readonly list with readonly objects<br>&nbsp;&nbsp;&nbsp; - e.g. InvoiceList and InvoiceInfo<br>&nbsp;&nbsp;&nbsp; - these readonly lists are top-level objects, they accept an AccountID parameter in their factory method (andalso in their criteria and dp_fetch)<br>&nbsp;&nbsp;&nbsp; - for convenience I of course put accessor methods on Accout (GetInvoices() {return InvoiceList.GetInvoiceList(Me.ID) } you get the idea)<br><br>- when users double-click in my grids, they get a details form where they can edit the properties of a single invoice, for this purpose I create a new editable root object, e.g. Invoice<br>&nbsp;&nbsp;&nbsp; - this invoice can be saved independently of the parent Account<br><br>There is one issue that could arise here:<br>- you add/edit invoices and the changes are not reflected in your grid bound to InvoiceList/InvoiceInfo<br>- easily resolved though by reinvoking Account.GetInvoices and rebinding the grid as soon as a 'InvoiceAdded event' is raised by the InvoiceDetailsForm<br><br><br>What is the difference with your approach? <br>- well, I htink you tried to solve multiple use cases with 1 top-level BO<br>- what I basically did here is break this down into as many top-level BOs as you have use cases<br><br>Note:<br>- if you don't want Invoice objects to be saved to the DB independent of the Account (usually because you have validation rules for Invoice that also involve the Account or vice versa), then that is possible too:<br>- make Invoice an EditableChild and have a AccountInvoices EditableChildList on your Account<br>- in your UI you could maintain the EXACT same forms and views, it's just some logic (mostly save button logic ;-) ) that moves:<br>&nbsp;&nbsp;&nbsp; - your Account details view stays the same<br>&nbsp;&nbsp;&nbsp; - your Invoices grid is bound to the editable child list AccountInvoices, but the grid is readonly and does not offer a means to edit the details<br>&nbsp;&nbsp;&nbsp; - you open up invoice detail views upon double click as before<br>&nbsp;&nbsp;&nbsp; - there is only 1 save button that will save the whole object graph that start from Account<br><br>- there is 1 difference: your Invoices grid will stay in sync automatically, so you wouldn't have to refresh it using a new call to Account.GetInvoices<br><br>Mostly I prefer the solution with readonly lists since in my scenario's users hardly ever add/edit data, so it would be a waste to load fully editable objects all the time. It's a trade-off, because when they do I have grids that need to refresh. But this only involves readonly lists and objects, so they are reasonably cheap to refresh.<br><br><br>It has turned in a somewhat lengthy response. I hope it's all clear and of any help! ;-)<br><br>Kind regards,<br>Bayu<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>BMT replied on Thursday, March 22, 2007</h2><P>Thanks for your response.&nbsp; </P>
<P>I would still like to know if, according to standard CSLA design patterns and its intended use, it's acceptable to have a CSLA root object contain another CSLA root object (a collection in this case).&nbsp; The users of this app <U>will</U> be editing/updating on a somewhat regularly.&nbsp; Previously, I thought seriously about implementing a design similar to what you described, but (if it works to have a root be a "child" of a root and is acceptable) I would much rather have a single editable Invoice object.</P>
<P>So the question remains, is there a problem with a CSLA root object containing other CSLA root objects?&nbsp; i.e. Account.Invoices (where Invoices is an editable collection and is NOT marked as a child).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, March 22, 2007</h2>The only problem I can think of is if you allow this, its possible for a client to call Save on the collection class.&nbsp; Since Save returns a new object with the updated collection, the object which also contains the collection would no longer be looking at the correct collection... it would be seeing the collection before save was called.&nbsp; That could lead to some bad things and hard to find bugs.<br><br>Usually what is done is that you provide a navigation method to get the other root object.&nbsp; This is a method just placed on the object for conveince's sake.<br><br>So your Account class would have an instance method called GetInvoices, which returns the Invoices root collection.&nbsp; However, even that may be an odd case; typically you'd probably have the navigation method on an AccountInfo class, which would be your readonly object.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>BMT replied on Monday, March 26, 2007</h2>After thinking about this a little more, I've decided to go back to my original design (and your suggested implementation).&nbsp; I'll have a read-only collection of read-only "XYZinfo" objects.&nbsp; Each of these objects will have a "GetXYZ" instance method to get the root XYZ object.&nbsp; I guess I'm just not used to creating multiple objects that contain the same data.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
