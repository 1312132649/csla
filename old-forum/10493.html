<html><header><title>Encapsulated Invocation vs Implementation question (CSLA 4)</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Encapsulated Invocation vs Implementation question (CSLA 4)</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/10493.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF posted on Tuesday, July 05, 2011</h2><p>I have read the Using CSLA e-book, but still have questions on which approach to take at my company for data access:&nbsp; encapsulated invocation or encapsulated implementation.</p>
<p>One of the questions we have is whether putting the DAL in a separate assembly can lead to misuse down the road by allowing future developers&nbsp;to use the DAL without going through the business objects, thus bypassing the business logic.&nbsp; (Perhaps we would need to be worried about bigger staffing issues if that were to occur...)</p>
<p>We are not a software shop, we have very few developers and we don&#39;t have a need to hit anything other than SQL for our apps.&nbsp; So we&#39;re not sure how the &quot;pluggable&quot; DAL benefit applies to us and whether that should be taken into consideration.&nbsp;</p>
<p>We&#39;re in the process of developing standards for how to use CSLA going forward, and we&#39;re open to either approach but would like to understand more of the pros/cons of each model and their day-to-day affects on us.&nbsp; Thanks.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>TSF replied on Thursday, July 07, 2011</h2><p>I ended up reading more online regarding separation of concerns in addition to Rocky&#39;s e-book, and am seeing more benefit in going the invocation route and the benefits it provides.&nbsp; One thing that helped change my mind even in the past day is the idea of a pluggable &quot;mock&quot; DAL that Rocky has in his examples...very useful.&nbsp; Another good point was made&nbsp;<a target="_blank" href="http://www.aspiringcraftsman.com/tag/separation-of-concerns/">here</a>:</p>
<p><span lang="EN">
<p style="padding-left:30px;">While designs which promote separation of concerns often add complexity to an application, it should be pointed out that they also remove the complexity that is generally associated with a lack of separation of concerns. For many applications, the trade-off is often between ordered complexity and disordered complexity. Applications which do not exhibit an appropriate amount of separation of concerns are often difficult to learn due to the need to understand the whole before understanding the part, and difficult to maintain and extend. </p>
</span></p>
<p>&nbsp;</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, July 07, 2011</h2><p>I also think one should consider that we all have an imperfect understanding of the future. I can&#39;t count the number of apps I&#39;ve built over the years where we (after months or years) had to do something &quot;simple&quot; like switch from 2-tier to 3-tier, or from Oracle to SQL Server.</p>
<p>Of course we all know that such changes aren&#39;t really simple unless the application architecture and design supports making such a change.</p>
<p>The data portal exists because I was burned so many times early in my career by the requirement to build &quot;a small departmental app&quot; in a 2-tier model, only to find that the project was actually <em>successful</em> and all of a sudden needed to be 3-tier so it could run over a WAN.</p>
<p>The same thing happens quite frequently with data. Today your company might be all over SQL Server. But in a few years maybe you get a new CIO who believes in the &quot;no-SQL&quot; movement, or owns stock in Oracle, or whatever...</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rxelizondo replied on Thursday, July 07, 2011</h2><p>
<p>We currently use Encapsulated Implementation and here is why.</p>
<p>Like you, we don&rsquo;t have the need to hit different databases simultaneously. This is an internal application that has been using SQL server since its inception almost 14 years ago. We are currently rewriting it and we don&rsquo;t have any short or long term plans on using another type of backend database.</p>
<p>But even if we did change the database, it will be a move from one database type to another. The pluggable concept brings very little value to us because we don&rsquo;t need to support multiple database at the *same* time.&nbsp;</p>
<p>But even if we needed to support multiple databases at the same time (Extremely uniquely for us), we could still do that using Encapsulated Implementation as in:</p>
<p><b><i>private void Child_Insert(Criteria criteria)</i></b></p>
<p><b><i>{</i></b></p>
<p><b><i>&nbsp; &nbsp;If(config file say use sqlServer)</i></b></p>
<p><b><i>&nbsp; &nbsp; &nbsp; &nbsp;Do this(criteria);</i></b></p>
<p><b><i>&nbsp; &nbsp;Else if(config file say use Oracle)</i></b></p>
<p><b><i>&nbsp; &nbsp; &nbsp; &nbsp;Do that(criteria);</i></b></p>
<p><b><i>&nbsp; &nbsp;Else</i></b></p>
<p><b><i>&nbsp; &nbsp; &nbsp; &nbsp;Display oh sh1t message.</i></b></p>
<p><b><i>}</i></b></p>
<p>It is only when you don&rsquo;t have access to edit the source code that pluggable becomes important. If you were selling your product to other companies and they wanted to create their own DAL implementation (and they don&rsquo;t have the source code) then pluggable DAL is pretty much the only and *by far* the most practical and easier way to go.</p>
<p>So what about separation of concerns? Well, doesn&rsquo;t the CSLA already offer that by implementing DataPortal_XYZ? If you need the physiological benefit of physically seeing the separation of concern then why not add a partial class to your business object where you handle the DataPortal_XYZ calls? That way, it will now be located on a different file and so it is officially &ldquo;separated&rdquo; (not pluggable but separated).</p>
<p>And what about testing? To us this was probably the most compelling reason to go pluggable, it seemed like such a convenient thing to do. The thing is that at the end of the day, your integrations testing will need to include testing against the database so you are going to have to do all the work of creating the code to tear down and set up the database for each integration test and if you are already going to have to do that then&hellip;. why bother with having a pluggable testing layer? Why not test directly against the database?</p>
<p>The biggest issue that I know about when conduction tests against the database is speed. Testing against the database is very slow so if you have a lot of test cases that hit the database it may be a problem. We are still not sure how we are going to solve this. Our current strategy is to limit the test we do (during development) to cover only the code we touch. Another possible solution is to create a RAM drive where the test database can reside, we hope will speed things up exponentially.</p>
<p>I am not sure if our strategy will pay off or not, but the benefits of Encapsulated Implementation (in our case) are too good to pass up.</p>
<p>Perhaps we are heading to absolute disaster, I don&rsquo;t know&hellip;. But I feel pretty confident about our decision. To us, the decision on what to do really depends on our own unique set of circumstances. I don&#39;t have a problem with going all out, but some times I feel that the benefits are just not there. Sorry if I am missing the point here.</p>
<p>I appreciate any feedback anyone would like to offer if you feel I am missing the point.</p>
<p>Thanks.</p>
</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
