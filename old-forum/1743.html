<html><header><title>5000 new objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>5000 new objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1743.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Smirk posted on Sunday, November 12, 2006</h2><P>I have to read in 5000 records from an Excel spreadsheet, turn them into business objects and save them to my new&nbsp;database.</P>
<P>If these objects are root objects, Save is called on each instance in turn, thereby generating 5000 object.Save() calls, with the corresponding 5000 connection.Open() calls...</P>
<P>If I use a BusinessListBase derived object and have each of my 5000 objects be a child of the list, my understanding is that each child's Save() method is still called, resulting in the same situation as above.</P>
<P>So my question is, have I missed one of the base classes opening the connection once, saving each item in turn and the closing the connection when done?</P>
<P>Thanks for any pointers...</P>
<P>Mark Haley</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Sunday, November 12, 2006</h2>If you use a BLB collection to contain your objects, then your objects would be child objects, not root objects. In that case, your collection code's DataPortal_Update() could open a single connection, and pass that connection to each child object's internal/Friend Insert(), Update() or Delete() method.<br><br>Obviously you still need to be careful in terms of your database. Updating 5000 rows of data in a single transaction could cause escalation to a table lock, which could have broad negative effects on other users as well as this particular task. But that's a database issue, not really an object issue, and the problems/solutions vary from database to database.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Smirk replied on Sunday, November 12, 2006</h2><P>Thanks, Rocky!</P>
<P>You know, I thought that I had read exactly what you described above, but I looked and looked in chapter 8 and couldn't find it.</P>
<P>Turns out I was looking at the Project class with it's Resourses collection and it was in the Resource class that you showed how to do&nbsp; connection sharing.</P>
<P>Thanks!</P>
<P>Mark Haley</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Smirk replied on Sunday, November 12, 2006</h2><P>By the way, this particular use is local on my development machine with me as the only user, so it's not going to affect any other users if the table is in use for a bit...</P>
<P>Mark</P>
<P>&nbsp;</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>William replied on Sunday, November 12, 2006</h2><DIV>This is just my thought from another view.</DIV>
<DIV>&nbsp;</DIV>
<DIV>If you trust your data that you kept in Excel, then you don't necessarily need to create a full featured object hierarchy to just import the data. Because you trust your own data, then data validation can be kept to the minimum. Thus, as an alternate approach, you can import your data "more directly" into the database through the use of CSLA.CommandBase and ADO.NET DataSet object might be more efficient.</DIV>
<DIV>&nbsp;</DIV>
<DIV>Regards,</DIV>
<DIV>William</DIV></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Smirk replied on Sunday, November 12, 2006</h2><P>William,</P>
<P>You are correct that this could be done more simply than with full-blown CSLA objects, but I have three reasons for doing it via objects:</P>
<P>1.&nbsp; I'm just using this as a "get my feet wet" excersise&nbsp;in CSLA</P>
<P>2.&nbsp; I actually do not trust the excel data - it is published by an external source (completely out of my influence) and needs some reformatting, trimming-down and enhancement.</P>
<P>3.&nbsp; Once the data is in the database, it will be accessed by different CSLA business objects but the validation that was used previously will apply in the new objects and is therefore reusable.</P>
<P>-- Although I do like the CommandBase idea and might do some thinking along that line to see what it turns up...&nbsp; Thanks</P>
<P>Mark</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>DW_CT replied on Monday, November 13, 2006</h2><P>I'm just starting to get my feet wet in CSLA as well, so these may be dumb questions.&nbsp;Wouldn't the inherent ADO.Net connection pooling deal with this behind the scenes? So, while there may be 5000 connection.Open calls in the code, there may only be, say, 5 connections actually made? Of course, how you sequence the 5000 calls would probably play a big part in what actually happens (you wouldn't be able to reuse a pooled connection if all the calls were simultaneous).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Monday, November 13, 2006</h2>Technically that's true. However, retrieving a connection from the pool isn't totally free, and in a tight loop over 5000 objects that overhead can become apparent.<br><br>Additionally, if there's the desire for transactional protection, opening these connections would require the use of the DTC, which is at least 15% overhead all by itself.<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
