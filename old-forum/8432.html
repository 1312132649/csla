<html><header><title>RxBA - Role Based Authorization or/and Resource Based Authorization</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>RxBA - Role Based Authorization or/and Resource Based Authorization</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/8432.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago posted on Thursday, January 28, 2010</h2><P>Dear all,</P>
<P>CSLA.NET supports Role Based Authorization (RoBA on this post). Given an object, a user is granted authorization&nbsp;to perform actions on that object depending on the role list&nbsp;of the user. A role might be denied access to that object (not even read access), another may read but not change anything, another may read but change only some properties, etc. I admit that must be the most common model on enterprise applications.</P>
<P>The point is RoBA isn't the only model of authorization. Sometimes one needs Resource Based Authorization (ReBA on this post). "Like when" you might ask. Like a Document Management System. There are documents I have access because I'm the guy that checks an invoice can be payed (that's my role). I have access to other documents because I belong to the Boston location (ok, we can think of it also as a role) but some other documents I have access because it's me (all documents on my HR file), whatever my present location or role in the company might be.</P>
<P>To make things even more complicated, I work on a TV station as a producer. There are a lot of producers on my TV station. Some aren't producing anything at all (they are friends with the station owner and just play golf with him), others are producing news, sports, etc. Their role is "producer". Producers have full access to all show objects (unrestricted authorization). But not for all shows, just for the shows they are assigned to.</P>
<P>I think it's not a good idea to create a new "producer" role for every new show. The answer looks a lot like "role by resource": the "producer" role has an authorization profile that applies only to assigned resources. For the unassigned resources, the "producer" role has no special&nbsp;autorization: just&nbsp;the same as any other ordinary role in the TV station.</P>
<P>Now take the "director". He has more restricted authorization level on the show objects but on the other hand&nbsp;- and just to make things worst - suppose the "director" is assigned on a daily base (that is more or less true). The next day he is no longer director on this show, but he must be granted read only access for the objects of the shown he was assigned as "director".</P>
<P>How should I handle authorization on my TV station management application? Do I need to use both RoBA and ReBA? How can I do it with CSLA.NET?</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, January 28, 2010</h2><P>CSLA supports authorization at two levels:&nbsp;type and property.</P>
<P>At the type level, authorization indicates whether you can create/fetch/save/delete a <EM>type</EM> of object. Not a specific instance, just a type. So this can't be adapted to a context-sensitive model because there's no instance, just the type.</P>
<P>Arguably you could make save/delete be context-sensitive, because you have an instance. But you can't ever make create/fetch context-sensitive, because you don't know if the operation is legal until after the operation is complete. Until you have the actual object, you can't find out if the user was authorized to do the operation you just did to get the object :)</P>
<P>If you want context-sensitive create/fetch/save/delete operations, my recommedation is to implement them in the DataPortal_XYZ methods, where you have context, and can prevent the operation from completing if the user isn't authorized.</P>
<P>At the property level, you can easily extend the existing role-based behavior by overriding CanReadProperty() and CanWriteProperty(). Overriding these methods allows you to add context-sensitive rules for specific objects and properties, while allowing other objects and properties to continue to use the normal role-based model.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Saturday, January 30, 2010</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div> </P>
<P>At the property level, you can easily extend the existing role-based behavior by overriding CanReadProperty() and CanWriteProperty(). Overriding these methods allows you to add context-sensitive rules for specific objects and properties, while allowing other objects and properties to continue to use the normal role-based model.</P>
<P></div></BLOCKQUOTE></P>
<P>This is most appropriate&nbsp;in several use cases.</P>
<P>When editing the object<BR>1)&nbsp;if current user is the creating user, show this field or allow him to edit that field<BR>2)&nbsp;if object is in workflow step "abc" and user is in role "def", allow him&nbsp;decide the next workflow step (edit a property or click a button)</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div> </P>
<P>(...) Until you have the actual object, you can't find out if the user was authorized to do the operation you just did to get the object :)</P>
<P></div></BLOCKQUOTE></P>
<P>But as you said, properties are useless for enabling/disabling user access to an object on a more radical approach:<BR>3)&nbsp;user can't list this object because he isn't assigned to this object<BR>4) user can have read only access but not edit access to this object because workflow step is "ghi"</P>
<P>Use cases 2) and 4) can be solved if I map a role to each workflow step. So they fall under the RoBA issue that is nicely solved by CSLA.NET.</P>
<P>Uses cases 1) and 3) are ReBA and 3) isn't solved.</P>
<P>Just for making this subject clear for CSLA starters, the point here isn't "how to <STRONG>show</STRONG> a list that shows only the objects I want the user to have access" (use case 3). This is esay enough to do if you transfer your business logic to the UI layer. Suppose you are using Web Services the fecth the same list. How do I return this list in use case 3?&nbsp; (see next message)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Monday, February 01, 2010</h2><P>#1 is solved by overriding CanReadProperty / CanWriteProperty.</P>
<P>#3 is solved in the DataPortal methods; usually by using the current users logon id to filter the list returned by the data.&nbsp; There's not much Csla can to directly to help you with this, but the BO can certainly have such logic built in.&nbsp; It's still a business rule... just happens to be enforced in the DP_F method, which I see nothing wrong with.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Wednesday, February 03, 2010</h2><P>Let's face it.</P>
<UL>
<LI>Resource access control rules are part of the business rules. 
<LI>Business rules should be contained in the business layer.</LI></UL>
<P>THUS</P>
<UL>
<LI>Resource access control rules should be contained in the business layer.</LI></UL>
<P>It's as simples as that.</P>
<P>CLSA.NET business object model&nbsp;has no provisions for full resource access control rules in the business layer. This is also a very simple fact.</P>
<P>There are 2 issues involved:</P>
<P>1) How can it be done in CSLA.NET? Rocky already said it can be done in the DataPortal (aka DAL). That means business logic will bleed to the data layer. That isn't a "Best Practice" for sure.&nbsp;It breaks some goals of OO design, namely some CSLA goals.</P>
<P>2) Is this solution acceptable? That's another issue, another answer and that's really the point.</P>
<P>The n layer model was adopted not because of some "original sin" issue but because it makes development and maintenance easier (read less expensive). The data access layer should care only about handling data access for storage purposes&nbsp;and shouldn't care a bit about business rules. Using this solution means that when business rules change, depending on the specific business rule that changed, I must change code in one layer or the other. It also means that when switching the DAL from SQL Server to Oracle one must sure the business rules inside the DAL aren't affected and they still behave the same way. This is all old news. What's the conclusion? In fact I can't say. But I think this deserves a good discussion of concepts so the concrete implementation can have a good design.</P>
<P>In fact it's hard to find discussion material about resource based authorization in the web. I imagine that isn't a very common problem. Or maybe it is, but is ignored most of the time because it's hard to solve.</P>
<P>In <A href="http://www.codeproject.com/KB/database/AFCAS.aspx">A Fairly Capable Authorization Sub-System with Row-Level Security Capabilities (AFCAS)</A>&nbsp;a resource acces method is discussed that handles ACL for users, groups and also can do hierarchy. I don't see any problem in implementing this model outside the business layer: it's a do or don't. Either you implement it or you don't implement it. No dependencies - except the database server - and no changing rules here. Once you are sure the sub-system is working, no further testing and maintenance&nbsp;is needed.</P>
<P>In fact AFCAS is quite interesting at the conceptual level as it plugs after the DAL, showing a view of the data that depends on the user that is using the database. The database is no longer the same for all users but each user sees a virtual copy of the database that is composed only of the data that he is allowed to see. This model provides a transparent base for whatever object model you put on top of it.</P>
<P>When I wrote the opening message I was expecting that some other solution would come up that wouldn't be database dependent. That's the only problem of this solution, and it's a very big problem!</P>
<P>I suppose this solution can be moved outside the database to a new layer that should sit between the DataPortal/DAL and the database server. We can argue about the bandwidth that is consumed&nbsp;"for nothing" if we get all the data only to throw it out as the user has no access to that data. But that really isn't an issue, as one can always make a query (not a stored procedure, just a plain query) that only gets the data the user is allowed to see.</P>
<P>Of course, you can make it part of the DAL&nbsp;or make it part of the database. "Sitting" betweeen those two layers means you can put it in one or the other.</P>
<P>The point here is the concept: resource access control is a special case of a business rule that acts as a filter of the data, creating a virtual database for each user.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tmg4340 replied on Wednesday, February 03, 2010</h2><P><FONT size=2 face=Tahoma>This delves a little bit beyond CSLA...</FONT></P>
<P><FONT size=2 face=Tahoma>I'm betting that there isn't much "reference material" on this largely because .NET wasn't designed to do this in an "elegant" fashion.&nbsp; .NET's security concepts revolve around the Principal/Identity (i.e. role-based) concept.&nbsp; Microsoft is working on a new solution (the Windows Identity Foundation framework), which is claims-based.&nbsp; Presuming you want to wait until .NET 4.0, this might be something to look into.</FONT></P>
<P><FONT size=2 face=Tahoma>Of course, it's also a "version 1 tech" from MS...</FONT></P>
<P><FONT size=2 face=Tahoma>From my perspective, the question is whether you want to maintain the "purity" of your system, or the performance of the system.&nbsp; If performance is an issue - or you have a particular aversion to returning a potentially large set of data from the database that you're going to throw away - then you don't really have a choice: some section of your resource-based rules must exist "on the database".&nbsp; Whether you use AFACS, SQL Server's row-/column-level security functionality, or a code-based solution (either stored procedures or dynamic SQL), your data layer will be "infected" with business rules.</FONT></P>
<P><FONT size=2 face=Tahoma>I'm also not entirely sure I agree with labeling security-related functionality "business rules".&nbsp; Security is one of those cross-cutting concerns that, IMHO, extends beyond your business layer.&nbsp; The ruleset that defines the overall security of your application does come into play in pretty much every piece of your application.&nbsp; The fact that CSLA encapsulates some of that into the framework design is a convenience to let you plug your security model into the workings of your business objects.&nbsp; A necessary convenience, but a convenience nonetheless.</FONT></P>
<P><FONT size=2 face=Tahoma>- Scott</FONT></P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Wednesday, February 03, 2010</h2><P>I'm open to proposals tiago. Exactly what would you think CSLA could do to help address your situation?</P>
<P>Define an interface? Implement some abstract instance-level methods that you could override?</P>
<P>Either way, CSLA itself wouldn't really do anything meaningful - it would just define places for you to write your code.</P>
<P>Since we're talking about context-specific rules here, the actual implementation of anything useful would be type-specific - not role-based right? So there's virtually nothing CSLA could do to help.</P>
<P>Though maybe I'm missing something obvious - which is why I welcome concrete proposals for exactly what you think CSLA could do.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Thursday, February 04, 2010</h2><P><BLOCKQUOTE><div><img src="/Themes/basicblue/images/icon-quote.gif"> <strong>tiago:</strong></div><div>1) How can it be done in CSLA.NET? Rocky already said it can be done in the DataPortal (aka DAL). That means business logic will bleed to the data layer. That isn't a "Best Practice" for sure.&nbsp;It breaks some goals of OO design, namely some CSLA goals.</div></BLOCKQUOTE></P>
<P>I view the DataPortal methods as part of the business layer, and not the DAL.&nbsp; The DAL would be my Linq2Sql object, linq2Entity, any web services that fetch or store data, etc.&nbsp; The BO&nbsp;knows how to use the DAL. I think the DataPortal should be named something else, because its purpose is really to allow you to run code on another physical layer, if you choose to, with the appropriate context intact.&nbsp; You could use it to run some complex calculations on a fast server if you so choose, it doesn't have to talk to a database at all.</P>
<P>Do you see any problems with the fetch method knowing how get a particular invoice from a set of invoices?&nbsp; How is the security you want to apply any different?&nbsp; Its just another criterion the BO uses to ask for the relevent data.&nbsp; </P>
<P>But my Linq2E objects don't change based on whether or my BO filters based on someones logon id.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Saturday, January 30, 2010</h2><P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div> </P>
<P>If you want context-sensitive create/fetch/save/delete operations, my recommedation is to implement them in the DataPortal_XYZ methods, where you have context, and can prevent the operation from completing if the user isn't authorized.</P>
<P></div></BLOCKQUOTE></P>
<P>Right.</P>
<P>Given the use case:<BR>A user can only know of objects he is assigned to. For other objects, the user is not only DenyRead but also DenyExistence. When fectching a list of objects I can do it in two different ways:<BR>a) fectch every object from the DB and filter out the ones that shouldn't be there<BR>b) have my SELECT query include only the objects I know are legal (how do I know it? this should be a business rule...)</P>
<P>I prefer b) for speed but that's a bit beside the point.</P>
<P><BLOCKQUOTE><div><img src="/Themes/default/images/icon-quote.gif"> <strong>RockfordLhotka:</strong></div><div> </P>
<P>At the type level, authorization indicates whether you can create/fetch/save/delete a <EM>type</EM> of object. Not a specific instance, just a type. So this can't be adapted to a context-sensitive model because there's no instance, just the type.</P>
<P></div></BLOCKQUOTE></P>
<P>In CSLA.NET something like DenyExistence is a type level authorization: user "jkl" has no access to objects of type "mno" This is ReBA but by resource type, not by resource instance.</P>
<P>To solve the Resource Based Authorization issue, I need to transfer part of&nbsp;my business logic ouside the Business Layer. That's the point.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Saturday, January 30, 2010</h2><P>I think the important thing is that you can't implement context-sensitive rules without the context.</P>
<P>So if the context is contained in the object, then the object must exist before the rules can be applied.</P>
<P>So applying context-sensitive rules to create/fetch (and immediate delete) operations poses a very real challenge.</P>
<P>You can always override Save() to apply context-sensitive insert/update/delete rules&nbsp;- that's pretty easy, and the code is in your business object (typically on the client - so before paying the cost of getting to the app server, etc).</P>
<P>But again, create/fetch require that context - so you have to get the context first... In short, you can implement these rules in your business layer, but they have to run in the server-side parts of your business layer (the DataPortal_XYZ methods).</P>
<P>You can provide context to your DataPortal_XYZ methods or DAL easily enough. The criteria object is context, and don't forget about Csla.ApplicationContext.ClientContext - which is a good way to provide limited amounts of context. As is the ApplicationContext.User object (custom principal).</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>RockfordLhotka replied on Thursday, February 04, 2010</h2><P>The thing is, there are no less than four models for implementing data access code:</P>
<OL>
<LI>DataPortal_XYZ; DAL code in the DP_XYZ methods</LI>
<LI>DataPortal_XYZ; DAL code in separate assembly invoked by DP_XYZ</LI>
<LI>Object factory; DAL code in the factory object</LI>
<LI>Object factory; DAL code in separate assembly invoked by object factory</LI></OL>
<P>In all cases it is fine to put business logic in the DP_XYZ, and <EM>maybe</EM> in the object factory (though I think that's iffy). But if you are going to do so, it is best to use models 2 or 4 so the DAL is cleanly separated from this business logic.</P>
<P>Really with an object factory, if you need business logic to run on the server, the object factory should invoke methods on the business object that implement that logic. So the logic isn't in the factory, it is in the business object - and is just invoked by the factory object.</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>tiago replied on Wednesday, February 17, 2010</h2><p>Scott, Andy, Rocky</p>
<p>Thank you all for the refreshing discussion</p>
<p>I guess Scott is right. .NET wasn&#39;t made for Resource Based Authorization.</p>
<p>I agree with Rocky: there is nothing CSLA could do to help to solve this use case.</p>
<p>As I said in my previous post, I&#39;m planning to solve it at the database level.</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
