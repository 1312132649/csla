<html><header><title>OT(?) Why separate IPrincipal and IIdentity objects</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>OT(?) Why separate IPrincipal and IIdentity objects</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/2594.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>SonOfPirate posted on Tuesday, March 27, 2007</h2><P>I have been engaged in a debate regarding why there are separate IPrincipal and IIdentity objects in the .NET security model.&nbsp; I've explained that the principal represents the security context and allows for role-checking while the identity is just that, the identity of the current user (name, etc.).&nbsp; However, having been confronted with numerous questions and arguments, I am trying to understand the practical side of this as we follow this practice with Csla.</P>
<P>In all but one case that I've been able to find, there is a one-to-one relationship between the principal and identity classes (WindowsPrincipal/WindowsIdentity, PassportPrincipal/PassportIdentity, GenericPrincipal/GenericIdentity).&nbsp; The only exception is the FormsIdentity object which will be contained by&nbsp;a GenericPrincipal object.</P>
<P>In researching the literature, Microsoft makes the statement that the only legitimate reasons why you would want to create your own custom principal is if you want to overload the IsInRole method (as is done with the WindowsPrincipal class) or add additional functionality (which is not demonstrated anywhere).</P>
<P>Given this, why then have a BusinessPrincipalBase class that does nothing different from GenericPrincipal?&nbsp; Couldn't the custom identity be simply wrapped in a GenericPrincipal (as with FormsIdentity) using something similar to:</P>
<P><CODE>IPrincipal p = new GenericPrincipal(myIdentity);</CODE></P>
<P>That's the first question.&nbsp; Second question is aside from the built-in forms authentication (using FormsIdentity), can anyone give me an example where it makes sense to have a separate identity class?</P>
<P>What I mean is, in the ProjectTracker sample application, there&nbsp;are custom PTPrincipal and PTIdentity classes.&nbsp; Why not just have one class that implements both interfaces if there is a one-to-one relationship?</P>
<P>Many more thoughts have been thrown around here but I will leave it at that and open the floor for your comments and thoughts.</P>
<P>Thx</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rrsstio replied on Saturday, January 05, 2008</h2>IMHO sometimes an application might have not only one-to-one relationship between the principal and identity classes. <br>For example, a web-app can accept human "users" and other program "users" (which call services of the web-app). For these different types of users you might have different types of IIdentyfy objects.<br>Of course in this case you might have one base IIdentity class which will provide role-checking and two derived classes for human and program "users". But then you can't easy change role-checking system (by configuring in config file) or may be you want to support different role-checking systems in the same app.<br><br>Summary, it's just separation of responsibilities: IIdentity contains data of user, but IPrincipal executes some security functionality against an user and (it's important) IPrincipal doesn't represent an user (in spite of confusing System.Web.HttpContext.Current.User which is an IPrincipal object).<br><br><span>edited by:</span> rrsstio at 7:25 PM (GMT -6) on Sat, Jan 05 2008<br>Found more clear explanation of responsibility separation of that interfaces at MSDN (http://msdn2.microsoft.com/en-us/library/ms172765(VS.80).aspx):<br><br>"Using two objects allows for a separation of authentication (in the identity object) and authorization (in the principal)."<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>goracio replied on Sunday, January 06, 2008</h2><P>Think that BuisinessPrincipalBase is serializable class and GenericPrincipal is not.</P>
<P>And Separation of responsibilities may prove usefull in complex scenarios.</P>
<P>Max</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>goracio replied on Sunday, January 06, 2008</h2><P>Figuruing it out a little i came to probable answer- Principal object can be used for caching some info in it that is not relevant to underlying identity.&nbsp;</P>
<P>And a little off the question - dosnt&nbsp; it seems to you that RolesForProperty is too granular for practical purposes, it adds heavyness to the business&nbsp;object?</P>
<P>It would be better to have RolesForObject instead, because object resposible for some functional resource that user in its entirety can read or write.</P>
<P>I think that such granularity is bad design of objects.</P>
<P>P.S.- Maybe its a question to Rocky:)</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rasupit replied on Sunday, January 06, 2008</h2><p><i>why there are separate IPrincipal and IIdentity objects in the .NET security model</i></p><p>The separation is just good OOP to follow SRP. IIdentity is for <b>authentication</b> and IPrincipal is for <b>authorization</b><br></p><p><i>Given this, why then have a BusinessPrincipalBase class that does
nothing different from GenericPrincipal?&nbsp; Couldn't the custom identity
be simply wrapped in a GenericPrincipal (as with FormsIdentity) using
something similar to:</i></p><p><i><code>IPrincipal p = new GenericPrincipal(myIdentity);</code></i></p><p><code>Actually it should be <font face="Courier New">new GenericPrincipal(myIdentity, myRoles);</font>&nbsp; This is a good question.&nbsp; I could not find the reason in the book and I have never use it.&nbsp; goracio, did you try that the GenericPrincipal could not be serialized?&nbsp; I took a peek using reflector and found signature of this class is as follow:</code></p>[<a title="System.SerializableAttribute.SerializableAttribute();" href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.SerializableAttribute/.ctor%28%29">Serializable</a>, <a title="System.Runtime.InteropServices.ComVisibleAttribute.ComVisibleAttribute(bool visibility);" href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Runtime.InteropServices.ComVisibleAttribute/.ctor%28Boolean%29">ComVisible</a>(<font color="#800000">true</font>)]
<font color="#1000a0">public</font> <font color="#1000a0">class</font> <b><a class="bold" href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Security.Principal.GenericPrincipal">GenericPrincipal</a></b> : <a title="System.Security.Principal.IPrincipal" href="http://www.aisto.com/roeder/dotnet/Default.aspx?Target=code://mscorlib:2.0.0.0:b77a5c561934e089/System.Security.Principal.IPrincipal">IPrincipal</a>
<br><br><i>Second question is aside from the built-in forms authentication (using
FormsIdentity), can anyone give me an example where it makes sense to
have a separate identity class?<br></i><br>I usually built internal app and let windows in charge of the authentication through WindowsIdentity.&nbsp; If the app want to manage the roles than I usually use have class to retrieve the roles for this user and use GenericPrincipal to store it, so I can use the IsInRole method.<br><br>Ricky<br><code></code></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>goracio replied on Sunday, January 06, 2008</h2>Then I dont know why there BuisinessPrincipalBase istead of GenericPrincipal. There would be sufficient the second. But no harm is done.</div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
