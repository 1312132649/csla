<html><header><title>Ordered lists</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Ordered lists</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/1366.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 posted on Monday, October 02, 2006</h2>Hi,<br><br>Has anyone created a business list in which the order of the items in the collection mattered?&nbsp; I have a list which needs to be always sorted in the same way, even between saving and loading.&nbsp; The user may also reorder the items in the collection manually.<br><br>What I've done is given each item in the list a position which is part of its state, so that it can save and load.&nbsp; As items are inserted or removed, the collection just runs though and assignes a value based on the index of each item.<br><br>On the UI side, I'll use SortedBindingList and force a sort on this position value.<br><br>How have others handled this?<br><br>Thanks<br>Andy<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Henrik replied on Tuesday, October 03, 2006</h2><P>Hi Andy</P>
<P>I've done exactly what you desribe, in several applications, with success, so I recommend this as the way to go.</P>
<P>/Henrik</P></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, October 03, 2006</h2>Great, thanks for the feedback, glad to know I'm not offbase.<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JHurrell replied on Tuesday, October 03, 2006</h2>I've also done it this way in the past. Your question did make me think a little and I'd like to share some of my thoughts.<br><br>In the past, my child objects have exposed a property called Position. One thing I didn't do is make this property public internal in scope. I think this is important because you want you collection to be able to change the Position but NOT allow the UI to do so. <br><br>The only time a child's Position would change would under the following circumstances:<br><ul><li>Insert</li><li>Remove</li><li>RemoveAt</li><li>MoveUp</li><li>MoveDown</li></ul>Here's what I'm thinking:<br><br><font face="Courier New" size="2">public class ChildObject<br>{<br>&nbsp;&nbsp;&nbsp; public int _position = -1;<br>&nbsp;&nbsp;&nbsp; public internal int Position { get; set; }<br>}<br><br>public class ParentCollection<br>{<br>&nbsp;&nbsp;&nbsp; public void MoveUp(int index)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(index &gt; 0 &amp;&amp; List.Count &gt; 1)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Swap elements [index] and [index - 1].<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Update Position on elements [index] and [index - 1].<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; public void MoveDown(int index)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(index &lt; List.Count - 1 &amp;&amp; List.Count &gt; 1)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Swap elements [index] and [index - 1].<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Update Position on elements [index] and [index - 1].<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; public ChildObject Insert(ChildObject child)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Add child to end of list and set Position.<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public void Remove(ChildObject child)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Determine [index] of child.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Remove child.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Update Position for each item &gt;= [index]<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; public void RemoveAt(int index)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Remove child at </font><font face="Courier New" size="2">[index]</font><font face="Courier New" size="2">.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Update Position for each item &lt;= [index]<br>&nbsp;&nbsp;&nbsp; }<br>}</font><br><br>Not that there's anything special about the pseudo-code, but I think the important things to base a best practice on are the following:<br><ul><li>The UI does not see and cannot set ChildObject.Position</li><li>The ParentCollection is entirely responsible for updating Position</li><li>The ParentCollection will only update ChildObject.Position if the position actually changes. In other words, it should NOT set Position on ALL objects unless they've all changed.</li></ul>Is this about what everyone else is thinking?<br><br>- John<br><br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Tuesday, October 03, 2006</h2>John,<br><br>You were able to answer another question for me.. thanks for the psuedo code which shows where MoveUp and MoveDown live.&nbsp; <br><br>My Position property is public get, but internal set.&nbsp; My reasoning is this; the collection and objects manage their positions, but actually displaying them in the right order is the job of the UI.&nbsp; It seems like keeping the internal list sorted would be more complex than wrapping my BLB in a SortedBindingList and forcing a sort.&nbsp; After all, there may be a UI that doesn't care to actually display them in the order they define for some reason.<br><br>I did something similar to your implementation, but I overrode InsertItem and RemoveItem and SetItem.&nbsp; After running the base method, I call a method which just blindly sets the position on each child object (after turning off events of course).&nbsp; <br><br>Andy<br></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
