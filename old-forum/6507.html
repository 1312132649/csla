<html><header><title>SearchByExpression extremely slow - is there a way to use the Indexing capabilities and bypass LINQ</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>SearchByExpression extremely slow - is there a way to use the Indexing capabilities and bypass LINQ</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/6507.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoshL posted on Wednesday, February 25, 2009</h2>I have a number of readonly object lists that have a numeric Id and other properties. Often I look up items by Id. I'd like to index Id so that the lookups are more efficient.<br /><br />Currently I have a "FindById" function that iterates through the list of objects and returns the first one that matches the input Id.<br /><br />I'm attempting to utilize the latest CSLA indexing features, and have done the following:<br />- added the [Indexable] attribute to the Id column<br />- used the following expression to find the item:<br />list.SearchByExpression(s => s.Id == searchValue).First()<br /><br />This is much slower than my original brute-force method of searching: attempting 7000 searches on a 7000-item list, the brute-force method takes 7-10 seconds, while the LINQ method takes 15+ seconds. I have confirmed via the debugger that SearchByExpression is indeed finding the index on the Id column and using it.<br /><br />I think that the performance hit is in the expression compile required for LINQ. If this is the case, it would be just wonderful if I could make use of the index without using LINQ at all. I know the property that I'm searching on and the value that I want to find. Is there any way of tapping into the CSLA indexing functionality to find a match for the property/value?<br /><br />Thanks!</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>Jack replied on Wednesday, February 25, 2009</h2>Out of curiosity - how long does it take the second time round?<br><br>How long does it take in LINQ without the index attribute on?&nbsp; How long the second time round?<br><br>I haven't used the index on anything that large yet but I've always done multiple lookups over and over and over while initializing objects and its been on the server vs. the client.<br><br>There are default values for how you want the index to be created (OnDemand, IndexModeAlways) etc.&nbsp; I believe the default is OnDemand but if you were to build the index right away maybe you can do it in the background so it is ready to go when you need to use it.<br><br>Jack<br></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>JoshL replied on Saturday, March 14, 2009</h2>The test case ran the query 7000 times. The index was built the first time the query was run.<br /><br />A standard LINQ query (without the indexable attribute) takes 19 seconds to complete; about the same as running it without the indexing.<br /><br />In order to support id-based searches on my business objects, I've implemented a HashTable-based index that is updated as objects are added/removed from a list. Running the 7000 queries using this index access method is almost instant (0 seconds).</div><div style='padding:0 15 3 15;background-color:powderblue'><h2>rsbaker0 replied on Sunday, April 12, 2009</h2><P>I ran into this today also. Even executing a search 350 times (with a different search value each time) produced a noticeable delay. </P>
<P>I replaced the call to SearchByExpression with my own HashTable and got instantaneous results. </P>
<P>I can understand problems if the search expression required a call for each list item, but I'd think that&nbsp;simple equality with a passed string value should be as fast give or take as the hash table.</P>
<P>&nbsp;</P></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
