<html><header><title>Using CSLA in a web environment</title></header><body><div style='float:right'><a href='http://cslanet.com'><img src='https://github.com/MarimerLLC/csla/raw/master/Support/Logos/csla%20win8_compact_s.png'/></a></div><p><h1>Using CSLA in a web environment</h1><span style='font-size:small'>Old forum URL: forums.lhotka.net/forums/t/11067.aspx</span></p><hr><div style='padding:0 15 3 15;background-color:powderblue'><h2>Mark Sulkowski posted on Wednesday, January 18, 2012</h2><p>CSLA seems good for a windows form environment, but problematic for&nbsp;a web environment.&nbsp; For instance, one has to load a root object that may have many child objects, and in a web environment it would be better to load and save smaller amounts of information instead of having to cache a large object graph.</p>
<p>What ways have&nbsp;others found to make CSLA work more effectively in a web environment?</p>
<p>&nbsp;</p>
<p>Mark Sulkowski</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>richardb replied on Wednesday, January 18, 2012</h2><p>Having a root object with editable children supports a smart rich UI like Winforms, WPF and maybe Silverlight nicely.&nbsp; WIth ASP.Net/Web you would probably create extra business objects to load up children in &quot;root editable&quot; mode and that can be more efficient in terms of performance.</p>
<p>Rocky discusses this in the ASP.Net MVC eBook as he shows the additonal business objects for the POSTracker demo he needed to suit the MVC model and technology.&nbsp; Essentially you might find yourself enhancing your Domain model to suit the user stories that typically you need in a stateless web environment.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>ajj3085 replied on Friday, January 20, 2012</h2><p>I would likely look into lazy loading then.&nbsp; It depends on your screens typically what your graph looks like.&nbsp; If you only want to allow the user to edit smaller amounts of data, then your objects only have that data.&nbsp; If the &quot;child&quot; objects can be edited independently you can have a lightweight list of readonly chlid objects which allow the user to select an object to edit, then load only that one full child object.</p>
<p>I suspect though that you&#39;re falling into the premature optimization antipattern.&nbsp; You&#39;re worrying about trading maintainablity for performance before you&#39;re even sure you have a performance problem.</p>
<p>I used Csla just fine in a web environment.</p></div><div style='padding:0 15 3 15;background-color:powderblue'><h2>drpuff replied on Monday, January 23, 2012</h2><p>Yeah I would agree. Obviously a large object graph &#39;could&#39; lead to performance problems, but you&#39;d want proof before you do too much to optimise (especially early on...you never know how things are going to change!).</p>
<p>The way I&#39;ve dealt with substantial object graphs is to do exactly what Andy has suggested and to allow the root object to have a read-only list of its children (with the minimium amount of data you can get away with), and allow the full editable Child object to load when requested...along with a list of any children it may have.</p>
<p>Obviously it really does depend on the system, but If you have large object graphs, it&#39;s unlikely that many &#39;child&#39; objects are required (for editing by the user) and so this solution seems to work pretty well in a web environment.</p>
<p>One other thing, make use of &#39;Unit of Work&#39; objects to ensure you are only making a single trip to the server to get all the data you require (e.g., the Business Object(s) &amp; any lists for dropdowns etc.)</p></div><p style='font-size:small'>Copyright (c) Marimer LLC</body></html>
